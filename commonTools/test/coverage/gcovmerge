#!/usr/bin/perl
#==========================================================================
# gcovmerge
#
# A script for automatically extracting and merging coverage information
# from C++ programs compiled using 'gcc -fprofile-arcs -ftest-coverage'.
# As of May 19, 2005, this script requires gcc 3.4.3 or above.
#
# Usage: 
#
#        gcovmerge [--with-files=min-max]           \
#                  [--with-directories]             \
#                  [--with-directories-recursive]   \
#                  [--without-files]                \
#                  [--with-total]                   \
#                  [--exclude=word]                 \
#                  [--source-dir=path]              \
#                  [--with-line-counts]             \
#                  [--with-percentages]             \
#                  build-dir
#
# Arguments:
#
#        build-dir
#            The path to search for .gcda files (which are the
#            markers for programs compiled with the appropriate
#            arguments and later executed).
#
#        --with-files=min-max [0-100]
#            When specified, no coverage information is displayed for
#            any individual files with a coverage percent outside of 
#            the range given.
#
#        --with-directories
#            When specified, coverage percentages are displayed for
#            each directory examined.  Only files directly under
#            each directory count towards this number.
#
#        --with-directories-recursive
#            When specified, coverage percentages are displayed for
#            each directory examined.  All files under each
#            directory, including those in subdirectories,  count
#            towards this number.
#
#        --without-files
#            No coverage information will be given for individual files.
#
#        --exclude=word []
#            No files with word in their name or path will be examined.
#            This option may be specified more than once, in order to
#            exclude a variety of files.
#
#        --with-total   
#            The total coverage for all files examined will be displayed.
#
#        --source-dir=path
#            The path to look for source files if the source and build
#            directories are seperate.  This directory should have an identical
#            hierarchy to that of build_dir, or else this script will not be
#            able to reconcile the data in source_dir with that in build_dir.
#            If not specified, the script will assume that the source files
#            are in build-dir.
#
#        --with-line-counts
#            Produces output in the form of Lines Tested / Lines Counted.
#
#        --with-percentages
#            Produces output in the form of percentage of lines tested.
#
# Written by Joe Outzen, for the Trilinos project.
#
#==========================================================================

# base options
use Cwd;
chomp($base = cwd);
$maximum_per_file = 100;
$minimum_per_file = 0;
$directories = 0;
$total = 0;
@exclude_list = ();
$line_counts = 0;
$percentages = 0;
@file_types = ("cpp", "c++", "c", "hpp", "h++", "h");
%source_files = ();
%path_exec = ();
%path_comp = ();
%file_cov = ();
$total_exec = 0;
$total_comp = 0;

# parse command-line options
$build_directory = pop;
$source_directory = $build_directory;
foreach (@ARGV){
    if(/^--with-files=(\d+)-(\d+)$/){
	$minimum_per_file = $1;
	$maximum_per_file = $2;
    }
    elsif(/^--with-directories$/){
	$directories = 1;
    }
    elsif(/^--with-directories-recursive$/){
	$directories = 2;
    }
    elsif(/^--without-files$/){
	$minimum_per_file = 100;
	$maximum_per_file = 0;
    }
    elsif(/^--exclude=(.*)$/){
	push @exclude_list, $1;
    }
    elsif(/^--with-total$/){
	$total = 1;
    }
    elsif(/^--source-dir=(.*)$/){
	$source_directory = $1;
    }
    elsif(/^--with-line-counts$/){
	$line_counts = 1;
    }
    elsif(/^--with-percentages$/){
	$percentages = 1;
    }
    else{ 
	die "96: Invalid paramater: $_"; 
    }
}

# find all source files of a type listed in @filetypes
$find_string = "find $source_directory";
foreach(@file_types){
    $find_string .= " -name \"*.$_\" -or";
}
chop $find_string;
chop $find_string;
chop $find_string;
chop $find_string;

foreach(`$find_string`){
    chomp;
    $current_file = $_;
    # skip files that match names in @exclude_list
    $skip = 0;
    foreach (@exclude_list){
	if($current_file =~ /$_/){
	    $skip = 1;
	    last;
	}
    }
    if($skip){
	next;
    }
    
    # add this source file and its path to %source_files
    s/^((.*\/)*)[^\/]+$/$1/ or die "128: Path-only regex failed for $_\n";
    $current_file =~ s/^(.*\/)*([^\/]+)$/$2/ or die "Name-only regex failed for $_\n";
    $source_files{$current_file} = $_;
    
    # if we are keeping track of directory-based coverage, then put 0s into
    # %path_exec and %path_comp
    if(!defined($path_comp{$_})){
	if($directories){
	    $path_exec{$_} = 0;
	    $path_comp{$_} = 0;
	}
	if($directories == 2){
	    while(s/^(\.\/(.+\/)+).+$/$1/){
		$path_exec{$_} = 0;
		$path_comp{$_} = 0;
	    }
	}
    }
}

# find all .gcda files (which indicate a successful execution of code)
$last = "!";
foreach(`find $build_directory -name \"*.gcda\"`){
    chomp;
    s/^((.*\/)*)[^\/]+$/$1/ or die "145: Path-only regex failed for $_\n";
    
    #skip this directory if we've already seen it
    if($_ eq $last){
	next;
    }
    $last = $_;

    # run gcov on all the .gcda files in this directory
    chdir $_ or die "could not cd to $_\n";
    foreach(<*.gcda>){
	system "gcov $_ > /dev/null" and die "156: gcov failed for $_\n";
    }
    chdir $base or die "158: could not cd to $base\n"
}

# find .gcov files for every source file
foreach(keys(%source_files)){
    $found = 0;
    $comp = 0;
    $exec = 0;
    foreach(`find $build_dir -name \"$_.gcov\"`){
	chomp;
	open GCOV, "< $_";
	foreach(<GCOV>){
	    # if a line in the .gcov file starts with either numbers or #s,
	    # then that line was compiled into executable form.
	    if(/^\s*([\d\#]+):/){
		$comp++;
		# if a line in the .gcov file starts with numbers, then that
		# line was executed.
		if($1 =~ /\d+/){
		    $exec++;
		}
	    }
	    # we shouldn't need to look at more than one .gcov file per source
	    # file, so we can skip all the rest of the find. 
	    $found = 1;
	}
	if($found){
	    close GCOV;	    
	    last;
	}
    }
    if(!$found){
	# this should only happen to an uncompiled file
	# or to an untested templated header.
    }else{
	# record the results for this source file
	$cov = $comp ? 100 * $exec / $comp : 0;
	if($cov >= $minimum_per_file && $cov <= $maximum_per_file){
	    $cov_output = "";
	    if($line_counts){
		$cov_output .= "$exec / $comp";
		if($percentages){
		    $cov_output .= " : ";
		}
	    }
	    if($percentages){
		$cov_output .= "$cov"."%";
	    }
	    $file_cov{$source_files{$_}.$_} = $cov_output;
	}
	$path = $source_files{$_};
	if($directories){
	    $path_exec{$path} += $exec;
	    $path_comp{$path} += $comp;
	}
	if($directories == 2){
	    while($path =~ s/^(\.\/(.+\/)+).+$/$1/){
		$path_exec{$path} += $exec;
		$path_comp{$path} += $comp;
	    }
	}
	if($total){
	    $total_exec += $exec;
	    $total_comp += $comp;
	}
    }
}
    
# output the results for files
foreach(sort(keys(%file_cov))){
    $s = " " x (60 - length);
    print "$_$s$file_cov{$_}\n";
}

print "\n";

# output the results for directories
foreach(sort(keys(%path_exec))){
    $s = " " x (60 - length);
    $cov_output = "";
    if($line_counts){
	$cov_output .= "$path_exec{$_} / $path_comp{$_}";
	if($percentages){
	    $cov_output .= " : ";
	}
    }
    if($percentages){
	$cov_percent = $path_comp{$_} ? $path_exec{$_} / $path_comp{$_} : 0;
	$cov_output .= "".$cov_percent."%";
    }
    print "$_$s$cov_output%\n";
}

print "\n";

# output the total results
if($total){
    $s = " " x (60 - length);
    $cov_output = "";
    if($line_counts){
	$cov_output .= "$total_exec / $total_comp";
	if($percentages){
	    $cov_output .= " : ";
	}
    }
    if($percentages){
	$cov_percent = $total_comp ? $total_exec / $total_comp : 0;
	$cov_output .= "$cov_percent"."%";
    }
    print "Total: $cov_output\n";
}
