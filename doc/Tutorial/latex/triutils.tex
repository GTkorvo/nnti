% @HEADER
% ***********************************************************************
% 
%            Trilinos: An Object-Oriented Solver Framework
%                 Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This library is free software; you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation; either version 2.1 of the
% License, or (at your option) any later version.
%  
% This library is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
%  
% You should have received a copy of the GNU Lesser General Public
% License along with this library; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
% USA
% Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
% 
% ***********************************************************************
% @HEADER

\section{Generating Linear Systems with Triutils}
\label{chap:triutils}

This Chapter presents two functionalities of Triutils, that will be
extensively used in the examples of the later chapters: 
\begin{itemize}
\item the Triutils command line parser (in
  Section~\ref{sec:triutils:CLP});
\item the Triutils matrix generator (in \ref{sec:triutils:gallery}).
\end{itemize}
The reader not interested in the examples may decide to skip this chapter.

%%%
%%%
%%%

\subsection{Trilinos\_Util\_CommandLineParser}
\label{sec:triutils:CLP}

\verb!Trilinos_Util_CommandLineParser! is a class to parse the command
line.  With this class, it is easy to handle
input line arguments and shell variables. For instance, the user can
write
\begin{verbatim}
$ ./ex2.exe -nx 10 -tol 1e-6 -solver=cg
\end{verbatim}
and then easily retrieve the value of {\tt nx}, {\tt tol}, and {\tt solver}.
 
A simple code using this class is as follows:
\begin{verbatim}
int main(int argc, char *argv[])
{

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  int nx = CLP.Get("-nx", 123);
  int ny = CLP.Get("-ny", 145);
  double tol = CLP.Get("-tol", 1e-12);
  string solver = CLP.Get("-solver","gmres");

  cout << "nx = " << nx << endl;
  cout << "ny = " << ny << " (default value)" << endl;
  cout << "tol = " << tol << endl;
  cout << "solver = " << solver << endl;

  return 0;
}
\end{verbatim}

Each line   option can have a value or not. For options with a value,
the user can specify this values as follows. Let \verb!-tolerance! be the
name of the option and \verb!1e-12! its value. Both choices are valid:
\begin{itemize}
\item \verb!-tolerance 1e-12! (with one or more spaces)
\item \verb!-tolerance=1e-12! (with \verb!=! sign and no spaces)
\end{itemize}

Option names must begin with one or more dashes (`\verb!-!'). Each option
cannot have more than one value.

To use this class, the user has to build the database using the
\verb!argc,argv! input arguments. Then, to retrieve the option value,
the user has the overloaded function \verb!Get!.
 
If option name is not found in the database, the default value is
returned. If needed, the user can also specify a default value to return
when the option name is not found in the database. Method
\verb!HaveOption! can be used to query the database for an option.

File \TriExe{triutils/ex2.cpp} gives an example of the usage of this class.
 
%%%
%%%
%%%

\subsection{Trilinos\_Util\_CrsMatrixGallery}
\label{sec:triutils:gallery}

\verb!Trilinos_Util_CrsMatrixGallery! is a class to Epetra\_CrsMatrix
and Epetra\_LinearProblem. It is meant to provide functionalities
similar to the MATLAB's \verb!gallery! function. Many of the matrices
that can be created using Trilinos\_Util\_CrsMatrixGallery are indeed
equivalent to those provided by MATLAB\copyright. In these cases, the
reader is referred to the MATLAB documentation for more details about
the matrices' properties. 

A typical constructor requires the problem type and an Epetra\_Comm, and
it is followed by a set of instructions to specify the problem. For
instance, we may have:
\begin{verbatim}
Trilinos_Util_CrsMatrixGallery Gallery("laplace_2d", Comm);
Gallery.set("problem_size",100);
Gallery.set("map_type","linear");
Gallery.set("solution_type","random");
\end{verbatim}
which creates a matrix corresponding to the discretization of a 2D
Laplacian on a Cartesian grid with 100 points. The nodes are decomposed
linearly, and the exact solution is a random vector.

Alternatively, it is possible to read a matrix stored in Harwell/Boeing
format as follows:
\begin{verbatim}
Trilinos_Util_CrsMatrixGallery Gallery("hb", Comm);
Gallery.set("matrix_name",''bcsstk14.rsa'');
Gallery.set("map_type","greedy");
\end{verbatim}
This snipper will read matrix (and, if available, solution and
right-hand side) from the file \verb!bcsstk14.rsa!, and will partition
the matrix across the processes using a gredy algorithm.

A list of currently avaialble problems is reported below. By notation,
\verb!IntValue! refers to a generic positive integer, {\tt
  a,b,c,d,e,f,g} to double-precision values or the Epetra\_Vector.
defined on the map \verb!Gallery.GetMap()!. In the latter case, vector
elements {\tt i} will be use to define the specified coefficient for row
{\tt i}.  Note that some matrices are dense, but still stored as
Epetra\_CrsMatrix. $i$ and $j$ are supposed to start from 0 (C-style).

\vskip .1 in

\choicebox{\tt eye}{Creates an identity matrix. The size of the
  problem is set using {\tt Set("problem size", IntValue)}, or,
  alternatively, by {\tt Set("nx", IntValue)}.}

\choicebox{\tt diag}{Creates a diagonal matrix. The elements on the
  diagonal can be set using {\tt Set("a",value)}. The problem size is
  set as for {\tt eye}.}

\choicebox{\tt tridiag}{Creates a tridiagonal matrix. The diagonal
  element is set using {\tt Set("a", a)}, the subdiagonal using {\tt
    Set("b",b)}, and the superdiagonal using {\tt Set("c",c)}. The
  problem size is specified as for {\tt eye}.}

\choicebox{\tt laplace\_1d}{Creates the classical tridiagonal matrix
  with stencil [-1, 2, -1].  The problem size is specified as for {\tt
    eye}.}

\choicebox{\tt laplace\_2d}{Creates a matrix corresponding to the
  stencil of a 2D Laplacian operator on a structured Cartesian grid.
  The problem size is specified using {\tt Set("problem size",
    IntValue)}.  In this case, IntValue must be a square number.
  Alternatively, one can set the number of nodes along the x-axis and
  y-axis, using {\tt Set("nx",IntValue)} and {\tt Set("ny",IntValue)}.}

\choicebox{\tt cross\_stencil\_2d}{Creates a matrix with the same stencil of
  {\tt laplace\_2d}, but with arbitrary values. The stencil is
  \[
  A =   \left[
    \begin{tabular}{ccc}
    & e &  \\
  b & a & c \\
    & d &   \\
  \end{tabular}
  \right] .
  \]
  The problem size is specified as in {\tt laplace\_2d}.}

\choicebox{\tt laplace\_3d}{Creates a matrix corresponding to the
  stencil of a 3D Laplacian operator on a structured Cartesian grid. The
  problem size is specified using Set("problme size",IntValue). In this
  case, IntValue must be a cube. Alternatively, one can specify the
  number of nodes along the axis, using {\tt Set("nx",IntValue),
    Set("ny",IntValue)}, and {\tt Set("nz",IntValue)}.}

\choicebox{\tt cross\_stencil\_3d}{Similar to the 2D case. The matrix
  stencil correspond to that of a 3D Laplace operator on a structured
  grid. On a given x-y plane, the stencil is as in {\tt laplace 2d}. The
  value on the plane below is set using {\tt Set("f",F)}, and in the
  plane above with {\tt Set("g",G")}. The problem size is specifed as in
  {\tt laplace3d}.}

\choicebox{\tt hb}{The matrix is read from file. File name is specified
  by {\tt Set("file name", FileName)}. {\tt FileName} is a C++ string.
  Problem size is automatically determined.}

\choicebox{\tt lehmer}{Returns a symmetric positive definite matrix, such
  that
  \[
  A_{i,j} = 
  \left\{
    \begin{array}{ll}
      \frac{i+1}{j+1} & if  j \ge i \\
      \frac{j+1}{i+1} & otherwise \\
    \end{array}
  \right. .
  \]
  This
  matrix has three properties: is totally nonnegative, the inverse
  is tridiagonal and esplicitly known, The condition number is bounded
  as $ n \le cond(A) \le 4*n$ (where $n$ is the problem size).}

\choicebox{\tt minij}{Returns the symmetric positive definite matrix
  defined as $A_{i,j} = \min(i+1,j+1)$. More information can be found in the
  help of MATLAB's gallery function.}

\choicebox{\tt ris}{Returns a symmetric Hankel matrix with elements
  $A_{i,j} = 0.5/(n-(i+1)-(j+1)+1.5)$, where $n$ is problem size. The
  eigenvalues of A cluster around $-\pi/2$ and $\pi/2$.}

\choicebox{\tt hilbert}{This is a famous example of a badly conditioned
  matrix. The elements are defined as $1/((i+1)+(j+1)-1)$.}

\choicebox{\tt jordblock}{Creates a Jordan block with eigenvalue set via
  {\tt Set("a",DoubleVal)}.}

\choicebox{\tt cauchy}{Creates a particular instance of a Cauchy matrix
  with elements $A(i,j) = 1/(i+j+2)$ Explicit formulas are known for the
  inverse and determinand of a Cauchy matrix. For this particular Cauchy
  matrix, the determinant is nonzero and the matrix is totally
  positive.}

\choicebox{\tt fiedler}{Creates a matrix whose element are $A_{i,j} = |
  i - j |$.  The matrix is symmetric, and has a dominant positive
  eigenvalue, and all the other eigenvalues are negative.}

\choicebox{\tt hanowa}{Creates a matrix whoe eigenvalues lie on a vertical line
  in the complex plane. The matrix has the 2x2 block structure
  \[
  A = \left[
    \begin{tabular}{cc} a * eye(n/2) & -diag(1:m) \\
        diag(1:m) &     a * eye(n/2) \\
\end{tabular}
      \right].
      \]
      The complex eigenvalues are of the form a $+- k*i$, for $1 \leq
      k \leq n/2$.  The default value for a is -1.}
    
    \choicebox{\tt kms}{Create the n-by-n Kac-Murdock-Szego Toepliz
      matrix such that $A_{i,j} = \rho^{|i-j|}$ (for real $\rho$ only).
      Default value is $\rho= 0.5.$  The inverse of this matrix is
      tridiagonal, and it is positive definite if and only if $0 <
      |\rho| < 1$.}
    
    \choicebox{\tt parter}{Creates a matrix $A_{i,j} = 1/(i-j+0.5)$.
      This matrix is a Cauchy and a Toepliz matrix. Most of the singular
      values of A are very close to $\pi$.}

\choicebox{\tt pei}{Creates the matrix $\alpha$ * eye(n) + ones(n). This
  matrix is singular for $\alpha = 0$ or $-n$.}

\choicebox{\tt vander}{Create the Vandermonde matrix whose second last
  column is the vector c. The j-th column is given by $A(:,j) = C^{(n-j)}$.}

\medskip

Some choices are available to define the exact solution, using {\tt
  Set("exact solution", value)}. {\tt value} can assume the following
values:

\vskip .1 in

\choicebox{\tt constant}{The exact solution vector is made up of 1's.}

\choicebox{\tt random}{Create a random solution vector}

\choicebox{\tt linear}{Set value at node i is defined as alpha*i. The
  double value alpha can be set via {\tt Set("alpha",DoubleVal)}.}

\medskip

\verb!CreateMap()! allows some different maps. The type of map is set
{\tt using Set("map",value)}. {\tt Value} is a string, defined as
reported below.

\vskip .1 in

\choicebox{\tt linear}{Create a linear map. Elements are divided into
  continuous chunks among the processors.}

\choicebox{\tt box}{Used for problems defined on Cartesian grids over a
  square. The domain subdivided into {\tt mx x my} subdomains.  {\tt
    mx} and {\tt my} are specified via {\tt Set("mx",IntValue)} and {\tt
    Set("my",IntValue)}.}

\choicebox{\tt interlaced}{Elements are subdivided so that element i is
  assigned to process i\%NumProcs.}
  
\choicebox{\tt random}{Assign each node to a random process}

\choicebox{\tt greedy}{(only for HB matrices) implements a greedy
  algorithm to decompose the graph of the HB matrix among the processes}

\bigskip

Once all the required parameters have been specified, the user can get a
pointer to the constructed Epetra\_CrsMatrix, to the exact and starting
solution, and to the right-hand side (all Epetra\_Vector's) by using
\begin{verbatim}
A = G.GetMatrix();
ExactSolution = G.GetExactSolution();
RHS = G.GetRHS();
StartingSolution = G.GetStartingSolution();
\end{verbatim}
and a pointer to the Epetra\_LinearProblem as
\begin{verbatim}  
Epetra_LinearProblem Problem(A,StartingSolution,RHS);
\end{verbatim}
At this point, one can for instance solve the linear problem as
\begin{verbatim}  
AztecOO Solver(Problem);
Solver.SetAztecOption( AZ_precond, AZ_dom_decomp );  
Solver.Iterate(1000,1E-9);
\end{verbatim}
Using Trilinos\_Util\_MatrixGallery, one can easily compute the true
residual and the difference between computed and exact solution, as
\begin{verbatim} 
double residual;
G.ComputeResidual(residual);
  
G.ComputeDiffBetweenStartingAndExactSolutions(residual);
\end{verbatim}

%An Epetra\_VrbMatrix pointer is returned by calling
%\verb!GetVbrMatrix()!.  This matrix is formed starting from the
%Epetra\_CsrMatrix, and it is formally equivalent to the CrsMatrix
%returned by \verb!GetMatrix()!, the difference being that each node of
%the CrsMatrix is replicated num\_PDE\_eqns times (this value is passed in
%input, or set via Set("num pde eqns",IntValue)). 
%A pointer to the linear problem defined by the Vbr matrix is returned by
%method \verb!GetVbrLinearProblem()!.

\medskip

Trilinos\_Util\_CrsMatrixGallery can be used in conjuction with
Trilinos\_Util\_CommandLineParser as in the following code:
\begin{verbatim}
int main(int argc, char *argv[]) 
{
 #ifdef HAVE_MPI
  MPI_Init(&argc,&argv);
  Epetra_MpiComm Comm(MPI_COMM_WORLD);
#else
  Epetra_SerialComm Comm;
#endif

  Epetra_Time Time(Comm);

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  Trilinos_Util_CrsMatrixGallery Gallery("", Comm);

  Gallery.Set(CLP);

  // get matrix
  Epetra_CrsMatrix * Matrix = Gallery.GetMatrix();
  Epetra_Vector * LHS = Gallery.GetLHS();
  Epetra_Vector * StartingSolution = Gallery.GetStartingSolution();
  Epetra_Vector * ExactSolution = Gallery.GetExactSolution();
  Epetra_LinearProblem * Problem =  Gallery.GetLinearProblem();

  // various computatons...

  // check that computed solution (in StartingSolution) 
  // is close enough the ExactSolution

  double residual, diff;

  Gallery.ComputeResidual(residual);
  Gallery.ComputeDiffBetweenStartingAndExactSolutions(diff);
  
  if( Comm.MyPID()==0 ) 
    cout << "||b-Ax||_2 = " << residual << endl;

  if( Comm.MyPID()==0 ) 
    cout << "||x_exact - x||_2 = " << diff << endl;

#ifdef HAVE_MPI
  MPI_Finalize() ;
#endif

  return 0 ;

}
\end{verbatim}
This program can be executed with the following command line:
\begin{verbatim}
[msala:triutils]> mpirun -np 4 ex1.exe -problem_type=laplace_2d \
                  -problem_size=10000
\end{verbatim}

\begin{remark}
  Most of the examples reported in the following chapters use both
  Trilinos\_Util\_CommandLineParser and Trilinos\_Util\_CrsMatrixGallery
  to define the distributed matrix. The user is encouraged to test a
  given method using matrices with different numerical properties.
\end{remark}

