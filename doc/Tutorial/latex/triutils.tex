% @HEADER
% ***********************************************************************
% 
%            Trilinos: An Object-Oriented Solver Framework
%                 Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This library is free software; you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation; either version 2.1 of the
% License, or (at your option) any later version.
%  
% This library is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
%  
% You should have received a copy of the GNU Lesser General Public
% License along with this library; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
% USA
% Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
% 
% ***********************************************************************
% @HEADER

\section{Generating Linear Systems with Triutils}
\label{chap:triutils}

This Chapter presents two functionalities of Triutils, that will be
extensively used in the examples of the later chapters: 
\begin{itemize}
\item the Triutils command line parser (in
  Section~\ref{sec:triutils:CLP});
\item the Triutils matrix generator (in \ref{sec:triutils:gallery}).
\end{itemize}
The reader not interested in the examples may decide to skip this chapter.

%%%
%%%
%%%

\subsection{Trilinos\_Util\_CommandLineParser}
\label{sec:triutils:shell}

\verb!Trilinos\_Util\_CommandLineParser! is a class to parse the command
line.  With this class, it is easy to handle
input line arguments and shell variables. For instance, the user can
write
\begin{verbatim}
$ ./ex2.exe -nx 10 -tol 1e-6 -solver=cg 
\end{verbatim}
and then easily retrieve the value of {\tt nx}, {\tt tol}, and {\tt solver}.
 
A simple code using this class is as follows:
\begin{verbatim}
int main(int argc, char *argv[])
{

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  int nx = CLP.Get("-nx", 123);
  int ny = CLP.Get("-ny", 145);
  double tol = CLP.Get("-tol", 1e-12);
  string solver = CLP.Get("-solver","gmres");

  cout << "nx = " << nx << endl;
  cout << "ny = " << ny << " (default value)" << endl;
  cout << "tol = " << tol << endl;
  cout << "solver = " << solver << endl;

  return 0;
}
\end{verbatim}

Each line   option can have a value or not. For options with a value,
the user can specify this values as follows. Let \verb!-tolerance! be the
name of the option and \verb!1e-12! its value. Both choices are valid:
\begin{itemize}
\item \verb!-tolerance 1e-12! (with one or more spaces)
\item \verb!-tolerance=1e-12! (with \verb!=! sign and no spaces)
\end{itemize}

Option names must begin with one or more dashes (`\verb!-!'). Each option
cannot have more than one value.

To use this class, the user has to build the database using the
\verb!argc,argv! input arguments. Then, to retrieve the option value,
the user has the overloaded function \verb!Get!.
 
If option name is not found in the database, the default value is
returned. If needed, the user can also specify a default value to return
when the option name is not found in the database. Method
\verb!HaveOption! can be used to query the database for an option.

File \TriExe{triutils/ex2.cpp} gives an example of the usage of this class.
 
%%%
%%%
%%%

\subsection{Trilinos\_Util\_CrsMatrixGallery}
\label{sec:triutils:gallery}

\verb!Trilinos_Util_CrsMatrixGallery! is a class to Epetra\_CrsMatrix
and Epetra\_LinearProblem. It is meant to provide functionalities
similar to the MATLAB's \verb!gallery! function. Many of the matrices
that can be created using Trilinos\_Util\_CrsMatrixGallery are indeed
equivalent to those provided by MATLAB\copyright. In these cases, the
reader is referred to the MATLAB documentation for more details about
the matrices' properties. 

A typical constructor requires the problem type and an Epetra\_Comm, and
it is followed by a set of instructions to specify the problem. For
instance, we may have:
\begin{verbatim}
Trilinos_Util_MatrixGallery Gallery("laplace_2d", Comm);
Gallery.set("problem_size",100);
Gallery.set("map_type","linear");
Gallery.set("solution_type","random");
\end{verbatim}
which creates a matrix corresponding to the discretization of a 2D
Laplacian on a Cartesian grid with 100 points. The nodes are decomposed
linearly, and the exact solution is a random vector.

A list of currently avaialble problems is reported below. By notation,
\verb!IntValue! refers to a generic positive integer, \verb!a,b,c! to
double-precision values.

\vskip .1 in

\choicebox{\tt eye}{Creates an identity matrix. The dimension of the
  problem is set using {\tt Set("problem size", IntValue)}, or,
  alternatively, by {\tt Set("nx", IntValue)}.}

\choicebox{\tt diag}{Creates a diagonal matrix. The elements on the
  diagonal can be set using {\tt Set("a",value)}, where value is either a
  double, or an Epetra\_Vector. Problem size set as for {\tt eye}.}

\choicebox{\tt tridiag}{ Creates a tridiagonal matrix. The diagonal
  element is set using {\tt Set("a", DiagValue)}, the subdiagonal using
  {\tt Set("b",SubDiagValue)}, and the superdiagonal using
  {\tt Set("c",SupDiagValue)}.  DiagValue, SubDiagValue, and SupDiagValue can
  be scalar or Epetra vectors.  In the latter case, all vectors must
  have the same number of elements. Elements i will be use to define row
  i. Problem size specified as for {\tt eye}.}

\choicebox{\tt laplace\_1d}{ Create the classical tridiagonal matrix
  with stencil [-1, 2, -1].  Problem size specified as for {\tt eye}.}

\choicebox{\tt laplace\_2d}{Creates a matrix corresponding to the
  stencil of a 2D Laplacian operator on a structured cartesian grid.
  Problem size is specified using {\tt Set("problem size", IntValue)}.
  In this case, IntValue must be a square number. Alternatively, one can
  set the number of nodes along the x-axis and y-axis, using {\tt
    Set("nx",IntValue)} and {\tt Set("ny",IntValue)}.}

\choicebox{\tt cross\_stencil\_2d}{Creates a matrix with the same stencil of
  "laplace\_2d", but with arbitrary values. The stencil is
  \[
  A =   \left[
    \begin{tabular}{ccc}
    & e &  \\
  b & a & c \\
    & d &   \\
  \end{tabular}
  \right]
  \]
  and each value can be either a double, or and Epetra\_Vector. Problem
  size specified as in "laplace\_2d."}

\choicebox{\tt laplace\_3d}{Creates a matrix corresponding to the stencil of
  a 3D Laplacian operator on a structured cartesian grid. Problem size
  specified using Set("problme size",IntValue). In this case, IntValue
  must be a cube. Alternatively, one can specify the number of nodes
  along the axis, using {\tt Set("nx",IntValue), Set("ny",IntValue)}, and
  {\tt Set("nz",IntValue)}.}

\choicebox{\tt cross\_stencil\_3d}{Similar to the 2D case. The matrix stencil
  correspond to that of a 3D Laplace operator on a structured grid. On a
  given x-y plane, the stencil is a in {\tt laplace 2d}. The value on the
  plane below is set using Set("f",F), and in the plane above with
  {\tt Set("g",G")}. Problem size specifed as in {\tt laplace3d}.}

\choicebox{\tt hb}{The matrix is read from file. File name is specified
  by {\tt Set("file name", FileName)}. {\tt FileName} is a C++ string.
  Problem size is automatically read from file.}

\choicebox{\tt lehmer}{Returns a symmetric positive definite matrix, such
  that A(i,j) = (i+1)/(j+1) (for j>=i), and (j+1)/(i+1) (for j<j). This
  matrix has three properties: is totally nonnegative, the inverse
  is tridiagonal and esplicitly known, The condition number is bounded
  as n <= cond(A) <= 4*n (n is the problem size).}

\choicebox{\tt minij}{Returns the symmetric positive definite matrix
  defined sd A(i,j) = min(i+1,j+1). More information can be found in the
  help of MATLAB's gallery function.}

\choicebox{\tt ris}{Returns a symmetric Hankel matrix with elements
  A(i,j) = 0.5/(n-(i+1)-(j+1)+1.5), with n equals problem size. (i and j
  start from 0.)  The eigenvalues of A cluster around -$\pi/2$ and
  $\pi/2$.}

\choicebox{\tt hilbert}{This is a famous example of a badly conditioned
  matrix. The elements are defined as 1/((i+1)+(j+1)-1). (i and j start
  from 0.)}

\choicebox{\tt jordblock}{Creates a Jordan block with eigenvalue set via
  {Set("a",DoubleVal)}.}

\choicebox{\tt  cauchy}{Creates a particular instance of a Cauchy matrix with
  elements A(i,j) = 1/(i+j) (where i and j range from 1 to
  NumGlobalElements).  Explicit formulas are known for the inverse and
  determinand of a Cauchy matrix. For this particular Cauchy matrix, the
  determinant is nonzero and the matrix is totally positive.}

\choicebox{\tt fiedler}{Creates a matrix whose element are A(i,j) = | i - j |.
  The matrix is symmetric, and has a dominant positive eigenvalue, and
  all the other eigenvalues are negative.}

\choicebox{\tt hanowa}{Creates a matrix whoe eigenvalues lie on a vertical line
  in the complex plane. The matrix has the 2x2 block structure
  \[
  A = \left[
    \begin{tabular}{cc} a * eye(n/2) & -diag(1:m) \\
        diag(1:m) &     a * eye(n/2) \\
\end{tabular}
      \right].
        \]
  The complex eigenvalues are of the form a +- k*i, for 1 <= k <= n/2.
  The default value for a is -1.}

\choicebox{\tt kms}{Create the n-by-n Kac-Murdock-Szego Toepliz matrix
  such that A(i,j) = rho\^(abs(i-j)) (for real rho only). Default value
  for rho is 0.5.  The inverse of this matrix is tridiagonal, and it is
  positive definite if and only if 0 < abs(rho) < 1.}

\choicebox{\tt parter}{Creates a matrix A(i,j) = 1/(i-j+0.5). A is a
  Cauchy and a Toeplliz matrix. Most of the singular values of A are
  very close to $\pi$.}

\choicebox{\tt pei}{Creates the matrix $\alpha$ * eye(n) + ones(n). This
  matrix is singular for $\alpha = 0$ or -n.}

\choicebox{\tt vander}{Create the Vandermonde matrix whose second last
  column is the vector c. The j-th column is given by $A(:,j) = C^{(n-j)}$.}

\medskip

Some choices are available to define the exact solution, using
Set("exact solution", value). value can be: 

\vskip .1 in

\choicebox{\tt constant}{The exact solution vector is made up of 1's.}

\choicebox{\tt random}{Create a random solution vector}

\choicebox{\tt linear}{Set value at node i is defined as alpha*i. The
  double value alpha can be set via {\tt Set("alpha",DoubleVal)}.}

\medskip

\verb!CreateMap()! allows some different maps. The type of map is set
using Set("map",value). Value is a string, defined as reported below.

\vskip .1 in

\choicebox{\tt linear}{Create a linear map. Elements are divided into
  continuous chunks among the processors.}

\choicebox{\tt box}{Used for problems defined on cartesian grids over a
  square. The nodes is subdivided into {\tt mx x my} subdomains. {\tt
    mx} and {\tt my} are specified via {\tt Set("mx",IntValue)} and {\tt
    Set("my",IntValue)}.}

\choicebox{\tt interlaces}{Elements are subdivided so that element i is
  assigned to process i\%NumProcs.}
  
\choicebox{\tt random}{Assign each node to a random process}

\choicebox{\tt greedy}{(only for HB matrices) implements a greedy
  algorithm to decompose the graph of the HB matrix among the processes}

\bigskip

Once all the required parameters have been specified, the user can get a
pointer to the constructed Epetra\_CrsMatrix, to the exact and starting
solution, and to the right-hand side (all Epetra\_Vector's) by using
\begin{verbatim}
A = G.GetMatrix();
ExactSolution = G.GetExactSolution();
RHS = G.GetRHS();
StartingSolution = G.GetStartingSolution();
\end{verbatim}
and a pointer to the Epetra\_LinearProblem as
\begin{verbatim}  
Epetra_LinearProblem Problem(A,StartingSolution,RHS);
\end{verbatim}
At this point, one can for instance solve the linear problem as
\begin{verbatim}  
AztecOO Solver(Problem);
Solver.SetAztecOption( AZ_precond, AZ_dom_decomp );  
Solver.Iterate(1000,1E-9);
\end{verbatim}
Using Trilinos\_Util\_MatrixGallery, one can easily compute the true
residual and the difference between computed and exact solution, as
\begin{verbatim} 
double residual;
G.ComputeResidual(residual);
  
G.ComputeDiffBetweenStartingAndExactSolutions(residual);
\end{verbatim}

An Epetra\_VrbMatrix pointer is returned by calling
\verb!GetVbrMatrix()!.  This matrix is formed starting from the
Epetra\_CsrMatrix, and it is formally equivalent to the CrsMatrix
returned by \verb!GetMatrix()!, the difference being that each node of
the CrsMatrix is replicated num\_PDE\_eqns times (this value is passed in
input, or set via Set("num pde eqns",IntValue)). 
A pointer to the linear problem defined by the Vbr matrix is returned by
method \verb!GetVbrLinearProblem()!.

\medskip

Trilinos\_Util\_CrsMatrixGallery can be used in conjuction with
Trilinos\_Util\_CommandLineParser as in the following code:
\begin{verbatim}
int main(int argc, char *argv[]) 
{
 #ifdef HAVE_MPI
  MPI_Init(&argc,&argv);
  Epetra_MpiComm Comm(MPI_COMM_WORLD);
#else
  Epetra_SerialComm Comm;
#endif

  Epetra_Time Time(Comm);

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  Trilinos_Util_CrsMatrixGallery Gallery("", Comm);

  Gallery.Set(CLP);

  // get matrix
  Epetra_CrsMatrix * Matrix = Gallery.GetMatrix();
  Epetra_Vector * LHS = Gallery.GetLHS();
  Epetra_Vector * StartingSolution = Gallery.GetStartingSolution();
  Epetra_Vector * ExactSolution = Gallery.GetExactSolution();
  Epetra_LinearProblem * Problem =  Gallery.GetLinearProblem();

  // various computatons...

  // check that computed solution (in StartingSolution) 
  // is close enough the ExactSolution

  double residual, diff;

  Gallery.ComputeResidual(residual);
  Gallery.ComputeDiffBetweenStartingAndExactSolutions(diff);
  
  if( Comm.MyPID()==0 ) 
    cout << "||b-Ax||_2 = " << residual << endl;

  if( Comm.MyPID()==0 ) 
    cout << "||x_exact - x||_2 = " << diff << endl;

#ifdef HAVE_MPI
  MPI_Finalize() ;
#endif

  return 0 ;

}
\end{verbatim}
This program may be ran with the following command line:
\begin{verbatim}
$ ex1.exe -problem_type=laplace_2d -problem_size=10000
\end{verbatim}