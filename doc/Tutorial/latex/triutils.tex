% @HEADER
% ***********************************************************************
% 
%            Trilinos: An Object-Oriented Solver Framework
%                 Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This library is free software; you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation; either version 2.1 of the
% License, or (at your option) any later version.
%  
% This library is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
%  
% You should have received a copy of the GNU Lesser General Public
% License along with this library; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
% USA
% Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
% 
% ***********************************************************************
% @HEADER

\section{Generating Linear Systems with Triutils}
\label{chap:triutils}

This Chapter presents two functionalities of Triutils, that will be
extensively used in the examples of the later chapters: 
\begin{itemize}
\item the Triutils command line parser (in
  Section~\ref{sec:triutils:CLP});
\item the Triutils matrix generator (in \ref{sec:triutils:gallery}).
\end{itemize}
The reader not interested in the examples may decide to skip this chapter.

%%%
%%%
%%%

\subsection{Trilinos\_Util\_CommandLineParser}
\label{sec:triutils:CLP}

\verb!Trilinos_Util_CommandLineParser! is a class to parse the command
line.  With this class, it is easy to handle
input line arguments and shell variables. For instance, the user can
write
\begin{verbatim}
[msala:triutils]> ./ex2.exe -nx 10 -tol 1e-6 -solver=cg
\end{verbatim}
and then easily retrieve the value of {\tt nx}, {\tt tol}, and {\tt solver}.
 
A simple code using this class is as follows:
\begin{verbatim}
int main(int argc, char *argv[])
{

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  int nx = CLP.Get("-nx", 123);
  int ny = CLP.Get("-ny", 145);
  double tol = CLP.Get("-tol", 1e-12);
  string solver = CLP.Get("-solver","gmres");

  cout << "nx = " << nx << endl;
  cout << "ny = " << ny << " (default value)" << endl;
  cout << "tol = " << tol << endl;
  cout << "solver = " << solver << endl;

  return 0;
}
\end{verbatim}

Each line   option can have a value or not. For options with a value,
the user can specify this values as follows. Let \verb!-tolerance! be the
name of the option and \verb!1e-12! its value. Both choices are valid:
\begin{itemize}
\item \verb!-tolerance 1e-12! (with one or more spaces)
\item \verb!-tolerance=1e-12! (with \verb!=! sign and no spaces)
\end{itemize}

Option names must begin with one or more dashes (`\verb!-!'). Each option
cannot have more than one value.

To use this class, the user has to build the database using the
\verb!argc,argv! input arguments. Then, to retrieve the option value,
the user has the overloaded function \verb!Get!.
 
If option name is not found in the database, the default value is
returned. If needed, the user can also specify a default value to return
when the option name is not found in the database. Method
\verb!HaveOption! can be used to query the database for an option.

File \TriExe{triutils/ex2.cpp} gives an example of the usage of this class.
 
%%%
%%%
%%%

\subsection{Trilinos\_Util\_CrsMatrixGallery}
\label{sec:triutils:gallery}

\verb!Trilinos_Util_CrsMatrixGallery! is a class to Epetra\_CrsMatrix
and Epetra\_LinearProblem. It is meant to provide functionalities
similar to the MATLAB's \verb!gallery! function\footnote{Many of the
  matrices that can be created using Trilinos\_Util\_CrsMatrixGallery
  are equivalent or simiilar to those provided by the MATLAB\copyright
  function {\tt gallery}. In these cases, the reader is referred to the
  MATLAB documentation for more details about the matrices'
  properties.}.

A typical constructor requires the problem type and an Epetra\_Comm, and
it is followed by a set of instructions to specify the problem. For
instance, we may have:
\begin{verbatim}
Trilinos_Util_CrsMatrixGallery Gallery("laplace_2d", Comm);
Gallery.set("problem_size",100);
Gallery.set("map_type","linear");
Gallery.set("solution_type","random");
\end{verbatim}
which creates a matrix corresponding to the discretization of a 2D
Laplacian on a Cartesian grid with 100 points. The nodes are decomposed
linearly, and the exact solution is a random vector.

Alternatively, it is possible to read a matrix stored in Harwell/Boeing
format as follows:
\begin{verbatim}
Trilinos_Util_CrsMatrixGallery Gallery("hb", Comm);
Gallery.set("matrix_name","bcsstk14.rsa");
Gallery.set("map_type","greedy");
\end{verbatim}
This snipper will read matrix (and, if available, solution and
right-hand side) from the file \verb!bcsstk14.rsa!, and will partition
the matrix across the processes using a gredy algorithm.

A list of currently avaialble problems is reported below. By notation,
\verb!IntValue! refers to a generic positive integer, {\tt
  a,b,c,d,e,f,g} to double-precision values or the Epetra\_Vector.
defined on the map \verb!Gallery.GetMap()!. In the latter case, vector
elements {\tt i} will be use to define the specified coefficient for row
{\tt i}.  Note that some matrices are dense, but still stored as
Epetra\_CrsMatrix. The generic $(i,j)$ element of a given matrix is
$A_{i,j}$ (for simplicity, we suppose that indices start from
1\footnote{It is understood that, in the actual implementation, indices
  start from 0.}). $n$ represents the matrix size.

\vskip .1 in

\choicebox{\tt eye}{Creates an identity matrix. The size of the
  problem is set using {\tt Set("problem size", IntValue)}, or,
  alternatively, by {\tt Set("nx", IntValue)}.}


\choicebox{\tt cauchy}{Creates a particular instance of a Cauchy matrix
  with elements $A_{i,j} = 1/(i+j)$ Explicit formulas are known for the
  inverse and determinand of a Cauchy matrix. For this particular Cauchy
  matrix, the determinant is nonzero and the matrix is totally
  positive.}

\choicebox{\tt cross\_stencil\_2d}{Creates a matrix with the same stencil of
  {\tt laplace\_2d}, but with arbitrary values. The stencil is
  \[
  A =   \left[
    \begin{tabular}{ccc}
    & e &  \\
  b & a & c \\
    & d &   \\
  \end{tabular}
  \right] .
  \]
  The default values are {\tt a=5, b=c=d=e=1}.
  The problem size is specified as in {\tt laplace\_2d}.}

\choicebox{\tt cross\_stencil\_3d}{Similar to the 2D case. The matrix
  stencil correspond to that of a 3D Laplace operator on a structured
  grid. On a given x-y plane, the stencil is as in {\tt laplace 2d}. The
  value on the plane below is set using {\tt Set("f",F)}, and in the
  plane above with {\tt Set("g",G")}.  The default values are {\tt
    a=7,b=c=d=e=f=g=1}. The problem size is specified as in {\tt
    laplace3d}.}

\choicebox{\tt diag}{Creates a diagonal matrix. The elements on the
  diagonal can be set using {\tt Set("a",value)}. Default value is {\tt
    a = 1}. The problem size is set as for {\tt eye}.}

\choicebox{\tt fiedler}{Creates a matrix whose element are $A_{i,j} = |
  i - j |$.  The matrix is symmetric, and has a dominant positive
  eigenvalue, and all the other eigenvalues are negative.}

\choicebox{\tt hanowa}{Creates a matrix whose eigenvalues lie on a
  vertical line in the complex plane. The matrix has the 2x2 block
  structure (in MATLAB's notation)
  \[
  A = \left[
    \begin{tabular}{cc} a * eye(n/2) & -diag(1:m) \\
        diag(1:m) &     a * eye(n/2) \\
\end{tabular}
      \right].
      \]
      The complex eigenvalues are of the form a $k \sqrt{-1}$ and $-k
      \sqrt{-1}$, for $1 \leq k \leq n/2$.  The default value for {\tt
        a} is -1.}

\choicebox{\tt hb}{The matrix is read from file. File name is specified
  by {\tt Set("file name", FileName)}. {\tt FileName} is a C++ string.
  The problem size is automatically determined.}



\choicebox{\tt hilbert}{This is a famous example of a badly conditioned
  matrix. The elements are defined as $A_{i,j} = 1/(i+j)$.}

\choicebox{\tt jordblock}{Creates a Jordan block with eigenvalue set via
  {\tt Set("a",DoubleVal)}. The default value is 0.1. The problem size
  is specified as for {\tt eye}.}
    
\choicebox{\tt kms}{Create the $n \times n$ Kac-Murdock-Szego
  Toepliz matrix such that $A_{i,j} = \rho^{|i-j|}$ (for real $\rho$
  only).  Default value is $\rho= 0.5$, or can be set as {\tt
    Set("a",value)}. The inverse of this matrix is tridiagonal, and
  the matrix is positive definite if and only if $0 < |\rho| < 1$.}

\choicebox{\tt laplace\_1d}{Creates the classical tridiagonal matrix
  with stencil [-1, 2, -1].  The problem size is specified as for {\tt
    eye}.}

\choicebox{\tt laplace\_1d}{As for {\tt laplace\_1d}, but with Neumann
  boundary condition. The matrix is singular. }

\choicebox{\tt laplace\_2d}{Creates a matrix corresponding to the
  stencil of a 2D Laplacian operator on a structured Cartesian grid.
  The problem size is specified using {\tt Set("problem size",
    IntValue)}.  In this case, IntValue must be a square number.
  Alternatively, one can set the number of nodes along the x-axis and
  y-axis, using {\tt Set("nx",IntValue)} and {\tt Set("ny",IntValue)}.}

\choicebox{\tt laplace\_2d\_n}{As for {\tt laplace\_2d}, but with Neumann
  boundary condition. The matrix is singular.}

\choicebox{\tt laplace\_3d}{Creates a matrix corresponding to the
  stencil of a 3D Laplacian operator on a structured Cartesian grid. The
  problem size is specified using Set("problme size",IntValue). In this
  case, IntValue must be a cube. Alternatively, one can specify the
  number of nodes along the axis, using {\tt Set("nx",IntValue),
    Set("ny",IntValue)}, and {\tt Set("nz",IntValue)}.}

\choicebox{\tt lehmer}{Returns a symmetric positive definite matrix, such
  that
  \[
  A_{i,j} = 
  \left\{
    \begin{array}{ll}
      \frac{i}{j} & \mbox{ if } j \ge i \\
      \frac{j}{i} & \mbox{ otherwise } \\
    \end{array}
  \right. .
  \]
  This matrix has three properties: is totally nonnegative, the inverse
  is tridiagonal and esplicitly known, The condition number is bounded
  as $ n \le cond(A) \le 4*n$. The problem size is set as for {\tt
    eye}.}



\choicebox{\tt minij}{Returns the symmetric positive definite matrix
  defined as $A_{i,j} = \min(i,j)$. The problem size is set as for {\tt
    eye}.}

\choicebox{\tt ones}{Creates a matrix with equal elements. The default
  value is 1, and cab be changed using {\tt Set("a",a)}.}

\choicebox{\tt parter}{Creates a matrix $A_{i,j} = 1/(i-j+0.5)$.  This
  matrix is a Cauchy and a Toepliz matrix. Most of the singular values
  of A are very close to $\pi$. The problem size is set as for {\tt
    eye}.}

\choicebox{\tt pei}{Creates the matrix 
\[
A_{i,j} = \left\{ \begin{array}{cc}
\alpha + 1 & \mbox{ if } i \neq j \\
1  & \mbox{ if } i = j.
\end{array}
\right. .
\]
The value of $\alpha$ can be set as {\tt Set("a",value)}, and it is
defaulted to 1. This matrix is singular for $\alpha = 0$ or $-n$.}


\choicebox{\tt recirc\_2d}{Returns a matrix corresponding to the
  finite-difference discretization of the problem
  \[
- \mu \Delta u + (v_x,v_y) \cdot \nabla u = f
\]
on the unitary square, with homogeneous Dirichlet boundary
conditions. A standard 5-pt formula is used to discretize the diffusive
term, and a simple upwind for the convective term. Here,
\[
v_x = ( y - 1/2 ) V, \quad \quad \quad v_y = ( 1/2 - x ) V
\]
The value of $\mu$ can be specified using {\tt Set("b", b)}, and that of
$V$ using {\tt Set("a", a)}. The default values are {\tt a=1, b=1e-5}.
The problem size is specified as in {\tt laplace\_3d}.}


\choicebox{\tt ris}{Returns a symmetric Hankel matrix with elements
  $A_{i,j} = 0.5/(n-i-j+1.5)$, where $n$ is problem size. The
  eigenvalues of A cluster around $-\pi/2$ and $\pi/2$.}

\choicebox{\tt tridiag}{Creates a tridiagonal matrix. The diagonal
  element is set using {\tt Set("a", a)}, the subdiagonal using {\tt
    Set("b",b)}, and the superdiagonal using {\tt Set("c",c)}. The
  default values are {\tt a=2, b=c=1}. The problem size is specified as
  for {\tt eye}.}

\choicebox{\tt unidir\_flow\_2d}{Returns a matrix corresponding to the
  finite-difference discretization of the problem
  \[
- \mu \Delta u + (v_x,v_y) \cdot \nabla u = f
\]
on the unitary square, with homogeneous Dirichlet boundary
conditions. A standard 5-pt formula is used to discretize the diffusive
term, and a simple upwind for the convective term. Here,
\[
v_x = cos(\alpha) V, \quad \quad \quad v_y =  sin(\alpha) V 
\]
that corresponds to an unidirectional 2D flow.  The value of $\mu$ can
be specified using {\tt Set("b", b)}, and that of $V$ using {\tt
  Set("a", a)}, and that of $\alpha$ using {\tt Set("c", c)}. The
default values are {\tt a=1, b=1e-5, c=0}. The problem size is specified
as in {\tt laplace3d}.}

%\choicebox{\tt vander}{Create the Vandermonde matrix whose second last
%  column is the vector c. The j-th column is given by $A(:,j) =
%  \alpha^{(n-j)}$. The value of $\alpha$ can be set as {\tt
%    Set("a",value)}, and it is defaulted to 0.5. }


\medskip

Some choices are available to define the exact solution, using {\tt
  Set("exact solution", value)}. {\tt value} can assume the following
values:

\vskip .1 in

\choicebox{\tt constant}{The exact solution vector is made up of
  1's. This is the default value.}

\choicebox{\tt random}{Create a random solution vector}

\choicebox{\tt linear}{Set value at node i is defined as alpha*i. The
  double value alpha can be set via {\tt Set("alpha",DoubleVal)}.}

\medskip

\verb!CreateMap()! allows some different maps. The type of map is set
{\tt using Set("map",value)}. {\tt Value} is a string, defined as
reported below.

\vskip .1 in

\choicebox{\tt linear}{Create a linear map. Elements are divided into
  continuous chunks among the processors. This is the default value.}

\choicebox{\tt box}{Used for problems defined on Cartesian grids over a
  square. The domain subdivided into {\tt mx x my} subdomains.  {\tt
    mx} and {\tt my} are specified via {\tt Set("mx",IntValue)} and {\tt
    Set("my",IntValue)}.}

\choicebox{\tt interlaced}{Elements are subdivided so that element i is
  assigned to process i\%NumProcs.}
  
\choicebox{\tt random}{Assign each node to a random process}

\choicebox{\tt greedy}{(only for HB matrices) implements a greedy
  algorithm to decompose the graph of the HB matrix among the processes}

\bigskip

Once all the required parameters have been specified, the user can get a
pointer to the constructed Epetra\_CrsMatrix, to the exact and starting
solution, and to the right-hand side (all Epetra\_Vector's) by using
\begin{verbatim}
A = G.GetMatrix();
ExactSolution = G.GetExactSolution();
RHS = G.GetRHS();
StartingSolution = G.GetStartingSolution();
\end{verbatim}
and a pointer to the Epetra\_LinearProblem as
\begin{verbatim}  
Epetra_LinearProblem Problem(A,StartingSolution,RHS);
\end{verbatim}
At this point, one can for instance solve the linear problem as
\begin{verbatim}  
AztecOO Solver(Problem);
Solver.SetAztecOption( AZ_precond, AZ_dom_decomp );  
Solver.Iterate(1000,1E-9);
\end{verbatim}
Using Trilinos\_Util\_MatrixGallery, one can easily compute the true
residual and the difference between computed and exact solution, as
\begin{verbatim} 
double residual;
G.ComputeResidual(residual);
  
G.ComputeDiffBetweenStartingAndExactSolutions(residual);
\end{verbatim}

The matrix can be written on a file in MATLAB format, using
\begin{verbatim}
string FileName = "matrix.m";
bool UseSparse = false;
Gallert.WriteMatrix(FileName,UseSparse);
\end{verbatim}
If \verb!UseSparse! is true, the matrix is created in sparse format
(using the MATLAB command \verb!spalloc!).

\medskip

Class Trilinos\_Util\_VrbMatrixGallery, derived from
Trilinos\_Util\_MatrixGallery, can be used to generate VBR matrices.
The class creates an Epetra\_CrsMatrix (following user's defined
parameters, as previously specified), then ``expands'' this matrix into
a VBR matrix. This VBR  matrix is based on an Epetra\_BlockMap, based on
the Epetra\_Map used to define the Epetra\_CrsMatrix. The number of PDE
equations per node is set with parameter \verb!num_pde_eqns!. The
Epetra\_CrsMatrix is expanded into a VBR matrix by replicating the
matrix \verb!num_pde_eqns! times for each equation.

Trilinos\_Util\_VrbMatrixGallery defines the following methods:

\vskip .1 in

\choicebox{\tt GetVrbMatrix()}{Returns a pointer to the internally
  stored Vbr matrix.}

\choicebox{\tt GetVrbExactSolution()}{Returns a pointer to the internally
  stored exact solution vector (as an Epetra\_Vector).}

\choicebox{\tt GetVrbStartingSolution()}{Returns a pointer to the
  internally stored starting solution vector (as an Epetra\_Vector).}

\choicebox{\tt GetVrbRhs()}{Returns a pointer to the internally
  stored right-hand side (as an Epetra\_Vector).}

\choicebox{\tt GetVrbLinearProblem()}{Returns a pointer to the internally
  stored  Epetra\_LinearProblem for the Vbr matrix).}

\choicebox{\tt GetBlock()}{Returns a pointer to the internally
  stored Epetra\_BlockMap.}
\medskip


\medskip

Trilinos\_Util\_CrsMatrixGallery can be used in conjuction with
Trilinos\_Util\_CommandLineParser as in the following code:
\begin{verbatim}
int main(int argc, char *argv[]) 
{
 #ifdef HAVE_MPI
  MPI_Init(&argc,&argv);
  Epetra_MpiComm Comm(MPI_COMM_WORLD);
#else
  Epetra_SerialComm Comm;
#endif

  Epetra_Time Time(Comm);

  Trilinos_Util_CommandLineParser CLP(argc,argv);
  Trilinos_Util_CrsMatrixGallery Gallery("", Comm);

  Gallery.Set(CLP);

  // get matrix
  Epetra_CrsMatrix * Matrix = Gallery.GetMatrix();
  Epetra_Vector * LHS = Gallery.GetLHS();
  Epetra_Vector * StartingSolution = Gallery.GetStartingSolution();
  Epetra_Vector * ExactSolution = Gallery.GetExactSolution();
  Epetra_LinearProblem * Problem =  Gallery.GetLinearProblem();

  // various computatons...

  // check that computed solution (in StartingSolution) 
  // is close enough the ExactSolution

  double residual, diff;

  Gallery.ComputeResidual(residual);
  Gallery.ComputeDiffBetweenStartingAndExactSolutions(diff);
  
  if( Comm.MyPID()==0 ) 
    cout << "||b-Ax||_2 = " << residual << endl;

  if( Comm.MyPID()==0 ) 
    cout << "||x_exact - x||_2 = " << diff << endl;

#ifdef HAVE_MPI
  MPI_Finalize() ;
#endif

  return 0 ;

}
\end{verbatim}
This program can be executed with the following command line:
\begin{verbatim}
[msala:triutils]> mpirun -np 4 ex1.exe -problem_type=laplace_2d \
                  -problem_size=10000
\end{verbatim}

\begin{remark}
  Most of the examples reported in the following chapters use both
  Trilinos\_Util\_CommandLineParser and Trilinos\_Util\_CrsMatrixGallery
  to define the distributed matrix. The user is encouraged to test a
  given method using matrices with different numerical properties.
\end{remark}

