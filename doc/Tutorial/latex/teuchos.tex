%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\section{The Teuchos Utility Classes}
\label{chap:teuchos}

Teuchos (pronounced ``te-fos'') is a collection of portable C++ tools
that facilitate the development of scientific codes.  Only a few of the many
tools in Teuchos are mentioned in this section.
For more details on all of the capabilities provided by Teuchos, please 
refer to the online documentation (\verb!http://software.sandia.gov/trilinos/packages/teuchos!).

Teuchos classes have been divided between a``standard'' build and an
``extended'' build. The ``standard'' build contains the general purpose
templated tools like BLAS/LAPACK wrappers, parameter lists, a command-line parser,
serial dense matrices, timers, flop counters, and a reference-counted pointer class.  
These tools are built by default when Teuchos is enabled using the 
configure option \verb!--enable-teuchos!. 
The ``extended'' build contains more special purpose tools like 
XML parsing and MPI communicators, which can be included in the Teuchos
library by using the configure option \verb!--enable-teuchos-extended!.

\medskip

In this Chapter, we will present the following ``standard'' build classes:
\begin{itemize}

\item \verb!Teuchos::ScalarTraits! class (Section~\ref{sec:teuchos:ScalarTraits}):
  The ScalarTraits class provides a basic interface to scalar types (float, double, 
  complex$<$float$>$, complex$<$double$>$) that is used by the templated computational
  classes within Teuchos.  It is the mechanism by which Teuchos' capabilities 
  can be extended to support arbitrary precisions.

\item \verb!Teuchos::SerialDenseMatrix! class (Section~\ref{sec:teuchos:SDM}): 
  The SerialDenseMatrix is a templated version of the \verb!Epetra_SerialDenseMatrix! class
  that is most often used to interface with the templated BLAS/LAPACK wrappers.

\item \verb!Teuchos::BLAS! class (Section~\ref{sec:teuchos:BLAS}):
  The BLAS class provides templated wrappers
  for the native BLAS library and can be extended to provide arbitrary precision
  computations.  

\item \verb!Teuchos::LAPACK! class (Section~\ref{sec:teuchos:LAPACK}):
  The LAPACK class provides templated wrappers for the native LAPACK library.

\item \verb!Teuchos::ParameterList! class (Section~\ref{sec:teuchos:ParameterList}):
  ParameterList is a container that can be used to group all the parameters required by a
  given piece of code.

\item \verb!Teuchos::RefCountPtr! class (Section~\ref{sec:teuchos:RefCountPtr}):
  RefCountPtr is a smart reference-counted pointer class, which provides a functionality
  similar to the garbage collector of Java. 

\item \verb!Teuchos::TimeMonitor! class (Section~\ref{sec:teuchos:TimeMonitor}):
  TimeMonitor is a timing class that starts a timer when it is initialized and
  stops it when the destructor is called on the class.

\item \verb!Teuchos::CommandLineProcessor! class (Section~\ref{sec:teuchos:CLP}): 
  CommandLineProcessor is a class that helps parse command line input arguments from 
  \verb!(argc,argv[])!.   
\end{itemize}

%%%
%%%
%%%

\subsection{Teuchos::ScalarTraits}
\label{sec:teuchos:ScalarTraits}

The ScalarTraits class provides a basic interface to scalar types (float, double, 
complex$<$float$>$, complex$<$double$>$) that is used by the templated 
computational classes within Teuchos.  This interface includes a definition of
the magnitude type and methods for obtaining random numbers, representations of 
zero and one, the square root, and machine-specific parameters.  
The Teuchos classes that utilize this scalar traits mechanism are 
\verb!Teuchos::SerialDenseMatrix!, \verb!Teuchos::BLAS!, and \verb!Teuchos::LAPACK!.  

ScalarTraits enables the extension of Teuchos' computational
capabilities to any scalar type that can support its basic interface.  In particular, 
this interface can be used for arbitrary precision scalar types.  An interface to the
arbitrary precision library ARPREC \cite{arprec:02} is available if Teuchos
is configured with \verb!--enable-teuchos-arprec!. Teuchos must also be configured
with the local ARPREC library paths (\verb!--with-libs!, \verb!--with-incdirs!, and 
\verb!--with-libdirs!).  To obtain more information on ARPREC or download the 
source code, see {\tt http://crd.lbl.gov/$\sim$dhbailey/mpdist/}.

\begin{remark} To enable complex arithmetic (complex$<$float$>$ or complex$<$double$>$) 
support in ScalarTraits or any dependent classes, configure Teuchos with {\tt --enable-teuchos-complex}.
\end{remark}

%%%
%%%
%%%

\subsection{Teuchos::SerialDenseMatrix}
\label{sec:teuchos:SDM}

\verb!Teuchos::SerialDenseMatrix! is a templated version of the SerialDenseMatrix class in \verb!Epetra!
(Chapter \ref{chap:epetra_mat}).  It is most useful for interfacing with the templated BLAS and 
LAPACK wrappers, which will be discussed in Sections \ref{sec:teuchos:BLAS} and \ref{sec:teuchos:LAPACK}.  
However, by enabling the simple construction and manipulation of small dense matrices, 
the SerialDenseMatrix class has also been used as an independent tool in many 
Trilinos packages.

\verb!Teuchos::SerialDenseMatrix! provides a serial interface to a small dense matrix
of templated scalar type.  This means a SerialDenseMatrix object can be created for any scalar type 
supported by Teuchos::ScalarTraits (Section \ref{sec:teuchos:ScalarTraits}).  Boundschecking
can be enabled for this class by configuring Teuchos with {\tt --enable-teuchos-abc}.
An exception will be thrown everytime a matrix bound is violated by any method.  This 
incurs a lot of overhead for this class, so boundschecking is only recommended as a debugging tool.

To use the Teuchos::SerialDenseMatrix class, include the header:

{\small 
\begin{verbatim}
#include "Teuchos_SerialDenseMatrix.hpp"
\end{verbatim}}
Creating a double-precision matrix can be done in several ways:
{\small 
\begin{verbatim}
// Create an empty matrix with no dimension
Teuchos::SerialDenseMatrix<int,double> Empty_Matrix;
// Create an empty 3x4 matrix
Teuchos::SerialDenseMatrix<int,double> My_Matrix( 3, 4 );
// Basic copy of My_Matrix
Teuchos::SerialDenseMatrix<int,double> My_Copy1( My_Matrix ),
// (Deep) Copy of principle 3x3 submatrix of My_Matrix
                  My_Copy2( Teuchos::Copy, My_Matrix, 3, 3 ),
// (Shallow) Copy of 2x3 submatrix of My_Matrix
                  My_Copy3( Teuchos::View, My_Matrix, 2, 3, 1, 1 );
\end{verbatim}}
The matrix dimensions and strided storage information can be obtained:
{\small
\begin{verbatim}
int rows = My_Copy3.numRows();  // number of rows
int cols = My_Copy3.numCols();  // number of columns
int stride = My_Copy3.stride(); // storage stride
\end{verbatim}}
Matrices can change dimension:
{\small
\begin{verbatim}
Empty_Matrix.shape( 3, 3 );     // size non-dimensional matrices
My_Matrix.reshape( 3, 3 );      // resize matrices and save values
\end{verbatim}}
Filling matrices with numbers can be done in several ways:
{\small 
\begin{verbatim}
My_Matrix.random();             // random numbers
My_Copy1.putScalar( 1.0 );      // every entry is 1.0
My_Copy2(1,1) = 10.0;           // individual element access
Empty_Matrix = My_Matrix;       // copy My_Matrix to Empty_Matrix 
\end{verbatim}}
Basic matrix arithmetic can be performed:
{\small
\begin{verbatim}
Teuchos::SerialDenseMatrix<int,double> My_Prod( 3, 2 );
// Matrix multiplication ( My_Prod = 1.0*My_Matrix*My_Copy^T )
My_Prod.multiply( Teuchos::NO_TRANS, Teuchos::TRANS, 
                  1.0, My_Matrix, My_Copy3, 0.0 );
My_Copy2 += My_Matrix;         // Matrix addition
My_Copy2.scale( 0.5 );         // Matrix scaling
\end{verbatim}}
The pointer to the array of matrix values can be obtained:
{\small
\begin{verbatim}
double* My_Array = My_Matrix.values();   // pointer to matrix values
double* My_Column = My_Matrix[2];        // pointer to third column values
\end{verbatim}}
The norm of a matrix can be computed:
{\small
\begin{verbatim}
double norm_one = My_Matrix.normOne();        // one norm
double norm_inf = My_Matrix.normInf();        // infinity norm
double norm_fro = My_Matrix.normFrobenius();  // frobenius norm
\end{verbatim}}
Matrices can be compared:
{\small
\begin{verbatim}
// Check if the matrices are equal in dimension and values
if (Empty_Matrix == My_Matrix) {
  cout<< "The matrices are the same!" <<endl;
}
// Check if the matrices are different in dimension or values
if (My_Copy2 != My_Matrix) {
  cout<< "The matrices are different!" <<endl;
}
\end{verbatim}}
A matrix can be sent to the output stream:
{\small
\begin{verbatim}
cout<< My_Matrix << endl;
\end{verbatim}}
This section presents examples of all the methods in the 
{\tt Teuchos::SerialDenseMatrix} class and can be found in
\TriExe{teuchos/ex1.cpp}.  There is also a specialization of
this class for serial dense vectors that includes additional creation, accessor, 
arithmetic, and norm methods ({\tt Teuchos::SerialDenseVector}).

%%%
%%%
%%%

\subsection{Teuchos::BLAS}
\label{sec:teuchos:BLAS}

The \verb!Teuchos::BLAS! class provides templated wrappers for the native BLAS library.
This class has been written to facilitate the interface between C++ codes and BLAS,
which are written in Fortran.  Unfortunately, the interface between C++ and Fortran
function calls is not standard across all computer platforms.  The \verb!Teuchos::BLAS!
class provides C++ wrappers for BLAS kernels that are specialized during the Teuchos
configuration.  This insulates the rest of Teuchos and its users from the details of
the Fortran to C++ translation.

The \verb!Teuchos::BLAS! class provides C++ wrappers for a substantial subset of the 
BLAS kernels (Figure \ref{blas_kernels}).
The native BLAS library implementations of those kernels
will be used for the standard scalar types (float, double, complex$<$float$>$, complex$<$double$>$).  
However, \verb!Teuchos::BLAS! also has a
templated version of each of these kernels.  Paired with \verb!Teuchos::ScalarTraits! 
(Section \ref{sec:teuchos:ScalarTraits}), the \verb!Teuchos::BLAS! class can be extended 
to provide arbitrary precision computations.  
To use the \verb!Teuchos::BLAS! class, 
include the header:
{\small 
\begin{verbatim}
#include "Teuchos_BLAS.hpp"
\end{verbatim}}
Creating an instance of the BLAS class for double-precision kernels looks like:
{\small 
\begin{verbatim}
Teuchos::BLAS<int, double> blas;
\end{verbatim}}
This instance provides the access to all the BLAS kernels listed in Figure \ref{blas_kernels}:
{\small
\begin{verbatim}
const int n = 10;
double alpha = 2.0;
double x[ n ];
for ( int i=0; i<n; i++ ) { x[i] = i; }
blas.SCAL( n, alpha, x, 1 );
int max_idx = blas.IAMAX( n, x, 1 );
cout<< "The index of the maximum magnitude entry of x[] is the "
    <<  max_idx <<"-th and x[ " << max_idx-1 << " ] = "<< x[max_idx-1] 
    << endl;
\end{verbatim}}
This is a small usage example, but its purpose is to illustrate that any of the supported 
BLAS kernels is a method of the {\tt Teuchos::BLAS} class.  
This example can be found in \TriExe{teuchos/ex2.cpp}.  

\begin{figure}[hbt]\centerline{\small{
\begin{tabular}{|l||l|}\hline
\bf{BLAS Kernel} & \bf{Description} \\\hline\hline
\_ROTG & Computes a Givens plane rotation \\\hline
\_SCAL & Scale a vector by a constant \\\hline
\_COPY & Copy one vector to another \\\hline
\_AXPY & Add one scaled vector to another \\\hline
\_ASUM & Sum the absolute values of the vector entries \\\hline
\_DOT  & Compute the dot product of two vectors \\\hline
\_NRM2 & Compute the 2-norm of a vector \\\hline
\_IAMAX & Determine the index of the largest magnitude entry of a vector \\\hline
\_GEMV & Add a scaled matrix-vector product to another scaled vector \\\hline
\_TRMV & Replaces a vector with its upper/lower-triangular matrix-vector product \\\hline
\_GER  & Updates a matrix with a scaled, rank-one outer product \\\hline
\_GEMM & Add a scaled matrix-matrix product to another scaled matrix \\\hline
\_SYMM & Add a scaled symmetric matrix-matrix product to another scaled matrix \\\hline
\_TRMM & Add a scaled upper/lower-triangular matrix-matrix product to another scaled matrix \\\hline
\_TRSM & Solves an upper/lower-triangular linear system with multiple right-hand sides \\\hline
\end{tabular}}}
\caption{BLAS kernels supported by Teuchos::BLAS}\label{blas_kernels}
\end{figure}

%%%
%%%
%%%

\subsection{Teuchos::LAPACK}
\label{sec:teuchos:LAPACK}

The \verb!Teuchos::LAPACK! class provides templated wrappers for the native LAPACK library.
This class has been written to facilitate the interface between C++ codes and BLAS,
which are written in Fortran.  Unfortunately, the interface between C++ and Fortran
function calls is not standard across all computer platforms.  The \verb!Teuchos::LAPACK!
class provides C++ wrappers for LAPACK routines that are specialized during the Teuchos
configuration.  This insulates the rest of Teuchos and its users from the details of
the Fortran to C++ translation.

\verb!Teuchos::LAPACK! is a serial interface only, as LAPACK functions
are. Users interested in the parallel counterpart of LAPACK, ScaLAPACK,
can use the Amesos package; see Chapter~\ref{chap:amesos}.

The \verb!Teuchos::LAPACK! class provides C++ wrappers for a substantial subset of the 
LAPACK routines (Figure \ref{lapack_routines}).
The native LAPACK library implementations of those kernels
will be used for the standard scalar types (float, double, complex$<$float$>$, complex$<$double$>$).  
Unlike \verb!Teuchos::BLAS!, the \verb!Teuchos::LAPACK! class does not have a templated version of 
these routines at this time, so it cannot offer arbitrary precision computations.

To use the \verb!Teuchos::LAPACK! class, include the header:
{\small 
\begin{verbatim}
#include "Teuchos_LAPACK.hpp"
\end{verbatim}}
Creating an instance of the LAPACK class for double-precision routines looks like:
{\small 
\begin{verbatim}
Teuchos::LAPACK<int, double> lapack;
\end{verbatim}}
This instance provides the access to all the LAPACK routines listed in Figure \ref{lapack_routines}:
{\small
\begin{verbatim}
Teuchos::SerialDenseMatrix<int,double> My_Matrix(4,4);
Teuchos::SerialDenseVector<int,double> My_Vector(4);
My_Matrix.random();
My_Vector.random();

// Perform an LU factorization of this matrix. 
int ipiv[4], info;
char TRANS = 'N';
lapack.GETRF( 4, 4, My_Matrix.values(), My_Matrix.stride(), ipiv, &info ); 

// Solve the linear system.
lapack.GETRS( TRANS, 4, 1, My_Matrix.values(), My_Matrix.stride(), 
	      ipiv, My_Vector.values(), My_Vector.stride(), &info );
\end{verbatim}}

This small example illustrates how easy it is to use the {\tt Teuchos::LAPACK}
class.  Furthermore, it also exhibits the compatibility of the {\tt Teuchos::SerialDenseMatrix} 
and {\tt Teuchos::SerialDenseVector} classes with the {\tt Teuchos::LAPACK} class.  
This example can be found in \TriExe{teuchos/ex3.cpp}.  

\begin{figure}[hbt]\centerline{\footnotesize{
\begin{tabular}{|l||l|}\hline
\bf{LAPACK Routine} & \bf{Description} \\\hline\hline
\_POTRF & Computes Cholesky factorization of a real symmetric positive definite (SPD) matrix. \\\hline
\_POTRS & Solves a system of linear equations where the matrix has been factored by POTRF. \\\hline
\_POTRI & Computes the inverse of a real SPD matrix after its been factored by POTRF. \\\hline
\_POCON & Estimates the reciprocal of the condition number (1-norm) of a real SPD matrix \\
 & after its been factored by POTRF. \\\hline
\_POSV  & Computes the solution to a real system of linear equations where the matrix is SPD. \\\hline
\_POEQU & Computes row and column scaling or equilibrating a SPD matrix and reduce \\
 & its condition number. \\\hline
\_PORFS & Improves the computed solution to a system of linear equations where the matrix is SPD. \\\hline
\_POSVX & Expert SPD driver:  Uses POTRF/POTRS to compute the solution to a real system of \\
 & linear equations where the matrix is SPD.  The system can be equilibrated (POEQU) or \\
 & iteratively refined (PORFS) also.\\\hline
\_GELS & Solves and over/underdetermined real linear system. \\\hline
\_GETRF & Computes an LU factorization of a general matrix using partial pivoting. \\\hline
\_GETRS & Solves a system of linear equations using the LU factorization computed by GETRF. \\\hline
\_GETRI & Computes the inverse of a matrix using the LU factorization computed by GETRF. \\\hline
\_GECON & Estimates the reciprocal of the condition number of a general matrix in either \\
 & the 1-norm or $\infty$-norm using the LU factorization computed by GETRF. \\\hline
\_GESV  & Computes the solution of a linear system of equations. \\\hline
\_GEEQU & Computes row and column scaling for equilibrating a linear system, reducing its \\
 & condition number. \\\hline
\_GERFS & Improves the computes solution to a system of linear equations and provides error \\
 & bounds and backward error estimates for the solution [ Use after GETRF/GETRS ].\\\hline
\_GESVX & Expert driver:  Uses GETRF/GETRS to compute the solution to a real system of linear \\
 & equations, returning error bounds on the solution and a condition estimate. \\\hline
\_GEHRD & Reduces a real general matrix to upper Hessenber form by orthogonal similarity \\
 & transformations \\\hline
\_HSEQR & Compute the eigenvalues of a real upper Hessenberg matrix and, optionally, the \\
 & Schur decomposition. \\\hline
\_GEES & Computes the real Schur form, eigenvalues, and Schur vectors of a real nonsymmetric \\
 & matrix. \\\hline
\_GEEV & Computes the eigenvalues and, optionally, the left and/or right eigenvectors \\
 & of a real nonsymmetric matrix. \\\hline
\_ORGHR & Generates a real orthogonal matrix which is the product of the elementary reflectors \\
 & computed by GEHRD. \\\hline
\_ORMHR & Overwrites the general real matrix with the product of itself and the elementary \\
 & reflectors computed by GEHRD. \\\hline
\_TREVC & Computes some or all of the right and/or left eigenvectors of a real upper \\
 & quasi-triangular matrix. \\\hline
\_TREXC & Reorders the real Schur factorization of a real matrix via orthogonal similarity \\
 & transformations. \\\hline
\_LARND & Returns a random number from a uniform or normal distribution. \\\hline
\_LARNV & Returns a vector of random numbers from a chosen distribution. \\\hline
\_LAMCH & Determines machine parameters for floating point characteristics. \\\hline
\_LAPY2 & Computes $x^2$ + $y^2$ safely, to avoid overflow. \\\hline
\end{tabular}}}
\caption{LAPACK routines supported by Teuchos::LAPACK}\label{lapack_routines}
\end{figure}

\clearpage
%%%
%%%
%%%

\subsection{Teuchos::ParameterList}
\label{sec:teuchos:ParameterList}

The {\tt Teuchos::ParameterList} class is a C++ container of $<${\it key}, {\it value}$>$ pairs, 
where the {\it key} is a character string ({\tt std::string}) and the {\it value} can be almost 
any type of C++ object.  The ability to hold almost any type of C++ object as a {\it value} 
in the same list makes this class very useful for storing parameters.  This parameter list can then
be passed to an object, like an iterative linear solver, which will use the information to define 
its behavior. 

The \verb!Teuchos::ParameterList! is currently being used by several Trilinos
packages.  For instance, all Amesos objects~(see Chapter
\ref{chap:amesos}) and the smoothed aggregation preconditioning object
\verb!ML_Epetra::MultiLevelPreconditioner! (see Section~\ref{sec:ml:preconditioner}) 
are configured through a \verb!Teuchos::ParameterList!.

\begin{remark}
The parameter list stores a copy of the input object if it passed by reference.  
If the list is passed a pointer to an object. only the pointer is copied and
not the object that it points to. 
\end{remark}

To use the \verb!Teuchos::ParameterList! class, include the header:
{\small 
\begin{verbatim}
#include "Teuchos_ParameterList.hpp"
\end{verbatim}}
Creating an empty parameter list looks like:
{\small 
\begin{verbatim}
Teuchos::ParameterList My_List;
\end{verbatim}}
Setting parameters in this list can be easily done:
{\small
\begin{verbatim}
My_List.set("Max Iters", 1550);
My_List.set("Tolerance", 1e-10);
My_List.set("Solver", "GMRES");
\end{verbatim}}
The templated ``set'' method should cast the input {\it value} to the
correct data type.  However, in the case where the compiler is not casting the input
{\it value} to the expected data type, an explicit cast can be used with the ``set'' method:
{\small
\begin{verbatim}
My_List.set("Tolerance", (float)(1e-10));
\end{verbatim}}
A hierarchy of parameter lists can be constructed using {\tt Teuchos::ParameterList}.  This 
means another parameter list is a valid {\it value} in any parameter list.  To create a sublist
in a parameter list and obtain a reference to it:
{\small
\begin{verbatim}
Teuchos::ParameterList& Prec_List = My_List.sublist("Preconditioner");
\end{verbatim}}
Now this parameter list can be filled with values:
{\small
\begin{verbatim}
Prec_List.set("Type", "ILU");
Prec_List.set("Drop Tolerance", 1e-3);
\end{verbatim}}
The parameter list can be queried about the existance of a parameter, sublist, or type:
{\small
\begin{verbatim}
// Has a solver been chosen?
bool solver_defined = My_List.isParameter("Solver");
// Has a preconditioner been chosen?
bool prec_defined = My_List.isSublist("Preconditioner"); 
// Has a tolerance been chosen and is it a double-precision number?
bool tol_double = My_List.template isType<double>("Tolerance");
// Has a drop tolerance been chosen and is it a double-precision number?
bool dtol_double = Teuchos::isParameterType<double>(Prec_List,
                                                    "Drop Tolerance"); 
\end{verbatim}}
\noindent The last two methods for checking the parameter type are equivalent.
There is some question as to whether the syntax of the first type-checking
method ({\tt isType}) is acceptable to older compilers.  Thus, the second type-checking 
method ({\tt isParameterType}) is offered as a portable alternative.

Parameters can be retrieved from the parameter list in quite a few ways:
{\small
\begin{verbatim}
// Get method that creates and sets the parameter if it doesn't exist.
int its = My_List.get("Max Iters", 1200);
// Get method that retrieves a parameter of a particular type.
float tol = My_List.template get<float>("Tolerance");
\end{verbatim}}
\noindent In the above example, the first ``get'' method is a safe way of
obtaining a parameter when its existence is indefinite but required.
The second ``get'' method should be used when the existense of the parameter
is definite.  This method will throw an exception if the parameter doesn't exist. 
The safest way to use the second ``get'' method
is in a try/catch block:
{\small
\begin{verbatim}
try {
tol = My_List.template get<float>("Tolerance");
}
catch (exception& e) {
tol = 1e-6;
}
\end{verbatim}}
\noindent The second ``get'' method uses a syntax that may not be
acceptable to older compilers.  Optionally, there is another portable templated 
``get'' function that can be used in the place of the second ``get'' method:
{\small
\begin{verbatim}
try {
tol = Teuchos::getParameter<float>(My_List, "Tolerance");
}
catch (exception& e) {
tol = 1e-6;
}
\end{verbatim}}

A parameter list can be sent to the output stream:
{\small
\begin{verbatim}
cout<< My_List << endl;
\end{verbatim}}
\noindent For this parameter list, the output would look like:
{\small
\begin{verbatim}
Max Iters = 1550
Preconditioner ->
  Drop Tolerance = 0.001   [unused]
  Type = ILU   [unused]
Solver = GMRES   [unused]
Tolerance = 1e-10
\end{verbatim}}
\noindent It is important to note that mispelled parameters 
(with additional space characters, capitalizations, etc.) may be ignored.  
Therefore, it is important to be aware that a given parameter has not been used. 
Unused parameters can be printed with method:
{\small
\begin{verbatim}
My_List.unused( cout );
\end{verbatim}}
This section presents examples of all the methods in the 
{\tt Teuchos::ParameterList} class and can be found in
\TriExe{teuchos/ex4.cpp}.  

%%%
%%%
%%%

\subsection{Teuchos::RefCountPtr}
\label{sec:teuchos:RefCountPtr}

Teuchos::RefCountPtr is a templated class, whose functionalities are very
similar to the garbage collector of Java. Memory allocated through
RefCountPtr will automatically freed when no longer referenced, avoding
memory leaks.

This Section presents the basic usage of RefCountPtr. For an extensive
presentation and details about the implementation, the reader is
referred to~\cite{RefCountPtr-guide}. 

As a starting example, consider the following simple piece of
code. 
\begin{verbatim}
#define HAVE_CONFIG_H
#include "Teuchos_RefCountPtr.hpp"
using namespace Teuchos;

class Data 
{
public:
  // allocate some data here
  Data::Data() { A_ = new int[100];  }
  Data::!Data() { delete [] A_; }
  void PrintHello() { cout << "Hello from Data!" << endl; }
private:
  int * A_;
};

int main(int argc, char *argv[]) 
{

  RefCountPtr<Data> DataPtr = null;
  DataPtr = rcp( new Data() );
  DataPtr->PrintHello();

  cout << DataPtr.get() << endl;
  cout << DataPtr.count() << endl;

  return 0;
}
\end{verbatim}
This simple code illustrates the basic usage of \verb!RefCountPtr<>!. In
the main function, we first declare a \verb!null! pointer (lowercase,
defined in the Teuchos namespace) for Data class. This is more for the
programmer's convenience, as \verb!RefCountPtr<>! are automatically
initialized to null.

The object is allocated using the standard C++ \verb!new! function, and
the RefCountPtr function \verb!rcp()!.  Methods of Data can be accessed
as if \verb!DataPtr! were a raw C++ pointer, using \verb!->!.  The raw
C++ pointer to the Data object can be obtained through the method
\verb!get()!.

\verb!RefCountPtr<>! objects keeps trace of the number of objects (or
functions) that need the object itself. As the object is no longer
required, it can be safely deleted. Users can query the number of
references to {\sl this} object using method \verb!DataPtr.count()!.

Counting the references allows to avoid several memory leaks. For
instance, one can erroneusly reassign a pointer, without calling
\verb!delete! to the no-longer used object, \verb!RefCountPtr<>! will
avoid this problem. Consider the following lines of code:
\begin{verbatim}
RefCountPtr<Data> DataPtr = rcp( new Data() );    
DataPtr = new( new Data );
\end{verbatim}
As the first object is no longer referenced after the second \verb!new!
statement, \verb!RefCountPtr<>! will take care of deleting it.

Some Trilinos applications require in input variables allocated through
\verb!RefCountPtr<>!. It may the case that those variable cannot be
allocated using \verb!rcp()!. This happens, for instance, if the
allocation is handled by other libraries, or by other parts of the code
that cannot be modifed. In this situation, on can create a
\verb!RefCountPtr<>! object as follows:
\begin{verbatim}
Data * DataObj = new Data;
RefCountPtr<Data> DataPtr;
DataPtr = rcp(DataObj,false);
DataPtr->PrintHello();
delete DataObj;
\end{verbatim}
In the above fragment of code, we have created a \verb!RefCountPtr<>!
that points to the raw C pointer \verb!DataObj!. As the second parameter
is \verb!false!, the code assumes that the pointer will be freed by the
user. 

More advanced features of \verb!RefCountPtr<>! are breifly listed below:
\begin{itemize}
\item \verb!rcp_implicit_cast()!, \verb!rcp_static_cast()!,
  \verb!rcp_dynamic_cast()!, \verb!rcp_static_cast()! must be used to
  cast RefCountPtr pointers, whose syntax is pretty similar to that of
  raw C++ pointers;
\item Specific deallocators can be specified in the construction phase;
\item Several RefCountPtr pointers can share the same data, so that
  deallocation occurs only once;
\item Additional data to be free can be specified using
  \verb!set_extra_data()!.
\end{itemize}

As a final remark, we note that \verb!RefCountPtr<>! is {\sl not} meant
to replace raw C pointers. First of all, some operations (like
\verb!++!) on raw pointers are not allowed on RefCountPtr pointers.
Secondly, it is probably not a good idea to use RefCountPtr pointers
with build-in data time such as \verb!int! or \verb!double!. As
suggested in~\cite{RefCountPtr-manual}, the most compelling situation
where \verb!RefCountPtr<>! objects should be used is for data shared
among various clients, of when a client needs to maintain a private data
member to another object which is of abstract type. As a general rule,
we may suggest to use \verb!RefCountPtr<>! for allocations that should
be freed by other, independent part of the same code. Also,
\verb!RefCountPtr<>! objects can be profitably used to dynamically
allocate a given object's private data, as those data will not explicit
deallocations in the object's destructor.

%%%
%%%
%%%

\subsection{Teuchos::TimeMonitor}
\label{sec:teuchos:TimeMonitor}

Class \verb!Teuchos::TimeMonitor! defines a timer that starts when
constructed and stops when its destructor is called. This class can be
used to keep trace of timing for various phases of the code. Example
\TriExe{teuchos/ex1.cpp} shows the use of this class. The example
declared (for the sake of simplicity) two global (smart) pointers,
\begin{verbatim}
RefCountPtr<Time> SetupTime;
RefCountPtr<Time> CompTime;
\end{verbatim}
and initialized them in the \verb!main! function,
\begin{verbatim}
SetupTime = TimeMonitor::getNewTimer("setup time");
CompTime  = TimeMonitor::getNewTimer("comp time");
\end{verbatim}
Then, each time we want to track timing, we can create an Time object as
\begin{verbatim}
TimeMonitor LocalTimer(*SetupTime);
\end{verbatim}
which will stop when its destructor is called. Timing are summarized
using
\begin{verbatim}
TimeMonitor::summarize();
\end{verbatim}

%%%
%%%
%%%

\subsection{Teuchos::CommandLineProcessor}
\label{sec:teuchos:CLP}

\verb!Teuchos::CommandLineProcessor! is a class that helps to parse command
line input arguments and set runtime options. Additionally, a CommandLineProcessor
object can provide the user with a list of acceptable command line arguments, and
their default values.

The basic idea is that users will specify the name of command line
options, their default values, and a pointer to variables that will host
those values, then parse the command line. This may be done as
follows. Let \verb!main! be defined as \verb!int main(int argc, char* argv[])!. First, we create an \verb!CommandLineParser! object as
\begin{verbatim}
CommandLineProcessor CLP;
\end{verbatim}
then, we set options name and default values, plus an help string:
\begin{verbatim}    
int NumIters = 1550;
CLP.setOption("iterations",&NumIters,"number of iterations");

double Tolerance = 1e-10;    
CLP.setOption("tolerance",&Tolerance,"tolerance");
    
bool Precondition;
CLP.setOption("precondition","no-precondition",
               &Precondition,"prec flag");
\end{verbatim}
Now, we allow some options not to be recognized, and we avoid Teuchos to
throw an error when \verb!--help! is specified an command line
option. Finally, we parse the command line, and print out results on
standart output.
\begin{verbatim}    
CLP.recogniseAllOptions(false);
CLP.throwExceptions(false);
    
CLP.parse(argc,argv);
cout << NumIters << endl << Tolerance << endl;
cout << Precondition << endl;
\end{verbatim}
An example of use may be as follows:
\begin{verbatim}
[msala:teuchos]> ./ex3.exe  --iterations=123 --tolerance=1e-6  
                            --no-precondition --help
Usage: ./ex3.exe [options]
  options:
  --help                     Prints this help message
  --iterations       int     number of iterations
                             (default: --iterations=123)
  --tolerance        double  tolerance
                             (default: --tolerance=1e-06)
  --precondition     bool    prec flag
  --no-precondition          (default: --no-precondition)
123
1e-06
0
\end{verbatim}

%%%
%%%
%%%

%\subsection{Teuchos::XMLObject}
%\label{sec:teuchos:XML}

%Teuchos contains few classes to parse a subset of the XML syntax. Users
%can easily create XML objects, as reported in file
%\TriExe{teuchos/ex4.cpp}. 
%As internal data, XML objects can be view as an alternative the
%Teuchos::ParameterList. Another use of XML parser is to read input file.

%Let us start from the definition of an internal XML object to setup a
%linear system solver:
%\begin{verbatim}
%XMLObject solver("solver");
%XMLObject prec("preconditioner");

%solver.addAttribute("krylov method", "gmres");
%solver.addInt("iterations", 1000);
%solver.addDouble("tolerance", 1.0e-10);

%solver.addChild(prec);
%prec.addAttribute("type", "smoothed aggregation");
%prec.addInt("max levels", 4);
%\end{verbatim}
%The content of the XML object can be printed out as
%\begin{verbatim}
%string str = solver.toString();
%cout << str << endl;
%\end{verbatim}
%An XML object can be queries using a variety of methods, like
%\verb!hasAttribute()!, \verb!getAttribute()!, \verb!getRequiredInt()!,
%\verb!getRequiredDouble()!, \verb!getChild()!.

%XML can be read from file in the following way. This example, reported
%in file \TriExe{teuchos/ex5.cpp}, requires option \verb!--with-expat!.

%\begin{remark}
%  \verb!Teuchos::StrUtils! is another class offered by Teuchos to read
%  ASCII files.
%\end{remark}
