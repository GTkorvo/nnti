%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\section{Teuchos}
\label{chap:triutils}

Teuchos is a collection of high-level C++ classes, meant to 
help the development of scientific codes. Teuchos (pronounced
``te-fos'') contains a large number of classes, and only a subset of
them will be presented in this Chapter. For more details, we refer to
the Teuchos documentation.

Teuchos classed have been divided between a "standard" build and an
"extended" build. The "standard" build has shown to be a portable subset
of the Teuchos tools and is built by default when Teuchos is enabled
(--enable-teuchos). The "extended" build is also portable, but contains
more special purpose tools like XML parsing and communicators
(--enable-teuchos-extended). 

Standard classes in the Teuchos namespace include low-level math functions ({\tt BLAS}
and {\tt LAPACK}, thin layers of C++ code wrapping BLAS and
LAPACK routines), serial dense matrix classes (for basic operations like
addition, multiplication, scaling, logical comparison, norms, etc. This
class also provides support for a dense matrix that needs to be
replicated across processors in a parallel application), a parameters'
list (ParameterList), a memory management class (
\verb!RefCountPtr!), performance monitoring classes
(\verb!TimeMonitor! and \verb!Flops!), and exception
handling macro (\verb!TEST_FOR_EXCEPTION!).

Extended classes include a templated array class
(\verb!Array!), XML utils ({\tt XMLObject},
{\tt FileInputSource} and {\tt StringInputSource}),
and MPI wrappers (\verb!MPISession!, \verb!MPIComm!
and \verb!ContainerComm!).

\medskip

In this Chapter, we will present the following classes:
\begin{itemize}
\item \verb!Teuchos::ParameterList! class, in
  Section~\ref{sec:teuchos:ParameterList}). ParameterList is a very
  handy container, that can be used to group all the parameters required
  by a piece of code;
\item \verb!Teuchos::RefCountPtr! class, a smart reference-counted
  pointer class, which provides functionalities similar to the garbage
  collector of Java. It is presented
  Section~\ref{sec:teuchos:RefCountPtr});
\item \verb!Teuchos::TimeMonitor! is briefly described in
  Section~\ref{sec:teuchos:TimeMonitor};
\item \verb!Teuchos::LAPACK! is introduced in
  Section~\ref{sec:teuchos:LAPACK};
\item \verb!Teuchos::CommandLineParser!, a parser for command line
  options, is detailed in Section~\ref{sec:teuchos:CLP}.
\end{itemize}

%%%
%%%
%%%

\subsection{Teuchos::ParameterList}
\label{sec:teuchos:ParameterList}

A parameters' list is a C++ containers of objects that can be used as
parameters for some operations. Almost all kind of C++ objects can be
stick into the same list. A very basic usage for an hypotetical list for
an iterative linear solver might be as follows:
\begin{verbatim}
Teuchos::ParameterList List;
List.setParameter("max number of iterations", 1550);
List.setParameter("tolerance", 1e-10);
List.setParameter("output prefix", "Velocity-Jacobian");
\end{verbatim}
Lists can contain sublists, created as 
\begin{verbatim}
Teuchos::ParameterList & PrecList = List.sublist("preconditioner");
\end{verbatim}
Lists can be redirected to stream objects:
\begin{verbatim}
cout << List;
\end{verbatim}
The linear system object will probably query a list about the existance
of a parameter or of a sublist as
\begin{verbatim}
List.isParameter("tolerance");
List.isSublist("preconditioner");
\end{verbatim}
It is important to note that mispelled parameters (which may mean with
additional space characters) are simply ignored. Therefore, it is
important to be aware that a given parameter has not been used. Unused
parameters can be retrived with method \verb!unused()!.

\begin{remark}
  \verb!Teuchos::ParameterList! is currently used by several Trilinos
  packages. For instance, all parameters for Amesos objects~(see Chapter
  \ref{chap:amesos}) and the smoothed aggregation preconditioning class
  \verb!Epetra_ML_Preconditioner! (see Section~\ref{sec:SA}) are set
  through a parameters' list.
\end{remark}


%%%
%%%
%%%

\subsection{Teuchos::RefCountPtr}
\label{sec:teuchos:RefCountPtr}

Teuchos::RefCountPtr is a template class, whose functionalities are very
similar to the garbage collector of Java. Memory allocated through
RefCountPtr will automatically freed when no longer referenced, avoding
memory leaks.

This Section presents the basic usage of RefCountPtr. For an extensive
presentation and details about the implementation, the reader is
referred to~\cite{RefCountPtr-guide}. 

As a starting example, consider the following simple piece of
code. 
\begin{verbatim}
#define HAVE_CONFIG_H
#include "Teuchos_RefCountPtr.hpp"
using namespace Teuchos;

class Data 
{
public:
  // allocate some data here
  Data::Data() { A_ = new int[100];  }
  Data::!Data() { delete [] A_; }
  void PrintHello() { cout << "Hello from Data!" << endl; }
private:
  int * A_;
};

int main(int argc, char *argv[]) 
{

  RefCountPtr<Data> DataPtr = null;
  DataPtr = rcp( new Data() );
  DataPtr->PrintHello();

  cout << DataPtr.get() << endl;
  cout << DataPtr.count() << endl;

  return 0;
}
\end{verbatim}
This simple code illustrates the basic usage of \verb!RefCountPtr<>!. In
the main function, we first declare a \verb!null! pointer (lowercase,
defined in the Teuchos namespace) for Data class. This is more for the
programmer's convenience, as \verb!RefCountPtr<>! are automatically
initialized to null.

The object is allocated using the standard C++ \verb!new! function, and
the RefCountPtr function \verb!rcp()!.  Methods of Data can be accessed
as if \verb!DataPtr! were a raw C++ pointer, using \verb!->!.  The raw
C++ pointer to the Data object can be obtained through the method
\verb!get()!.

\verb!RefCountPtr<>! objects keeps trace of the number of objects (or
functions) that need the object itself. As the object is no longer
required, it can be safely deleted. Users can query the number of
references to {\sl this} object using method \verb!DataPtr.count()!.

Counting the references allows to avoid several memory leaks. For
instance, one can erroneusly reassign a pointer, without calling
\verb!delete! to the no-longer used object, \verb!RefCountPtr<>! will
avoid this problem. Consider the following lines of code:
\begin{verbatim}
RefCountPtr<Data> DataPtr = rcp( new Data() );    
DataPtr = new( new Data );
\end{verbatim}
As the first object is no longer referenced after the second \verb!new!
statement, \verb!RefCountPtr<>! will take care of deleting it.

Some Trilinos applications require in input variables allocated through
\verb!RefCountPtr<>!. It may the case that those variable cannot be
allocated using \verb!rcp()!. This happens, for instance, if the
allocation is handled by other libraries, or by other parts of the code
that cannot be modifed. In this situation, on can create a
\verb!RefCountPtr<>! object as follows:
\begin{verbatim}
Data * DataObj = new Data;
RefCountPtr<Data> DataPtr;
DataPtr = rcp(DataObj,false);
DataPtr->PrintHello();
delete DataObj;
\end{verbatim}
In the above fragment of code, we have created a \verb!RefCountPtr<>!
that points to the raw C pointer \verb!DataObj!. As the second parameter
is \verb!false!, the code assumes that the pointer will be freed by the
user. 

More advanced features of \verb!RefCountPtr<>! are breifly listed below:
\begin{itemize}
\item \verb!rcp_implicit_cast()!, \verb!rcp_static_cast()!,
  \verb!rcp_dynamic_cast()!, \verb!rcp_static_cast()! must be used to
  cast RefCountPtr pointers, whose syntax is pretty similar to that of
  raw C++ pointers;
\item Specific deallocators can be specified in the construction phase;
\item Several RefCountPtr pointers can share the same data, so that
  deallocation occurs only once;
\item Additional data to be free can be specified using
  \verb!set_extra_data()!.
\end{itemize}

As a final remark, we note that \verb!RefCountPtr<>! is {\sl not} meant
to replace raw C pointers. First of all, some operations (like
\verb!++!) on raw pointers are not allowed on RefCountPtr pointers.
Secondly, it is probably not a good idea to use RefCountPtr pointers
with build-in data time such as \verb!int! or \verb!double!. As
suggested in~\cite{RefCountPtr-manual}, the most compelling situation
where \verb!RefCountPtr<>! objects should be used is for data shared
among various clients, of when a client needs to maintain a private data
member to another object which is of abstract type. As a general rule,
we may suggest to use \verb!RefCountPtr<>! for allocations that should
be freed by other, independent part of the same code. Also,
\verb!RefCountPtr<>! objects can be profitably used to dynamically
allocate a given object's private data, as those data will not explicit
deallocations in the object's destructor.

%%%
%%%
%%%

\subsection{Teuchos::TimeMonitor}
\label{sec:teuchos:TimeMonitor}

Class \verb!Teuchos::TimeMonitor! defines a timer that starts when
constructed and stops when its destructor is called. This class can be
used to keep trace of timing for various phases of the code. Example
\TriExe{teuchos/ex1.cpp} shows the use of this class. The example
declared (for the sake of simplicity) two global (smart) pointers,
\begin{verbatim}
RefCountPtr<Time> SetupTime;
RefCountPtr<Time> CompTime;
\end{verbatim}
and initialized them in the \verb!main! function,
\begin{verbatim}
SetupTime = TimeMonitor::getNewTimer("setup time");
CompTime  = TimeMonitor::getNewTimer("comp time");
\end{verbatim}
Then, each time we want to track timing, we can create an Time object as
\begin{verbatim}
TimeMonitor LocalTimer(*SetupTime);
\end{verbatim}
which will stop when its destructor is called. Timing are summarized
using
\begin{verbatim}
TimeMonitor::summarize();
\end{verbatim}

%%%
%%%
%%%

\subsection{Teuchos::LAPACK}
\label{sec:teuchos:LAPACK}

\verb!Teuchos::LAPACK! is a wrapper to LAPACK routines. This class has
been written to facilitate the interface between C++ codes and LAPACK,
written in Fortran. Unfortunately, the interface between C++ and Fortran
is not standard across all computer platforms. The Teuchos::LAPACK class
provides C++ wrappers for the LAPACK kernels in order to insulate the
rest of Teuchos from the details of C++ to Fortran translation.

\verb!Teuchos::LAPACK! is a serial interface only, as LAPACK functions
are. Users interested in the parallel counterpart of LAPACK, ScaLAPACK,
can use the Amesos package; see~\ref{chap:amesos}.

\verb!Teuchos::LAPACK! is a templated class for float, double and
complex arithmetics (the latter only available if Teuchos has been
configured with \verb!--enable-teuchos-complex!).  Note: These templates
are specialized to use the Fortran LAPACK routines for scalar types
float and double.

A very basic example is reported in file \TriExe{teuchos/ex2.cpp}. The
file defines a dense matrix and a dense vector (locally on the calling
process)  as
\begin{verbatim}
Teuchos::SerialDenseMatrix<int,float> Matrix(4,4);
Teuchos::SerialDenseVector<int,float> Vector(4);
\end{verbatim}
and populate them using method \verb!random()!. Then, after set up of
LAPACK parameters, it invokes GETRF:
\begin{verbatim}
int ipiv[4], info;
Teuchos::LAPACK<int,float> L;
L.GETRF(4,4,Matrix.values(),4,ipiv,&info); 
cout << Matrix;
\end{verbatim}

%%%
%%%
%%%

\subsection{Teuchos::CommandLineParser}
\label{sec:teuchos:CLP}

\verb!Teuchos::CommandLineParser! is a class that helps to parse command
line input arguments and set runtime options. An example of use can be
found in \TriExe{teuchos/ex3.cpp}, and it is detailed here.

The basic idea is that users will specify the name of command line
options, their defaul values, and a pointer to variables that will host
those values, then parse the command line. This may be done as
follows. Let \verb!main! be defined as \verb!int main(int argc, char* argv[])!. First, we create an \verb!CommandLineParser! object as
\begin{verbatim}
CommandLineProcessor CLP;
\end{verbatim}
then, we set options name and default values, plus an help string:
\begin{verbatim}    
int NumIters = 1550;
CLP.setOption("iterations",&NumIters,"number of iterations");

double Tolerance = 1e-10;    
CLP.setOption("tolerance",&Tolerance,"tolerance");
    
bool Precondition;
CLP.setOption("precondition","no-precondition",
               &Precondition,"prec flag");
\end{verbatim}
Now, we allow some options not to be recognized, and we avoid Teuchos to
throw an error when \verb!--help! is specified an command line
option. Finally, we parse the command line, and print out results on
standart output.
\begin{verbatim}    
CLP.recogniseAllOptions(false);
CLP.throwExceptions(false);
    
CLP.parse(argc,argv);
cout << NumIters << endl << Tolerance << endl;
cout << Precondition << endl;
\end{verbatim}
An example of use may be as follows:
\begin{verbatim}
[msala:teuchos]> ./ex3.exe  --iterations=123 --tolerance=1e-6  
                            --no-precondition --help
Usage: ./ex3.exe [options]
  options:
  --help                     Prints this help message
  --iterations       int     number of iterations
                             (default: --iterations=123)
  --tolerance        double  tolerance
                             (default: --tolerance=1e-06)
  --precondition     bool    prec flag
  --no-precondition          (default: --no-precondition)
123
1e-06
0
\end{verbatim}

%%%
%%%
%%%

\subsection{Teuchos::XMLObject}
\label{sec:teuchos:XML}

Teuchos contains few classes to parse a subset of the XML syntax. Users
can easily create XML objects, as reported in file
\TriExe{teuchos/ex4.cpp}. 
As internal data, XML objects can be view as an alternative the
Teuchos::ParameterList. Another use of XML parser is to read input file.

Let us start from the definition of an internal XML object to setup a
linear system solver:
\begin{verbatim}
XMLObject solver("solver");
XMLObject prec("preconditioner");

solver.addAttribute("krylov method", "gmres");
solver.addInt("iterations", 1000);
solver.addDouble("tolerance", 1.0e-10);

solver.addChild(prec);
prec.addAttribute("type", "smoothed aggregation");
prec.addInt("max levels", 4);
\end{verbatim}
The content of the XML object can be printed out as
\begin{verbatim}
string str = solver.toString();
cout << str << endl;
\end{verbatim}
An XML object can be queries using a variety of methods, like
\verb!hasAttribute()!, \verb!getAttribute()!, \verb!getRequiredInt()!,
\verb!getRequiredDouble()!, \verb!getChild()!.

XML can be read from file in the following way. This example, reported
in file \TriExe{teuchos/ex5.cpp}, requires option \verb!--with-expat!.

\begin{remark}
  \verb!Teuchos::StrUtils! is another class offered by Teuchos to read
  ASCII files.
\end{remark}
