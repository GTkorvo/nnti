 \documentclass[12pt,relax]{SANDreport}

%
% Set the title, author, and date
%
    \title{Trilinos Developer's Guide}
\SANDsubtitle{}

    \author{James Willenbring\\
       Computational Mathematics \& Algorithms \\
	  Sandia National Laboratories\\
	  P.O. Box 5800\\
	  Albuquerque, NM 87185-1110 \\
	  jmwille@sandia.gov \\
	 }

    % There is a "Printed" date on the title page of a SAND report, so
    % the generic \date should generally be empty.
    \date{}

    % While this document is under active development, the date
    % field will reflect the current date, eventually a final date
    % will be assigned.
%    \today - Latex spits out errors when this is used here

\SANDnum{SAND2003-xxxx}
\SANDprintDate{February 2003}
\SANDauthor{James Willenbring, Sandia National Laboratories}


\SANDreleaseType{Unlimited Release}


\SANDdistcategory{UC-999}     % DOE mandates it, but many reports don't have it


%
% Start the document
%
\begin{document}
    \maketitle

    % ------------------------------------------------------------------------ %
    % An Abstract is required for SAND reports
    %
    \begin{abstract}

Research efforts in advanced solution algorithms and parallel solver
libraries have historically had a large impact on engineering and
scientific computing.  Algorithmic advances increase the range
of tractable problems and reduce the cost of solving existing
problems.  Well-designed solver libraries provide a mechanism for
leveraging solver development across a broad set of applications and
minimize the cost of solver integration.  Emphasis is
required in both new algorithms and new software in order
to achieve the maximum impact of efforts.

The Trilinos project encompasses a variety of efforts that are to some
extent self-contained but at the same time inter-related.  The
Trilinos design allows individual packages to grow and mature
autonomously to the extent the algorithms and package developers
dictate. 

The Trilinos Developer's Guide is meant to assist existing, as well as new and
potential Trilinos developers.  Topics covered include how to configure and 
build Trilinos, what is required to integrate an existing package into Trilinos
and examples of how those requirements can be met, as well as what tools are 
available to Trilinos packages.  Also discussed are some common practices that 
are followed by many Trilinos package developers.  Finally, a graphical 
depiction of Trilinos package iteroperability is supplied along with a list of 
platforms that Trilinos has been ported to.

\end{abstract}

%
% Page style chosen that prints chapter heading and page number in the 
% header on each page.
%

    % -------------------------------------------------- %
    % Acknowledgement section
    % Use \section* since we don't want it in the table of context
    %
    %\clearpage - this is the beginning of the document
    \section*{Acknowledgement}
The author would like to acknowledge the support of the ASCI and LDRD 
programs that funded development of Trilinos and recognize all Trilinos 
contributors: Michael Heroux, Teri Barth, David Day, Bob Heaphy, 
Robert Hoekstra, Jonathan Hu, Tammy Kolda, Richard Lehoucq, Kevin Long, 
Roger Pawlowski, Andrew Rothfuss, Andrew Salinger, Ken Stanley, Ray 
Tuminaro, Jim Willenbring, and Alan Williams.

    % --------------------------------------------------------- %
    % The table of contents and list of figures and tables
    % Comment out \listoffigures and \listoftables if there are no
    % figures or tables. Make sure this starts on an odd numbered page
    %
    \clearpage
    \tableofcontents
    \listoffigures
    \listoftables

    % ---------------------------------------------------------------------- %
    % An optional glossary. We don't want it to be numbered
    \clearpage
    \section*{Nomenclature}
    \addcontentsline{toc}{section}{Nomenclature}
    \begin{itemize}
	\item[Package]
	    A collection of software focused on one primary class of numerical methods
	\item[Trilinos]
	    A Greek term that loosely translated means ``a string of pearls,'' meant
         to evoke an image that each Trilinos package is a pearl in its own right,
         but is even more valuable when combined with other packages.
	\item[Petra]
	    A Greek term meaning ``foundation.''  Trilinos has three Petra libraries: Epetra, 
	    Tpetra and Jpetra (discussed in Section~\ref{subsect:PetraObjectModel}) that
	    provide basic classes for constructing and manipulating matrix, graph and vector 
	    objects.
        \item[AztecOO] Linear solver package based on preconditioned Krylov methods.  A
	  follow-on to the Aztec solver package.  Supports all Aztec interfaces and
	  functionality, but also provides significant new functionality.
	\item[TSF]
	\item[NOX]
	\item[ML]
	\item[Komplex] Complex linear equation solver using equivalent real formulations,
	  built on top of Aztec.
	\item[Ifpack] Object-oriented algebraic preconditioner, compatible with Epetra and
	  AztecOO.
    \end{itemize}


    % ---------------------------------------------------------------------- %
    % This is where the body of the report begins; usually with an Introduction
    %
    %\SANDmain		% Start the main part of the report

% ------------------------------------------- %
% Introduction to Developer's Guide
%
    \section{Introduction}
	\subsection{Briew Overview}
	\begin{quote}
The Trilinos Project is an effort to develop parallel solver algorithms and 
libraries within 
an object-oriented software framework for the solution of large-scale, complex
multi-physics engineering and scientific applications.   Our emphasis is on 
developing robust, scalable algorithms in a software framework, using abstract 
interfaces for flexible interoperability of components and providing a 
full-featured set of concrete classes that implement all abstract interfaces. 
Trilinos components are primarily written in C++, but provide essential C and 
Fortran user interface support.  We provide an open architecture that allows 
easy integration with other solver packages and we deliver our software to 
the outside community via the Gnu Lesser General Public License
(LGPL)~\cite{gnu-license-site}.
	\end{quote}
% Figure out how to cite Mike's overview doc
	\subsection{Motivation}
	\begin{quote}
Research efforts in advanced solution algorithms and parallel solver
libraries have historically had a large impact on engineering and
scientific computing.  Algorithmic advances increase the range
of tractable problems and reduce the cost of solving existing
problems.  Well-designed solver libraries provide a mechanism for
leveraging solver development across a broad set of applications and
minimize the cost of solver integration.  Emphasis is
required in both new algorithms and new software in order
to achieve the maximum impact of efforts.

The Trilinos project encompasses a variety of efforts that are to some
extent self-contained but at the same time inter-related.  The
Trilinos design allows individual packages to grow and mature
autonomously to the extent the algorithms and package developers
dictate. 
	\end{quote}

	\subsection{What is Covered in this Guide}

The Trilinos Developer's Guide is meant to assist existing, as well as new and
potential Trilinos developers.  Topics covered include how to configure and 
build Trilinos, what is required to integrate an existing package into Trilinos
and examples of how those requirements can be met, as well as what tools are 
available to Trilinos packages.  Also discussed are some common practices that 
are followed by many Trilinos package developers; these are found in the 
chapter entitled ``Suggested practices''.  Finally, a graphical depiction of 
Trilinos package iteroperability is supplied along with a list of platforms 
that Trilinos has been ported to.

For a higher-level view of the Trilinos project, please see An Overview
of the Trilinos Project by Mike Heroux. 
%**(Use a citation.)

	\section{Getting Started}
%	**(How to configure and build Trilinos - Sync this section with AUTOTOOLS_README)**
%	**(Need intro! - also include examples!)**

\subsection{Trilinos Configuration Options}

The following options apply to all Trilinos packages unless 
the option doesn't make sense for a particular package (for example, a 
package that does not include any Fortran code will not be sensitive to 
F77=g77), or otherwise noted.  NOTE: This list is not yet complete, in 
particular many options that apply to only a subset of Trilinos packages 
are not included.  For options specific to individual package, 'cd' to the 
home directory of the source code of the individual package and type 
``configure --help'' (without quotes).

Basic Options

\begin{itemize}
\item --enable-debug 

(Nox only.)  This turns on compiler debugger flags. It has 
not been fully tested. As an alternate, specify CXXFLAGS on the 
                 configure line.

\item --enable-opt

(Nox only.)  This turns on compiler optimization flags. It 
has not been fully tested. As an alternate, specify CXXFLAGS on the 
                 configure line. 

\item --with-cppflags 

Specify additional preprocessor flags (e.g., "-Dflag -Idir") 

\item --with-cxxflags 

Specify additional C++ flags 

\item --with-ldflags 

Specify additional linker flags (e.g., "-Ldir") 

\item --with-ar 

Specify a special archiver command, the default is "ar cru". 
\end{itemize}

 Influential Environmental Variables

\begin{itemize}
\item CC 

C compiler command.

\item CFLAGS 

C compiler flags.

\item CXX 

C++ compiler command.

\item CXXFLAGS 

C++ compiler flags.

\item LDFLAGS 

Specify linker flags.

\item CPPFLAGS 

C/C++ preprocessor flags.

\item CXXCPP 

C++ preprocessor.

\item F77 

Fortran 77 compiler command.

\item FFLAGS 

Fortran 77 compiler flags.
\end{itemize}

MPI-Related Options

\begin{itemize}
\item --enable-mpi 

Enables MPI mode. Defines HAVE\_MPI in the (Package)\_Config.h file. Will test 
for the ability to preprocess the MPI header file and may test ability to link 
with MPI.  This option is rarely necessary as many of the below options also 
turn MPI on.  

\item --with-mpi-compilers

Sets the MPI c++ compiler = mpicxx (or mpiCC if mpicxx not available), 
the MPI C compiler = mpicc and the MPI Fortran compiler = mpif77.  
Automatically enables MPI mode.  To use compilers other than these, 
specify mpi locations with the below options.  If none of these options 
are necessary, don't forget to use --enable-mpi.  CXX, CC, and F77 may also 
have to be set if autoconf does not choose the correct compilers by default.

\item --with-mpi=MPIROOT 

Specify the MPI root directory. Automatically enables MPI mode.  If this 
option is set, --with-mpi-incdir and --with-mpi-libdir should not be used.  
--with-mpi is meant to be a shortcut for setting --with-mpi-libdir=MPIROOT/lib 
and --with-mpi-incdir=MPIROOT/include.  Use these two options instead if 
these default locations are not correct.

\item --with-mpi-libdir=DIR 

Specify the MPI libraries location. Defaults to MPIROOT/lib if --with-mpi 
is specified. If multiple directories must be specified, try 
--with-ldflags="-L<dir1> -L<dir2>" instead. 

\item --with-mpi-libs="LIBS" 

Specify the MPI libraries. Defaults to "-lmpi" if either --with-mpi or 
--with-mpi-libdir is specified.

\item --with-mpi-incdir=DIR

Specify the MPI include files location. Defaults to MPIROOT/include if 
--with-mpi is specified. If multiple directories  must be specified, try 
--with-cppflags="-I<dir1> -I<dir2>" instead.
\end{itemize}

Developer-Related Options
\begin{itemize}
\item --enable-maintainer-mode 

Enable make rules and dependencies not useful (and sometimes confusing) to 
the casual installer.
\end{itemize}

Other important notes about the configure/build process.
\begin{itemize}
\item Any code that links to Trilinos should define 'HAVE\_CONFIG\_H' (without
quotes).
\item Often the output from 'configure' will be inadequate for diagnosing 
problems.  A developer should look (in the buildtree) at the config.log file 
for the package that failed to configure properly.  To figure out which 
package failed to configure, simply look at the bottom of the output from the 
'configure' command.  One of the last lines should say something like:
configure: error: /bin/sh '../../../packages/epetra/configure' failed 
for packages/epetra.

This particular error indicates to look in packages/epetra/config.log.  This 
file is useful for developers trying to build Trilinos, and those who are 
adding or editing autoconf-specific files such as configure.ac.
\end{itemize}

\subsection{Adding and Removing Source Files}

Commonly a developer needs to add files to or remove files from a Trilinos 
package.  We outline the steps for adding or removing source files from a 
Trilinos package that uses Autotools.  The below outline assumes the simple 
addition or removal of files.  Special situations such as adding header file 
or library dependencies to a Trilinos package or conditionally compiling new 
files require a more complicated process.
\begin{enumerate}
\item Obtain the supported versions of Autoconf and Automake.

The current supported versions of Autoconf and Automake are documented in 
the Trilinos repository.  Trilinos/config/AutotoolsVersionInfo contains the 
information.  The Trilinos team does not attempt to keep up with the latest 
versions of Autoconf and Automake, so please do not assume that the most 
recent versions are supported.  The supported versions of Autoconf and 
Automake can always be found on software.sandia.gov.  This makes software a 
good machine to bootstrap on.  However, software does not currently have an
mpi implementation installed.

\item Update source code from Trilinos repository

Obtain the most current version of Trilinos (for the branch being worked on).  
First, cd to the top Trilinos directory, then type
\begin{verbatim}
cvs -q update-dP
\end{verbatim}

\item Add new files to or remove obsolete files from the Trilinos repository

To add new files abc.cpp and abc.h to the Trilinos repository, cd to the 
directory in which the files are located in a checked out version of the 
Trilinos repository and type
\begin{verbatim}
cvs add abc.cpp abc.h
\end{verbatim}
To remove the same files, type
\begin{verbatim}
cvs remove abc.cpp abc.h
\end{verbatim}
The above commands do not actually add the files to or remove the files 
from the repository, but simply prepare for the addition or removal of the 
files.  The files will really be added or removed later using ``cvs commit''.  
However, this is a necessary step in the process.

\item List new files in or remove obsolete files from Makefile.am

New source files should be placed into a category in the appropriate 
Makefile.am.  Typically, the directory in which the new files are located will 
contain a Makefile.am.  If not, the appropriate Makefile.am will be found in 
the Makefile.am that is in the parent directory directly above the directory 
in which the new files are located.  The number of possibly categories to add 
files to varies a lot.  For a test or example a developer will typically just 
add the files directly to a SOURCES primary.  For a Trilinos package, there 
may be several categores of files.  For example UTIL, CORE, and DIST, to name 
a few.  Do not worry too much about which macro category to add the files to.  
The categories are simply a way to sort files into logical groups.  To remove 
files from the build process, simply delete the file names from the 
appropriate Makefile.am.

\item Bootstrap

First, cd to the top-level directory of the appropriate Trilinos package.  
For example Trilinos/packages/epetra.  Then type 
\begin{verbatim}
./bootstrap
\end{verbatim}
The process should complete without any errors, but the following warnings do 
commonly occur:
\begin{verbatim}
configure.ac:9: warning: do not use m4_patsubst: use patsubst or m4_bpatsubst
configure.ac:184: warning: do not use m4_regexp: use regexp or m4_bregexp
\end{verbatim}

\item Test the new code

Reconfigure and rebuild the Trilinos package.  Perform tests associated with 
the new code, as well as the rest of the tests for the package to insure that 
both the new code works and existing code has not been broken.  When changes 
could possibly affect other packages, tests for affected packages should also 
be run.

\item Update source code from Trilinos repository

Didn't we just do this?  Yes, but there are two good reasons to do it again.

Other developers could have committed changes during the past several 
steps of this process.  Though is not likely, it is worth checking.  If 
changes were committed, minimally the testing step will need to be redone.  
If files related to configuring or building were modified, more will have to 
be done if collisions occur.  Some of the possibilities are beyond the scope 
of this introductory document, however we will briefly discuss the most 
common collision scenario.  Typically the generated files will contain 
collisions (for example configure, Makefile.in, or aclocal.m4), while the 
changes in the files created by developers (for example configure.ac or 
Makefile.am) will be successfully merged by CVS.  In this case, the best 
course of action is to remove the files with collisions, cd to the top level 
of the Trilinos package, perform a cvs update, and then begin the above 
process again from ``Bootstrap'' step.  As long as the changes are merged in 
the non-generated files, bootstrapping should resolve the problem.

An even better reason to update again before committing changes is to avoid 
confusion.  After a bootstrap, all of the generated files will get an updated 
timestamp, but in most cases only some of the files will actually be 
modified.  If a developer commits changes before updating, all of the 
generated files will be viewed as having been modified.  This is bad for 
several reasons.  One of the most important is that when committing changes, a 
developer should always verify that the list of files that are about to be 
committed makes sense.  The list is guaranteed to not make sense if files are 
going to be committed that have not been changed.  A cvs update will check to 
see if the file has really been changed or if it simply has a new timestamp.

\item Commit the changes to the Trilinos repository

Once all of the above steps are completed, the final step is to commit the 
changes to the repository.  Start by typing
\begin{verbatim}
cvs commit
\end{verbatim}
Now, look at the list of files that are to be added, removed  or modified.  
It is easy to inadvertantly commit files.  It is also easy to forget to use 
``cvs add''.  If a file has not been added, it will not show up on the list of 
files to be added.  Conversely, to remove a file, don't forget to use ``cvs 
remove''.  

Here are a few helpful tips to use when verifying the list of files 
to be committed.  First, make sure that all files you modified directly appear 
in the list.  Second, when modifying a Makefile.am, the corresponding 
Makefile.in will change also.  Third, when modifying configure.ac, configure 
will also change, but some Makefile.in files may also change when using macros 
such as AC_SUBST.  Finally, when unsure about whether or not a file should be 
in the commit list, abort the commit by closing the edior without saving, and 
chosing ``abort''.  Then, if abc.cpp is in question, type 
\begin{verbatim}
cvs diff abc.cpp
\end{verbatim}
Then look at the diff output and see if it makes sense for the changes that 
were made.  After verifying that all of the files that are in the list belong 
there, and that all files that belong in the list are, in fact, listed, remove 
unnecessary instances of ``CVS: `` from the log message and enter an 
appropriate description of the changes that are to be committed.  Don't forget 
to reference any appropriate Bugzilla bug numbers.  Further, detailed log 
messages make it easier to track problems in the future.  It is a good habit 
to indicate which tests were run before making the change.

Finally, save the file, and exit the CVS editor to commit the changes.

When using the above process to commit new source code, the new source must 
be functioning properly, otherwise the repository will not be stable.  
At the same time, developers are encouraged put new code into the repository 
during initial development.  This will ensure that work is backed up and 
provide version control.  When adding unstable code to the repository, only
two steps are necessary.  First, use the ``cvs add'' command as mentioned 
above, and then modify the commit command slightly to commit only the new 
source by typing
\begin{verbatim}
cvs commit newfile1.cpp newfile2.cpp
\end{verbatim}
Provided that the new files are not added to the make structure, the addition 
of the new files should not negatively affect the repository.  Distribution 
tarballs will even skip over the new source.  A common log message for this 
type of commit is simply ``Checking in for safe keeping; code is not yet 
funcitoning''.  Sometimes developers will include a short description of what 
the code will do when complete.
\end{enumerate}

% start reading Mike's stuff at 243

\section{Package Requirements}
%	**(Req's and how to satisfy them - break into subsections)**

Stages of integration:
\begin{enumerate}
\item Put the package in the Trilinos repository.

This is a minimum requrirement for any package wanting to become a part of 
Trilinos.  Other than receiving approval from the Trilinos Project Leader to 
add a new package to Trilinos, there are no prerequisites for adding a new 
package to the Trilinos repository.  At this stage, it does not matter if the 
package is finished, or even if it works.  However, a package in an unstable 
state should not be added to the configure and build structure.  A package 
can remain in this predistribution state indefinitely.  When release branches 
are created, any packages not ready or approved for distribution can easily be 
ommitted.

\item Package should respond to all relevant configure options.
\item Package should have a process in place to port to all supported 
platforms and respond to bug reports in timely manner.
\end{enumerate}


\section{Suggested Practices}
%	**(suggested coding guidelines, and other non-manditory practices that are encouraged - break up.  See Overview Doc pg 11,14-15.)**

There are many ways to define an effective software process.  As a result, the 
Trilinos project specifies very few {\it requirements}.  At the same time, 
many software packages do not have well-defined practices to support good 
software engineering.  In this section, we discuss suggested practices based 
on our experience with some common tools and processes for software 
engineering.  We want to strongly emphasize that these are {\it suggested} 
practices only and we discuss them here in order to facilitate adoption of 
practices for packages that have few existing practices in place.

\subsection{Preliminary Steps}

\begin{enumerate}
\item Set up necessary accounts on software.sandia.gov.
\item Establish Bugzilla Product and Component Definitions.
Discussion of how to define bugzilla pieces.  Should discuss common component 
definitions.  List Heroux or Kolda or Sery as contacts.
\item Establish Email Lists
%\item Others?
\end{enumerate}

\subsection{Practices to Support Software Lifecycle}

One common view of software engineering processes breaks the process down into 
seven phases:
\begin{enumerate}
\item Requirements.
\item Specification.
\item Design.
\item Implementation.
\item Integration.
\item Maintenance.
\item Retirement/Replacement.
\end{enumerate}
In this section we discuss suggested practices to address most of these 
phases.  The value of adopting these practices is that they are commonly used 
or planned for use in a number of existing Trilinos packages.  It is worth 
noting that testing is not a phase, but should be done at each of the above 
phases in the process as appropriate for that phase.

\subsection{Requirements}
The majority of requirements for Trilinos packages come either directly or 
indirectly from funded research proposals and plans.  Although these 
requirements are sometimes difficult to elicit from the proposals and plans, 
we assume that a package is satisfying requirements by virtue of being 
funded.  Therefore we only suggest that package developers track their 
requirements as part of the communication with funding sponsors.

\subsection{Specification/Design}
Package specifications can be done in many ways.  An effective way for 
object-oriented, e.g., C++ packages is to use documented header files and a 
documentation tool such as Doxygen~\cite{doxyen}, and then communicate the 
generated HTML output to the package development team via the 
{\it package-developers@software.sandia.gov} email list.  This both

\subsection{Implementation}
Implementing new capabilites should never take place in a release branch.  
Changes to release branches should be limited to fixing broken code and 
related activities.  For example, clarifying vague or incorrect documentation 
and making changes necessary to port to a new platform.

\subsection{Integration}
Mention Epetra/TSF. Autotools.Integration into a release.

\subsection{Maintenance}
Say something about bugzilla, bonzai, mailman (checkins list), CVS (release 
branches) the test harness.

\subsection{Retirement/Replacement}
To the extent possible checkins to a release branch should not force interface 
changes for users.  Even on the development branch, users should be notified 
(via the package-users mail list) that checkins are about to happen that would 
require an interface change to user code.

In general, we will be very slow to omit a package, or version of a package, 
that is in use unless there is equivalent interface and functionality support 
from a new package.

	\section{Services Available to Trilinos Packages}
	A number of services exist for Trilinos packages.
	\subsection{Configuration Management}
%	**(See Overview Doc pg 12)**
Autoconf~\cite{Autoconf},  Automake~\cite{Automake} and
Libtool~\cite{Libtool} provide a robust, full-featured set of tools for
building software across a broad set of platforms (see also the ``Goat
Book''~\cite{GoatBook}).  Although these
tools are not official standards, they are commonly used in many
packages.  Many existing
Trilinos packages use Autoconf and Automake (and will use
Libtool in the future).  However, use of these tools is not required.

Package developers who are not currently using autotools, but would like
to, can get a jump start by using a Trilinos package called 
``new\_package''.  This trivial package exists for one primary purpose.  
It walks a developer through the process of setting up a package to 
configure and build using autotools.  General instructions for how to get 
started can be found in Trilinos/packages/new\_package/README.  Please note 
that new\_package is a work in progess, suggestions and contributions are 
welcome, especially for FAQ's.

Trilinos provides a set of M4~\cite{M4} macros that can be used by any other
package that wants to use Autoconf and Automake for configuring and
building libraries.  These macros perform common configuration tasks such as
locating a valid LAPACK~\cite{lapack} library, or checking for a user-
defined MPI C compiler.  The macros can be found in the Trilinos CVS 
repository in Trilinos/config.  These macros minimize the amount of redudant
 effort in using Autotools, and make it easier to apply a general change to 
the configure process for all packages.
	\subsection{Regression Testing}
Trilinos provides a variety of regression
testing capabilities.  Within a number of Trilinos packages, we employ
``white box'' testing where detailed information about the software is
used and probed.  In addition, Trilinos performs ``black box'' testing
of packages via the Trilinos Solver Framework (TSF) virtual class
interfaces.  Any package that implements the TSF interfaces (see
Section~\ref{subsect:InteropTSF} below 
%**(Add this section)), 
can be tested via this black box
test environment.  ({\bf NOTE: Black box testing via TSF is not in
place at this time}
	\subsection{Periodic Testing}
Trilinos Packages that configure and build using Autotools can easily 
utilize the the Trilinos test harness.  The test harness performs a CVS update
(gets the most recent source code) every night and then builds the libraries
and runs any tests that have been integrated into the testharness.  
Currently the testharness only runs on Linux, IRIX64, and DEC/OSF1, but it 
will eventually run on 5-8 platforms.  Packages that have not ported to a 
particular platform can be excluded from the testing process on that 
platform.  Packages that do not have any tests integrated into the 
testharness can still benefit by ensuring that libraries build without 
errors.  Integrating existing tests into the testharness is not difficult.  
The process is discussed in Trilinos/testharness/HowToAddToTestHarness.  
Please note that this document is a work in progress.

\subsection{CVS Repository}
%**Add an appendix for a lot of this info.**
Trilinos source code is maintained in a CVS~\cite{CVS} repository.  It is 
very easy to add new packages to the repository.  Packages that already use 
CVS can even retain their CVS history!  To access the repository, one must 
have an account on software.sandia.gov.  Once an account has been granted, 
set the following two environment variables (replace ``your\_user\_name'' 
with your user name on software):

\begin{verbatim}
CVSROOT :ext:your\_user\_name@software.sandia.gov:/space/CVS
CVS\_RSH ssh
\end{verbatim}

For those not familiar with CVS, below is a brief discussion covering some 
of the most common CVS commands.  For more information, see the Gnu CVS Home
Page~\cite{CVS}.

Checking Out a Working Copy

To get started, checkout a copy of the development branch of the repository.
(Releases branches can be obtained by by checking out the appropriate 
tagged version of the repository.)

\begin{verbatim}
cvs checkout Trilinos
\end{verbatim}

Updating a Woring Copy
To update after a version has been obtained use the ``update'' command.  
First, cd to the directory that is to be updated (usually the Trilinos root 
directory).  Then type:

\begin{verbatim}
cvs -q update -dP
\end{verbatim}

The ``-q'' option means ``be somewhat quiet''.  Try the command without this
option to see what it does.  

The ``-d'' option means to get any new directories.  For example, if a new 
package is added to the repository, but the ``-d'' option is not used, that 
new package will never appear in the working copy.  However, the first time 
that the ``-d'' option is used, all of the new package directories will be 
downloaded, and from that time on, all CVS updates will update the 
directories that were downloaded.  It is good practice to include this 
option for every CVS update.

... Decide if this subsection is worth it, or if people should read the doc.  If eexpanded, add info about when to check in, and which branch...

\subsection{Bonsai}
A lot of useful information related to CVS history is accessible via a
web-based interface package called Bonsai~\cite{Bonsai}.  This tool can be 
found on the web at ``http://software.sandia.gov/bonsai''.  Bonsai gives a 
developer the ability to view the changes made to the files in the 
repository.  The tool can be especially useful when trying to figure out which 
changes may have introduced bugs into a piece of code.  Developers can search 
for changes based on filename, directory, branch, date, user who made the 
change, or any combination of these criteria.  The entire revision histories of
individual files returned in a search can be utilized in finding the source of 
bugs.  The differences between any two versions of a file may be viewed.  

\subsection{Bugzilla}

Features and bug reports are tracked using Bugzilla~\cite{Bugzilla}.  Bugzilla 
can be found on the web at ``http://software.sandia.gov/bugzilla''.  A 
Bugzilla account is necessary for submitting bugs.  Those interested can sign 
up at the website.  All bugs related to any package of Trilnos that uses 
Bugzilla should be submitted to Bugzilla.  This even applies to cases in which 
one developer diagnoses and fixes a bug within a short period of time.  A bug 
report is still very valuable in this case because it provides an artifact 
that outlines the problem and explains how the problem was fixed.  A bug 
report should be filled out with as much detail as possible.  Likewise, after 
a bug has been resolved, the developer should also provide a detailed 
description of the solution that was used.

%**explain how this is truly useful, and not just busy work.**

NOTE: In the context of Bugzilla, ``bug'' can refer not only to an error in 
existing code, but also to a desired enhancement.  For example, a bug report 
should be submitted to Bugzilla to report a segmentation fault that occurs 
when using an existing Ifpack preconditioner, and a bug report should also be
submitted to request a new Ifpack preconditioner.

\subsection{Mailman}

Email lists are maintained for Trilinos as a whole and for each package 
through Mailman~\cite{Mailman}.  This tool can be found on the web at 
``http://software.sandia.gov/mailman/listinfo''.  Those interested in signing 
up for one or more lists may do so at the website.  Non-Sandians are able to 
sign up for the ``Users'' and ``Announce'' lists.  Sandians should keep this 
in mind when posting to these lists.

Lists for new packages can be set up very easily.  Each package usually has 
five mailing lists.  The example mailing lists mentioned below are to be used 
for issues relating to all of Trilinos.  The names for the lists pertaining to 
individual packages follow the same naming scheme, simply replace ``Trilinos'' 
with the name of the package.  For example the list for Trilnos users is 
called Trilinos-Users and the email address is 
\begin{verbatim}trilinos-users@software.sandia.gov\end{verbatim}  The list 
for Epetra users is called Epetra-Users and the associated email address is 
\begin{verbatim}epetra-users@software.sandia.gov\end{verbatim}

TIP: While those who use Epetra (or any other Trilinos package) are also
``Trilinos users'', the lists are not set up to recognize this.  In other 
words, those who subscribe to the Epetra-Users mailing list do not necessarily 
form a subset of those who subscribe to the Trilinos-Users mailing list.  This 
is also true of all other list types.  Keep this in mind when subscribing and 
posting to lists.
\begin{itemize}
\item Trilinos-Announce 
\begin{verbatim}trilinos-announce@software.sandia.gov\end{verbatim}

All Trilinos release announcements and other major news.

\item Trilinos-Checkins 
\begin{verbatim}trilinos-checkins@software.sandia.gov\end{verbatim}

CVS commit log messages that are releated to Trilinos in general or packages 
that have not had separate lists established.

\item Trilinos-Developers 
\begin{verbatim}trilinos-developers@software.sandia.gov\end{verbatim}

All discussions releated to Trilinos-specific development (not specific to a 
Trilinos package) are conducted via this list.  Important development 
decisions that originate in other places (regular email, discussions, etc) 
should also be posted to this list (or to the appropriate package list).  
By doing this, the list archive can provide a record explaining why various 
changes were made over time.

\item Trilinos-regression 
\begin{verbatim}trilinos-regression@software.sandia.gov\end{verbatim}

All regression test output that is not specific to a package. 

\item Trilinos-Users 
\begin{verbatim}trilinos-users@software.sandia.gov\end{verbatim}

List for Trilinos Users.  General discussions about the use of Trilinos.

\item Trilinos-Leaders
\begin{verbatim}trilinos-leaders@software.sandia.gov\end{verbatim}

Mailing list for representatives for each Trilinos package.  There are no 
leaders lists for individual packages.
\end{itemize}

All 
tools are accessible from the main Trilinos website~\cite{Trilinos-home-page}.

%**Consider an example showing how tools can work together to fix bugs.**

%	**(Add a section comp to Epetra and TSF: Two special packages - minimixe redundant work.)**
	\subsection{Portable Interface to BLAS and LAPACK}
%	**(See Overview Doc pg 12)**

Portable interface to BLAS and LAPACK: The Basic Linear Algebra
Subprograms (BLAS)~\cite{BLAS1,BLAS2,BLAS3} and LAPACK~\cite{lapack}
provide a large repository of robust, high-performance mathematical
software for serial and shared memory parallel dense linear algebra
computations.  However, the BLAS and LAPACK interfaces are Fortran
specifications, and the mechanism for calling Fortran interfaces from
C and C++ varies across computing platforms.  Epetra (and Tpetra)
provide a set of simple, portable interfaces to the BLAS and LAPACK
that provide uniform access to the BLAS and LAPACK across a broad
set of platforms.  These interfaces are accessible to
other packages.
%**(Expand on this)**


	\section{Integrating a Package into Trilinos}
%	**(list formal? process, meet above requirements Overview Doc pg 11,14-15)**




	\section{Interoperability Status for Existing Trilinos Packages}

	\section{Platform Portablility}
%	**(List platforms - encourage script submission)**
    % ---------------------------------------------------------------------- %
    % References
    %
    \clearpage
    \bibliographystyle{plain}
    \bibliography{TrilinosDevGuide}
    \addcontentsline{toc}{section}{References}

% Include Appendices??  If they are needed, they go here.


\end{document}
