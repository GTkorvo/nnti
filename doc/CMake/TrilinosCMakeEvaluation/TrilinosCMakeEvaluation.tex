
\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage[all]{draftcopy}
\input{rab_commands}
\newtheorem{theorem}{Theorem}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{
Trilinos CMake Evaluation
}
\author{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2008-xxx}
\SANDprintDate{xxx 2008}
\SANDauthor{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}
\raggedright

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Autotools is terrible. We need something better.  How about CMake?
Here we document our evaluation of CMake as a build system and testing
infrastructure to replace the current autotools-based system.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgment section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
%\clearpage
%\section*{Acknowledgment}
%The authors would like to thank ...
%
%The format of this report is based on information found
%in~\cite{Sand98-0730}.
%

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
%\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\setcounter{secnumdepth}{3}
\SANDmain % Start the main part of the report


%
\section{Introduction}
%

Here, we summarize a detailed evaluation of the CMake set of build and
testing tools as a possible replacement for the current
autotools-based and home-grown perl-based test harness.  This
evaluation includes the development of a comprehensive protype build
system infrastructure for Trilinos using CMake that is likely very
representative of what a final system would look like.


%
\section{Build Capabilities and Features}
%

Here we describe a set of features relateding to building and how they
are (or are not) supported with the current autotools build system and
the new CMake prototype system.  These features are subdivided into
critical and non-critical categories.


%
{}\subsection{Critical build features currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Dependency tracking of header files to rebuild object files

  \begin{enumerate}

  {}\item Why this is important: To enable fast and safe rebuilds

  {}\item Autotools: Only supported on Linux and very few other
  platforms.  Not support on the Sun, IBM, and SGI

  {}\item CMake: Built into CMake so it will work on every platform,
  period!

  \end{enumerate}

{}\item Dependency tracking of object files to libraries

  \begin{enumerate}

  {}\item Why this is important: To enable fast and safe rebuilds

  {}\item Autotools: Fully supported on all platforms

  {}\item CMake: Fully supported on all platforms

  \end{enumerate}

{}\item Scalable build system where libraries and header directory
locations are only defined once

  \begin{enumerate}

  {}\item Why this is important: This is needed to allow for the
  scalable growth and maintenance of Trilinos.

  {}\item Autotools: The current export makefile system (with
  makefile fragments Makefile.package.export) defines a single file
  where these are things are defined.  Every test and example in
  Trilinos (with a few shameful exceptions) uses the export
  makefiles to get all of these.  There is no duplication.

  {}\item CMake: The prototype CMake build system handles all
  dependences automatically with only simple intra-package dependency
  lists.  There is no duplication at all whatsoever and is much
  cleaner than the current autotools system.

  \end{enumerate}

{}\item Build system must be portable to all required platforms

  \begin{enumerate}

  {}\item Why this is important: Trilinos must support a wide set of
  different platforms.

  {}\item Autotools: Autotools generates very portable makefiles.
  However, avoiding ``command-line too long'' errors on many
  platforms requires that one use GNU Make.

  {}\item CMake: One needs to have cmake built on the target
  platform but all that is needed to build and install cmake is a
  fairly recent C++ compilers.  A simple 'configure', 'make', and
  'make install' is all that is needed. 

  \end{enumerate}

{}\item Cross compiling

  \begin{enumerate}

  {}\item Why this is important: Building for the big iron (e.g. Red Storm)

  {}\item Autotools: Yes, because everything is manual.

  {}\item CMake: Cross compiling is a new feature in CMake and it is
  unclear how well tested this in in our environment but organization
  1420 has had some success with this on reddish/redstorm.

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical build features not currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Library to executable dependency tracking:

  \begin{enumerate}

  {}\item Why this is important: We need this for fast rebuild/retest
  cycles before checkin and faster feedback from continuous
  integration tests.  Currently, it takes up to 50 minutes and longer
  on a very fast Linux machine to relink all the tests and examples in
  Trilinos.

  {}\item Autotools: No support at all

  {}\item CMake: This is built into CMake.  In my opinion (rabartl),
  this is one of the major motivations for going to CMake.

  \end{enumerate}

{}\item MS Windows support:

  \begin{enumerate}

  {}\item Why this is important: Windows represents a big growth area
  for Trilinos is and the Titain project is one example.

  {}\item Autotools: No direct support but cygwin can be used with
  Windows Intel compilers to install headers/libraries.  This is not
  easy to set up and not very portable.

  {}\item CMake: Direct support for MS Windows and a variety of
  other systems.  This includes creating project files for Visual
  Studio.  There is lots of experience with this at Sandia for
  Visual Studio and NMake for native Windows binaries.  This is one
  of the major selling points for CMake over the autotools system.

  \end{enumerate}

{}\item Must support multiple languages including Fortran 77,
Fortran 90, and Fortran 2003

  \begin{enumerate}

  {}\item Why this is important: ForTrilinos requires a very current
  Fortran 90 compiler with some Fortran 2003 features.  Included in
  this is name mangling for Fortran 77.

  {}\item Autotools: This is currently handled by setting 'F90' to
  point to the Fortran 90+ compiler when calling configure.  However,
  Fortran 2003 with gfortran creates auxiliary files that need to be
  linked symbolically linked in a manual way and it is not clear how
  portable this is.  Basically, autotools really does *not* support
  Fortran 2003.  What we have right now is a hack that works with
  gfortran.  Name mangling with Fortran 77 is well supported and
  largely automatic on most platforms.

  {}\item CMake: It is unclear how CMake support Fortran 90+ but
  Chapter 11 in {}\cite{MasteringCMake_fourth} deals with how to add
  new compilers so it seems this could be supported more cleanly than
  with autotools. $=>$ Perhaps we can copy and extend the Fortran 90
  macro package?  This may be hard to make portable but hopfully we
  would get some help from the CMake community or Kitware.  Right now
  Fortran 77 name mangling is determined by platform but it will be
  easy to write a Module/Macro that will figure this out automtically
  if such capability does not already exist.

  \end{enumerate}

\end{enumerate}


%
{}\subsection{Less-critical but desirable build features}
%

\begin{enumerate}

{}\item Circular dependencies allowed between tests/examples in
different packages

  \begin{enumerate}

  {}\item Why this is important: It is not clear where to put some
  examples/tests which require multiple packages and there are
  several cases of tests/examples that refer to libraries that build
  later in the build tree.

  {}\item Autotools: The default target for 'make' just builds
  libraries and the 'tests', 'examples', and 'everything' targets make
  all libraries before any tests or examples are linked.  The support
  for this with autotools is less than straightforward.  However,
  support for these types of circular dependences has proven to make
  the current system fragile is not scaling well.

  {}\item CMake: The current CMake build system prototype does not
  support cicular dependences between tests/examples and later package
  libraries.  However, it is not clear that this feature is worth
  preserving.  Instead, we can put such problem-some tests/exapmles
  into packages like TrilinosCouplings or others.

  \end{enumerate}

{}\item Shared libraries:

  \begin{enumerate}

  {}\item Why this is important: Some customers demand this.  Also,
  shared libraries can allow for much faster rebuild cycles where
  executables do not even need to be relinked after a dependent
  library is rebuilt.  This can substantially speed up pre-checkin
  testing and shorten the feedback time from a continuous
  integration server.

  {}\item Autotools: Past attempts at using libtool have failed.
  The Python-based system for creating shared libraries on Linux is
  not well characterized.

  {}\item CMake: Shared library support with CMake is advertised to be
  very strong (see Section 4.8 in {}\cite{MasteringCMake_fourth}).
  Experience with shared libraries with CMake in our computing
  environment includes Linux, Mac OS, and Windows (but with some extra
  work in the CMakeLists.txt files).  If shared libraries don't work
  on a platform, you can just switch back to static libraries and that
  is pretty fool-proof.
  
  {}\textit{Caveat:} Currently, at least for the makefile generator,
  changes in {}\texttt{*.cpp} files that result in the recreation of a
  shared library also result in unecessary relinking of all dependent
  test and example executables.  This is unfortunate but
  understandable given that makefiles are being used and this type of
  logic is not supported by 'make'.  {}\textit{Work around}: We can
  add a 'libs' target that will result in only libraries being rebuilt
  and then a developer can just to 'make libs' followed by 'ctest' and
  avoid relinking.  However, if other code does need to be rebuilt,
  then that will result in inconsistent executbles and therefore
  inaccurate test results.  However, it may be possible to devise a
  general system of manipulating time stamps when shared libraries are
  used so that we can avoid relinking executables when we don't need
  to.  For example, we could perform a {}\texttt{make libs}, sleep for
  a second, touch all of the {}\texttt{*.exe} files, and then make all
  the rest of the targets.  In this way, if header files have been
  updated, all other {}\texttt{*.cpp} files associated with tests and
  example executables would get rebuilt and the necessary relinking
  would automatically occur.

  \end{enumerate}

{}\item Creation of export makefiles with compilers, compiler
options, include directories, libraries etc. to external clients:

  \begin{enumerate}

  {}\item Why this is important: Building compatible client code
  that will successfully link against Trilinos can be difficult to
  do in a portable when done manually.  This feature is really only used
  by second-tier customers (e.g. graduate students and other off
  projects) as our major customers handle this differently.

  {}\item Autotools: This is done by installing
  Makefile.package.export and Makefile.package.export.macros in the
  \$prefix/install directory.

  {}\item CMake: This will be easy to support.

  \end{enumerate}

{}\item Clean and understandable mechanism for extending
functionality

  \begin{enumerate}

  {}\item Why this is important: We will need to create specialized
  features form time to time and we need a supported way to do this
  that is clean and understandable.

  {}\item Autotools: Autotools uses M4 which has to be the most
  confusing and hacked language ever designed in semi-modern times.
  It is clear that M4 was hacked together as some wrapper for shell
  scripting.

  {}\item CMake: CMake has its own scripting language that is fairly
  general and fairly compact for basic usage.  It appears to be a full
  featured language that would seem to be ``turning complete'' which
  includes the ability to define lists and loops over those lists and
  create arbitrary new functions (call macros).  You can debug CMake
  scripts by putting in MESSAGE(...) calls where are the equivalent to
  print statements.

  {}\textit{Disclaimers}: The CMake scripting language is a little
  strange.  For one, the varible scoping rules involving cache,
  internal cache, and non-cache varibles are very confusing and make
  it difficult to implement complex logic.  However, CMake is still
  many times better than autotools for which we are comparing.

  \end{enumerate}

{}\item Simple development environment

  \begin{enumerate}

  {}\item Why this is important: Leaning how to develop in a Trilinos
  package needs to be faily easy and setting up a development
  environment needs to be faily easy to work with.

  {}\item Autotools: In order to develop on Trilinos, you need to go
  out and find specific versions of autoconf and automake and put them
  on whatever system where you will need to change the build system
  for any reason (e.g. add/remove files, add new tests, etc.).  This
  is a big hassle when you work on a variety of platforms, espeically
  ones where you do not have root administrator privileges (e.g. the
  SCICO LAN).  Also, whenever you changed any Makefile.am file or
  configure.ac file, you need to remember to run ./bootscrap in any
  package that you change and at the top level.  It is easy to forget
  or hassle to run these scripts.  An if you don't remember to
  bootstrap, the build system will not update anything.

  {}\item CMake: With CMake there is no intermediate ``bootstrap''
  step.  After the CMake files are modified, they can be directly
  checked in (after being tested of course).  As a developer, this
  means only having to get the CMake source and install it (version
  2.6 is currently required but 2.7 is needed for correct CDash
  reporting).  That is better than having to get two different
  programs with different versions for automake and autoconf.  Also,
  as long as you have a recent version of CMake (currentl 2.6 or
  newer), you can use any version you would like (including the CVS
  version).  Finally, if you change any CMake build system file, the
  next type you type 'make' the build system will automatically
  reconfigure itself without needing any bootstrap stage.

  \end{enumerate}

{}\item Simple installation for users

  \begin{enumerate}

  {}\item Why this is important: While installing Trilinos for users
  for the general case will never be ``easy'' because of the
  complexity of Trilinos, we don't want to make it too hard.

  {}\item Autotools: With autotools, a ``configure'' shell script is
  provided and in theory, a user just needs to run configure with the
  correct input arguments and then they can do 'make install'.
  Testing a serial version of Trilinos is also easy as 'make
  runtests-serial'.  Running the full serial test suite requires 'make
  rutnests-serial TRILINOS\_TEST\_CATEGORY=FRAMEWORK'.  However,
  running the MPI tests is not so easy and I imagine most users will
  never do this because of having to specify several other tricky make
  variables like TRILINOS\_MPI\_GO.  Also, in order to really install
  and test all of Trilinos on some systems, you have to use
  --with-gnumake or you get ``command-line too long'' errors or errors
  that are much more cryptic.  What this means is that you essentally
  need to have and use GNU Make in order to make Trilinos portable.
  On some systems, user may have to install GNU Make theirselves but
  usually it is already installed and they just need to use it instead
  of the default 'make' command.

  {}\item CMake: Users must have a current enough version (currently
  2.6) of cmake installed on their system to configure and generate
  makefiles and then build and install.  However, for some specialized
  distributions, it will be possible to distribute RPM files, MS
  Visual Studio project files, and the like where users would not need
  CMake but there will be less flexibility in what packages and
  options are enabled and disabled.  Note, however, that cmake appears
  to be as portable and easy to build from source as GNU Make so this
  is not a huge extra requirement over the autotools system.  Also
  note that on MS windows, there are binary self-extracting installers
  for a very nice CMake GUI program that users can just download,
  double-click to install, and then run.  On MS Windows, if you have
  the free MS Visual C++ edition, then configuring project files by
  downloading and installing the Windows version of CMake is really
  not any harder than downloading a pre-created project file.

  \end{enumerate}

\end{enumerate}


%
\section{Testing and Reporting Capabilities and Features}
%


%
{}\subsection{Critical testing features currently handled by the
existing perl test harness}
%

\begin{enumerate}

{}\item Selection of subsets of tests using keywords:

  \begin{enumerate}

  {}\item Why this is important: a) routine developer testing during
  the development process requires the ability to run subsets of tests
  easily, b) tests for individual packages need to be selected
  individually, c) different sets of test categories like
  ``Performance'' and ``Scalability'' tests must selected as needed.

  {}\item Perl test harness: Superficial support where only one
  ``keyword'' can be selected for inclusion but multiple sets of
  keywords can not be selected and keywords can not be excluded.

  {}\item CMake/CTest: While CTest does not directly support keywords,
  they are emulated with the TRILINOS\_ADD\_TEST(...) function by
  simply appending the keywords to the name of the test.  Then,
  'ctest' support the options -R, -E, and -U for including and
  excluding tests in a very flexible way.

  \end{enumerate}

{}\item Separate archiving and reporting of test results for each
package:

  \begin{enumerate}

  {}\item Why this is important: It is important to create targeted
  package test result web pages and emails so that individual
  package developers can focus on their own packages and not be
  distracted by errors from other related packages.  This is
  something that SIERRA does *not* have worked out and it is killing
  them.

  {}\item Perl test harness: Handled very cleaning but there are
  still some improvements to be made .. e.g. a) listing of all
  platforms run, b) email notifications

  {}\item CMake/CTest/CDash: This can be done at the CTest scripting
  level to configure the dashboard but it could be a good bit of work.

  \end{enumerate}

{}\item Platform-specific tests:

  \begin{enumerate}

  {}\item Perl test harness: Handed with 'HOST' and 'X-HOST' options
  in a very clean way with 'uname -n' but it is not very portable (for
  example, does not work on the MAC).

  {}\item CMake: This is trivially handled with a HOST and XHOST
  argument with the TRILINOS\_ADD\_TEST(...) function.  Actually, this
  is more portable since it relies on the built-in SITE\_NAME(...) 
  command in CMake and not the non-portable 'uname -n' command.

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical testing features not currently handled by the perl
test harness}
%

\begin{enumerate}

{}\item Code coverage

  \begin{enumerate}

  {}\item Why this is important: This is one of the most basic
  metrics of code quality and of the completeness of tests.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of other groups.

  \end{enumerate}

{}\item Memory usage testing (i.e. valgrind and/or purify)

  \begin{enumerate}

  {}\item Why this is important: Memory usage errors in C/C++
  continue to degrade the quality of our code and they tend to sit
  dormant for long periods of time and don't cause major problems
  until we really need our software to work.  This includes memory
  leaks, accessing deleted memory, accessing memory with invalid
  addresses, out-of-bounds errors, etc.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and is run on many platforms
  by lots of other groups.  This can be run in local build with:

    \begin{verbatim}
      ctest -T memcheck
    \end{verbatim}

  It can also run memory checking as part of the nightly testing
  process with:

    \begin{verbatim}
      ctest -D NightlyMemoryCheck
    \end{verbatim}

  \end{enumerate}

{}\item Automatic timeout of tests

  \begin{enumerate}

  {}\item Why this is important: Hanging tests can freeze up the test
  harness so that no results are sent at all and it requires a lot of
  manual work to monitor this and to manually kill hanging tests.
  Every major test harness used by our APP customers have support for
  this feature (e.g. Alegra, Charon, SIERRA, Xyce).

  {}\item Perl test harness: Not currently supported

  {}\item CMake/CTest: Currently supported with the CMake cache
  variable {}\texttt{DART\_TESTING\_TIMEOUT:STRING=<seconds>}.  A
  timeout can also be set on a test-by-test basis with the
  {}\texttt{TIMEOUT} test property set by the
  {}\texttt{set\_tests\_properties(...)} command.  This has been
  tested and verified to work well even with parallel tests (with Open
  MPI).  This will be a huge in improving the robustness of the
  testing infrastructure for Trilinos.

  \end{enumerate}

\end{enumerate}

\
%
{}\subsection{Less-critical but desirable testing and reporting features}
%

\begin{enumerate}

{}\item Performance testing

  \begin{enumerate}

  {}\item Why this is important: Performance tests are typically
  serial tests that do relative or absolute runtime comparisons for
  optimized code.  We need a mechanism for defining and selecting to
  run performance tests on various platforms for optimized builds.

  {}\item Perl test harness: No direct support but could be handled
  with a special test category (i.e. keyword) and run for optimized
  builds?

  {}\item CMake/CTest: Can be very easily supported with a CATEGORIES
  option with the TRILINOS\_ADD\_TEST(...) function.

  \end{enumerate}

{}\item Parallel running of (serial) tests:

  \begin{enumerate}

  {}\item Why this is important: Running tests is parallel can
  significantly speed up pre-checking testing and shorten the feedback
  time from a continuous integration server.

  {}\item Perl test harness: No support

  {}\item CMake/CTest: Is being developed in the current CMake
  development version.

  \end{enumerate}

{}\item PBS-type batch running of MPI tests:

  \begin{enumerate}

  {}\item Why this is important: Scalability testing requires some
  more substantial parallel clusters and this requires using a batch
  system like PBS.  The test harness needs to support submitting
  batch jobs of mpi runs and wait for the results to come back in an
  efficient way.

  {}\item Perl test harness: No support yet but some experimentation
  has been done?

  {}\item CMake/CTest: Not directly supported but given the
  flexibility of the CMake scripting language, if it is possible to
  support this can be supported in the new TRILNOS\_ADD\_TEST(...) 
  macro.

  \end{enumerate}

{}\item Archiving all test outputs for sufficient period of time

  \begin{enumerate}

  {}\item Why this is important: Complete test results are needed to
  be able to diagnose failing tests.  Otherwise, you must manually
  go to the platform, build the executable(s) and run the tests
  manually.  Older test result data can be cleaned out as space gets
  tight.

  {}\item Perl test harness: Currently, only stdout is captured and
  saved and then only a limit of so many bytes for each file.

  {}\item CMake/CTest/CDash: CTest/CDash supports grabbing
  ``measurements'' including files and puts them in the database.  You
  can also pose files to the dashboard database using the -A option
  with ctest.

    \begin{itemize}

    {}\item TODO: Look into -A option with ctest for posting multiple
    files to dashboard.  The VTK dashboard already has examples of
    this

    \end{itemize}

  \end{enumerate}

{}\item Allowing the specification of any arbitrary number of
programs and/or criteria to determine test success or failure

  \begin{enumerate}

  {}\item Why this is important: Complex tests require that you be
  able to define ``success'' in a variety of ways.  Examples: a)
  Grepping an output file looking for a specific string, b) Checking
  for a non-zero return value and grepping for a specific string in
  stdout, c) running multiple test executables and then comparing
  files to define an overall test that gets reported (This could also
  be used for scalability testing for PBS-type queuing systems).

  {}\item Perl test harness: The current Trilinos test harness only
  allows you to run one script as the test or a single grep of the
  console output.  There is also support for running the compareOutput
  program but that is not enough.

  {}\item CMake/CTest: No direct support but you could do this behind
  the scenes of the TRILINOS\_ADD\_TEST(...) macro in a way that was
  100\% transparent with, for example, PASS\_COMMAND arguments.

  \end{enumerate}

{}\item Disabling of packages that fail the build and rebuilding

  \begin{enumerate}

  {}\item Why this is important: In order to maximize the amount of
  (Experimental) code that can be built and tested, it is desirable
  to be able to disable packages that fail to compile and then
  disable optional support in the other packages.

  {}\item Perl test harness: This is supported but it requires a lot
  of manual work to maintain the package dependencies and the
  completion banners in every package.

  {}\item CMake/CTest: There is not built-in support for this but
  intra-package dependence tracking has been implemented in the
  prototype CMake build system for Trilinos.  An advanced CTest script
  (see Section 10.9 in {}\cite{MasteringCMake_fourth}) could be
  written to drive the entire process and the dashboard display could
  be modified to support this.

  \end{enumerate}

\end{enumerate}

%
\section{Desired enhancements to CMake/CTest/CDash}
%

Here we list some identified areas of missing support in
CMake/CTest/CDash that we either strongly need or would be of great
benefit for Trilinos.

\begin{enumerate}

{}\item\textit{Strongly desired}: CMake/CTest: Support for keywords
for tests.  This could be added with a {}\texttt{KEYWORDS} property
for the {}\texttt{set\_tests\_properties(...)} command.
{}\textit{Work around}: Simply append all of the keywords to the name
of the test.

{}\item\textit{Desired}: Direct support for running (multiple)
programs to post-process the output from a test (both the console and
any ouptut files).  {}\textit{Work around}: This can be emulated
within the TRILINOS\_ADD\_TEST(...) function by writing script files
that combine everything but it will be hard to make this portable and
might make it confusing to trace what is happening.

{}\item CTest: Default outputting issues:

  \begin{itemize}

  {}\item\textit{Desired}: Show what the test criteria is and why a
  test passed or failed in the test output in
  Testing/Temporary/LastTest.log.  Currently, it does not show if the
  test passed or failed, just what the output is.
  
  {}\item\textit{Desired}: ctest: Print the time for each test (not
  just the start and end times in the log file).

  {}\item\textit{Desired}: Automatically widen the output to show the
  full test names.  Currently, only the first 30 characters of the
  name are shown.  The option -W was added to the CVS version of CTest
  to allow the width to be manually set but this is a hassel and does
  not interact well with MS Visual C++ projects.

  \end{itemize}

{}\item\textit{Desired:} CTest/CDash: Submit all test data (no matter
the size) and then pruning test results over time.  This includes
files that get output as well.  This is being done for the SIERRA +
Trilinos Integration test repository for instance.

{}\item\textit{Desired}: CMake: Generate error messages for missing
source files that have line numbers in the corresponding
CMakeLists.txt file.  Currently, it just lists the entire
CMakeLists.txt file and nothing else.

{}\item\textit{Desired:} CMake: Strong checking for variables that are
not defined.  Just letting undefined variables be empty is a bad
practice (used by Make and bad Fortran).  This practice is well known
to result in higher rates of software defects.  {}\textit{Work
around}: Use a user-defined {}\texttt{ASSERT\_DEFINED(...)} macro.

\end{enumerate}


%
\section{Summary and Recommendations}
%


%
\subsection{Gains and losses for switching from autotools to CMake for the build sytem}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Full dependancy tracking of every kind possible on all
  platforms (i.e.\ header to object, object to library, library to
  exectuble, and build system files to all other files).

  {}\item Support for shared libraries on a variety of platforms

  {}\item Support for MS Windows (i.e.\ Visual Studio projects,
  Windows installers, etc.)

  {}\item Simplified build system and easier maintenance (extremely
  easy to add new packages and maintain existing packages)

  {}\item Improved mechanism for extending capabilities (as compared
  to M4 in autotools)

  {}\item Ability to affect the development of the build tools and
  good existing collaborations (i.e.\ with both Kitware and witn 1420)

  {}\item Significant ``in house'' knowledge-base (i.e.\ visualization
  people in 1420)

  {}\item One hundred percent automated interpackage dependency
  tracking and handling (built into the prototype Trilinos/CMake build
  system)

  {}\item ???

  \end{enumerate}

{}\item What we loose (at least initally):

  \begin{enumerate}

  {}\item CMake requires that all uses have 'cmake' installed on their
  machine when building from source and users will need to have at a
  very recent version of cmake. (However, cmake is very easy to build
  from source).

  {}\item Support for circular test/example and package libraries is
  not provided in the current prototype Trilinos/CMake build system

  \end{enumerate}

\end{enumerate}


%
\subsection{Gains and losses for switching from current perl-based test
harness to CTest/CDash test system}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Test time-outs (this is a major maintance issue for the
  current perl-based test harness)

  {}\item Memory testing with valgrind and purify that is backed up by
  Kitware and a larger development community

  {}\item Line coverage testing that is backed up by Kitware and a
  large development community

  {}\item Support for selecting and excluding subsets of tests based
  on regular expresions (but better support for keywords would be
  welcomed)

  {}\item Better tracking of specific tests (i.e.\ each and every test
  can have a unique name that is easy to find).

  {}\item ???

  \end{enumerate}

{}\item What we loose (at least initially):

  \begin{enumerate}

  {}\item Separate reporting of test results for different Trilinos
  packages on the web page and in emails sent out. (however, such
  support could be layered on top of CTest and CDash).

  {}\item Support for selectively disabling package tests/examples and
  entire packages when a build fails.  (however, such support could be
  layered on top of ctest for driving the test harness).

  {}\item ???

  \end{enumerate}

\end{enumerate}


%
\subsection{Final recommendations}
%

The potential gains for switching from the current autools build
system to a CMake build system summarized above are overwhelming.
Therefore, our recommendation is to transition all of Trilinos to the
new CMake-based build system and completely drop the current autotools
build system as soon as possible.

There are also significant advantages to supporting the CTest/CDash
based test harness as summarized above.  However, some features
supported by the home-grown perl-based test harness will take
considerable time and effort to replicate with CTest/CDash.
Therefore, our recommandation is to maintain test suites for both
CTest/CDash and the perl-based test harness until such time that the
infrastructure around CTest/CDash sufficiently supports the
compartmentalization of test results archiving and reporting.  This
means maintaining each package's test/defintion file, and adding
TRILINOS\_ADD\_TEST(...) calls in CMakeLists.txt files.  By
maintaining both testing systems, we will have the best of both worlds
but at the cost of needing to maintain two test systems for some time.

The current Trilinos/CMake prototype build system is now at a state
where we believe it can now be pushed out to all of Trilinos.


% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}


% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%
\appendix



%
\section{Trilinos/CMake ToDo}
%

In this section, we describe the specific tasks/requirements that must
be completed in order to complete this inital Trilinos/CMake
evaluation to facilitate an informed decision about whether Trilinos
will drop autotools for the build and swtich over to CMake after
Trilinos 9.0 is released.  Also, as an another decision, if in
addition the perl-based test harness will be replaced with CTest/CDash
and when.  We can drop autotools for building Trilinos and we can keep
the current perl-based test harness for awhile (or forever) or we can
switch over to CTest/CDash and drop the current perl-based test
harness at the same time or we can maintian both test harness for some
time.  There are many possibilities.

\begin{enumerate}

{}\item Decide on package autonomy

Two options:

  \begin{itemize}

  {}\item Option 1: Require that all packages be built from the top
  Trilinos level $=>$ This will significanlty reduce the amount of
  effort it takes to create and maintain packages.  NOTE: Packages
  that want to build indepenently can add whatever special support for
  bulding separately.  NOTE: You could pass include directories and
  libraries to cmake for individual packages.

  {}\item Option 2: Require that all packages be able to build
  separately not from the top level. $=>$ This forces every package
  have to take on this requirement.

  \end{itemize}

Suggested approach: Have each package just read and write global
varaibles for PACKAGE\_INCLUDE\_DIRS and PACKAGE\_LIBS set up at the
global level.  Then, packages can be configured and built
independently by passing in the needed cache variables.  This is
essentially what has been done but we have not tested building
packages independently yet.

{}\item Refactor and break about the TRILINOS\_ADD\_EXECUTABLE(...) 
script to separate add\_target(...) and add\_test(...) commands.
Features that these new scripts must support and related issues
include:

  \begin{enumerate}

  {}\item Allow test target executable to be defined independently
  from its test [Done]

  {}\item All executables should have the *.exe extension, even on
  Linux as this makes it easy to grep for executables and this is the
  current Trilinos convention ... Investigate what happens on Windows
  ... see if there is an global extention to add ... [Somewhat done
  but more testing on Windows is needed]

  {}\item Allow (require) the names of the test executables to be
  exactly the same as with current autotools system (to allow use of
  test/definition files with no changes). [Done]

  {}\item Include or exlucde specific machines for running a test
  (both as a group of tests or individually) ... I.e. HOST and XHOST
  [Done]

  {}\item Do not assume tests are in a subdirectory but allow for this
  (i.e. the DIRECTORY argument is optional). [Done]

  {}\item Allow for multiple sets of input arguments for each test
  executable

    \begin{itemize}

    {}\item If unique test name is not given, allow for automatic
    numeric postfix [Done]

    \end{itemize}

   [Done]

  {}\item Build in MPI information (serial and/or MPI, number of
  processors, etc.)

    \begin{itemize}

    {}\item The ``Comm'' (i.e. 'mpi' or 'serial') [Done]

    {}\item Selection/defintion of test based on the number of allowed
    MPI processors for the test and the global machine max number of
    processes (Hint: See what the perl-based 'runtests' script does).
    I.e. compare the input NUM\_MPI\_PROCS to the global cache varible
    MPIEXEC\_MAX\_NUMPROCS and see if the test passes.  TODO: Search
    through the test/definition files to see how COMM = MPI(???) is
    actually being used and talk with Jim W.\ about this.
	
    \end{itemize}

   [Done]

  {}\item Allow passthrough of all of the set\_test\_properties(...) 
  command for WILL\_FAIL, PASS\_REGULAR\_EXPRESSION, and
  FAIL\_REGULAR\_EXPRESSION [Done].

  {}\item (Low priority) Put in support for the compareTestOutput
  program and other post-processing programs that look at test output.
  TODO: Grep through the current test/definition files to see where
  compareTestOutput.  Also, talk with Jim W. about making this feature
  more flexible and simpler to use any postprocessing program to
  determine success or failure.

  {}\item (Low priority) Support adding keywords for groups of tests
  or individual tests.  Supporting this for real requires keyword
  support in ctest which it does not have this but we could emulate
  this by tacking on the keywords to the end of each test name in the
  group.

  {}\item (Low priority) Specify current working directory where the
  test should be run from (e.g. DESEND\_INTO\_DIRECTORY option).
  TODO: Search and see where DESEND\_INTO\_DIR is being used in
  current test/defintion files.  Workaround: If you define the test in
  a CMakeList.txt file in the actualy directory, ctest will cd into
  that directory when it runs the test.  We don't need
  DESEND\_INTO\_DIRECTORY [WONTFIX]

  \end{enumerate}

Here is what an example of the refactored macros might look like:

\begin{verbatim}

TRILINOS_ADD_EXECUTABLE(ArrayRCP_test
  DIRECTORY MemoryManagement
  NAME ArrayRCP_test # Name of the test (defalts to executable name)
  DIRECTORY MemoryManagement
  XHOST S859352.sandia.gov # Run on all hosts except this one
  KEYWORDS unit framework install
  PASS_REGULAR_EXPRESSION "All Tests PASSED"
  COMM serial mpi
  NUM_MPI_PROCS 1
  ARGS "--verbose --n=1" "--n=2" "--n=4"
  )

# Above, add_test(...) would define the tests ArrayRCP_test_0,
# ArrayRCP_test_1, and ArrayRCP_test_2.

TRILINOS_ADD_TEST(ArrayRCP_test
  NAME ArrayRCP_test_big
  DIRECTORY MemoryManagement
  DESEND_INTO_DIR
  KEYWORDS performance
  COMM serial mpi
  NUM_MPI_PROCS 6-16
  ARGS "--n=500" "--n=1000"
  )

# Above, add_test(...) would define the tests ArrayRCP_test_big_0,
# ArrayRCP_test_big_1

\end{verbatim}

It is critically important that the TRILINOS\_ADD\_TEST(...) macro be
very flexible and full featured as it needs to replace the current
perl-based test harness PACKAGE/test/defintion file entries.  Also, it
will be difficult to change once a lot of tests have been
defined. [Done]

{}\item Bring the current Trilinos/CMake support in the existing
CMake-ified packages up to spec with the above requirements and to
achieve:

  \begin{enumerate}

  {}\item Put in custom targets 'runtest-serial' and 'runtest-mpi' to
  invoke the perl 'runtest' script to run tests.  These targets must
  be supported in each pacakge and at the global Trilinos
  level. [Done]

  {}\item Remove all duplication in header file paths, library paths
  and libraries (Ross B.) [Done]

  {}\item Build all test and example executables with exact same names
  in the same locations as is being done with existing autotools
  system (Ross B.) [Done]

  {}\item Implement automatic dependancy tracking facility for
  required and optional dependancies and recursive enables and
  disables (Ross B.) [Done]

  {}\item Add full ctest testing support for all current tests and
  examples the same as is defined and being performed with the current
  PACKAGES/test/definition files (Ross) ... Not done yet but not hard
  ...

  {}\item Test installing Trilinos heades and libraries and create
  same structure as existing Trilinos system (Ross B.)

  {}\item Get a CDash dashboard up and running controled by Trilinos
  developers and get nightly testing with a cron scirpt
  going. (Esteban G.)

  {}\item Add Windows, MAC, and Linux nightly testing for
  Trilinos/CMake (Esteban G.)

  {}\item (Lower priority just because it is a slam dunk with no risk)
  Implement and demonstrate the generation of export makefiles in the
  same exact way the current autotools system
  does\footnote{Specifically requested by Mike Heroux and Roger
  Pawloski} (Ross B.) ... This is *not* going to be hard ...

  {}\item (Low priority) Make the default 'make' target just build
  libraries and add 'tests' and 'examples' targets just like the
  current autotools system does (Ross B.)

  {}\item (Low priority) Implement two-state configuration and
  building to support circular dependancies between tests/examples and
  up-stream libraries.  Test this in a superficial way?

  \end{enumerate}

{}\item Expand CMake/CTest support to the packages rtop, epetraext,
thyra, amesos, ifpack, aztecoo, stratimikos, CTrilinos, and
ForTrilinos (optionally). (Ross B.)

This list of packages will bring a number of new issues into play
(e.g. different capitalization of package directories, Fortran 2003
support, etc.)  and will help to test the circular test/example
library dependancies issue.

{}\item Test out and demonstrate CMake features:

  \begin{enumerate}

  {}\item CTest time-out feature killing MPI tests (see if OpenMPI
  brings down orphaned processes or not) (Ross B.) [Done]

  {}\item Building MS Visual Studio projects on MS Windows (Esteban
  G.) [Done]

  {}\item Shared library support on Linux and other platforms (Ross B.)

    \begin{itemize}

    {}\item Look into rebuilds for changing *.cpp files and impact on
    relinking.  CMake should not be relinking executables when just a
    *.o file changes in a shared library.  If CMake is relinking, we
    need to find out if this is really needed or if this is a bug in
    CMake.

    {}\item Look into a 'libs' target to avoid relinks.

    \end{itemize}

  {}\item Full dependancy tracking on various platforms (Ross B.)

  {}\item Using CPack to create binary serial distribution for MS
  Windows (e.g.\ installed headers and libraries, and/or Visual Studio
  project files, etc.)\footnote{Specifically requested by Mike
  Heroux.} (Esteban B.)

  \end{enumerate}

\end{enumerate}

Once all of the above tasks are finished, this initial evaluation of
CMake/CTest/CDash etc. for Trilinos will be complete.

Shortly after the completion of the evaluation and the corresponding
summary and conclusions are stated below, the Trilinos leaders will
decide on a course of action regarding replacing the current autotools
and perl-based test harness with CMake/CTest/CDash/CPack and on a time
table for doing so.


\begin{SANDdistribution}[NM]
% \SANDdistCRADA	% If this report is about CRADA work
% \SANDdistPatent	% If this report has a Patent Caution or Patent Interest
% \SANDdistLDRD	% If this report is about LDRD work
% External Address Format: {num copies}{Address}
%\SANDdistExternal{}{}
%\bigskip
%% The following MUST BE between the external and internal distributions!
%\SANDdistClassified % If this report is classified
% Internal Address Format: {num copies}{Mail stop}{Name}{Org}
%\SANDdistInternal{}{}{}{}
% Mail Channel Address Format: {num copies}{Mail Channel}{Name}{Org}
%\SANDdistInternalM{}{}{}{}
%\SANDdistInternal{2}{MS 9018}{Central Technical Files}{8944}
%\SANDdistInternal{2}{MS 0899}{Technical Library}{4536}
\end{SANDdistribution}

\end{document}
