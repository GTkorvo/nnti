\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage[all]{draftcopy}
\input{rab_commands}
\newtheorem{theorem}{Theorem}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{
Trilinos CMake Evaluation
}
\author{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2008-xxx}
\SANDprintDate{June 2008}
\SANDauthor{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}
\raggedright

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Autotools is terrible. We need something better.  How about CMake?
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgment section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
%\clearpage
%\section*{Acknowledgment}
%The authors would like to thank ...
%
%The format of this report is based on information found
%in~\cite{Sand98-0730}.
%

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
%\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\setcounter{secnumdepth}{3}
\SANDmain % Start the main part of the report


%
\section{Introduction}
%

Blah, blah, blah ...


%
\section{Build Capabilities and Features}
%


%
{}\subsection{Critical build features currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Dependency tracking of header files to rebuild object files

  \begin{enumerate}

  {}\item Autotools: Only supported on Linux and very few other
  platforms.  Not support on the Sun, IBM, and SGI

  {}\item CMake: Built into CMake so it will work on every platform,
  period!

  \end{enumerate}

{}\item Dependency tracking of object files to libraries

  \begin{enumerate}

  {}\item Autotools: Fully supported?

  {}\item CMake: Fully supported?

  \end{enumerate}

{}\item Scalable build system where libraries and header directory
locations only defined once

  \begin{enumerate}

  {}\item Why this is important: This is needed to allow for the
  scalable growth and maintenance of Trilinos.

  {}\item Autotools: The current export makefile system (with
  makefile fragments Makefile.package.export) defines a single file
  where these are things are defined.  Every test and example in
  Trilinos (with a few shameful exceptions) uses the export
  makefiles to get all of these.  There is no duplication.

  {}\item CMake: Chapter 7 in {}\cite{MasteringCMake_fourth}
  describes a system would this should be well supported but it does
  not appear the current Trilinos/CMake system has fully embraced
  this.

  \end{enumerate}

{}\item Build system must be portable to all required platforms

  \begin{enumerate}

  {}\item Autotools: Autotools generates very portable makefiles.
  However, avoiding ``command-line too long'' errors on many
  platforms requires that one use GNU Make.

  {}\item CMake: One needs to have cmake built on the target
  platform but all that is needed to build and install cmake is a
  fairly recent C++ compilers.  A simple 'configure', 'make', and
  'make install' is all that is needed. 

  \end{enumerate}

{}\item Cross compiling

  \begin{enumerate}

  {}\item Why this is important: Building for the big iron (e.g. Red Storm).

  {}\item Autotools: Yes, because everything is manual.

  {}\item CMake: New feature in CMake but seems untested in our
  environment?

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical build features not currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Library to executable dependency tracking:

  \begin{enumerate}

  {}\item Why this is important: We need this for fast
  rebuild/retest cycles before checkin and faster feedback from
  continuous integration tests.  Currently, it takes up to 50
  minutes to relink all the tests and examples in Trilinos.

  {}\item Autotools: No support at all

  {}\item CMake: This is built into CMake.  In my opinion (rabartl),
  this is one of the major motivations for going to CMake.

  \end{enumerate}

{}\item MS Windows support:

  \begin{enumerate}

  {}\item Why this is important: Windows represents a big growth
  area for Trilinos is and the Tritan project is one example.

  {}\item Autotools: No direct support but cygwin can be used with
  Windows Intel compilers to install headers/libraries.  This is not
  easy to set up and not very portable.

  {}\item CMake: Direct support for MS Windows and a variety of
  other systems.  This includes creating project files for Visual
  Studio.  There is lots of experience with this at Sandia for
  Visual Studio and NMake for native Windows binaries.  This is one
  of the major selling points for CMake over the autotools system.

  \end{enumerate}

{}\item Must support multiple languages including Fortran 77,
Fortran 90, and Fortran 2003

  \begin{enumerate}

  {}\item Why this is important: ForTrilinos requires a very current
  Fortran 90 compiler with some Fortran 2003 features.  Included in
  this is name mangling for Fortran 77.

  {}\item Autotools: This is currently handled by setting 'F90' to
  point to the Fortran 90+ compiler when calling configure.  However,
  Fortran 2003 with gfortran creates auxiliary files that need to be
  linked symbolically linked in a manual way and it is not clear how
  portable this is.  Basically, autotools really does *not* support
  Fortran 2003.  What we have right now is a hack that works with
  gfortran.  Name mangling with Fortran 77 is well supported and
  largely automatic on most platforms.

  {}\item CMake: It is unclear how CMake support Fortran 90+ but
  Chapter 11 in {}\cite{MasteringCMake_fourth} deals with how to add
  new compilers so it seems this could be supported more cleanly than
  with autotools. $=>$ Perhaps we can copy and extend the Fortran 90
  macro package?  This may be hard to make portable but hopfully we
  would get some help from the CMake community or Kitware.  Right now
  Fortran 77 name mangling is determined by platform but it will be
  easy to write a Module/Macro that will figure this out automtically
  if such capability does not already exist.

  \end{enumerate}

\end{enumerate}


%
{}\subsection{Less-critical but desirable build features}
%

\begin{enumerate}

{}\item Circular dependencies allowed between tests/examples in
different packages

  \begin{enumerate}

  {}\item Why this is important: It is not clear where to put some
  examples/tests which require multiple packages and there are
  several cases of tests/examples that refer to libraries that build
  later in the build tree.

  {}\item Autotools: The default target for 'make' just builds
  libraries and the 'tests', 'examples', and 'everything' targets
  make all libraries before any tests or examples are linked.  The
  support for this with autotools is less than straightforward.

  {}\item CMake: There does not seem to be any direct support for
  this but perhaps this could be implemented in a clean way? 
  Options: a) Single pass configure with jumps to up-stream
  libraries, b) two pass, one for dependencies, second for the rest
  (e.g. libraries, tests, examples etc.)

  \end{enumerate}

{}\item Shared libraries:

  \begin{enumerate}

  {}\item Why this is important: Some customers demand this.  Also,
  shared libraries can allow for much faster rebuild cycles where
  executables do not even need to be relinked after a dependent
  library is rebuilt.  This can substantially speed up pre-checkin
  testing and shorten the feedback time from a continuous
  integration server.

  {}\item Autotools: Past attempts at using libtool have failed.
  The Python-based system for creating shared libraries on Linux is
  not well characterized.

  {}\item CMake: Shared library support with CMake is advertised to
  be very strong (see Section 4.8 in
  {}\cite{MasteringCMake_fourth}).  Experience with shared libraries
  with CMake in our computing environment includes Linux, Mac OS,
  and Windows (but with some extra work in the CMakeLists.txt
  files).  If shared libraries don't work on a platform, you can
  just switch back to static libraries and that is pretty
  fool-proof.

  \end{enumerate}

{}\item Creation of export makefiles with compilers, compiler
options, include directories, libraries etc. to external clients:

  \begin{enumerate}

  {}\item Why this is important: Building compatible client code
  that will successfully link against Trilinos can be difficult to
  do in a portable when done manually.  This feature is really only used
  by second-tier customers (e.g. graduate students and other off
  projects) as our major customers handle this differently.

  {}\item Autotools: This is done by installing
  Makefile.package.export and Makefile.package.export.macros in the
  \$prefix/install directory.

  {}\item CMake: This can be supported in some way with CMake to
  generate export makefile fragments.

  \end{enumerate}

{}\item Clean and understandable mechanism for extending
functionality

  \begin{enumerate}

  {}\item Why this is important: We will need to create specialized
  features form time to time and we need a supported way to do this
  that is clean and understandable.

  {}\item Autotools: Autotools uses M4 which has to be the most
  confusing and hacked language ever designed in semi-modern times.
  It is clear that M4 was hacked together as some wrapper for shell
  scripting.

  {}\item CMake: CMake has its own scripting language that is fairly
  general and fairly compact.  It appears to be a full featured
  language that would seem to be ``turning complete'' which includes
  the ability to define lists and loops over those lists and create
  arbitrary new functions (call macros).  The CMake scripting
  language does seem to be a little too implicit for my liking.

  \end{enumerate}

{}\item Simple development environment

  \begin{enumerate}

  {}\item Why this is important: Leaning how to develop in a Trilinos
  package needs to be faily easy and setting up a development
  environment needs to be faily easy to work with.

  {}\item Autotools: In order to develop on Trilinos, you need to go
  out and find specific versions of autoconf and automake and put them
  on whatever system where you will need to change the build system
  for any reason (e.g. add/remove files, add new tests, etc.).  This
  is a big hassle when you work on a variety of platforms, espeically
  ones where you do not have root administrator privileges (e.g. the
  SCICO LAN).  Also, whenever you changed any Makefile.am file or
  configure.ac file, you need to remember to run ./bootscrap in any
  package that you change and at the top level.  It is easy to forget
  or hassle to run these scripts.

  {}\item CMake: With CMake there is no intermediate ``bootstrap''
  step.  After the CMake files are modified, they can be directly
  checked in (after being tested of course).  As a developer, this
  means only having to get the CMake source and install it (version
  2.6 is currently required but 2.7 is needed for correct CDash
  reporting).  That is better than having to get two different
  programs with different versions for automake and autoconf.

  \end{enumerate}

{}\item Simple installation for users

  \begin{enumerate}

  {}\item Why this is important: While installing Trilinos for users
  for the general case will never be ``easy'' because of the
  complexity of Trilinos, we don't want to make it too hard.

  {}\item Autotools: With autotools, a ``configure'' shell script is
  provided and in theory, a user just needs to run configure with the
  correct input arguments and then they can do 'make install'.
  Testing a serial version of Trilinos is also easy as 'make
  runtests-serial'.  Running the full serial test suite requires 'make
  rutnests-serial TRILINOS\_TEST\_CATEGORY=FRAMEWORK'.  However,
  running the MPI tests is not so easy and I imagine most users will
  never do this because of having to specify several other tricky make
  variables like TRILINOS\_MPI\_GO.  Also, in order to really install
  and test all of Trilinos on some systems, you have to use
  --with-gnumake or you get ``command-line too long'' errors or errors
  that are much more cryptic.  What this means is that you essentally
  need to have and use GNU Make in order to make Trilinos portable.
  On some systems, user may have to install GNU Make theirselves but
  usually it is already installed and they just need to use it instead
  of the default 'make' command.

  {}\item CMake: Users must have a current enough version (currently
  2.6) of cmake installed on their system to configure and generate
  makefiles and then build and install.  However, for some specialized
  distributions, it will be possible to distribute RPM files, MS
  Visual Studio project files, and the like where users would not need
  CMake but there will be less flexibility in what packages and
  options are enabled and disabled.  Note, however, that cmake appears
  to be as portable and easy to build from source as GNU Make so this
  is not a huge extra requirement over the autotools system.

  \end{enumerate}

\end{enumerate}


%
\section{Testing and Reporting Capabilities and Features}
%


%
{}\subsection{Critical testing features currently handled by the
existing perl test harness}
%

\begin{enumerate}

{}\item Defining different tests with same the executable but
different sets of test arguments:

  \begin{enumerate}

  {}\item Perl test harness: This is well supported and easy to do.

  {}\item CMake/CTest: This is supported by the 'add\_test' command
  but is not supported by the current CMake macro
  TRILINOS\_ADD\_EXECUTABLE(...) but could be supported by maybe
  rename up TRILINOS\_ADD\_EXECUTABLE(...) to be
  TRILINOS\_ADD\_EXECUTABLE\_AND\_TEST(...) split up to call
  TRILINOS\_ADD\_EXECUTABLE(...) and TRILINOS\_ADD\_TEST(...).

  \end{enumerate}

{}\item Selection of subsets of tests using keywords:

  \begin{enumerate}

  {}\item Why this is important: a) routine developer testing during
  the development process requires the ability to run subsets of tests
  easily, b) tests for individual packages need to be selected
  individually, c) different sets of test categories like
  ``Performance'' and ``Scalability'' tests must selected as needed.

  {}\item Perl test harness: Superficial support where only one
  ``keyword'' can be selected for inclusion but multiple sets of
  keywords can not be selected and keywords can not be excluded.

  {}\item CMake/CTest: While CTest does not directly support keywords,
  then can be supported with the new TRILINOS\_ADD\_TEST(...) function
  by simply appending the keywords to the name of the test (not the
  executable).  Then, 'ctest' support the options -R, -E, and -U for
  including and excluding sets of keywords.

  \end{enumerate}

{}\item Separate archiving and reporting of test results for each
package:

  \begin{enumerate}

  {}\item Why this is important: It is important to create targeted
  package test result web pages and emails so that individual
  package developers can focus on their own packages and not be
  distracted by errors from other related packages.  This is
  something that SIERRA does *not* have worked out and it is killing
  them.

  {}\item Perl test harness: Handled very cleaning but there are
  still some improvements to be made .. e.g. a) listing of all
  platforms run, b) email notifications

  {}\item CMake/CTest/CDash: This can be done at the CTest scripting
  level to configure the dashboard but it could be a good bit of
  work. $=>$ This will be deferred for a later evaluation but must
  be done to replace the current Trilinos perl-based test harness.

  \end{enumerate}

{}\item Platform-specific tests:

  \begin{enumerate}

  {}\item Perl test harness: Handed with 'HOST' and 'X-HOST' options
  in a very clean way.

  {}\item CMake: No direct support but could be implemented using
  system introspection in a CMake macro?  $=>$ Platform includes and
  excludes would have to be added to a new TRILINOS\_ADD\_TEST(...
  HOSTS host1 host2 XHOST host1 host2 ) macro?

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical testing features not currently handled by the perl
test harness}
%

\begin{enumerate}

{}\item Code coverage

  \begin{enumerate}

  {}\item Why this is important: This is one of the most basic
  metrics of code quality and of the completeness of tests.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of other groups.

  \end{enumerate}

{}\item Memory usage testing (i.e. valgrind and/or purify)

  \begin{enumerate}

  {}\item Why this is important: Memory usage errors in C/C++
  continue to degrade the quality of our code and they tend to sit
  dormant for long periods of time and don't cause major problems
  until we really need our software to work.  This includes memory
  leaks, accessing deleted memory, accessing memory with invalid
  addresses, out-of-bounds errors, etc.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of other groups.

  \end{enumerate}

{}\item Automatic timeout of tests

  \begin{enumerate}

  {}\item Why this is important: Hanging tests can freeze up the
  test harness so that no results are sent at all and it requires a
  lot of manual work to monitor this and to manually kill hanging
  tests.  Every major test harness used by our APP customers have
  support for this (e.g. Alegra, Charon, SIERRA, Xyce).

  {}\item Perl test harness: Not currently supported

  {}\item CMake/CTest: Currently supported with a '--test-timeout'
  option to 'ctest'.  Not clear if this will work with MPI tests
  (unless we can ensure that the MPI implementation will clean up
  processes when it mpirun or mpiexec gets killed).  Time out value
  can also be set as a property on individual tests. $=>$ This is a
  huge robustness issue.

    \begin{itemize}
   
    {}\item TODO: Test timeouts for MPI tests with current
    Trilinos/CMake infrastructure.

    \end{itemize}

  \end{enumerate}

\end{enumerate}

\
%
{}\subsection{Less-critical but desirable testing and reporting features}
%

\begin{enumerate}

{}\item Performance testing

  \begin{enumerate}

  {}\item Why this is important: Performance tests are typically
  serial tests that do relative or absolute runtime comparisons for
  optimized code.  We need a mechanism for defining and selecting to
  run performance tests on various platforms for optimized builds.

  {}\item Perl test harness: No direct support but could be handled
  with a special test category (i.e. keyword) and run for optimized
  builds?

  {}\item CMake/CTest: No direct support but could be handled in
  some way? $=>$ Keywords support will help a lot here.

  \end{enumerate}

{}\item Parallel running of (serial) tests:

  \begin{enumerate}

  {}\item Why this is important: Running tests is parallel can
  significantly speed up pre-checking testing and shorted the
  feedback time from a continuous integration server

  {}\item Perl test harness: No support

  {}\item CMake/CTest: Planned to be added to the next major release
  of CMake/CTest
    
    {\scriptsize\begin{verbatim}
    List:       cmake
    Subject:    Re: [CMake] parallel builds for ctest
    From:       "Alan W. Irwin" <irwin () beluga ! phys ! uvic ! ca>
    Date:       2008-02-16 19:22:39
    Message-ID: Pine.LNX.4.60.0802161105280.4080 () ybpnyubfg ! ybpnyqbznva
    [Download message RAW]
    
    On 2008-02-16 12:38-0500 Bill Hoffman wrote:
    
    > [...]parallel ctest is on the todo list for this year.  Most likely  it 
    > will be ctest -j N.   We can not depend on the make system to do the parallel 
    > stuff, and ctest -j would be useful for all generators.
    
    That's excellent news!  The execution of the PLplot tests actually take
    about the same time to run as (non-parallel) building of PLplot itself. Now
    we are doing our builds in parallel, convenient parallel testing will be
    most welcome as well, and I look forward to trying out that new ctest
    functionality once you are ready.
    
    Alan
    \end{verbatim}}

  \end{enumerate}

{}\item PBS-type batch running of MPI tests:

  \begin{enumerate}

  {}\item Why this is important: Scalability testing requires some
  more substantial parallel clusters and this requires using a batch
  system like PBS.  The test harness needs to support submitting
  batch jobs of mpi runs and wait for the results to come back in an
  efficient way.

  {}\item Perl test harness: No support yet but some experimentation
  has been done?

  {}\item CMake/CTest: Not directly supported but it could be
  implemented in the native CMake scripting language?

  \end{enumerate}

{}\item Archiving all test outputs for sufficient period of time

  \begin{enumerate}

  {}\item Why this is important: Complete test results are needed to
  be able to diagnose failing tests.  Otherwise, you must manually
  go to the platform, build the executable(s) and run the tests
  manually.  Older test result data can be cleaned out as space gets
  tight.

  {}\item Perl test harness: Currently, only stdout is captured and
  saved and then only a limit of so many bytes for each file.

  {}\item CMake/CTest/CDash: CTest/CDash supports grabbing
  ``measurements'' including files and puts them in the database.  You
  can also pose files to the dashboard database using the -A option
  with ctest.

    \begin{itemize}

    {}\item TODO: Look into -A option with ctest for posting multiple
    files to dashboard.  The VTK dashboard already has examples of
    this

    \end{itemize}

  \end{enumerate}

{}\item Allowing the specification of any arbitrary number of
programs and/or criteria to determine test success or failure

  \begin{enumerate}

  {}\item Why this is important: Complex tests require that you be
  able to define ``success'' in a variety of ways.  Examples: a)
  Grepping an output file looking for a specific string, b) Checking
  for a non-zero return value and grepping for a specific string in
  stdout, c) running multiple test executables and then comparing
  files to define an overall test that gets reported (This could also
  be used for scalability testing for PBS-type queuing systems).

  {}\item Perl test harness: The current Trilinos test harness only
  allows you to run one script as the test or a single grep of the
  console output.  There is also the compareOutput that is not
  enough.

  {}\item CMake/CTest: No direct support but you could define a
  CMake macro for CTest to do this?

  \end{enumerate}

{}\item Disabling of packages that fail the build and rebuilding

  \begin{enumerate}

  {}\item Why this is important: In order to maximize the amount of
  (Experimental) code that can be built and tested, it is desirable
  to be able to disable packages that fail to compile and then
  disable optional support in the other packages.

  {}\item Perl test harness: This is supported.

  {}\item CMake/CTest: This is not supported but perhaps could be
  implemented inside of an advanced CTest script (see Section 10.9
  in {}\cite{MasteringCMake_fourth}).

  \end{enumerate}

\end{enumerate}



%
\section{Issues with the current Trilinos/CMake system}
%

\begin{enumerate}

{}\item Build system Issues

  \begin{enumerate}

  {}\item 'Debug' configuration is not supported by current CMake
  system in Trilinos

    \begin{itemize}

    {}\item TODO: We can put in logic to check CMAKE\_BUILD\_TYPE and
    add more define macros (e.g. TEUCHOS\_DEBUG).

    \end{itemize}

  {}\item Circular dependencies between tests/examples and other
  packages is not supported ... Default top-level 'make' must build
  all libraries before building tests and examples ...

  {}\item Build system is not scalable or use the
  ``one-definition-rule'' ... There is lots of redundancy in library
  names, include paths, etc. ...

  {}\item CMake system does not put in logic for required enables
  (e.g. enabling anasazi does not enable epetra or teuchos).

  {}\item There is a lot of logic in the top-level CMakeLists.txt file
  that looks like might be better distributed into the various
  package's CMakeLists.txt files?

  {}\item There is too much clutter and duplication in the
  CMakeLists.txt for for tests and examples to handle MPI and other
  issues ... We need to be able to just list the minimum and have the
  rest taken care of ...

  {}\item Fortran 2003 support?

  \end{enumerate}

{}\item Testing Issues

  \begin{enumerate}

  {}\item Examples are not being tested (they must be tested as well
  as being built)

  {}\item There is no way to run a test with more than one set of test
  arguments (we need to support running test and example executables
  with multiple sets of command-line arguments and we need different
  names for each test case that gets reported).  $=>$ This can be
  handled by the implementation of a TRILINOS\_ADD\_TEST(...) macro.

  {}\item Keywords of some type need to be supported (okay, the name
  of the package is in there but that is not really enough) ... This
  appears to be a fundamental deficiency of CMake/CTest.

  \end{enumerate}

\end{enumerate}


%
\section{Trilinos/CMake ToDo}
%

In this section, we describe the specific tasks/requirements that must
be completed in order to complete this inital Trilinos/CMake
evaluation to facilitate an informed decision about whether Trilinos
will drop autotools for the build and swtich over to CMake after
Trilinos 9.0 is released.  Also, as an another decision, if in
addition the perl-based test harness will be replaced with CTest/CDash
and when.  We can drop autotools for building Trilinos and we can keep
the current perl-based test harness for awhile (or forever) or we can
switch over to CTest/CDash and drop the current perl-based test
harness at the same time or we can maintian both test harness for some
time.  There are many possibilities.

\begin{enumerate}

{}\item Decide on package autonomy

Two options:

  \begin{itemize}

  {}\item Option 1: Require that all packages be built from the top
  Trilinos level $=>$ This will significanlty reduce the amount of
  effort it takes to create and maintain packages.  NOTE: Packages
  that want to build indepenently can add whatever special support for
  bulding separately.  NOTE: You could pass include directories and
  libraries to cmake for individual packages.

  {}\item Option 2: Require that all packages be able to build
  separately not from the top level. $=>$ This forces every package
  have to take on this requirement.

  \end{itemize}

Group's suggested approach: Have each package just read and write
global varaibles for PACKAGE\_INCLUDE\_DIRS and PACKAG\_LIBS set up at
the global level.  Then, packages can be configured and built
independently by passing in the needed cache variables.  TODO: Set up
example to prove that this works with a) Dakota, b) Acro, c) simple
example in Trilinos to test this?

{}\item Deal with issue of different cases for package names and their
directory names.  We might just define a double entry list like:

\begin{verbatim}

# Package name and its package directory name
SET( PACKAGES
  Teuchos teuchos
  Epetra epetra
  ...
  ForTrilinos ForTrilinos
  MOOCHO moocho
  )
LIST(LENGTH PACKAGES PACKAGES_LEN)
MATH(EXPR NUM_PACKAGES "${PACKAGES_LEN}/2")


...

MATH(EXPR PACKAGES_MAX_IDX "${NUM_PACKAGES} - 1")
FOREACH(PACKAGE_IDX RANGE 0 ${PACKAGES_MAX_IDX})
  MATH(EXPR PACKAGE_NAME_IDX "2*${PACKAGE_IDX}")
  MATH(EXPR PACKAGE_DIR_IDX "2*${PACKAGE_IDX}+1")
  LIST(GET PACKAGES ${PACKAGE_NAME_IDX} PACKAGE_NAME)
  LIST(GET PACKAGES ${PACKAGE_DIR_IDX} PACKAGE_DIR)
 ...
ENDFOREACH()

\end{verbatim}

{}\item Refactor and break about the TRILINOS\_ADD\_EXECUTABLE(...) 
script to separate add\_target(...) and add\_test(...) commands.
Features that these new scripts must support and related issues
include:

  \begin{enumerate}

  {}\item Allow test target executable to be defined independently
  from its test [Done]

  {}\item All executables should have the *.exe extension, even on
  Linux as this makes it easy to grep for executables and this is the
  current Trilinos convention ... Investigate what happens on Windows
  ... see if there is an global extention to add ... [Somewhat done
  but more testing on Windows is needed]

  {}\item Allow (require) the names of the test executables to be
  exactly the same as with current autotools system (to allow use of
  test/definition files with no changes). [Done]

  {}\item Include or exlucde specific machines for running a test
  (both as a group of tests or individually) ... I.e. HOST and XHOST
  [Done]

  {}\item Do not assume tests are in a subdirectory but allow for this
  (i.e. the DIRECTORY argument is optional). [Done]

  {}\item Allow for multiple sets of input arguments for each test
  executable

    \begin{itemize}

    {}\item If unique test name is not given, allow for automatic
    numeric postfix [Done]

    \end{itemize}

   [Done]

  {}\item Build in MPI information (serial and/or MPI, number of
  processors, etc.)

    \begin{itemize}

    {}\item The ``Comm'' (i.e. 'mpi' or 'serial') [Done

    {}\item Selection/defintion of test based on the number of allowed
    MPI processors for the test and the global machine max number of
    processes (Hint: See what the perl-based 'runtests' script does).
    I.e. compare the input NUM\_MPI\_PROCS to the global cache varible
    MPIEXEC\_MAX\_NUMPROCS and see if the test passes.  TODO: Search
    through the test/definition files to see how COMM = MPI(???) is
    actually being used and talk with Jim W.\ about this.
	
    \end{itemize}

   [Done]

  {}\item Allow passthrough of all of the set\_test\_properties(...) 
  command for WILL\_FAIL, PASS\_REGULAR\_EXPRESSION (Done), and
  FAIL\_REGULAR\_EXPRESSION [Mostly done].

  {}\item (Low priority) Put in support for the compareTestOutput
  program and other post-processing programs that look at test output.
  TODO: Grep through the current test/definition files to see where
  compareTestOutput.  Also, talk with Jim W. about making this feature
  more flexible and simpler to use any postprocessing program to
  determine success or failure.

  {}\item (Low priority) Support adding keywords for groups of tests
  or individual tests.  Supporting this for real requires keyword
  support in ctest which it does not have this but we could emulate
  this by tacking on the keywords to the end of each test name in the
  group.

  {}\item (Low priority) Specify current working directory where the
  test should be run from (e.g. DESEND\_INTO\_DIRECTORY option).
  TODO: Search and see where DESEND\_INTO\_DIR is being used in
  current test/defintion files.  Workaround: If you define the test in
  a CMakeList.txt file in the actualy directory, ctest will cd into
  that directory when it runs the test.  We don't need
  DESEND\_INTO\_DIRECTORY [WONTFIX]

  \end{enumerate}

Here is what an example of the refactored macros might look like:

\begin{verbatim}

# Just define the exec target ./MemoryManagement/ArrayRCP_test.exe
TRILINOS_ADD_EXECUTABLE(ArrayRCP_test
  DIRECTORY MemoryManagement
  SOURCES ArrayRCP_test.cpp
  )

# Define the tests that will run ./MemoryManagement/ArrayRCP_test.exe
TRILINOS_ADD_TEST(ArrayRCP_test # The name of the executable (required)
  NAME ArrayRCP_test # Name of the test (defalts to executable name)
  DIRECTORY MemoryManagement
  DESEND_INTO_DIR
  XHOST S859352.sandia.gov # Run on all hosts except this one
  KEYWORDS unit framework install
  PASS_REGULAR_EXPRESSION "All Tests PASSED"
  COMM serial mpi
  NUM_MPI_PROCS 1
  ARGS "--verbose --n=1" "--n=2" "--n=4"
  )

# Above, add_test(...) would define the tests ArrayRCP_test_00,
# ArrayRCP_test_01, and ArrayRCP_test_02.

TRILINOS_ADD_TEST(ArrayRCP_test
  NAME ArrayRCP_test_big
  DIRECTORY MemoryManagement
  DESEND_INTO_DIR
  KEYWORDS performance
  COMM serial mpi
  NUM_MPI_PROCS 6-16
  ARGS "--n=500" "--n=1000"
  )

# Above, add_test(...) would define the tests ArrayRCP_test_big_00,
# ArrayRCP_test_big_01

\end{verbatim}

It is critically important that the TRILINOS\_ADD\_TEST(...) macro be
very flexible and full featured as it needs to replace the current
perl-based test harness PACKAGE/test/defintion file entries.  Also, it
will be difficult to change once a lot of tests have been defined.

{}\item Bring the current Trilinos/CMake support in the existing
CMake-ified packages up to spec with the above requirements and to
achieve:

  \begin{enumerate}

  {}\item Remove all duplication in header file paths, library paths
  and libraries.

  {}\item Make the default 'make' target just build libraries and add
  'tests' and 'examples' targets just like the current autotools
  system does

  {}\item Implement and demonstrate the generation of export makefiles
  in the same exact way the current autotools system
  does\footnote{Specifically requested by Mike Heroux and Roger
  Pawloski}

  {}\item Build all test and example executables with exact same names
  in the same locations as is being done with existing autotools
  system

  {}\item Put in custom targets 'runtest-serial' and 'runtest-mpi' to
  invoke the perl 'runtest' script to run tests.  These targets must
  be supported in each pacakge and at the global Trilinos level.

  {}\item Add full ctest testing support for all current tests and
  examples the same as is defined and being performed with the current
  PACKAGES/test/definition files

  {}\item Get a CDash dashboard up and running controled by Trilinos
  developers and get nightly testing with a cron scirpt going.

  {}\item (Low priority) Implement two-state configuration and
  building to support circular dependancies between tests/examples and
  up-stream libraries.  Test this in a superficial way?

  \end{enumerate}

{}\item Expand CMake/CTest support to the packages rtop, epetraext,
thyra, amesos, ifpack, aztecoo, stratimikos, CTrilinos, and
ForTrilinos (optionally).

This list of packages will bring a number of new issues into play
(e.g. different capitalization of package directories, Fortran 2003
support, etc.)  and will help to test the circular test/example
library dependancies issue.

{}\item Test out and demonstrate CMake features:

  \begin{enumerate}

  {}\item Shared library support on Linux and other platforms

  {}\item Building MS Visual Studio projects on MS Windows

  {}\item CTest time-out feature killing MPI tests (see if OpenMPI
  brings down orphaned processes or not)

  {}\item Full dependancy tracking on various platforms

  {}\item Using CPack to create binary serial distribution for MS
  Windows (e.g.\ installed headers and libraries, and/or Visual Studio
  project files, etc.)\footnote{Specifically requested by Mike
  Heroux.}

  \end{enumerate}

\end{enumerate}

Once all of the above tasks are finished, this initial evaluation of
CMake/CTest/CDash etc. for Trilinos will be complete.

Shortly after the completion of the evaluation and the corresponding
summary and conclusions are stated below, the Trilinos leaders will
decide on a course of action regarding replacing the current autotools
and perl-based test harness with CMake/CTest/CDash/CPack and on a time
table for doing so.

%
\section{Desired and required enhancements to CMake/CTest/CDash}
%

Here we list some identified areas of missing support in
CMake/CTest/CDash that we either strongly need or would be of great
benefit for Trilinos.

\begin{enumerate}

{}\item\textit{Strongly desired}: CMake/CTest: Support for keywords
for tests.  This could be added with a {}\texttt{KEYWORDS} field for
the {}\texttt{add\_test(...)} command (e.g. {}\texttt{add\_test(
... KEYWORDS keyword1 keyword2 ... )}) or could be supported with a
{}\texttt{KEYWORDS} property for an existing test (this would not
break any existing add\_test(...) uses where KEYWORDS might be a
command-line argument).  {}\textit{Work around}: Simply append all of
the keywords to the name of the test (not the executable).

{}\item\textit{Desired:} CMake: Strong checking for variables that are
not defined.  Just letting undefined variables be empty is a bad
practice (used by Make and bad Fortran).

{}\item\textit{Desired:} CTest/CDash: Submit all test data (no matter
the size) and then pruning test results over time.  This is being done
for SIERRA + Trilinos Integration test repository.

\end{enumerate}


%
\section{Summary and Recommendations}
%


%
\subsection{Gains and losses for switching from autotools to CMake for the build sytem}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Dependancy tracking for header to object files that works on
  all platforms

  {}\item Full dependancy tracking form libaries to all executable
  programs

  {}\item Support for shared libraries on a variety of platforms (not
  the mess that is libtool)

  {}\item Support for MS Windows (i.e.\ Visual Studio projects,
  Windows installers, etc.)

  {}\item Simplified build system and easier maintenance (easier to
  add new packages and maintain existing packages)

  {}\item Improved mechanism for extending capabilities (as compared
  to M4 in autotools)

  {}\item ???

  \end{enumerate}

{}\item What we loose:

  \begin{enumerate}

  {}\item CMake requires that all uses have 'cmake' installed on their
  machine when building from source and users will need to have at a
  very recent version of cmake. (However, cmake is very easy to build
  from source).

  \end{enumerate}

\end{enumerate}


%
\subsection{Gains and losses for switching from current perl-based test
harness to CTest/CDash test system}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Test time-outs. (this is a major maintance issue for the
  current perl-based test harness).

  {}\item Memory testing with valgrind and purify that is backed up by
  Kitware and a larger development community

  {}\item Line coverage testing that is backed up by Kitware and a larger
  development community

  {}\item Better support for selecting and excluding subsets of tests
  based on keywords

  {}\item ???

  \end{enumerate}

{}\item What we loose:

  \begin{enumerate}

  {}\item Separate reporting of test results for different Trilinos
  packages on the web page and in emails sent out. (however, such
  support could be layered on top of CTest and CDash).

  {}\item Support for selectively disabling package tests/examples and
  entire packages when a build fails.  (however, such support could be
  layered on top of ctest for driving the test harness).

  {}\item ???

  \end{enumerate}

\end{enumerate}


%
\subsection{Final recommendations}
%

The potential gains for switching from the current autools build
system to a CMake build system summarized above are overwhelming.
Therefore, our recommendation is to transition all of Trilinos to the
new CMake-based build system and completely drop the current autotools
build system as soon as possible after the Trilinos 9.0 release is
finished.

There are also significant advantages to going with a CTest/CDash
based test harness as summarized above.  However, some features
supported by the home-grown perl-based test harness will take
considerable time and effort to replicate with CTest/CDash.
Therefore, our recommandation is to maintain test suites for both
CTest/CDash and the perl-based test harness until such time that the
infrastructure around CTest/CDash sifficiently supports the
compartmentalization of test results archiving and reporting.  This
means maintaining each packages test/defintion file, and adding
TRILINOS\_ADD\_TEST(...) calls in CMakeLists.txt files.  By
maintaining both testing systems, we will have the best of both worlds
but at the cost of needing to maintain to test systems for some time.


% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}


\begin{SANDdistribution}[NM]
% \SANDdistCRADA	% If this report is about CRADA work
% \SANDdistPatent	% If this report has a Patent Caution or Patent Interest
% \SANDdistLDRD	% If this report is about LDRD work
% External Address Format: {num copies}{Address}
%\SANDdistExternal{}{}
%\bigskip
%% The following MUST BE between the external and internal distributions!
%\SANDdistClassified % If this report is classified
% Internal Address Format: {num copies}{Mail stop}{Name}{Org}
%\SANDdistInternal{}{}{}{}
% Mail Channel Address Format: {num copies}{Mail Channel}{Name}{Org}
%\SANDdistInternalM{}{}{}{}
%\SANDdistInternal{2}{MS 9018}{Central Technical Files}{8944}
%\SANDdistInternal{2}{MS 0899}{Technical Library}{4536}
\end{SANDdistribution}

\end{document}
