\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}
\newtheorem{theorem}{Theorem}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{
Trilinos CMake Evaluation
}
\author{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2008-xxx}
\SANDprintDate{June 2008}
\SANDauthor{Roscoe A. Bartlett, Daniel M. Dunlavy, Guillen J. Esteban, Tim Shead}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}
\raggedright

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Autotools is terrible. We need something better.  How about CMake?
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgment section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
%\clearpage
%\section*{Acknowledgment}
%The authors would like to thank ...
%
%The format of this report is based on information found
%in~\cite{Sand98-0730}.
%

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
%\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\setcounter{secnumdepth}{3}
\SANDmain % Start the main part of the report


%
\section{Introduction}
%

Blah, blah, blah ...


%
\section{Build Capabilities and Features}
%


%
{}\subsection{Critical build features currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Dependency tracking of header files to rebuild object files

  \begin{enumerate}

  {}\item Autotools: Only supported on Linux and very few other
  platforms.  Not support on the Sun, IBM, and SGI

  {}\item CMake: Built into CMake so it will work on every platform,
  period!

  \end{enumerate}

{}\item Dependency tracking of object files to libraries

  \begin{enumerate}

  {}\item Autotools: Fully supported?

  {}\item CMake: Fully supported?

  \end{enumerate}

{}\item Scalable build system where libraries and header directory
locations only defined once

  \begin{enumerate}

  {}\item Why this is important: This is needed to allow for the
  scalable growth and maintenance of Trilinos.

  {}\item Autotools: The current export makefile system (with
  makefile fragments Makefile.package.export) defines a single file
  where these are things are defined.  Every test and example in
  Trilinos (with a few shameful exceptions) uses the export
  makefiles to get all of these.  There is no duplication.

  {}\item CMake: Chapter 7 in {}\cite{MasteringCMake_fourth}
  describes a system would this should be well supported but it does
  not appear the current Trilinos/CMake system has fully embraced
  this.

  \end{enumerate}

{}\item Circular dependencies allowed between tests/examples in
different packages

  \begin{enumerate}

  {}\item Why this is important: It is not clear where to put some
  examples/tests which require multiple packages and there are
  several cases of tests/examples that refer to libraries that build
  later in the build tree.

  {}\item Autotools: The default target for 'make' just builds
  libraries and the 'tests', 'examples', and 'everything' targets
  make all libraries before any tests or examples are linked.  The
  support for this with autotools is less than straightforward.

  {}\item CMake: There does not seem to be any direct support for
  this but perhaps this could be implemented in a clean way? 
  Options: a) Single pass configure with jumps to up-stream
  libraries, b) two pass, one for dependencies, second for the rest
  (e.g. libraries, tests, examples etc.)

  \end{enumerate}

{}\item Build system must be portable to all required platforms

  \begin{enumerate}

  {}\item Autotools: Autotools generates very portable makefiles.
  However, avoiding ``command-line too long'' errors on many
  platforms requires that one use GNU Make.

  {}\item CMake: One needs to have cmake built on the target
  platform but all that is needed to build and install cmake is a
  fairly recent C++ compilers.  A simple 'configure', 'make', and
  'make install' is all that is needed. 

  \end{enumerate}

{}\item Must support multiple languages including Fortran 77,
Fortran 90, and Fortran 2003

  \begin{enumerate}

  {}\item Why this is important: ForTrilinos requires a very current
  Fortran 90 compiler with some Fortran 2003 features.

  {}\item Autotools: This is currently handled by setting 'F90' to
  point to the Fortran 90+ compiler when calling configure.

  {}\item CMake: It is unclear how CMake support Fortran 90+ but
  Chapter 11 in {}\cite{MasteringCMake_fourth} deals with how to add
  new compilers so it seems this could be supported more cleanly
  than with autotools. $=>$ Perhaps we can copy and extend the
  Fortran 90 macro package?

  \end{enumerate}

{}\item Cross compiling

  \begin{enumerate}

  {}\item Why this is important: Building for the big iron (e.g. Red Storm).

  {}\item Autotools: Yes, because everything is manual.

  {}\item CMake: New feature in CMake but seems untested in our
  environment?

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical build features not currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Library to executable dependency tracking:

  \begin{enumerate}

  {}\item Why this is important: We need this for fast
  rebuild/retest cycles before checkin and faster feedback from
  continuous integration tests.  Currently, it takes up to 50
  minutes to relink all the tests and examples in Trilinos.

  {}\item Autotools: No support at all

  {}\item CMake: This is built into CMake.  In my opinion (rabartl),
  this is one of the major motivations for going to CMake.

  \end{enumerate}

{}\item MS Windows support:

  \begin{enumerate}

  {}\item Why this is important: Windows represents a big growth
  area for Trilinos is and the Tritan project is one example.

  {}\item Autotools: No direct support but cygwin can be used with
  Windows Intel compilers to install headers/libraries.  This is not
  easy to set up and not very portable.

  {}\item CMake: Direct support for MS Windows and a variety of
  other systems.  This includes creating project files for Visual
  Studio.  There is lots of experience with this at Sandia for
  Visual Studio and NMake for native Windows binaries.  This is one
  of the major selling points for CMake over the autotools system.

  \end{enumerate}

\end{enumerate}


%
{}\subsection{Less-critical but desirable build features}
%

\begin{enumerate}

{}\item Shared libraries:

  \begin{enumerate}

  {}\item Why this is important: Some customers demand this.  Also,
  shared libraries can allow for much faster rebuild cycles where
  executables do not even need to be relinked after a dependent
  library is rebuilt.  This can substantially speed up pre-checkin
  testing and shorten the feedback time from a continuous
  integration server.

  {}\item Autotools: Past attempts at using libtool have failed.
  The Python-based system for creating shared libraries on Linux is
  not well characterized.

  {}\item CMake: Shared library support with CMake is advertised to
  be very strong (see Section 4.8 in
  {}\cite{MasteringCMake_fourth}).  Experience with shared libraries
  with CMake in our computing environment includes Linux, Mac OS,
  and Windows (but with some extra work in the CMakeLists.txt
  files).  If shared libraries don't work on a platform, you can
  just switch back to static libraries and that is pretty
  fool-proof.

  \end{enumerate}

{}\item Creation of export makefiles with compilers, compiler
options, include directories, libraries etc. to external clients:

  \begin{enumerate}

  {}\item Why this is important: Building compatible client code
  that will successfully link against Trilinos can be difficult to
  do in a portable when done manually.  This feature is really only used
  by second-tier customers (e.g. graduate students and other off
  projects) as our major customers handle this differently.

  {}\item Autotools: This is done by installing
  Makefile.package.export and Makefile.package.export.macros in the
  \$prefix/install directory.

  {}\item CMake: This can be supported in some way with CMake to
  generate export makefile fragments.

  \end{enumerate}

{}\item Clean and understandable mechanism for extending
functionality

  \begin{enumerate}

  {}\item Why this is important: We will need to create specialized
  features form time to time and we need a supported way to do this
  that is clean and understandable.

  {}\item Autotools: Autotools uses M4 which has to be the most
  confusing and hacked language ever designed in semi-modern times.
  It is clear that M4 was hacked together as some wrapper for shell
  scripting.

  {}\item CMake: CMake has its own scripting language that is fairly
  general and fairly compact.  It appears to be a full featured
  language that would seem to be ``turning complete'' which includes
  the ability to define lists and loops over those lists and create
  arbitrary new functions (call macros).  The CMake scripting
  language does seem to be a little too implicit for my liking.

  \end{enumerate}

{}\item Simple development environment

  \begin{enumerate}

  {}\item Why this is important: Leaning how to develop in a Trilinos
  package needs to be faily easy and setting up a development
  environment needs to be faily easy to work with.

  {}\item Autotools: In order to develop on Trilinos, you need to go
  out and find specific versions of autoconf and automake and put them
  on whatever system where you will need to change the build system
  for any reason (e.g. add/remove files, add new tests, etc.).  This
  is a big hassle when you work on a variety of platforms, espeically
  ones where you do not have root administrator privileges (e.g. the
  SCICO LAN).  Also, whenever you changed any Makefile.am file or
  configure.ac file, you need to remember to run ./bootscrap in any
  package that you change and at the top level.  It is easy to forget
  or hassle to run these scripts.

  {}\item CMake: With CMake there is no intermediate ``bootstrap''
  step.  After the CMake files are modified, they can be directly
  checked in (after being tested of course).  As a developer, this
  means only having to get the CMake source and install it (version
  2.6 is currently required but 2.7 is needed for correct CDash
  reporting).  That is better than having to get two different
  programs with different versions for automake and autoconf.

  \end{enumerate}

{}\item Simple installation for users

  \begin{enumerate}

  {}\item Why this is important: While installing Trilinos for users
  for the general case will never be ``easy'' because of the
  complexity of Trilinos, we don't want to make it too hard.

  {}\item Autotools: With autotools, a ``configure'' shell script is
  provided and in theory, a user just needs to run configure with the
  correct input arguments and then they can do 'make install'.
  Testing a serial version of Trilinos is also easy as 'make
  runtests-serial'.  Running the full serial test suite requires 'make
  rutnests-serial TRILINOS\_TEST\_CATEGORY=FRAMEWORK'.  However,
  running the MPI tests is not so easy and I imagine most users will
  never do this because of having to specify several other tricky make
  variables like TRILINOS\_MPI\_GO.  Also, in order to really install
  and test all of Trilinos on some systems, you have to use
  --with-gnumake or you get ``command-line too long'' errors or errors
  that are much more cryptic.  What this means is that you essentally
  need to have and use GNU Make in order to make Trilinos portable.
  On some systems, user may have to install GNU Make theirselves but
  usually it is already installed and they just need to use it instead
  of the default 'make' command.

  {}\item CMake: Users must have a current enough version (currently
  2.6) of cmake installed on their system to configure and generate
  makefiles and then build and install.  However, for some specialized
  distributions, it will be possible to distribute RPM files, MS
  Visual Studio project files, and the like where users would not need
  CMake but there will be less flexibility in what packages and
  options are enabled and disabled.  Note, however, that cmake appears
  to be as portable and easy to build from source as GNU Make so this
  is not a huge extra requirement over the autotools system.

  \end{enumerate}

\end{enumerate}


%
\section{Testing and Reporting Capabilities and Features}
%


%
{}\subsection{Critical testing features currently handled by the
existing perl test harness}
%

\begin{enumerate}

{}\item Defining different tests with same the executable but
different sets of test arguments:

  \begin{enumerate}

  {}\item Perl test harness: This is well supported and easy to do.

  {}\item CMake/CTest: This is supported by the 'add\_test' command
  but is not supported by the current CMake macro
  TRILINOS\_ADD\_EXECUTABLE(...) but could be supported by maybe
  rename up TRILINOS\_ADD\_EXECUTABLE(...) to be
  TRILINOS\_ADD\_EXECUTABLE\_AND\_TEST(...) split up to call
  TRILINOS\_ADD\_EXECUTABLE(...) and TRILINOS\_ADD\_TEST(...).

  \end{enumerate}

{}\item Selection of subsets of tests using keywords:

  \begin{enumerate}

  {}\item Why this is important: a) routine developer testing during
  the development process requires the ability to run subsets of tests
  easily, b) tests for individual packages need to be selected
  individually, c) different sets of test categories like
  ``Performance'' and ``Scalability'' tests must selected as needed.

  {}\item Perl test harness: Full support for keywords and selecting
  tests for individual packages is built in.

  {}\item CMake/CTest: The TRILINOS\_ADD\_EXECUTABLE(...) macro add
  the package name prefix to all tests (and examples) and you can
  use 'ctest -R (PACKAGE1$|$PACKAGE2$|$...)' to select any subset of
  package tests to run. $=>$ This would require additions to CMake
  and CTest by Kitware.

  \end{enumerate}

{}\item Separate archiving and reporting of test results for each
package:

  \begin{enumerate}

  {}\item Why this is important: It is important to create targeted
  package test result web pages and emails so that individual
  package developers can focus on their own packages and not be
  distracted by errors from other related packages.  This is
  something that SIERRA does *not* have worked out and it is killing
  them.

  {}\item Perl test harness: Handled very cleaning but there are
  still some improvements to be made .. e.g. a) listing of all
  platforms run, b) email notifications

  {}\item CMake/CTest/CDash: This can be done at the CTest scripting
  level to configure the dashboard but it could be a good bit of
  work. $=>$ This will be deferred for a later evaluation but must
  be done to replace the current Trilinos perl-based test harness.

  \end{enumerate}

{}\item Platform-specific tests:

  \begin{enumerate}

  {}\item Perl test harness: Handed with 'HOST' and 'X-HOST' options
  in a very clean way.

  {}\item CMake: No direct support but could be implemented using
  system introspection in a CMake macro?  $=>$ Platform includes and
  excludes would have to be added to a new TRILINOS\_ADD\_TEST(...
  HOSTS host1 host2 XHOST host1 host2 ) macro?

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical testing features not currently handled by the perl
test harness}
%

\begin{enumerate}

{}\item Code coverage

  \begin{enumerate}

  {}\item Why this is important: This is one of the most basic
  metrics of code quality and of the completeness of tests.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of other groups.

  \end{enumerate}

{}\item Memory usage testing (i.e. valgrind and/or purify)

  \begin{enumerate}

  {}\item Why this is important: Memory usage errors in C/C++
  continue to degrade the quality of our code and they tend to sit
  dormant for long periods of time and don't cause major problems
  until we really need our software to work.  This includes memory
  leaks, accessing deleted memory, accessing memory with invalid
  addresses, out-of-bounds errors, etc.

  {}\item Perl test harness: Has been supported in the past but not
  currently working?

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of other groups.

  \end{enumerate}

{}\item Automatic timeout of tests

  \begin{enumerate}

  {}\item Why this is important: Hanging tests can freeze up the
  test harness so that no results are sent at all and it requires a
  lot of manual work to monitor this and to manually kill hanging
  tests.  Every major test harness used by our APP customers have
  support for this (e.g. Alegra, Charon, SIERRA, Xyce).

  {}\item Perl test harness: Not currently supported

  {}\item CMake/CTest: Currently supported with a '--test-timeout'
  option to 'ctest'.  Not clear if this will work with MPI tests
  (unless we can ensure that the MPI implementation will clean up
  processes when it mpirun or mpiexec gets killed).  Time out value
  can also be set as a property on individual tests. $=>$ This is a
  huge robustness issue.

    \begin{itemize}
   
    {}\item TODO: Test timeouts for MPI tests with current
    Trilinos/CMake infrastructure.

    \end{itemize}

  \end{enumerate}

\end{enumerate}

\
%
{}\subsection{Less-critical but desirable testing and reporting features}
%

\begin{enumerate}

{}\item Performance testing

  \begin{enumerate}

  {}\item Why this is important: Performance tests are typically
  serial tests that do relative or absolute runtime comparisons for
  optimized code.  We need a mechanism for defining and selecting to
  run performance tests on various platforms for optimized builds.

  {}\item Perl test harness: No direct support but could be handled
  with a special test category (i.e. keyword) and run for optimized
  builds?

  {}\item CMake/CTest: No direct support but could be handled in
  some way? $=>$ Keywords support will help a lot here.

  \end{enumerate}

{}\item Parallel running of (serial) tests:

  \begin{enumerate}

  {}\item Why this is important: Running tests is parallel can
  significantly speed up pre-checking testing and shorted the
  feedback time from a continuous integration server

  {}\item Perl test harness: No support

  {}\item CMake/CTest: Planned to be added to the next major release
  of CMake/CTest
    
    {\scriptsize\begin{verbatim}
    List:       cmake
    Subject:    Re: [CMake] parallel builds for ctest
    From:       "Alan W. Irwin" <irwin () beluga ! phys ! uvic ! ca>
    Date:       2008-02-16 19:22:39
    Message-ID: Pine.LNX.4.60.0802161105280.4080 () ybpnyubfg ! ybpnyqbznva
    [Download message RAW]
    
    On 2008-02-16 12:38-0500 Bill Hoffman wrote:
    
    > [...]parallel ctest is on the todo list for this year.  Most likely  it 
    > will be ctest -j N.   We can not depend on the make system to do the parallel 
    > stuff, and ctest -j would be useful for all generators.
    
    That's excellent news!  The execution of the PLplot tests actually take
    about the same time to run as (non-parallel) building of PLplot itself. Now
    we are doing our builds in parallel, convenient parallel testing will be
    most welcome as well, and I look forward to trying out that new ctest
    functionality once you are ready.
    
    Alan
    \end{verbatim}}

  \end{enumerate}

{}\item PBS-type batch running of MPI tests:

  \begin{enumerate}

  {}\item Why this is important: Scalability testing requires some
  more substantial parallel clusters and this requires using a batch
  system like PBS.  The test harness needs to support submitting
  batch jobs of mpi runs and wait for the results to come back in an
  efficient way.

  {}\item Perl test harness: No support yet but some experimentation
  has been done?

  {}\item CMake/CTest: Not directly supported but it could be
  implemented in the native CMake scripting language?

  \end{enumerate}

{}\item Archiving all test outputs for sufficient period of time

  \begin{enumerate}

  {}\item Why this is important: Complete test results are needed to
  be able to diagnose failing tests.  Otherwise, you must manually
  go to the platform, build the executable(s) and run the tests
  manually.  Older test result data can be cleaned out as space gets
  tight.

  {}\item Perl test harness: Currently, only stdout is captured and
  saved and then only a limit of so many bytes for each file.

  {}\item CMake/CTest/CDash: CTest/CDash supports grabbing
  ``measurements'' including files and puts them in the database.  You
  can also pose files to the dashboard database using the -A option
  with ctest.

    \begin{itemize}

    {}\item TODO: Look into -A option with ctest for posting multiple
    files to dashboard.  The VTK dashboard already has examples of
    this

    \end{itemize}

  \end{enumerate}

{}\item Allowing the specification of any arbitrary number of
programs and/or criteria to determine test success or failure

  \begin{enumerate}

  {}\item Why this is important: Complex tests require that you be
  able to define ``success'' in a variety of ways.  Examples: a)
  Grepping an output file looking for a specific string, b) Checking
  for a non-zero return value and grepping for a specific string in
  stdout, c) running multiple test executables and then comparing
  files to define an overall test that gets reported (This could also
  be used for scalability testing for PBS-type queuing systems).

  {}\item Perl test harness: The current Trilinos test harness only
  allows you to run one script as the test or a single grep of the
  console output.  There is also the compareOutput that is not
  enough.

  {}\item CMake/CTest: No direct support but you could define a
  CMake macro for CTest to do this?

  \end{enumerate}

{}\item Disabling of packages that fail the build and rebuilding

  \begin{enumerate}

  {}\item Why this is important: In order to maximize the amount of
  (Experimental) code that can be built and tested, it is desirable
  to be able to disable packages that fail to compile and then
  disable optional support in the other packages.

  {}\item Perl test harness: This is supported.

  {}\item CMake/CTest: This is not supported but perhaps could be
  implemented inside of an advanced CTest script (see Section 10.9
  in {}\cite{MasteringCMake_fourth}).

  \end{enumerate}

\end{enumerate}



%
\section{Issues with the current Trilinos/CMake system}
%

\begin{enumerate}

{}\item Build system Issues

  \begin{enumerate}

  {}\item 'Debug' configuration is not supported by current CMake
  system in Trilinos

    \begin{itemize}

    {}\item TODO: We can put in logic to check CMAKE\_BUILD\_TYPE and
    add more define macros (e.g. TEUCHOS\_DEBUG).

    \end{itemize}

  {}\item Circular dependencies between tests/examples and other
  packages is not supported ... Default top-level 'make' must build
  all libraries before building tests and examples ...

  {}\item Build system is not scalable or use the
  ``one-definition-rule'' ... There is lots of redundancy in library
  names, include paths, etc. ...

  {}\item CMake system does not put in logic for required enables
  (e.g. enabling anasazi does not enable epetra or teuchos).

  {}\item There is a lot of logic in the top-level CMakeLists.txt file
  that looks like might be better distributed into the various
  package's CMakeLists.txt files?

  {}\item There is too much clutter and duplication in the
  CMakeLists.txt for for tests and examples to handle MPI and other
  issues ... We need to be able to just list the minimum and have the
  rest taken care of ...

  {}\item Fortran 2003 support?

  \end{enumerate}

{}\item Testing Issues

  \begin{enumerate}

  {}\item Examples are not being tested (they must be tested as well
  as being built)

  {}\item There is no way to run a test with more than one set of test
  arguments (we need to support running test and example executables
  with multiple sets of command-line arguments and we need different
  names for each test case that gets reported).  $=>$ This can be
  handled by the implementation of a TRILINOS\_ADD\_TEST(...) macro.

  {}\item Keywords of some type need to be supported (okay, the name
  of the package is in there but that is not really enough) ... This
  appears to be a fundamental deficiency of CMake/CTest.

  \end{enumerate}

\end{enumerate}


%
\section{Trilinos/CMake ToDo}
%

In this section, we describe the specific tasks/requirements that must
be completed in order to complete this inital Trilinos/CMake
evaluation to facilitate an informed decision about whether Trilinos
will drop autotools for the build and swtich over to CMake after
Trilinos 9.0 is released.  Also, as an another decision, if in
addition the perl-based test harness will be replaced with CTest/CDash
and when.  We can drop autotools for building Trilinos and we can keep
the current perl-based test harness for awhile (or forever) or we can
switch over to CTest/CDash and drop the current perl-based test
harness at the same time or we can maintian both test harness for some
time.  There are many possibilities.

\begin{enumerate}

{}\item Decide on package autonomy

Two options:

  \begin{itemize}

  {}\item Option 1: Require that all packages be built from the top
  Trilinos level $=>$ This will significanlty reduce the amount of
  effort it takes to create and maintain packages.  NOTE: Packages
  that want to build indepenently can add whatever special support for
  bulding separately.  NOTE: You could pass include directories and
  libraries to cmake for individual packages.

  {}\item Option 2: Require that all packages be able to build
  separately not from the top level. $=>$ This forces every package
  have to take on this requirement.

  \end{itemize}

Group's suggested approach: Have each package just read and write
global varaibles for PACKAGE\_INCLUDE\_DIRS and PACKAG\_LIBS set up at
the global level.  Then, packages can be configured and built
independently by passing in the needed cache variables.  TODO: Set up
example to prove that this works with a) Dakota, b) Acro, c) simple
example in Trilinos to test this?

{}\item Deal with issue of different cases for package names and their
directory names.  We might just define a double entry list like:

\begin{verbatim}

# Package name and its package directory name
SET( PACKAGES
  Teuchos teuchos
  Epetra epetra
  ...
  ForTrilinos ForTrilinos
  MOOCHO moocho
  )
LIST(LENGTH PACKAGES PACKAGES_LEN)
MATH(EXPR NUM_PACKAGES "${PACKAGES_LEN}/2")


...

MATH(EXPR PACKAGES_MAX_IDX "${NUM_PACKAGES} - 1")
FOREACH(PACKAGE_IDX RANGE 0 ${PACKAGES_MAX_IDX})
  MATH(EXPR PACKAGE_NAME_IDX "2*${PACKAGE_IDX}")
  MATH(EXPR PACKAGE_DIR_IDX "2*${PACKAGE_IDX}+1")
  LIST(GET PACKAGES ${PACKAGE_NAME_IDX} PACKAGE_NAME)
  LIST(GET PACKAGES ${PACKAGE_DIR_IDX} PACKAGE_DIR)
 ...
ENDFOREACH()

\end{verbatim}

{}\item Deal circular dependancies between tests/examples and
up-stream libraries.  This will require both a two-step configuration
process and a two-step build process.

{}\item Refactor and break about the TRILINOS\_ADD\_EXECUTABLE(...) 
script to separate add\_target(...) and add\_test(...) commands.
Features that these new scripts must support are:

  \begin{enumerate}
  \item Allow test target executable to be defined independently (see example below)
  \item All executables should have the *.exe extension, even on Linux
    as this makes it easy to grep for executables and this is the
    current Trilinos convention. 
  \item Not assume tests are in a subdirectory but allow for this
  \item Run and test ``examples'' as well as ``tests''
  \item Allow for multiple sets of arguments for each test executable
  \item Allow each final test name to be given a unique postfix name
  \item If unique test name is not given, allow for automatic numeric postfix
  \item Build in MPI information (serial and/or MPI, number of processors, etc.)
  \item Specify current working directory where the test should be run from
    (e.g. DESEND\_INTO\_DIRECTORY option)
  \item Include or exlucde specific machines for running a test (both
    as a group of tests or individually)
  \item Support adding keywords for groups of tests or individual tests
    (requires keyword support in ctest which it does not have)
  \item Allow passthrough of all of the set\_test\_properties(...) command
    for WILL\_FAIL, PASS\_REGULAR\_EXPRESSION, and FAIL\_REGULAR\_EXPRESSION.
  \end{enumerate}

Here is what an example of the refactored macros might look like:

\begin{verbatim}

# Just define the exec target ./MemoryManagement/ArrayRCP_test.exe
TRILINOS_ADD_EXECUTABLE(ArrayRCP_test
  DIRECTORY MemoryManagement
  SOURCES ArrayRCP_test.cpp
  )

# Define the tests that will run ./MemoryManagement/ArrayRCP_test.exe
TRILINOS_ADD_TEST(ArrayRCP_test
  DIRECTORY MemoryManagement
  DESEND_INTO_DIR
  XHOST S859352.sandia.gov # Run on all hosts except this one
  KEYWORDS unit framework install
  PASS\_REGULAR\_EXPRESSION "All Tests PASSED"
  COMM SERIAL
  COMM MPI "1"
  ARGS --n=1 POSTFIX "one"
  ARGS --n=2 --verbose POSTFIX "two-verbose"
  ARGS --n=4 POSTFIX "four"
  )

TRILINOS_ADD_TEST(ArrayRCP_test
  DIRECTORY MemoryManagement
  DESEND_INTO_DIR
  KEYWORDS performance
  COMM MPI "1-16"
  ARGS --n=500 POSTFIX "big500" HOST gabriel.sandia.gov
  ARGS --n=1000 POSTFIX "big1000" HOST regression.sandia.gov
  )

\end{verbatim}

It is critically important that the TRILINOS\_ADD\_TEST(...) macro be
very flexible and full featured as it needs to replace the current
perl-based test harness PACKAGE/test/defintion file entries.

{}\item Organize CMake-built tests in the same way as the autotools
system to allow exisitng PACKAGE/test/definition files to be easily
updated to call the CMake-built versions.  This will allow us to drop
the autotools build system but still maintain the current perl-based
test harness until such time that the CTest/CDash version can be
developed as a good replacment.  We can facilitate this by duplicating
entries in the existing PACKAGE/test/defintion files like:

\begin{verbatim}

# List tests for both autotools-built and CMake built versions
(FRAMEWORK,INSTALL) {
    TESTS = MemoryManagement/ArrayRCP_test.exe, # Current autotools
            MemoryManagement/Teuchos-Test-ArrayRCP_test.exe; # New CMake
    ARGS = --teuchos-suppress-startup-banner;
    EXIT-STATUS = STRING-COMPARISON;
    COMM = MPI(1),SERIAL;
}

\end{verbatim}

Above, the perl-based test harness will run whichever executable
exists (which will alway be either ArrayRCP\_test.exe or
Teuchos-Test-ArrayRCP\_test.exe, never both).

The above approach will make adding CMake-built executables easy and
it will be easy to maintain.  Also, the autotools versions can be
removed (mostly be hand) after the autotools build has been removed
and fully replaced by CMake for the build.

{}\item Bring the current Trilinos/CMake support in the existing
packages up to spec with the above requirements and to achieve:

  \begin{enumerate}
  \item Remove all duplication in header file paths, library paths and libraries.
  \item Make the default 'make' target just build libraries and add
    'tests' and 'examples' targets just like the current autotools system
    does
  \item Implement two-state configuration and building to support circular
    dependancies between tests/examples and up-stream libraries.  Test this
    in a superficial way?
  \item Build all test and example executables with similar names in the
    same locations as is being done with existing autotools system
  \item Upgrade the current PACKAGE/test/definition files to call all
    of the same tests as is being called with autotools-built system.
    Verify this in a number of ways?
  \item Add fully ctest testing support for all current tests and examples
    the same as is defined and being performed with the current
    PACKAGES/test/definition files
  \item Get a CDash dashboard up and running controled by Trilinos developers
    and get nightly testing with a cron scirpt going.
  \end{enumerate}

{}\item Expand CMake/CTest support to the packages rtop, thyra,
amesos, ifpack, aztecoo, and straimikos.

This list of packages will bring a number of new issues into play and
will help to test the circular test/example library dependancies
issue.

\end{enumerate}

Once all of the above tasks are finished, this initial evaluation of
CMake/CTest/CDash etc. for Trilinos will be complete.

Shortly after the completion of the evaluation and the corresponding
summary and conclusions are stated below, the Trilinos leaders will
decide on a course of action regarding replacing the current autotools
and perl-based test harness with CMake/CTest/CDash/CPack and on a time
table for doing so.

%
\section{Desired and required enhancements to CMake/CTest/CDash}
%

Here we list some identified areas of missing support in
CMake/CTest/CDash that we either strongly need or would be of great
benefit for Trilinos.

\begin{enumerate}

{}\item\textit{Strongly desired / Required}: CMake/CTest: Support for
keywords for tests.  This could be added with a {}\texttt{KEYWORDS}
field for the {}\texttt{add\_test(...)} command
(e.g. {}\texttt{add\_test( ... KEYWORDS keyword1 keyword2 ... )}) or
could be supported with a {}\texttt{KEYWORDS} property for an existing
test (this would not break any existing add\_test(...) uses where
KEYWORDS might be a command-line argument).

{}\item\textit{Desired:} CMake: Strong checking for variables that are
not defined.  Just letting undefined variables be empty is a bad
practice (used by Make and bad Fortran).

{}\item\textit{Desired:} CTest/CDash: Submit all test data (no matter
the size) and then pruning test results over time.  This is being done
for SIERRA + Trilinos Integration test repository.

\end{enumerate}


%
\section{Summary and Recommendations}
%

Blah, blah, blah ...


% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}


\begin{SANDdistribution}[NM]
% \SANDdistCRADA	% If this report is about CRADA work
% \SANDdistPatent	% If this report has a Patent Caution or Patent Interest
% \SANDdistLDRD	% If this report is about LDRD work
% External Address Format: {num copies}{Address}
%\SANDdistExternal{}{}
%\bigskip
%% The following MUST BE between the external and internal distributions!
%\SANDdistClassified % If this report is classified
% Internal Address Format: {num copies}{Mail stop}{Name}{Org}
%\SANDdistInternal{}{}{}{}
% Mail Channel Address Format: {num copies}{Mail Channel}{Name}{Org}
%\SANDdistInternalM{}{}{}{}
%\SANDdistInternal{2}{MS 9018}{Central Technical Files}{8944}
%\SANDdistInternal{2}{MS 0899}{Technical Library}{4536}
\end{SANDdistribution}

\end{document}
