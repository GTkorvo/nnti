
\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
%\usepackage[all]{draftcopy}
\input{rab_commands}
\newtheorem{theorem}{Theorem}
\usepackage{hyperref}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{
Trilinos CMake Evaluation
}
\author{Roscoe A. Bartlett, Daniel M. Dunlavy,  Esteban J. Guillen, Tim Shead}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2008-7593}
\SANDprintDate{November 2008}
\SANDauthor{Roscoe A. Bartlett, Daniel M. Dunlavy, Esteban J. Guillen, Tim Shead}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}
\raggedright

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Autotools is terrible. We need something better.  How about CMake?
Here we document our evaluation of CMake as a build system and testing
infrastructure to replace the current autotools-based system for
Trilinos.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgment section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
\clearpage
\section*{Acknowledgment}

The authors would like to thank Kitware and the open-source community
for creating such a great set of tools.

%The format of this report is based on information found
%in~\cite{Sand98-0730}.
%

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\setcounter{secnumdepth}{3}
\SANDmain % Start the main part of the report


%
\section{Introduction}
%

Here, we summarize a detailed evaluation of the CMake set of build and
testing tools as a possible replacement for the current
autotools-based and home-grown Perl-based test harness.  This
evaluation includes the development of a comprehensive prototype build
system infrastructure for Trilinos using CMake that is likely very
representative of what a final system would look like.

The CMake set of configuration, build, test, and reporting tools are
developed and maintained by Kitware,
Inc.\footnote{www.kitware.com} The four (4) tools available in the
current CMake system are as follows:

\begin{itemize}
 {}\item {\em CMake}: portable build manager that includes a complete
 scripting language for configuring and building software libraries and
 executables.

 {}\item {\em CTest}: executable to handle running tests along with a
 scripting language to control test flows.

 {}\item {\em CPack}: cross-platform software packaging tool, with
 installer support for all systems currently supported by CMake.

 {}\item {\em CDash}: build and test reporting dashboard built on PHP,
 CSS, XSL, MySQL, and Apache HTTPD.

\end{itemize} 

Note that although these tools have been developed to work in tandem
as a complete build and test environment, the components can be used
independently as well. For example, CMake can be used to configure and
build a library, and testing can be handled using another set of
tools. Furthermore, CTest and CDash can be used to handle testing and
reporting of a software library without using CMake as the build
manager. This said, it is recommended to use the full
CMake/CTest/CPack/CDash system as there is more work involved to use
only parts of the system.

%
\section{Build Capabilities and Features}
%

Here we describe a set of features relating to building and how they
are (or are not) supported with the current autotools build system and
the new CMake prototype system.  These features are subdivided into
critical and non-critical categories.


%
{}\subsection{Critical build features currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Dependency tracking of header files to rebuild object files:

  \begin{enumerate}

  {}\item Why this is important: To enable fast, safe, and correct rebuilds.

  {}\item Autotools: Only supported on Linux and very few other
  platforms.  Not supported on the Sun, IBM, and SGI.

  {}\item CMake: Built into CMake for C and C++ so it will work on
  every platform, period!

  \end{enumerate}

{}\item Dependency tracking of object files to libraries:

  \begin{enumerate}

  {}\item Why this is important: To enable fast, safe, and correct rebuilds.

  {}\item Autotools: Fully supported on all platforms.

  {}\item CMake: Fully supported on all platforms.

  \end{enumerate}

{}\item Scalable build system where Trilinos package libraries and
header file directory locations are only defined once:

  \begin{enumerate}

  {}\item Why this is important: This is needed to allow for the
  scalable growth and maintenance of Trilinos.

  {}\item Autotools: The current export makefile system (with makefile
  fragments Makefile.package.export) defines a single file where these
  things are defined.  Every test and example in Trilinos (with a few
  shameful exceptions) uses the export makefiles to get all of these.
  There is no duplication.

  {}\item CMake: The prototype CMake-based build system for Trilinos
  handles all intra-package dependencies automatically with only simple
  intra-package dependency lists in Dependencies.cmake files.  There
  is no duplication at all and this system is much cleaner than the
  current autotools system.

  \end{enumerate}

{}\item Build system must be portable to all required platforms:

  \begin{enumerate}

  {}\item Why this is important: Trilinos must support a wide set of
  different platforms.

  {}\item Autotools: Autotools generates very portable makefiles.
  However, avoiding ``command-line too long'' errors on many
  platforms requires that one use GNU Make.

  {}\item CMake: One needs to have cmake built on the target
  platform but all that is needed to build and install cmake is a
  fairly recent C++ compiler.  A simple 'configure', 'make', and
  'make install' is all that is needed. 

  \end{enumerate}

{}\item Cross compiling:

  \begin{enumerate}

  {}\item Why this is important: Cross compiling is required to build
  for production parallel machines (e.g. Red Storm).

  {}\item Autotools: Yes, because everything is manual.

  {}\item CMake: Cross compiling is a new feature in CMake and it is
  unclear how well tested this is in the Sandia environment.  However,
  organization 1420 has had some success with using this feature with
  Paraview to build for reddish/redstorm.

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical build features not currently handled by the
existing autotools system}
%

\begin{enumerate}

{}\item Library to executable dependency tracking:

  \begin{enumerate}

  {}\item Why this is important: We need this for fast rebuild/retest
  cycles before repository commits and faster feedback from continuous
  integration builds.  Currently, it takes up to 50 minutes or longer
  on a very fast Linux machine to relink a large number of the tests
  and examples in Trilinos.

  {}\item Autotools: No support at all.

  {}\item CMake: This is built into CMake.  This is one of the major
  motivations for going to CMake.

  \end{enumerate}

{}\item MS Windows support:

  \begin{enumerate}

  {}\item Why this is important: Windows represents a big growth area
  for Trilinos; the Titan project is one example.

  {}\item Autotools: No direct support but cygwin can be used with
  Windows Intel compilers to install headers/libraries.  This is not
  easy to set up and not very portable.

  {}\item CMake: Direct support for MS Windows and a variety of other
  systems.  This includes creating project files for MS Visual Studio
  and binary installers using NSIS\footnote{A scriptable win32
  installer/uninstaller system available at
  \url{http://nsis.sourceforge.net/}}.  There is lots of experience
  with this at Sandia for Visual Studio and NMake for native Windows
  binaries.  This is one of the major selling points for CMake over
  the autotools system.

  \end{enumerate}

{}\item Support for multiple languages including Fortran 77, Fortran
90, and Fortran 2003:

  \begin{enumerate}

  {}\item Why this is important: ForTrilinos requires a very current
  Fortran 90 compiler with some Fortran 2003 features.  Included in
  this is name mangling for Fortran 77.

  {}\item Autotools: This is currently handled by setting 'F90' to
  point to the Fortran 90+ compiler when calling configure.  However,
  Fortran 2003 with gfortran creates auxiliary files that need to be
  symbolically linked in a manual way and it is not portable.
  Basically, autotools really does *not* support Fortran 2003.  What
  we have right now is a hack that works with gfortran.  Name mangling
  with Fortran 77 is well supported and largely automatic on most
  platforms.

  {}\item CMake: It is unclear how well CMake supports Fortran 90+ but
  Chapter 11 in {}\cite{MasteringCMake_fourth} deals with how to add
  new compilers so it seems this could be supported more cleanly than
  with autotools. One idea is to copy and extend the Fortran 90 macro
  package for Fortran 2003.  This may be hard to make portable but
  hopefully we would get some help from the CMake community or Kitware.
  Right now Fortran 77 name mangling is determined by platform but it
  will be easy to write a Module/Macro that will figure this out
  automatically with the \texttt{try\_compile(...)} command.

  \end{enumerate}

\end{enumerate}


%
{}\subsection{Less-critical but desirable build features}
%

\begin{enumerate}

{}\item Shared libraries:

  \begin{enumerate}

  {}\item Why this is important: Some customers demand this.  Also,
  shared libraries can allow for much faster rebuild cycles where
  executables do not even need to be relinked after a dependent
  library is rebuilt.  This can substantially speed up pre-checkin
  testing and shorten the feedback time from a continuous integration
  server.

  {}\item Autotools: Past attempts at using libtool have failed.  The
  Python-based system for creating shared libraries on Linux is not
  well characterized.

  {}\item CMake: Shared library support with CMake is advertised to be
  very strong (see Section 4.8 in {}\cite{MasteringCMake_fourth}).
  Experience that organization 1420 has had with shared libraries with
  CMake in our computing environment at Sandia includes Linux, Mac OS,
  and Windows (but Windows requires some extra work in the
  CMakeLists.txt files).  If shared libraries don't work on a
  particular platform, you can just switch back to static libraries.
  
  {}\textit{Caveat:} Currently, at least for the makefile generator,
  changes in {}\texttt{*.cpp} files that result in the recreation of a
  shared library also result in unnecessary relinking of all dependent
  test and example executables.  This is unfortunate but
  understandable given that makefiles are being used and this type of
  special shared library logic is not supported by 'make'.
  {}\textit{Work around}: We can add a 'libs' target that will result
  in only libraries being rebuilt and then a developer can just use
  'make libs' followed by 'ctest' and avoid relinking.  However, if
  other code related to a test/example also needs to be rebuilt, then
  that will result in inconsistent executables and therefore inaccurate
  test results. But, it may be possible to devise a general system of
  manipulating time stamps when shared libraries are used so that we
  can avoid relinking executables unnecessarily.

  \end{enumerate}

{}\item Creation of export makefiles with compilers, compiler options,
include directories, libraries etc. for use by external client
makefiles:

  \begin{enumerate}

  {}\item Why this is important: Building compatible client code
  that will successfully link against Trilinos can be difficult to
  do in a portable when done manually.  This feature is really only used
  by second-tier customers (e.g. graduate students and other off
  projects) as our major customers handle this differently.

  {}\item Autotools: This is done by installing
  Makefile.package.export and Makefile.package.export.macros in the
  \$prefix/install directory.

  {}\item CMake: This will be easy to support, and a prototype system
  is already in place for the LSALIB library currently used in the
  Titan project.

  \end{enumerate}

{}\item Clean and understandable mechanism for extending
functionality:

  \begin{enumerate}

  {}\item Why this is important: We will need to create specialized
  features form time to time, and we need a supported way to do this
  that is clean and understandable.

  {}\item Autotools: Autotools uses the so-called M4 language which
  has to be the most confusing and hacked language ever designed in
  semi-modern times.  It is clear that M4 was hacked together in a
  pinch as some wrapper around shell scripting.

  {}\item CMake: CMake has its own scripting language that is fairly
  general and fairly compact for basic usage.  It is a ``Turing
  complete'' (i.e.\ you can write complete programs with it) which
  includes the ability to define lists and loops over those lists and
  create arbitrary new functions (call macros).  Unlike makefiles,
  commands in CMake script files are executed from beginning to end
  with clear programming language semantics.  While there is no CMake
  ``debugger'', you can effectively debug CMake scripts by putting in
  \texttt{MESSAGE(...)} calls which are the equivalent to print statements.

  {}\textit{Disclaimers}: The CMake scripting language is a little
  strange.  For one, the variable scoping rules involving cache,
  internal cache, and non-cache variables are a little confusing and
  make it difficult to implement complex logic.  I would not try to
  write a complex stand-alone program or complex logic in CMake (but
  you could as all of the tools for doing so are there).  However,
  CMake is still many times better than autotools for which we are
  comparing.

  \end{enumerate}

{}\item Simple development environment:

  \begin{enumerate}

  {}\item Why this is important: Leaning how to develop in a Trilinos
  package needs to be fairly easy and setting up a development
  environment needs to be easy as well.

  {}\item Autotools: In order to develop on Trilinos, you need to go
  out and find specific versions of autoconf and automake and put them
  on whatever system where you will need to change the build system
  for any reason (e.g. add/remove files, add new tests, etc.).  This
  is a big hassle when you work on a variety of platforms, especially
  ones where you do not have root administrator privileges (e.g. the
  SCICO LAN).  Also, whenever you changed any Makefile.am file or
  configure.ac file, you need to remember to run ./bootstrap in any
  package that you change and at the top level.  It is easy to forget
  and a hassle to run these scripts.  And if you don't remember to
  bootstrap, the build system will not update anything.  This is a
  real problem, especially for new developers.

  {}\item CMake: With CMake there is no intermediate ``bootstrap''
  step.  After the CMake files are modified, you can just type 'make'
  and the system will reconfigure itself if it needs to do so. Also, there
  are no intermediate files that need to be added to the VS
  repository.  As a developer, this means only having to get the CMake
  source and install it (version 2.6 is currently required but 2.7 is
  needed for correct CDash reporting).  That is better than having to
  get two different programs with different versions for automake and
  autoconf. 

  \end{enumerate}

{}\item Simple installation for users:

  \begin{enumerate}

  {}\item Why this is important: While installing Trilinos for users
  for the general case will never be ``easy'' because of the
  complexity of Trilinos, we don't want to make it harder than it
  needs to be.

  {}\item Autotools: With autotools, a ``configure'' shell script is
  provided and in theory, a user just needs to run configure with the
  correct input arguments and then they can do 'make install'.
  Testing a serial version of Trilinos is also as easy as 'make
  runtests-serial'.  Running the full serial test suite requires 'make
  runtests-serial TRILINOS\_TEST\_CATEGORY=FRAMEWORK'.  However,
  running the MPI tests is not so easy, and we imagine most users will
  never do this because of having to specify several other tricky
  input 'make' variables like TRILINOS\_MPI\_GO (which requires double
  quotes).  Also, in order to really install and test all of Trilinos
  on some systems, you have to use --with-gnumake or you get
  ``command-line too long'' errors or errors that are much more
  cryptic.  What this means is that you essentially need to have and
  use GNU Make in order to make Trilinos portable.  On some systems,
  user may have to install GNU Make themselves but usually it is
  already installed and they just need to use it instead of the
  default 'make' command.

  {}\item CMake: Users must have a current enough version (currently
  2.6) of CMake installed on their system to configure and generate
  makefiles and then build and install.  However, for some specialized
  distributions, it will be possible to distribute Trilinos as RPM
  files, MS Visual Studio project files, and the like where users
  would not need CMake.  However, this will result in less flexibility
  in what packages and options are enabled and disabled.  Note,
  however, that CMake appears to be as portable and easy to build from
  source as GNU Make so this is not a huge extra requirement over the
  autotools system.  Also note that on MS Windows, there are binary
  self-extracting installers for a very nice CMake GUI program that
  users can just download, double-click to install, and then run.  On
  MS Windows, if you have the free MS Visual C++ express edition, then
  configuring project files by downloading and installing the Windows
  version of CMake is really not any harder than downloading a
  pre-created project file.

  \end{enumerate}

{}\item Circular dependencies allowed between tests/examples in
different packages:

  \begin{enumerate}

  {}\item Why this is important: It is not clear where to put some
  examples/tests which require multiple packages and there are
  several cases of tests/examples that refer to libraries that build
  later in the build tree.

  {}\item Autotools: The default target for 'make' just builds
  libraries and the 'tests', 'examples', and 'everything' targets
  build all libraries before any tests or examples are linked.  The
  support for this with the current autotools-based system is less than
  straightforward.  Also, support for these types of circular
  dependencies has proved to make the current autotools-based system
  quite fragile is not scaling well.

  {}\item CMake: The current CMake build system prototype does not
  support circular dependencies between tests/examples and later package
  libraries.  However, it is not clear that this feature is worth
  preserving.  Instead, we can put such troublesome tests/examples
  into packages like TrilinosCouplings (and NonlinearStrategies) or
  others that already have all of the needed package dependencies.
  Also, packages have used this feature as a crutch to avoid having to
  build appropriate mock objects in order to do proper unit testing.

  \end{enumerate}

\end{enumerate}


%
\section{Testing and Reporting Capabilities and Features}
%

In this section we list some features that are needed for a testing
system for Trilinos and compare current support for them in the
autotools-based and CMake-based Trilinos systems.  These features are
separated into critical and less critical sets.


%
{}\subsection{Critical testing features currently handled by the
existing Perl-based test harness}
%

\begin{enumerate}

{}\item Separate archiving and reporting of test results for each
package:

  \begin{enumerate}

  {}\item Why this is important: It is important to create targeted
  package test result web pages and emails so that individual package
  developers can focus on their own packages and not be distracted by
  errors from other related packages.  This is something that SIERRA
  does *not* have worked out yet and it is causing the problems.

  {}\item Perl test harness: Handled very cleanly but there are still
  some improvements to be made.  Examples of needed improvements: a)
  listing of all platforms run, b) email notifications of specific
  platform builds.

  {}\item CMake/CTest/CDash: This can be done at the CTest scripting
  level and with some PHP database programing.  This might take a
  significant amount of work to accomplish.

  \end{enumerate}

{}\item Platform-specific tests:

  \begin{enumerate}

  {}\item Why this is important: One must be able to target and
  specialize tests for different platforms in order to deal with
  portability problems and other issues.

  {}\item Perl test harness: Handed with 'HOST' and 'X-HOST' options
  in a very clean way with 'uname -n' but it is not very portable (for
  example, does not work on the MAC).

  {}\item CMake: This is trivially handled with a HOST and XHOST
  argument with the TRILINOS\_ADD\_TEST(...) function.  Actually, this
  is more portable since it relies on the built-in SITE\_NAME(...) 
  command in CMake and not the non-portable 'uname -n' command.

  \end{enumerate}

{}\item Disabling of packages that fail the build and then rebuilding

  \begin{enumerate}

  {}\item Why this is important: In order to maximize the amount of
  (Experimental) code that can be built and tested, it is desirable
  to be able to disable packages that fail to compile and then
  disable optional support in the other packages.

  {}\item Perl test harness: This is supported but it requires a lot
  of manual work to maintain the package dependencies and the
  completion banners in every package.  This system is also fairly
  fragile and breaks a lot giving false results and resulting in code
  not being tested for days.

  {}\item CMake/CTest: There is no built-in CMake support for this but
  intra-package dependence tracking has been implemented in the
  prototype CMake build system for Trilinos.  An advanced CTest script
  (see Section 10.9 in {}\cite{MasteringCMake_fourth}) could be
  written to drive the entire process and the dashboard display could
  be modified to support this.  Because all intra-package dependency
  management would be handled automatically, this system would be much
  more robust than the current autotools Perl-based test harness.

  \end{enumerate}

{}\item Selection of subsets of tests using keywords:

  \begin{enumerate}

  {}\item Why this is important: 1) routine developer testing during
  the development process requires the ability to run subsets of tests
  easily, 2) tests for individual packages need to be selected
  individually, 3) different sets of test categories like
  ``Performance'' and ``Scalability'' tests must selected as needed.

  {}\item Perl test harness: There is only superficial support where
  only one ``keyword'' can be selected for inclusion.  However
  multiple sets of keywords can not be selected and keywords can not
  be excluded.

  {}\item CMake/CTest: While CTest does not directly support keywords,
  they are emulated with the TRILINOS\_ADD\_TEST(...) function by
  simply appending the keywords to the name of the test.  Then,
  'ctest' supports the options -R, -E, and -U for including and
  excluding tests in a fairly flexible way.

  \end{enumerate}

\end{enumerate}

%
{}\subsection{Critical testing features not currently handled by the
Perl-based test harness}
%

\begin{enumerate}

{}\item Code coverage:

  \begin{enumerate}

  {}\item Why this is important: This is one of the most basic
  metrics of code quality and of the completeness of tests.

  {}\item Perl test harness: Has been supported in the past but not
  currently.

  {}\item CMake/CTest: Built-in support and run on many platforms by
  lots of groups.

  \end{enumerate}

{}\item Memory usage testing (i.e. Valgrind and/or purify):

  \begin{enumerate}

  {}\item Why this is important: Memory usage errors in C/C++
  continue to degrade the quality of our code and they tend to sit
  dormant for long periods of time and don't cause major problems
  until we really need our software to work.  This includes memory
  leaks, accessing deleted memory, accessing memory wit.h invalid
  addresses, out-of-bounds errors, etc.

  {}\item Perl test harness: Has been supported in the past but not
  currently

  {}\item CMake/CTest/CDash: Built-in support and is run on many
  platforms by lots of other groups.  This can be run in local build
  with:

    \begin{verbatim}
      ctest -T memcheck
    \end{verbatim}

  It can also run memory checking as part of the nightly testing
  process with:

    \begin{verbatim}
      ctest -D NightlyMemoryCheck
    \end{verbatim}

  Individual memory problems are cleanly reported on the CDash
  dashboard.

  \end{enumerate}

{}\item Automatic timeout of tests:

  \begin{enumerate}

  {}\item Why this is important: Hanging tests can freeze up the test
  harness so that no results are reported at all and it requires a lot
  of manual work to monitor this and to manually kill hanging tests.
  Every major test harness used by the Trilinos application customers
  have support for this feature (e.g. Alegra, Charon, SIERRA, Xyce).

  {}\item Perl test harness: Not currently supported.

  {}\item CMake/CTest: Currently supported with the CMake cache
  variable {}\texttt{DART\_TESTING\_TIMEOUT:STRING=<seconds>}.  A
  timeout can also be set on a test-by-test basis with the
  {}\texttt{TIMEOUT} test property set by the built-in
  {}\texttt{set\_tests\_properties(...)} CMake command.  This feature
  has been tested and verified to work well even with parallel tests
  (with Open MPI).  This will result in a huge improvement in the
  robustness of the testing infrastructure for Trilinos.

  \end{enumerate}

\end{enumerate}

\
%
{}\subsection{Less-critical but desirable testing and reporting features}
%

\begin{enumerate}

{}\item Performance testing:

  \begin{enumerate}

  {}\item Why this is important: Performance tests are typically
  serial tests that do relative or absolute run-time comparisons for
  optimized code.  We need a mechanism for defining and selecting to
  run performance tests on various platforms for optimized builds.

  {}\item Perl test harness: No direct support but could be handled
  with a special test category (i.e. keyword) and run for optimized
  builds?

  {}\item CMake/CTest: Can be very easily supported with a CATEGORIES
  option with the TRILINOS\_ADD\_TEST(...) function.

  \end{enumerate}

{}\item Parallel running of (serial) tests:

  \begin{enumerate}

  {}\item Why this is important: Running tests is parallel can
  significantly speed up pre-checking testing and shorten the feedback
  time from a continuous integration server.

  {}\item Perl test harness: No support.

  {}\item CMake/CTest: This is being developed in the current CMake
  CVS development version (but does not seem to work yet).

  \end{enumerate}

{}\item PBS-type batch running of MPI tests:

  \begin{enumerate}

  {}\item Why this is important: Scalability testing requires some
  more substantial parallel clusters and this requires using a batch
  system like PBS.  The test harness needs to support submitting
  batch jobs of MPI runs and wait for the results to come back in an
  efficient way.

  {}\item Perl test harness: No support yet but some experimentation
  has been done.

  {}\item CMake/CTest: Not directly supported but given the
  flexibility of the CMake scripting language, if it is possible to
  support, then this can be supported in the TRILINOS\_ADD\_TEST(...) 
  function in a way that is largely transparent to the Trilinos
  developer.  For example, the TRILINOS\_ADD\_TEST(...) function could
  add an initial PBS submit script with a call to ADD\_TEST(...) and
  then a back-end could store a list of followup commands that would
  all get added after all initial tests are defined with additional
  with ADD\_TEST(...) calls at the end to poll for completion of the
  various PBS jobs.  With CMake, all of this can be handled
  automatically in a consistent way.

  \end{enumerate}

{}\item Archiving all test outputs for sufficient periods of time:

  \begin{enumerate}

  {}\item Why this is important: Complete test results are needed to
  be able to diagnose failing tests.  Otherwise, you must manually go
  to the platform, build the executable(s) and run the tests manually.
  Older test result data can be cleaned out as needed to make space.

  {}\item Perl test harness: Currently, only stdout is captured and
  saved and then only a limit of so many bytes for each file.

  {}\item CMake/CTest/CDash: CTest/CDash supports grabbing
  ``measurements'' including files and putting them in the CDash
  database.  You can also post files to the dashboard database using
  the -A option with ctest.

    \begin{itemize}

    {}\item TODO: Look into ctest -A option for posting multiple files
    to dashboard.  The VTK dashboard already has examples of this

    \end{itemize}

  We could also augment the system to store larger files in a separate
  directory structure outside of the database and then just put in
  HTML links from the posted CDash files.  The new SIERRA Dart
  Dashboard system uses a system like this.  We would then implement a
  separate job to clean out older results based on various criteria.
  This has been done, for example, for the SIERRA + Trilinos
  Integration testing scripts (i.e.\ the STANA scripts).

  \end{enumerate}

{}\item Allowing the specification of any arbitrary number of programs
and/or criteria to determine the success or failure of a test:

  \begin{enumerate}

  {}\item Why this is important: Complex tests require that you be
  able to define ``success'' in a variety of different ways.
  Examples: a) Grepping an output file looking for a specific string,
  b) checking for a non-zero return value and grepping for a specific
  string in stdout, c) running multiple test executables and then
  comparing files to define an overall test that gets reported (This
  could also be used for scalability testing for PBS-type queuing
  systems).

  {}\item Perl test harness: The current Trilinos test harness only
  allows you to run one script as the test or a single grep of the
  console output.  There is also support for running the compareOutput
  program but that is not enough.

  {}\item CMake/CTest: No direct support but you could do this behind
  the scenes of the TRILINOS\_ADD\_TEST(...) function in a way that
  was 100\% transparent.  For example, the TRILINOS\_ADD\_TEST(...) 
  function or a new similar function could handle multiple COMMAND and
  ARGS fields and on the back end could write a portable python script
  that would then be directly set by the built-in ADD\_TEST(...) CMake
  command.

  \end{enumerate}

\end{enumerate}

%
\section{Desired enhancements to CMake/CTest/CDash}
%

Here we list some identified areas of missing support in
CMake/CTest/CDash that we either strongly need or would be of great
benefit for Trilinos.  These are features that could not easily be
built over top of existing support or would greatly benefit from
direct CMake support.

\begin{enumerate}

{}\item\textit{Strongly desired}: CMake/CTest: Support for keywords
for tests.  This could be added with a {}\texttt{KEYWORDS} property
for the {}\texttt{set\_tests\_properties(...)} command.
{}\textit{Work around}: Simply append all of the keywords to the name
of the test.

{}\item\textit{Desired}: Direct support for running (multiple)
programs to post-process the output from a test (both the console and
any output files).  {}\textit{Workaround}: This can be emulated
within the TRILINOS\_ADD\_TEST(...) function by writing script files
that combine everything but it will be hard to make this portable and
might make it confusing to trace what is happening.

{}\item CTest: Default outputting issues:

  \begin{itemize}

  {}\item\textit{Desired}: Show what the test criteria is and why a
  test passed or failed in the test output in the output file
  Testing/Temporary/LastTest.log.  Currently, it does not show if the
  test passed or failed, just the command used to invoke the test and
  the test output.  {}\textit{Workaround}: Run 'ctest -VV' and skip
  the shorter summary output.  However, the absences of the summary
  output is greatly missed.
  
  {}\item\textit{Desired}: Print the CPU time for each test (not just
  the start and end times in the log file).  The test run time helps
  to determine what tests are taking too long and need to be revised.
  This feature will be easy to add to the CTest C++ source code and we
  can do this ourselves.

  {}\item\textit{Desired}: Automatically widen the main summary output
  to show the full test names.  Currently, only the first 30
  characters of the name are shown.  The option -W was added to the
  CVS version of CTest to allow the width to be manually set but this
  is a hassle and does not interact well with MS Visual C++ projects.
  This will be fairly easy to add to the CTest C++ source code.

  \end{itemize}

{}\item\textit{Desired:} CTest/CDash: Submit all test data (no matter
the size) and then prune test results over time.  This includes
files that get output as well.  This is being done for the SIERRA +
Trilinos Integration test repository for instance.
{}\textit{Workaround}: We can emulate this with our own handling
scripting code but this will not be available to other CMake projects.

{}\item\textit{Desired}: CMake: Generate error messages for missing
source files that have line numbers in the corresponding
CMakeLists.txt file.  Currently, it just lists the entire
CMakeLists.txt file and nothing else.  {}\textit{Workaround}: Just add
files slowly and re-run CMake each time to debug the problem.

{}\item\textit{Desired:} CMake: Strong checking for variables that are
not defined.  Just letting undefined variables be empty is a bad
practice (used by Make and bad Fortran).  This practice is well known
to result in higher rates of software defects.  {}\textit{Workaround}:
Use a user-defined {}\texttt{ASSERT\_DEFINED(...)} macro (which is
being done right now and is somewhat effective).

{}\item\textit{Desired:} CMake: Strong checking for user input
misspelling CMake cache variables: Currently, if a user misspells the
name of a defined user cache variable, the default for that variable
will be used instead and the misspelled user variable will be ignored.
This is very bad behavior that is carried over from the autotools
world and should not be repeated with the CMake system.  It would be
very useful if the cmake executable could take a new option (e.g.\
--validate-cache-variables) that would force the validation of all
user-set cache variables to make sure that they had a matching
internally defined cache variable.  {}\textit{Workaround}: We could
create a new VALIDATED\_OPTION(...) command that would store a list of
all defined options and then we could devise a system that would
validate that all cache variables set were expected.  However, this
would only work for Trilinos-defined variables and not other cache
variables defined by built-in CMake commands like SITE\_NAME(...) and
FIND\_FILE(...).  User input checking is a serious software
verification issue that needs to be addressed.

\end{enumerate}


%
\section{Summary and Recommendations}
%

Here, we summarize the major gains and (at least initial) losses that
we would experience by switching from the current autotools-based
build system for Trilinos to the prototype CMake-based build system for
Trilinos.  Then, separately, we summarize the gains and losses that
would be experienced in switching from the current Perl-based test
harness for Trilinos to the prototype CMake/CTest/CDash-based test
harness for Trilinos.  We list these separately because we can decide
to replace the current autotools build system with the CMake system
and still maintain the current Perl-based test harness.


%
{}\subsection{Gains and losses for switching from autotools to CMake
for the build system}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Full dependency tracking of every kind possible on all
  platforms (i.e.\ header to object, object to library, library to
  executable, and build system files to all built files).

  {}\item Support for shared libraries on a variety of platforms.

  {}\item Support for MS Windows (i.e.\ Visual Studio projects,
  Windows installers, etc.).

  {}\item Simplified build system and easier maintenance (extremely
  easy to add new packages and maintain existing packages).

  {}\item Improved mechanism for extending capabilities (as compared
  to M4 in autotools).

  {}\item Ability to affect the development of the build tools with
  good existing collaborations (i.e.\ with both Kitware and with
  organization 1420).

  {}\item Significant ``in house'' knowledge-base (i.e.\ visualization
  group in 1420).

  {}\item One hundred percent automated intra-package dependency
  tracking and handling (built into the prototype Trilinos/CMake build
  system).

  \end{enumerate}

{}\item What we lose (at least initially):

  \begin{enumerate}

  {}\item CMake requires that all uses have 'cmake' installed on their
  machine when building from source and users will need to have at a
  very recent version of cmake. (However, cmake is very easy to build
  from source).

  {}\item Support for circular test/example and package libraries is
  not provided in the current prototype Trilinos/CMake build system.

  \end{enumerate}

\end{enumerate}


%
{}\subsection{Gains and losses for switching the test harness to the
current system to CTest/CDash}
%

\begin{enumerate}

{}\item What we gain:

  \begin{enumerate}

  {}\item Test time-outs (this is a major maintenance issue for the
  current Perl-based test harness).

  {}\item Memory testing with Valgrind and purify that is backed up by
  Kitware and a larger development community.

  {}\item Line coverage testing that is backed up by Kitware and a
  large development community.

  {}\item Support for selecting and excluding subsets of tests based
  on regular expressions (but better support for keywords would be
  welcomed).

  {}\item Better integration with the build system (e.g.\ easier to
  support more advanced features like PBS batch systems and flexible
  testing control).

  {}\item Better tracking of specific tests (i.e.\ each and every test
  can have a unique name that is easy to find).

  \end{enumerate}

{}\item What we lose (at least initially):

  \begin{enumerate}

  {}\item Separate reporting of test results for different Trilinos
  packages on the web page and in emails sent out (however, such
  support could be layered on top of CTest and CDash).

  {}\item Support for selectively disabling package tests/examples and
  entire packages when a build fails (however, such support could be
  layered on top of CTest for driving the test harness).

  \end{enumerate}

\end{enumerate}


%
\subsection{Final recommendations}
%

The potential gains for switching from the current autotools-based build
system for Trilinos to the prototype CMake-based build system
summarized above are overwhelming.  Therefore, our recommendation is
to transition all of Trilinos to the new CMake-based build system and
completely drop the current autotools build system as soon as
possible.  However, maintaining limited support for the current
autotools-based build system through the next major release of
Trilinos would be recommended.

There are also significant advantages to supporting the
CMake/CTest/CDash-based test harness as summarized above.  However,
some features supported by the home-grown Perl-based test harness will
take considerable time and effort to replicate with the
CMake/CTest/CDash system.  Therefore, our recommendation is to
maintain test suites for both the new CMake/CTest/CDash system and the
current Perl-based test harness until such time that the
infrastructure around the CMake/CTest/CDash system sufficiently
supports the compartmentalization of test results for archiving and
reporting.  This means maintaining each package's test/definition file,
and adding TRILINOS\_ADD\_TEST(...) calls in CMakeLists.txt files.  By
maintaining both testing systems, we will have the best of both worlds
but at the cost of needing to maintain two test systems for some time.
However, it is expected that maintaining both testing system will be
much easier that maintaining both build systems for several reasons.

The current Trilinos/CMake prototype build system is now at a state
where we believe it can now be pushed out to all of Trilinos very
rapidly.


% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}


% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%
\appendix

%\include{apdx_ToDo}


\begin{SANDdistribution}[NM]
% \SANDdistCRADA	% If this report is about CRADA work
% \SANDdistPatent	% If this report has a Patent Caution or Patent Interest
% \SANDdistLDRD	% If this report is about LDRD work
% External Address Format: {num copies}{Address}
%\SANDdistExternal{}{}
%\bigskip
%% The following MUST BE between the external and internal distributions!
%\SANDdistClassified % If this report is classified
% Internal Address Format: {num copies}{Mail stop}{Name}{Org}
%\SANDdistInternal{}{}{}{}
% Mail Channel Address Format: {num copies}{Mail Channel}{Name}{Org}
%\SANDdistInternalM{}{}{}{}
%\SANDdistInternal{2}{MS 9018}{Central Technical Files}{8944}
%\SANDdistInternal{2}{MS 0899}{Technical Library}{4536}
\end{SANDdistribution}

\end{document}
