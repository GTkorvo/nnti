
% Outlining a Development Model for CSE Software
% Jim Willenbring, Mike Phenow, Mike Heroux

%## Header ####################################################################

\documentclass[12pt,relax]{article}
\addtolength {\textheight}{0.2in}
\addtolength {\textwidth}{0.2in}
\linespread{1.6}
\newcommand{\DisplayCommand}[1]{%
\par\vspace{1ex}%
{\bf Command:}%
{\hspace{0.2 in}} {\tt #1} {\par\vspace{1ex}}}

% InlineCommand
\newcommand{\InlineCommand}[1]{
  {\hspace{0.01 in}} {\tt #1} {\hspace{0.01 in}}}

% InlineDirectory
\newcommand{\InlineDirectory}[1]{
  {\hspace{0.01 in}} {\tt #1} {\hspace{0.01 in}}}

\usepackage{array}

%## Content ###################################################################

%== Title Page ================================================================

\title{Improving the Development Process for CSE Software}

\author{
Michael Heroux\\
James Willenbring\\
Michael Phenow\\
}

% There is a "Printed" date on the title page of a SAND report, so
% the generic \date should generally be empty.
\date{\today} % Remove ``\today'' in final version

\begin{document}

\maketitle
%\setcounter{page}{3} % Accounts for blank page at beginning

%== Abstract ==================================================================

\begin{abstract}

Most existing computational science and engineering (CSE) software has been 
developed without the benefit of Software Quality Assurance (SQA) processes.
The increasing complexity of applications is dictating a higher standard for 
CSE software quality; it is no longer sufficient to claim to have 
written high quality software.  However, traditional
software development models can be impractical for CSE projects to implement.
Despite this, CSE software teams can benefit by implementing
valuable SQA processes and tools.  We will outline some the
processes and tools that the Trilinos Project has had success with.  These 
tools and processes have been useful not only in increasing 
\textit{verifiable} software quailty, but also have improved 
overall software quality, and the development experience in 
general.

\end{abstract}

\clearpage

%== Acknowledgements ==========================================================

\section*{Acknowledgments}

The authors would like to acknowledge the support of the ASC and LDRD programs 
that funded development of Trilinos and recognize all Trilinos contributors:
Michael Heroux (project leader), Teri Barth, Ross Bartlett, Paul Boggs, Jason
Cross, David Day, Clark Dohrmann, Robert Heaphy, Ulrich Hetmaniuk, Robert
Hoekstra, Russell Hooper, Vicki Howle, Jonathan Hu, Tammy Kolda, Kris
Kampshoff, Sarah Knepper, Joe Kotulski, Richard Lehoucq, Kevin Long, Joe
Outzen, Roger Pawlowski, Eric Phipps, Andrew Rothfuss, Marzio Sala, Andrew
Salinger, Paul Sery, Paul Sexton, Ken Stanley, Heidi Thornquist, Ray Tuminaro
and Alan Williams.

\clearpage
\tableofcontents

\clearpage

%== Introduction ==============================================================

\section{Introduction}
\label{Section:Introduction}


The Trilinos Project, developed at Sandia National Laboratories, is an effort
to develop parallel solver algorithms and libraries within an object-oriented
software framework for the solution of large-scale, complex multi-physics
engineering and scientific applications.  Trilinos consists of about thirty
packages.  Each package is focused on important, state-of-the-art algorithms
in a particular domain and is developed by a small team of experts.

Four years ago the Trilinos development team was charged with the task of
improving its existing software quality practices.  Since many computational
science and engineering (CSE) software projects are not dedicated to formal
Software Quality Assurance (SQA) practices, a lot of work is required to define
practices that are well suited to the project.

A few characteristics of the project make defining formal practices and
processes especially challenging.  Specifically, the requirements of the
project are intractable, which makes it exceedingly difficult to maintain a
formal requirements document.  The fact that the Trilinos Team is spread
across the United States places special emphasis on enabling effective methods
of communication.  As with many CSE software projects, the budgetary focus is
on algorithms development, leaving little money to put directly towards
software quality efforts--either dedicated personnel or proprietary tools.

Now, four years into the process of improving software quality practices, we 
have come to realize that there are certain low-cost, high-yield processes and
tools that tend to work well to enable the development of high quality CSE
software.  To demonstrate this, we will present some high-level goals that 
apply to most CSE software projects.  We will then present some principles that
keep the Trilinos project on the right development path.  Finally, we will
discuss some general classes (and specific instances) of tools that, guided
by our driving principles, help us to achieve the goals of the project.

Those who are interested in learning more about the Trilinos project should
consult {\it An Overview of Trilinos}~\cite{Trilinos-Overview} or the
{\it Trilinos Users Guide}~\cite{Trilinos-Users-Guide}.  Trilinos also has an
extensive web site that can be found at \newline
\InlineDirectory{http://software.sandia.gov/trilinos}~\cite{Trilinos-home-page}.

%== Goals =====================================================================

\section{Goals}
\label{Section:Goals}

Based on the above project characteristics, it is easy to extract some high-
level project goals.  These goals can be applied to most software projects,
but are described below in the specific context of the Trilinos Project.

\subsection{Quality}
%-------------------
Trilinos, like all software projects, seeks quality as a primary goal--quality
both in the colloquial meaning of the word and the particular meaning it
carries in the software engineering world, specifically:  a measure of the
degree to which software meets its stated requirements.  Additionally, for an 
increasing number of CSE software projects, claiming to do a good job is no 
longer sufficient.  Customers now require artifacts that show that documented 
software processes are followed.

\subsection{Modularity}
%----------------------
Individual sets of functionality in Trilinos are contained in individual,
autonomous modules called packages, which are developed by individuals or small
teams.  Keeping logically distinct pieces of functionality modular is critical
to the long-term health of the project.  

\subsection{Interoperability}
%----------------------------
Because of this modular architecture, it is of utmost importance that the
various packages ``play well together.''  For Trilinos to realize its full
potential, all of the various independent parts need to work together in
concert.  This is an important issue for CSE software in general.  There 
is a lot of excellent existing software that cannot readily be brought to
bear on a single problem.

\subsection{Scalability}
%-----------------------
Trilinos started as a collection of three packages.  In a few short years, it
has grown organically to include roughly 30 packages.  To maximize the
benefits reaped from economies of scale and to leverage to power of other
codes, scalability (in this context, the ability to continue to add more
packages) is a primary concern for Trilinos.  The degree to which the Trilinos
architecture scales is directly dependent on the level of modularity and
interoperability achieved.  Another key scalability issue for Trilinos is that
as packages are added, users should be shielded from the additional complexity;
using Trilinos should not become significantly more compilicated as Trilinos
grows.

\subsection{Reliability}
%-----------------------
Trilinos developers are not generally experts in software engineering, nor do
they wish to sample the bleeding edge of software engineering tools.  Rather,
tools that are established and well tested are preferable to newer,
experimental tools.  Fortunately, the tools that have been adopted are not only
reliable, but are also freely available.

\subsection{Efficient Use of Expert Time}
%----------------------------------------
Trilinos packages are developed by experts in the particular domain of a
package.  One very critical goal of the Trilinos project is to make efficient
use of these experts' time.  These experts ought to be spending as much time as
possible in their domain of expertise, not bothering with the comparatively
mundane tasks of software project management, which, unchecked, have a way of
crowding out other tasks.  When inefficient SQA processes are adopted, it can 
decrease, rather than increase, efficiency.

\subsection{Support}
%-------------------
Finally, the ultimate goal of any piece of software is to actually get used.  
It is important to provide support so that all of the energy spent developing
the software is put to good use, but, here again, it is important that the
experts don't have to spend all of their time helping users install and use the
software.

\clearpage

%== Driving Principles ========================================================

\section{Driving Principles}
\label{Section:Driving Principles}

As described in the introduction, the Trilinos project, and likewise many CSE
projects, have a unique set of characteristics within the software world.
These characteristics define the setting, or the landscape, within which the
project lives.  Within the context of this reality, certain goals can then be
formulated that define the destination the project aspires to reach.  We now
know both the lay of the land and the destination.  What we need is a route to
get us there.

Trilinos has been guided throughout it's life by a small set of principles
that, when faced with a critical decision, help us to stay on track.  

\subsection{Package Orthogonality}
%---------------------------------

Trilinos was originally created as a way to bring together parallel solvers
to enable effective reuse, enable interoperability, and minimize duplication of
effort by application developers.  The mechanism chosen for containing a solver
was a ``package.''  A Trilinos package is simply a self-contained piece of
software that is developed in the Trilinos source repository, can build within
the Trilinos build system, and can interact with other Trilinos packages.
Trilinos began as a set of three packages and got its name from the Greek 
``trilinos,'' which loosely translated means ``string of pearls.''  The name is
meant to convey the idea that each package is a valuable pearl, but is even
more valuable when combined with the rest of the packages.  This image also
contains the notion of a common thread holding all the packages together.

Having both a collection of packages and a central entity gives Trilinos a
two-tiered architecture.  What we think of as the lower level is simply the
packages, the pearls.  Above that, we have what we call the Trilinos framework,
the string.  The framework is where we seek to capitalize on economies of scale
by providing global services to packages so duplication of effort is minimized
wherever possible.  The two driving principles that keep this two-tiered
architecture in its delicate balance are global services, which we will discuss
in the next section, and package orthogonality.

One critically important driving principle of the project since its inception
has been the idea that we must do everything we can to preserve package
autonomy.  While it's true that most packages never stray very far from the
pack and may never do so, it has served us well to always design to allow for
it.  This principle of package autonomy has evoloved into a the more
encomassing principle of package orthogonality.  It is quite possible for
packages to be autonomous, but not very orthogonal.  What we want is for the
relationship between one package and another, as well as the relationship
between packages and the framework, to be such that a change in one place has
minimal effects in other places.

Achieving a high level of orthogonality does a number of things for us.  First,
it allows packages to be effectively developed by small groups of domain
experts without unnecessary hassles external to the algorithmic problem at
hand.  As mentioned above, Trilinos began as three packages and has since
grown to include more than 25.  Each of these packages has a different story.  
Some were started from scratch within Trilinos.  Many others were existing
projects imported into Trilinos.  Of these, we find the whole range, from
those just off the ground, to mature codes that have been in use for years.
In all cases, the development of the code is done by experts in the given
domain.  These groups generally consist of one to five developers.  This
small size keeps the groups focused, agile, and accountable.
  
Packages that join Trilinos after they are relatively mature often wouldn't
do so if they felt they would be forever dependent on Trilinos.  The design
of the Trilinos architecture very deliberately seeks to prevent a central
entity upon which all packages must be dependent.  Many packages came to 
Trilinos already having an established user base and it is very important
for some packages to be able to exist either within the Trilinos framework
or completely apart from it.

Similarly, many packages would not be inclined to become a part of Trilinos
if they had to surrender the control of their package.  Being a part of
Trilinos brings with it very few requirements.  Instead, there are many
guidelines and services that, in practice, are almost all adopted by all
packages.  Local decisions about the direction or design of a package are
left in the hands of the package developers.

Finally, maintaining a high level of package othogonality and autonomy
keeps us honest.  We don't just acquire source and hold it hostage under heavy
handed requirements.  Since packages are free to go at any time, we know that
to retain them (and thus to retain the benefits of the functionality they
provide and the expertise of their developers) we must continue to provide
value to the package developers.

\subsection{Global Services}
%---------------------------

In the two-tiered architecture, we generally refer to the upper tier as the
framework.  The framework is the string holding the pearls of the various
packages together.  The framework exists for the benefit of member
packages, providing numerous services and suggested practices.

The Trilinos Framework makes many optional, valuable services available to
member packages.  Focusing on a large number of packages makes more advanced
services available to development teams that otherwise might be too
small to have access to such an array of services.  Some of the standard
services include source control, an issue reporting tool, and mail lists.
More advanced services include a package webpage prototype and personal 
assistance in creating and maintaining package websites as well as a build 
system that allows all packages to be built as a part of a single process 
and helps to ease some porting issues.  A functional example package called
New Package can be used by developers to quickly adapt an existing package 
to the suggested Trilinos build system or to hasten the process of 
building a portable package from scratch.  Automated testing on an expanding 
number of platforms as well as the ability to set up customized test runs is 
available via the Trilinos Test Harness.  A relatively new service provided 
by  the framework is the ability to view test results on the internet from
all of the Trilinos Test Harness testing platforms.

As mentioned above, Trilinos does not impose a large number of requirements
on member packages.  Rather, the Trilinos Framework provides suggested 
practices that, with very few exceptions, are adopted by all packages.
For example, packages are required to complete some sort of organized
process prior to an external release (having a documented release
process is a requirement that is imposed by powers above the Trilinos
Framework).  The Trilinos Framework team has developed a checklist that
packages can complete to satisfy this requirement; however, package teams
are free to develop an alternative process.  At this time, every package
uses the default release checklist, which saves developers the hassle of
developing an individualized process and gives them a release process that
has been hardened through process improvement based on feedback from
member package teams.  Another suggested practice is running tests
associated with a package before committing new code for that package to the 
CVS repository.

With some Trilinos team members concentrated on framework-level issues and
valuable input from numerous Trilinos package developers, the Trilinos 
Framework now provides many valuable services and suggested practices that
are inexpensive for package teams to utilize and that have evolved over 
time based on the experience of dozens of people.  

The impact of the Trilinos Framework has spread beyond the boundaries of 
the project.  The package website template and New Package are available 
at the Trilinos website.  Other project teams at Sandia are also in various
stages of adapting for their own project one or more of many Trilinos
services, including the test harness, homepage, results webpage, 
release checklists, or build system to meet their specific needs.

\subsection{Tight Collaboration}
%-------------------------------

CSE software, like most software, has grown in complexity in recent years.
The most interesting and challenging problems are generally not solved by an
individual or project team working in isolation.  Solid relationships with 
external and internal collaborators are essential.  It may even be the case
that an outside collaborator is a significant stakeholder in the project and 
whose requirements are of utmost importance.

But how do you gather the requirements of your stakeholders?  What happens
when they change?  Classical development models would prescribe a formal
requirements gathering process to set the direction of the project from the
outset.  From then on, all development has to be traceable back to the
requirements and any deviation from the requirements warrants a formal revision
of them.  

For many CSE projects, this is not a reasonable approach.  When your work, or 
the work of your stakeholders, is research-intensive or exploratory in nature, 
the problem may not be understood well enough at the outset of the project to 
make it worthwhile to define traditional formal requirements.  Requirements 
will likely change and evolve very quickly.  In such cases, attempting to
adhere to a classical development model becomes, instead of necessary
bookkeeping, an exercise in paper-generation.

How then to communicate effectively with your stakeholders?  Establish a
collaborative relationship with them.  Bring them into the workings of your
project.  This doesn't mean that they have to be concerned with the day to day
activities, but rather, use close collaboration to gather, implement,
integrate, and iterate on their requirements.  Proactively seek additional
input from stakeholders on a regular basis and keep them well informed.

Between packages, Trilinos takes advantage of close collaboration by 
establishing well-defined channels of communication.  Issue-tracking
software, mail lists, and regular meetings all give developers of one package
the means to communicate with other packages to coordinate important design
decisions.

Outside of the project, Trilinos maintains close relationships with its primary
stakeholders, some of whom have a developer working on both Trilinos and the
project in question.  This helps ensure the successful integration of Trilinos
into their codes.  It also provides an effective means of staying abreast of
the changing requirements of these external codes.  Close collaborations of
this nature help Trilinos prevent possible problems before they arise and also
help to steer the project in the right direction.

\subsection{Iterative Development}
%---------------------------------

(simplicity (KISS), YAGNY, organic growth, rapid prototyping)

Close collaborations facilitate the communication of design decisions, 
requirements, and countless other important bits of information, but the
ultimate goal of all this communication is to produce working code and the
longer development continues without being integrated and tested, the more
time will have to be sunk into the integration and debugging processes.  This
has led the Trilinos Project to strive for shorter iterations where possible.
%Trilinos tends to release every 6-9 months, so in the context of some 
%development paradigms, such as XP (cite), Trilinos iterations would not be
%considered short, but Trilinos tends to release more often than many of
%its customers and has shortened some iterations within the release cycle...
%not working now, try to revise later
This is a practice that is valuable in a number of areas, from design,
development, and debugging to building, testing, and integrating.  Below we
will discuss a number of tools that the Trilinos Project relies on to enable
these short iterations.

\subsection{Process Improvement}
%-------------------------------

Software is always a work in progress.  On any project there are things
being done well and things that need work.  One of the difficulties of 
software engineering or software project management is to take the realities
of a given project and mold them into a form that is in agreement with the
theories of accepted development models.  After realizing that a wholesale 
overhaul of an entire project to bring it into compliance with an accepted
model was infeasible, but also that acceptance of sub-optimal processes is
inefficient, the Trilinos Project adopted a model of process improvement by
which the processes that drive the project are always subject to ongoing,
incremental revision and and improvement.  We always keep our eyes open for the 
``low-hanging fruit,'' or those modifications to existing processes that are
likely to yield the most benefit at the least cost.

\clearpage

%== Tools =====================================================================

\section{Development Practices and Tools}
\label{Section:Tools}

We have laid out the goals for our project.  We have described a development
model to steer us towards those goals.  But all of that is just talk unless we
really make progress towards our ultimate goals.  The tools of a project are
where the rubber hits the road.  They have to be chosen carefully to serve the
needs of the project and to minimize overhead while producing the most benefit.
Here we'll discuss a number of different general classes of tools that we feel
a project should have and then discuss the particular tools we have chosen.
%quality and reliability are addressed in some way by each of the tools

\subsection{Source Management}
%-----------------------------

% Quality, reliability, eff use of exp time, support
% tight collab, iterative dev, is a global service



\subsection{Communication Channels}
%----------------------------------

% Quality, reliability, iterop, eff use of exp time, support
% global services, tight collab, process imp.

\subsection{Requirements \& Issue-Tracking}
%------------------------------------------

% all
% global services, tight collab, it dev, process imp. 

\subsection{Documentation}
%-------------------------

% quality, interop, reliab, support
% tight collab

\subsection{Configuration Management}
%------------------------------------

% all
% pkg orthog, gloabal serv, tight collab, 

\subsection{Information Distribution}
%------------------------------------

% quality, reliab, eff use exp time, support
% global serv, tight collab, proc imp

\subsection{Testing}
%-----------------------------

% all
% pkg orthog, global serv, it dev, proc imp

\subsection{Release Process}
%---------------------------

% put under info dist?

\clearpage

%== Conclusion ================================================================

\section{Conclusion}
\label{Section:Conclusion}

Developing quality CSE software is tough.  Finding the time, energy, and
resources to improve the processes by which you develop it can be even tougher.
Often the biggest obstacle is the mere thought of the daunting task of getting
from where you are to where you should be.  But, through organic integration of
these simple, proven, freely-available tools and techniques, you can
incrementally improve the quality of your project's processes which will, in
turn, improve the quality of your software.

\clearpage

%== More Information ==========================================================

** From Jim's paper, revise, but this shows how to cite papers and prevents the
empty bib problem.

Those who are interested in learning more about the Trilinos project should 
consult {\it An Overview of Trilinos}~\cite{Trilinos-Overview} or the
{\it Trilinos Users Guide}~\cite{Trilinos-Users-Guide}.  Trilinos also has an 
extensive web site that can be found at \newline
\InlineDirectory{http://software.sandia.gov/trilinos}~\cite{Trilinos-home-page}.

\clearpage

%== Bibliography ==============================================================

\bibliographystyle{plain}
%\bibliography{SIAMnews}
\bibliography{../CommonFiles/TrilinosBibliography}
\addcontentsline{toc}{section}{References}

\end{document}

%## Notes #####################################################################

%== Outline ===================================================================

%I.    Introduction                                                                                
%      A.  Motivation (problem)
%      B.  Claim (proposed solution)
%      C.  Preview (teaser, road map)
%                                                                      
%II.   Body                                                                                
%      A.  Goals (problem)
%          1.  Quality
%          2.  Modularity
%          3.  Interoperability
%          4.  Scalability
%          5.  Efficient use of expert time
%          6.  Support                                                                                
%      B.  Development model (proposed solution)
%          1.  Tight collaboration
%          2.  Frequent iterations
%          3.  Quality control, process improvement
%          4.  Two-tiered organizational architecture
%              a.  Packages/modules
%                  1.  Small expert groups
%                  2.  Highly autonomous
%                  3.  Local authority
%              b.  Framework/project
%                  1.  Global "control"
%                  2.  Global "services"
%                  3.  Support filter, common front
%      C.  Tools (to support/enable proposed solution)
%          1.  version system
%          2.  mail lists
%          3.  bug-tracking
%          4.  website
%          5.  test harness
%                                                                                
%III.  Conclusion                                                                                
%      A.  Recapitulate problem
%      B.  Recapitulate solution
%      C.  Claim / action item / prediction (say *something*)

%== Titles ====================================================================

%Modern Software Development practices for CSE
%Impact of Modern Software Tools on CSE
%Exploring the Impact of Modern Development practices on CSE
%Examining the Impact of Modern Software Tools on CSE
%Assessing the Impact of Modern Software Tools on CSE
%Assessing the Impact of Tools and Processes on CSE Software Development
%Assessing the Impact of a Customized Development Processes on ...
%Outlining a Development Model for CSE Software
%Making the Case for Agile Models in CSE Software

%== Thesis ====================================================================

%== Ideas =====================================================================
