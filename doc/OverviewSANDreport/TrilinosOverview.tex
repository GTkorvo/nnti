%
% This is an example LaTeX file which uses the SANDreport class file.
% It shows how a SAND report should be formatted, what sections and
% elements it should contain, and how to use the SANDreport class.
%
% Build it using
%     latex SANDExample
%     bibtex SANDExample
%     latex SANDExample
%     latex SANDExample
%     dvips -o SANDExample.ps SANDExample.dvi
%     ps2pdf SANDExample.ps SANDExample.pdf
%
% This file and the SANDreport.cls file are based on information
% contained in "Guide to Preparing {SAND} Reports", Sand98-0730, edited
% by Tamara K. Locke.
% Please send corrections and suggestions for improvements to
% Rolf Riesen, Org. 9223, MS 1110, rolf@cs.sandia.gov
%
\documentclass[12pt,strict]{SANDreport}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}



% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%
    \title{An Overview of the Trilinos Project}

    \author{Michael A.~Heroux\\
       Numerical and Applied Mathematics Department \\
	  Sandia National Laboratories\\
	  P.O. Box 5800\\
	  Albuquerque, NM 87185-1110 \\
	  maherou@sandia.gov \\
	 }

    % There is a "Printed" date on the title page of a SAND report, so
    % the generic \date should generally be empty.
    \date{}


% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2002-xxxx}
\SANDprintDate{August 2002}
\SANDauthor{Michael A.~Heroux, Sandia National Laboratories}


% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}


% ---------------------------------------------------------------------------- %
% The following definitions do not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND00-0000}{January 0000}
\SANDdistcategory{UC-999}	% DOE mandates it, but many reports don't have it


% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}
    \maketitle

    % ------------------------------------------------------------------------ %
    % An Abstract is required for SAND reports
    %
    \begin{abstract}
The Trilinos Project is an effort to develop parallel solver algorithms within 
an object-oriented software framework for the solution of large-scale, complex
multi-physics engineering and scientific applications.   Our emphasis is on 
developing robust, scalable algorithms in a software framework, using abstract 
interfaces for flexible interoperability of components and providing a 
full-featured set of concrete classes that implement all abstract interfaces. 
Trilinos components are primarily written in C++, but provide essential C and 
Fortran user interface support.  We provide an open architecture that allows 
easy integration with other solver packages and we deliver our software to 
the outside community via the Gnu Lesser General Public License
(LGPL)~\cite{gnu-license-site}.
This report provides an overview of Trilinos, discussing the objectives, history,
current development and future plans of the project.
    \end{abstract}


    % ------------------------------------------------------------------------ %
    % An Acknowledgement section is optional but important, if someone made
    % contributions or helped beyond the normal part of a work assignment.
    % Use \section* since we don't want it in the table of context
    %
    \clearpage
    \section*{Acknowledgement}
The author would like to acknowledge the support of the ASCI and LDRD programs
that funded development of Trilinos and the talented group of Trilinos contributors: 
Robert Hoekstra, Alan Williams, Richard Lehoucq, James Willenbring, Kevin Long, Tamara
Kolda, Roger Pawlowski, David Day, Ray Tuminaro, Jonathan Hu, Mark Adams and Teri
Barth.



    % ------------------------------------------------------------------------ %
    % The table of contents and list of figures and tables
    % Comment out \listoffigures and \listoftables if there are no
    % figures or tables. Make sure this starts on an odd numbered page
    %
    \clearpage
    \tableofcontents
    \listoffigures
    \listoftables


    % ---------------------------------------------------------------------- %
    % An optional preface or Foreword
%    \clearpage
%    \section{Preface}
%	Although muggles usually have only limited experience with
%	magic, and many even dispute its existence, it is worthwhile
%	to be open minded and explore the possibilities.


    % ---------------------------------------------------------------------- %
    % An optional executive summary
    \clearpage
    \section{Summary}
The Trilinos Project grew out of a group of established numerical algorithms
efforts at Sandia, motivated by  a recognition that a modest degree of 
coordination among these efforts could have a large positive impact on the quality and
usability of the software we produce and therefore enhance the
research, development and integration of new solver algorithms into
applications.  This document describes the Trilinos project,
focusing on the project philosophy and description, and
providing the reader with an overview of the project in its current state.  It also
includes brief developer and user guides.


    % ---------------------------------------------------------------------- %
    % An optional glossary. We don't want it to be numbered
    \clearpage
    \section*{Nomenclature}
    \addcontentsline{toc}{section}{Nomenclature}
    \begin{itemize}
	\item[Package]
	    a collection of software focused on one primary class of numerical methods
	\item[Trilinos]
	    A Greek term that loosely translated means ``a string of pearls,'' meant
         to evoke an image that each Trilinos package is a pearl in its own right,
         but is even more valuable when combined with other packages.
    \end{itemize}


    % ---------------------------------------------------------------------- %
    % This is where the body of the report begins; usually with an Introduction
    %
    \SANDmain		% Start the main part of the report

\section{Introduction}

Research efforts in advanced solution algorithms and parallel solver
libraries have historically had a large impact on engineering and
scientific computing.  Algorithmic advances increase the range
of tractable problems and reduce the cost of solving existing
problems.  Well-designed solver libraries provide a mechanism for
leveraging solver development across a broad set of applications and
minimizing the cost of solver integration.  Emphasis is
required in both new algorithms and new solver frameworks in order
to achieve the maximum impact of efforts.

The Trilinos project encompasses a variety of efforts that are to some
extent self-contained but at the same time inter-related.  The
Trilinos design allows individual packages to grow and mature
autonomously to the extent the algorithms and package developers
dictate. 

Integration of a package into Trilinos, and what Trilinos can provide
to a package, have multiple possibilities
that will be discussed in Section~\ref{sect:TrilinosDesign}.
Section~\ref{sect:EpetraAndTSF} discusses two special Trilinos
packages: Epetra and TSF.  The general definition of a Trilinos
package is presented in Section~\ref{sect:PackageDefinition}

An overview of current algorithmic and software research and
development is given in Sections~\ref{sect:Algorithms}
and~\ref{sect:Software}, respectively.  Finally this document contains
three appendices.  Appendix~\ref{sect:OOTutorial} gives a brief
tutorial on object-oriented concepts for readers who are unfamiliar
with the area.  Appendix~\ref{sect:UserGuide} provides a brief User Guide
for Trilinos and finally Appendix~\ref{sect:DeveloperGuide} provides a
set of policies and procedures for Trilinos developers.

\section{Trilinos Design Philosophy}
\label{sect:TrilinosDesign}
Each Trilinos package is a self-contained, independent piece
of software with its own set of requirememts, its own development team
and a group of users.  Because of this,
Trilinos itself is designed to respect the autonomy of packages.
Trilinos offers a variety of ways for a particular package to interact with other
Trilinos packages.  Trilinos also offers a set of tools that can
assist a package with builds across muliple platforms, generating
documentation and regression testing across a set of target platforms.
At the same time, what a package {\it must} do to be called a Trilinos
package is minimal, and varies with each package.

\subsection{Services Provided by Trilinos}

Trilinos provides a variety of services to a developer wanting to
integrate a package into Trilinos.  In particular, the following are
provided:
\begin{itemize}
\item Configuration management:
Autoconf~\cite{Autoconf},  Automake~\cite{Automake} and
Libtool~\cite{Libtool} provide a robust, full-featured set of tools for
building software across a broad set of platforms (see also the ``Goat
Book''~\cite{GoatBook}).  Although these
tools are not official standards, they are commonly used in many
packages.  Many existing
Trilinos packages use Autoconf and Automake (and will soon use
Libtool). In order to
minimize the amount of redudant effort, Trilinos provides a set of
M4~\cite{M4} macros that can be used as a starting point for any other
package that wants to use Autoconf and Automake for configuring and
building libraries.  However, use of these tools is not required.

\item Regression testing: Trilinos provides a variety of regression
testing capabilities.  Within a number of Trilinos packages, we employ
``white box'' testing where detailed information about the software is
used and probed.  In addition, Trilinos performs ``black box'' testing
of packages via the Trilinos Solver Framework (TSF) virtual class
interfaces.  Any package that implements the TSF interfaces (see
Section~\cite{Interop_TSF} below), can be tested via this black box
test environment.  ({\bf NOTE: Black box testing via TSF is not in
place at this time}


\item Portable interface to BLAS and LAPACK: The Basic Linear Algebra
Subprograms (BLAS)~\cite{BLAS1,BLAS2,BLAS3} and LAPACK~\cite{lapack}
provide a large repository of robust, high-performance mathematical
software for serial and shared memory parallel dense linear algebra
computations.  However, the BLAS and LAPACK interfaces are Fortran
specifications, and the mechanism for calling Fortran interfaces from
C and C++ varies across computing platforms.  Epetra (and Tpetra)
provide a set of simple, portable interfaces to the BLAS and LAPACK
that hide these interface variations.  These interfaces are accessible to
other packages.

\item Source code repository and build tools: Trilinos source code is
maintained in a CVS~\cite{CVS} repository that is accessible via a
web-based interface package called Bonsai~\cite{Bonsai}.  Features and bug reports
are tracked using Bugzilla~\cite{Bugzilla}, and email lists are
maintained for Trilinos as a whole and for each package.  Support for new
packages can easily be added.  All tools are accessible from the main
Trilinos website~\cite{Trilinos-home-page}.

\end{itemize}

\section{Epetra and TSF: Two Special Trilinos Packages}
\label{sect:EpetraAndTSF}
In order to understand what Trilinos provides beyond the
contributions of each Trilinos package, we briefly discuss two special
Trilinos packages: Epetra and TSF.  These two packages are complimentary,
with TSF providing a common abstract application
programmer interface (API) for other Trilinos packages and Epetra
providing a common concrete implementation of basic classes used by most
Trilinos packages.

\subsection{Epetra}
Matrices, vectors and graphs are basic objects used in most solver
algorithms. Most Trilinos
packages interact with these objects via abstract interfaces that
allow a package to define what services and behaviors are expected,
without enforcing a specific implementation.  However, in order to use
these packages, some concrete
implementation must be selected.  Epetra (and in the future other packages described
in Section~\ref{subsect:PetraObjectModel}) is a collection of concrete
classes that supports the construction and use of vectors, sparse
graphs, and dense and sparse matrices.  It provides serial, parallel and distributed memory
capabilities.  It uses the BLAS and LAPACK where possible, and as a
result has good performance characteristics.

\subsection{TSF}
Many different algorithms are available to solve any given numerical
problems.  For example, there are many algorithms for solving a system
of linear equations, and many solver packages are available to solve
linear systems.  Which package is appropriate is a function of
many details about the problem being solved. However, even though
there are many different solvers, conceptually, from an abstract view,
these solvers are providing a similar capability, and it is
advantageous to utilize this abstract view.
TSF is a collection of abstract classes that provides an application
programmer interface (API) to perform the most common solver
operations.  It can provide a single interface to many different
solvers and has powerful compositional mechanisms that support the
light-weight construction of composite objects from a set of
existing objects.  As a result, TSF users gain easy access to many
solvers and can bring multiple solvers to bear on a single problem.


\section{Trilinos Package Interoperability Mechanisms}
\label{sect:PackageDefinition}
As mentioned above, what a package {\it must} do to be called a Trilinos
package is minimal, and varies with each package.  In this section we
list the primary mechanisms for a package to become part of Trilinos.
Note that each mechanism is an extension or augmentation of package
capabilities, creating connections between packages.  Thus, a package does 
not need to change its internal structure to become part of Trilinos.

\subsection{Package Accepts User Data as Epetra Objects}
All solver packages require some user data, usually in the form of
vectors and matrices, or require the user to supply the action of an
operator on a vector.  Accepting this data in the form of Epetra
objects is the first Trilinos interoperability mechanism.  Any package
that accept user data this way immediately becomes accessible to an
application that has built its data using Epetra.  We expect every
Trilinos package to implement this mechanism in some way.  Since
Epetra provides a variety of ways to extract data from an Epetra
object, minimally we expect that a package can at least copy data from
the user objects that were built using Epetra.  More often, a well-designed
package can typically encapsulate Epetra objects and ask for services from
the Epetra objects without explicitly copying them.

\subsection{Package Callable via TSF Interfaces}
TSF provides a powerful set of abstract interfaces that can be used to
interface to a variety of solver packages.  TSF can accept
pre-constructed solver objects, e.g., preconditioners, iterative
solvers, etc., by simple encapsulation or it can
construct solver objects using one of a variety of factories.  (See
Appendix~\ref{sect:OOTutorial} for the definition of a factory.)  Once
constructed, a solver object can be further modified by passing it a
parameter list containing a list of key-value pairs that can control
solver behavior when it is trying to solve a problem.  For example,
the parameter list could specify a residual tolerance for an iterative solver.

A package is callable via TSF if it implements one or more of the TSF
abstract class interface, making it available to TSF users as one of a
suite of possible solver options.

\subsection{Package Builds Under Trilinos {\tt configure} Scripts}
Trilinos uses Autoconf~\cite{Autoconf} and Automake~\cite{Automake} to
build libraries and test suites.  The Trilinos directory structure
keeps each Trilinos package completely self-contained.  As such, each
package is free to use its own configuration and build process.  At
the same time, Trilinos has a top-level configure script that searches
the directory structure for the existence of other configure scripts,
executing one if it is found, passing on any parameter definitions
from the top level.  Similarly, the make process is also recursive.

A package may easily be automatically built from the top-level
Trilinos configuration and make process by copying and modifying the
Autoconf and Automake scripts from another package.  The benefit for
doing this is that Autoconf and Automake improve the portability of a
package across a broad set of platforms.  Also, Automake provides a
rich set of targets for building libraries, software distributions,
test suites and installation processes.  If a package adopts the
Trilinos configuration and build process, it will be built
automatically along with a large number of other Trilinos packages.

\subsection{Package Can Use Epetra Internally}

The final interoperability mechanism available to a package is that of
using Epetra objects as the
internal objects for storing vector, matrices, etc. that are seldom or
never seen by the user.  In many instances, this mechanism has no
practical advantages.  However, in some instances, there can be a
saving in storage requirements.  Furthermore, by using Epetra objects
internally, a package can in turn use other Trilinos packages to
manipulate its own internal objects.

\section{Overview of Current Package Development}

\subsection{The Petra Object Model}
\label{subsect:PetraObjectModel}
The Petra class libraries provide a
foundation for all Trilinos solver development.  Petra provides object classes for
constructing and using parallel, distributed memory matrices and vectors.  Petra exists in
multiple forms.  Its most basic form is as an object model~\cite{HeroHoekWill2002}.
As such, it is an abstract 
description of a variety of vector, matrix and supporting classes, along with a description of
how these classes interact.  There are presently three implementations
of the Petra Object Model: Epetra, Tpetra and Jpetra.

\subsection{Epetra: Essential Implementation of Petra Object Model}

Epetra~\cite{Epetra-User-Guide}, the current production version of Petra,
 is written for real-valued double-precision scalar field data only, and
restricts itself to a stable core
of the C++ language standard.  As such, Epetra is very portable and stable, and  
is accessible to Fortran and C users.  
Epetra is unique in that it combines in a single package (i) support for generic parallel
machine descriptions, (ii) extensive use of standard numerical libraries, (iii) use of best
practices in object-oriented C++ programming and (iv) parallel data redistribution.
Other basic linear algebra packages, e.~.g.~ the Template Numerical Toolkit~\cite{TNT-site},
PETSc~\cite{petsc-manual} and the Matrix Template Library~\cite{SiekLums98}, feature one
or two of these aspects only.  The availability of Epetra has facilitated rapid development
of numerous applications and solvers at Sandia because many of the complicated issues of
working on a parallel distributed memory machine are handled by Epetra.

Application developers can use Epetra to construct and manipulate matrices
and vectors, and then pass these objects to most Trilinos solver components.  Furthermore,
solver developers can develop many new algorithms relying solely on Epetra classes to
handle the intricacies of parallel execution.  Epetra also has extensive parallel data  
redistribution capabilities, including an interface to the Zoltan load-balancing
library~\cite{zoltan-ug}.

\subsection{Tpetra: Templated C++ Implementation of Petra Object Model}

In addition to Epetra, we have started development of a templated version of Petra,
called Tpetra, that implements the scalar and ordinal fields as templated types.  
When fully developed, Tpetra will allow
matrices and vectors to be composed of real or complex, and single or double precision scalar
values.  Furthermore, in principle, any abstract data type (ADT) can be used as 
the scalar field type as long
as the ADT supports basic mathematical operations such as addition and multiplication and
inversion. Specifically, we could compute using an interval scalar field, matrices, integers,
etc., without any additional code development in Tpetra.  
Tpetra can also use any size integer for indexing.  Typically the ordinal field would be 
an integral data type such as int or long int.  However,
any ADT that supports an indexing capability can be used, including integers in other bases, 
or cyclic indexing. Additionally, Tpetra also
uses the C++ language standard more fully.  In particular, it utilizes the Standard
Template Library (STL)~\cite{Stroustrup}, to provide maximal
algorithmic efficiency with minimal code
development.

We will fully develop Tpetra as a peer library to Epetra. By using partial
specialization of templates, we will base Tpetra on established libraries such as the
BLAS~\cite{BLAS1,BLAS2,BLAS3} and LAPACK~\cite{lapack} and therefore acquire the
performance and robustness of these libraries.
Like Epetra, Tpetra is written for generic parallel distributed
memory computers whose nodes are
potentially shared memory multiprocessors.

\subsection{Jpetra: Java Implementation of Petra Object Model}

In addition to Tpetra, we have started a Java implementation of Petra.  The primary design
goals of this project are to produce a library that is a high performance, pure Java
implementation of Petra.  By restricting ourselves to Java and avoiding the use of the Java
Native Interface (JNI)~\cite{JNI-site} to link to other libraries, we
get the true portability that Java
promises.  The fundamental implication of these goals is that we cannot rely on
BLAS~\cite{BLAS1,BLAS2,BLAS3}, LAPACK~\cite{lapack} or MPI~\cite{MPI}
since they are not written in Java, and we do not use the JNI.
As such, we must track the development of pure Java equivalents of these libraries.  Several
efforts, including Ninja~\cite{MoreMidkGuptArtiWuAlma2001} and
MPJ~\cite{CarpGetoJuddSkjeFox2000}, provide equivalent functionality to the BLAS, LAPACK and
MPI, but are completely written in Java.

We will fully implement Jpetra as a peer library to Epetra.  By making extensive use of Java
interfaces, we can create loose dependencies on emerging BLAS, LAPACK and MPI replacements as
they become mature and stable.  Recently, several research
efforts~\cite{MoreMidkGuptArtiWuAlma2001,SCIMARK-site}
have shown that there is no fundamental performance bottleneck using Java.  Instead, Java
compilers and user practices have been the issue.  As a result, Java holds much promise as a
high performance computing language.  Jpetra will facilitate adoption of Java in scientific and
engineering applications.   Java also has native graphical user interfaces (GUI) support.  A
significant part of Jpetra will be the development of GUI tools for visualization and
manipulation of Jpetra objects.


\subsection{TSF: The Trilinos Abstract Class Package}

Packages like Epetra, Tpetra and Jpetra provide a broad set of powerful 
capabilities.  As a direct
result, their class and interface specifications can be quite complex and difficult to use
for algorithm developers that only need to work with abstract matrix and vector objects.
Furthermore, implementation details are necessarily exposed in a way that commit users
of these packages to pay attention to the particular way these packages are implemented.
For some types of algorithms (for example, algorithms like incomplete factorizations that 
must work directly with matrix coefficients as efficiently as possible), working at this
concrete level is necessary.  

However, many algorithms have no need for this detailed
information.  Forcing use of these concrete classes is a disservice to these algorithm
developers because they are forced to deal with details that are irrelevant to their work.
This causes undue burden on the developer, and make their code tightly connected to the 
concrete library for no good reason.

The TSF abstract class package addresses this potential problem by defining a collection 
of classes that define the expected behavior of abstract matrix and vector objects from a
user perspective, independent of implementation.  The result is that each TSF class has
a much simpler interface than the corresponding Epetra interface.  Furthermore, the TSF
interface can be implemented using Epetra, or any other package that can provide the 
required functionality.

TSF provides abstract interfaces for vector, matrix, operator and solver objects.  In
addition, it has powerful aggregation mechanisms that allow existing TSF objects to 
be combined in a variety of ways to create new TSF objects.
TSF can be useful in many situations.  For example:
\begin{enumerate}
\item Generic Krylov method implementation:  If a preconditioned Krylov solver 
is implemented using TSF vectors and operators, then any concrete package that implements
the TSF vector and operator interfaces can be used with the Krylov solver.
\item Generic solver driver:  If an application accesses solver services via the TSF
solver interfaces, then any solver that implements the TSF solver interface is 
accessible to that application.
\item Aggregate objects to implicitly construct a Schur complement: 
TSF provides mechanisms to implicitly 
construct a matrix of operators, the sum or composition of two operators, the inverse
of an operator, etc.  Similar aggregation mechanisms are available for vectors, matrices
and solvers.  Given these mechanisms, a TSF operator that describes the action of the
Schur compliment of an operator is easy to define.  Let
\[
A=\left[
\begin{array}{ll}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{array} \right].
\]
Then the Schur compliment of $A$ with respect to $A_{22}$ is 
$S = A_{22} - A_{21}A_{11}^{-1}A_{12}$.
Assume that A11, A12, A21 and A22 are TSF operator objects that store $A_{11}$, $A_{12}$,
$A_{21}$ and $A_{22}$.  To very explicit, we can think of these objects as Epetra matrices
that are encapsulated as TSF operators.
\end{enumerate}

\subsection{AztecOO}

\subsection{Ifpack}

\subsection{Komplex}

\subsection{NOX}
	

    \section{Conclusion}


    % ---------------------------------------------------------------------- %
    % References
    %
    \clearpage
    \bibliographystyle{plain}
    \bibliography{TrilinosOverview}
    \addcontentsline{toc}{section}{References}


    % ---------------------------------------------------------------------- %
    % Appendices should be stand-alone for SAND reports. If there is only
    % one appendix, put \setcounter{secnumdepth}{0} after \appendix
    %
    \appendix
    \section{Historical Perspective}
	This is an example of an appendix.

	If we follow~\cite{Sand98-0730} strictly, we would have to
	have a separate bibliography section for each appendix.
	The style file doesn't provide that, but it can be done
	using the {\tt bibunits} and {\tt chapterbib} packages.

	If there are many subsections in an appendix, it should also
	have its own table of contents. Again, the SAND report class
	file does not provide that functionality.

	\subsection{The Past a Long Time Ago}
	    This is where we talk about things so old nobody
	    can verify them. We are safe.

	\subsection{The Past More Recently}
	    Now we have to be a little bit more careful, since
	    records exist from that time, and some people still
	    alive actually lived back then.


\section{A Brief Overview of Some Object-Oriented Concepts}
\label{sect:OOTutorial}
Object-oriented.
Define ``factory''.  Implementation, interface, derived, specialization.
    % \printindex

    \begin{SANDdistribution}
	\SANDdistExternal{1}{An Address\\ 99 $99^{th}$ street NW\\City, State}
	\SANDdistExternal{3}{Some Address\\ and street\\City, State}
	\bigskip
	\SANDdistExternal{12}{Another Address\\ On a street\\City, State\\U.S.A.}


	\SANDdistInternal{1}{1110}{Rolf Riesen}{9223}

	% Housekeeping copies necessary for every unclassified report:
	\SANDdistInternal{1}{9018}{Central Technical Files}{8940-2}
	\SANDdistInternal{2}{0899}{Technical Library}{4916}
	\SANDdistInternal{2}{0619}{Review \& Approval Desk}{4916}

	% If report has a Patent Caution or Patent Interest, add this:
	\SANDdistInternal{3}{0161}{Patent and Licensing Office}{4916}
    \end{SANDdistribution}

\end{document}
