%\documentclass[11pt]{SANDreport}
\documentclass[pdf,ps2pdf,11pt]{SANDreport}
%\usepackage{pslatex}
\usepackage{psfig}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{\center
Pure Nonmember Function Interfaces to C++ Classes}
\author{
Roscoe A. Bartlett \\ Optimization/Uncertainty Estim \\ \\ Sandia National
Laboratories\footnote{ Sandia is a multiprogram laboratory operated by Sandia
Corporation, a Lockheed-Martin Company, for the United States Department of
Energy under Contract DE-AC04-94AL85000.}, Albuquerque NM 87185 USA, \\ }
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2007-xxx}
\SANDprintDate{??? 2007}
\SANDauthor{
Roscoe A. Bartlett \\ Optimization/Uncertainty Estim \\ \\
}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for general release}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
A pure nonmember function interface to an abstract C++ class might provide the
best approach for keeping clean minimal interfaces, insulating client code
from changes to the interface, and providing a uniform interface when other
nonmember nonfriend functions are used.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgement section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
%\clearpage
%\section*{Acknowledgment}
%
%
%The format of this report is based on information found
%in~\cite{Sand98-0730}.

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\SANDmain % Start the main part of the report

%
\section{Introduction}
%

Object-oriented programming has been used and refined for many decades in a
variety of programming languages.  Some of the most basic descriptions of
object orientation speak of {}\textit{programming with objects} and refer to
such concepts as {}\textit{object methods}, {}\textit{polymorphism}, and
{}\textit{encapsulation}.  These concepts can be expressed in different ways
in different programming languages and each language lends itself to different
idioms for how object orientation is to be used to its fullest.  Here we focus
on the C++ language and combine some of the more modern idioms being advocated
in C++ to propose an extension involving the consistent use of nonmember
functions to encapsulate external clients of abstract interfaces and concrete
classes from the details and changes to the public interfaces of these
classes.  Here we will draw on the advice of several respected authors on C++
programming {}\cite{C++CodingStandards05,EffectiveC++3rd}.

The primary focus here is on issues related to object-oriented programming in
the C++ language and specifically the interaction between an abstract
interface (consisting of pure virtual functions), clients that use objects
through the interface, and subclasses of the interface that provide concrete
implementations of all of the member functions.  A secondary focus of this
discussion addresses how nonmember functions can also be used as the interface
to concrete classes and describe the benefits of such an approach.

With respect to abstract interfaces, our main goal here is to describe an
approach for developing C++ interfaces and encapsulation mechanisms which
protect clients of an abstract C++ interface from changes to the specification
of the interface's virtual functions.  This is especially critical when the
interface represents an important interoperability mechanism and is part of a
library which may have many diverse and unaccessible external clients which
the library developers can not directly change.  Minimizing the impact of code
refactorings is even more important in C++ than in other languages because of
the lack of good quality refactoring tools in C++.

What we want is to have an approach to developing, maintaining, and using
abstract C++ interfaces that:

\begin{itemize}

{}\item\textit{Provides for the absolute minimal abstract C++ interfaces}: An
abstract C++ interface is the critical specification of the capabilities of an
object which must be able to cover the needs of a large set of potential
clients and allow great flexibility and efficiency in the implementation of
subclasses.  The more minimal an interface is, the more likely it will be
adopted for a larger community and the easier it will be to develop powerful
``Decorator'', ``Composite'' and other such general subclasses.  Minimal and
efficient interfaces are especially critical for interoperability.

{}\item\textit{Maintains a uniform, consistent, and convenient interface for
the clients of the abstract interface}: We want clients to be able to access
the capabilities of the object in a clean way that is robust to changes in the
interface.

{}\item\textit{Avoids many of the Gotchas associated with object oriented
programming in C++}: In particular, we want to avoid difficulties associated
with overloaded virtual functions {}\cite[Item 73]{C++Gotchas03}, virtual
functions with default arguments {}\cite[Item 37]{EffectiveC++3rd}, and other
such problems.

{}\item\textit{Allows for changes to an abstract interface's virtual function
set in such as way consistent with the above goals}: As requirements become
more clear or change over the life of a piece of software, changes to the
specification of the virtual function set for an interface will be inevitable
in order to satisfy the new requirements in an efficient an safe way, and to
maintain a minimal interface.  We want to avoid a sub-standard abstract
interface that is cluttered with backward-compatible functions for older
clients.  Ideally, the integrity and the quality of the current incarnation of
an interface should not suffer from having been incrementally developed where
compromises where made to support current clients and use cases at the expense
of the interface.  We want the interface to be the same quality as if it where
nearly totally redesigned after the fact.

\end{itemize}

In particular, two idioms have been advocated that are designed to address many
of the above issues: The Nonvirtual Interface (NVI) idiom {}\cite[Item
39]{C++CodingStandards05}, and the nonmember function idiom {}\cite[Item
44]{C++CodingStandards05}.  Other guidelines that are pertinent to our
discussion are ``prefer minimal classes to monolithic classes'' {}\cite[Item
33]{C++CodingStandards05}, ``prefer providing abstract interfaces''
{}\cite[Item 36]{C++CodingStandards05}, ``practice safe overriding''
{}\cite[Item 38]{C++CodingStandards05} {}\cite[Gotcha 74]{C++Gotchas03}, and
``avoid overloading virtual functions'' {}\cite[Gotcha 73]{C++Gotchas03}.

The Nonvirtual Interface (NVI) idiom {}\cite[Item 35]{EffectiveC++3rd}
advocates making all virtual functions non-public (i.e.\ either private or
protected) and making all public functions nonvirtual.  For example, we might
have an interface that looks like:

{\small\begin{verbatim}
  class BlobBase {
  public:
    // Non-virtual public interface
    void foo(int a=0) { implNonconstFoo(a); }
    void foo(int a=0) const { implFoo(a); }
  protected: // or private:
    // Pure virtual non-public functions to be overridden
    virtual void implNonconstFoo(int a) = 0;
    virtual void implFoo(int a) const = 0;
  };
\end{verbatim}}

The details of the NVI idiom are given in {}\cite[Item
39]{C++CodingStandards05} and {}\cite[Item 35]{EffectiveC++3rd} but basically
the idiom allows clients to call regular member functions and overloaded
member function on the object without the problems associated with overloaded
virtual functions and it also avoids problems with default function arguments
since the default values are only defined in the non-public, nonvirtual
function interface.

Another idiom that is advocated in {}\cite[Item 44]{C++CodingStandards05} and
{}\cite[Item 23]{EffectiveC++3rd} is to prefer writing a function as a
nonmember nonfriend function unless it needs access to private or protected
members.  This increases encapsulation and improves modularity.  Typically,
this idiom is described in the context of concrete classes which actually have
private data, but it is also applicable for abstract interfaces as well.  If
some capability can be performed just using the existing public interface,
then that capability should be implemented as a nonmember nonfriend function.
Adding another nonvirtual function to the interface (or worse making the new
function virtual with a default implementation) mostly just clutters up the
abstract interface and complicates maintenance.  For example, some function
{}\texttt{goo(...)} could be implemented in terms of
{}\texttt{BlobBase\-::foo(int)} as:

{\small\begin{verbatim}
  void goo( BlobBase &obj ) {
    obj.foo(0);
    obj.foo(1);
  }
\end{verbatim}}

The NVI idiom and ``nonmember function'' idiom, can and should be used
together, but they are also somewhat at odds with each other.  The NVI idiom
implies that all operations that are directly implemented as virtual functions
on the abstract interface would be accessed using corresponding public
nonvirtual member functions.  The ``nonmember function'' dictates that all
other functions would be implemented as nonmember nonfriend functions.
However, the straightforward combination of these two idioms has several
disadvantages:

\begin{itemize}

{}\item\textit{The client interface is a mix of member and nonmember
functions}: The most obvious disadvantage of having an interface composed of
both nonmember and member functions is that it can be hard for the developers
of client code to remember how to call an operation.  For instance, is the
operation {}\texttt{foo(...)} called as {}\texttt{obj.foo(i)} or as
{}\texttt{foo(obj,i)}?

{}\item\textit{Changes to the virtual function structure are difficult to
handle}: A change to the virtual function structure requires that either
clients be changed or that the interface be polluted with public functions
that no longer need direct access to the nonpublic virtual functions.  For
example, what if requirements for the abstract interface change such that it
would be beneficial, from a design point of view, to change the specification
of a virtual function.  The change might involve a modification to the
signature and/or the behavior of the function.  Such a change in the virtual
function would naturally involve a similar change in the corresponding public
nonvirtual member function that calls the virtual function.  Let's also assume
that the current capability of the function in question can be maintained
through a simple function that calls the newly updated function.  Now the
problem; how do we implement this change and how does this change impact the
current clients of the interface?  There are one of two possible ways to
refactor the code: a) move the function from a member function to a nonmember
function, or b) leave the current public nonvirtual member function in the
abstract interface and make it call the newly updated member function.  Both
of these choices are fraught with problems.

\end{itemize}

Let's examine the two possibilities for handling changes to the virtual
function structure of the abstract interface mentioned above.  As an example,
consider a new set of requirements where the {}\texttt{foo()} member functions
need to be changed to accept a {}\texttt{Bar} object (represented through its
own abstract interface) instead of just an integer, and the functions also
need to accept an extra boolean argument.  In addition, let's assume that the
old meaning and behavior of the {}\texttt{foo()} functions can be retained by
using a default implementation of {}\texttt{Bar} called {}\texttt{DefaultBar}.
We consider two approaches for dealing with such a change below.

First, if we want to keep the abstract interface minimal and be consistent
with the ``nonmember nonfriend function'' idiom, then we want to choose option
'a' which involves moving the old public nonvirtual member {}\texttt{foo()}
functions out of the interface and making them new nonmember nonfriend
functions.  In this case, the updated class interface {}\texttt{BlobBase}
would look like:

{\small\begin{verbatim}
  namespace BlobPack {

  class Bar;

  class BlobBase {
  public:
    void foo( const Bar &bar, bool useDog = false )
      { implNonconstFoo(bar,useDog); }
    void foo( const Bar &bar, bool useDog = false ) const
      { implFoo(bar,useDog); }
  protected: // or private:
    // Pure virtual non-public functions to be overridden
    virtual void implNonconstFoo( const Bar &bar, bool useDog ) = 0;
    virtual void implFoo( const Bar &bar, bool useDog ) const = 0;
  };

  } // namespace BlobPack
\end{verbatim}}

{}\noindent{}and the nonmember form of the old {}\texttt{foo()} functions
would look like:

{\small\begin{verbatim}
  void BlobPack::foo( BlobBase & obj, int a)
  {
    obj.foo(DefaultBar(a),false);
  }

  void BlobPack::foo( const BlobBase & obj, int a)
  {
    obj.foo(DefaultBar(a),false);
  }
\end{verbatim}}

However, this refactoring would require changing the syntax by which all
clients that currently call the old version of the {}\texttt{foo()} member
function.  This change is simple to make since one just needs to replace
{}\texttt{blob.foo(i)} with {}\texttt{foo(blob,i)} and one could almost write
a script to perform the refactoring.  However, this type of automated
refactoring could never be performed 100\% correctly and preexisting clients
outside of the library developer's control (i.e.\ clients of our libraries)
could not be changed easily.  While this approach maintains a clean abstract
interface and is consistent with both the NVI and the ``nonmember nonfriend
function'' idioms, is has the disadvantage of requiring the clients to change
their code, which is undesirable, impractical, or too expensive.

Second, if we want to minimize the impact on existing clients (i.e.\ if our
library is widely used by external clients out of our control), then we might
want to to choose option 'b' to leave the old public nonvirtual function in
the abstract interface and to augment the interface with the new public
nonvirtual function corresponding to the refactored nonpublic virtual
function.  The refactored class interface in this case would look something
like:

{\small\begin{verbatim}
  #include ``DefaultBar.hpp''

  namespace BlobPack {

  class BlobBase;

  class BlobBase {
  public:
    // Old public nonvirtual functions that do not need direct access
    void foo( int a)
      { foo(DefaultBar(a),false); }
    void foo( int a) const
      { foo(DefaultBar(a),false); }
    // Public nonvirtual functions that need direct access
    void foo( const Bar &bar, bool useDog = false )
      { implNonconstFoo(bar,useDog); }
    void foo( const Bar &bar, bool useDog = false ) const
      { implFoo(bar,useDog); }
  protected: // or private:
    // Pure virtual non-public functions to be overridden
    virtual void implNonconstFoo( const Bar &bar, bool useDog ) = 0;
    virtual void implFoo( const Bar &bar, bool useDog ) const = 0;
  };

  } // namespace BlobPack
\end{verbatim}}

The refactoring shown above has the advantage that the clients don't need to
be changed (other than needing to be recompiled).  However, the problem with
this approach of course is that it no longer maintains a clean minimal
interface and is in direct violation of the ``nonmember nonfriend function''
idiom.  Over time, such refactorings will result in a bloat of the abstract
interface which is discouraged by many experts in object-oriented programming
in C++ {}\cite[Item 33]{C++CodingStandards05}.

In the next section, an approach for addressing the problems of combining
these two idioms is presented which involves the adoption of a pure nonmember
function interface.

%
\section{The Pure Nonmember Function Interface Idiom}
%

Here we present an variation of the NVI idiom that is more complementary with
the ``nonmember nonfriend function'' idiom.  The idea is the replace the pubic
nonvirtual member functions in the abstract interface with nonmember friend
functions.  Therefore, a simple interface using the ``pure nonmember function
interface'' idiom would look like:

{\small\begin{verbatim}
  namespace BlobPack {

  class BlobBase;

  // Forward prototypes for nonmember functions that
  // will directly call virtual functions.  Note that default
  // argument values are defined here and here only.
  void foo( BlobBase & obj, int a=0);
  void foo( const BlobBase & obj, int a=0);

  class BlobBase {
    friend void foo( BlobBase & obj, int a);
    friend void foo( const BlobBase & obj, int a);
  protected: // or private:
    // Pure virtual non-public functions to be overridden
    virtual void implNonconstFoo(int a) = 0;
    virtual void implFoo(int a) const = 0;
  };

  } // namespace BlobPack
\end{verbatim}}

{}\noindent{}and the nonmember friend functions would be implemented as:

{\small\begin{verbatim}
  void BlobPack::foo( BlobBase & obj, int a)
  {
    foo.implNonconstFoo(a);
  }

  void BlobPack::foo( const BlobBase & obj, int a)
  {
    foo.implFoo(a);
  }
\end{verbatim}}

Other functions that can be implemented in terms of the existing capabilities
on the object without requiring special access would be implemented as
nonmember nonfriend functions such as:

{\small\begin{verbatim}
  void goo( BlobBase &obj ) {
    foo(obj,0);
    foo(obj,1);
  }
\end{verbatim}}

This approach has all of the same advantages of the NVI idiom with respect to
allowing for function overloading without problems and for allowing
for a single definition of default parameter values.  Note that it is critical
that the virtual functions themselves must remain non-public since we can't
allow clients to be calling these directly (for lots of reasons) and therefore
these special nonmember functions must be friends.

Even through at first sight replacing the public nonvirtual member functions
with corresponding nonmember friend functions looks to be more complicated,
there are several advantages to doing this:

\begin{itemize}

{}\item\textit{The client accesses capabilities in a more consistent way}: For
example, a client would invoke every operation on an object using a nonmember
function, independent of how that function was treated.  For example, the
client would call {}\texttt{foo(obj,i)} or {}\texttt{goo(obj)} consistently as
nonmember functions without having to worry how these are implemented now or
in the future.

{}\item\textit{Changes to the structure of the virtual function set can be
handed without affecting clients and without cluttering the abstract
interface}: If a virtual function needs to be modified in some significant
way, then the nonmember function that calls that virtual function can be
changed and the old nonmember friend function can be turned into a plain
nonmember nonfriend function and removed from the abstract interface.

\end{itemize}

To see how changes to the virtual function structure can be handled without
impacting clients (other than require that they be recompiled), let's consider
the same refactoring scenario described above where a new set of requirements
are introduced where the {}\texttt{foo()} functions need to be changed to
accept a {}\texttt{Bar} object (represented through its own abstract
interface) instead of just an integer, and the new {}\texttt{foo()} functions
also need to accept an extra boolean argument.  Using the ``pure nonmember
function interface'' idiom, the refactored interface and supporting code would
look something like:

{\small\begin{verbatim}
  namespace BlobPack {

  class Bar;

  // Forward prototypes for nonmember functions that
  // will directly call virtual functions
  void foo( BlobBase& obj, const Bar &bar, bool useDog = false );
  void foo( const BlobBase& obj, const Bar &bar, bool useDog = false );

  class BlobBase {
    friend void foo( BlobBase& obj, const Bar &bar, bool useDog );
    friend void foo( const BlobBase& obj, const Bar &bar, bool useDog );
  protected: // or private:
    // Pure virtual non-public functions to be overridden
    virtual void implNonconstFoo( const Bar &bar, bool useDog ) = 0;
    virtual void implFoo( const Bar &bar, bool useDog ) const = 0;
  };

  } // namespace BlobPack
\end{verbatim}}

{}\noindent{}where the direct nonmember friend functions now have the
implementation:

{\small\begin{verbatim}
  void BlobPack::foo( BlobBase & obj, const Bar &bar, bool useDog )
  {
    foo.implNonconstFoo(bar,useDog);
  }

  void BlobPack::foo( const BlobBase & obj,  const Bar &bar, bool useDog )
  {
    foo.implFoo(bar,useDog);
  }
\end{verbatim}}

Now, what about all of the clients that relied on the old definition of the
{}\texttt{foo()} functions?  As was stated above, let's assume that the old
meaning and behavior of the {}\texttt{foo()} functions can be retained by
using a default implementation of {}\texttt{Bar} called {}\texttt{DefaultBar}
and a value of {}\texttt{useDog=false} which gives the following nonmember
nonfriend functions:

{\small\begin{verbatim}
  void BlobPack::foo( BlobBase & obj, int a )
  {
    foo(obj,DefaultBar(a),false);
  }

  void BlobPack::foo( const BlobBase & obj, int a )
  {
    foo(obj,DefaultBar(a),false);
  }
\end{verbatim}}

The above new nonmember nonfriend {}\texttt{foo()} function overloads could
then be included in the same files as the other ``standard'' nonmember
functions where {}\texttt{goo()}, for instance, is also declared and defined.
After this refactoring, clients that currently use expressions like
{}\texttt{foo(obj,0)} now just need to be recompiled and that is it!

As described above, the ``pure nonmember function interface'' idiom allows for
changes in the virtual functions of an abstract interface without requiring
any changes to current client code and without compromising the integrity and
quality of the refactored interface.  While the ``pure nonmember function
interface'' idiom solves the problem of having to refactor client code when an
interface changes, it does not address how changes to the virtual function set
affects subclasses that implement the interface's virtual functions.  The next
section describes how changes to an interface's virtual function set affects
subclasses.

%
\section{The Full Impact of Changing Virtual Functions}
%

As mentioned earlier, there are clarifications, changes, and augmentations to
requirements for software that beg for changes in the structure and behavior
of the virtual functions on an abstract interface.  The ``pure nonmember
function interface'' idiom described above takes care of insulating clients
from most types of changes to the virtual function set, but how do these
changes affect subclasses of the abstract C++ interface that override virtual
functions?  There are two main categories of subclasses of abstract C++
interfaces to consider: a) those that are owned and controlled by the library,
and b) those that are developed by external users and are out of the control
of the library developers.  Subclasses can also be classified as i) those that
are direct subclasses of the base abstract interface (e.g.\ such as
``Decorator'' and ``Composite'' subclasses), and ii) those that are indirect
subclasses of the base abstract interface and don't directly override any of
the top-level virtual functions.

{\bsinglespace
\begin{figure}
\begin{center}
%\fbox{
\includegraphics*[angle=270,scale=0.55
]{BlobBaseBeforeRefactoring}
%}
\end{center}
\caption{
\label{fig:BlobBaseBeforeRefactoring}
UML class diagram : Blob software before refactoring.  }
\end{figure}
\esinglespace}

Consider the simplified {}\texttt{Blob\-Base} interface and some of its
subclasses shown in Figure {}\ref{fig:BlobBaseBeforeRefactoring}.  This
example is provided to illuminate the issues involved when refactoring the
virtual functions in a base class interface.  In this example diagram, we show
several different categories of subclasses mentioned above.  The intermediate
subclasses {}\texttt{Type\-A\-Blob\-Base} and {}\texttt{Type\-B\-Blob\-Base}
are designed to provide support for implementing the {}\texttt{Blob\-Base}
interface for two different general types subclasses for more specific types
of use cases.  For instance, {}\texttt{Type\-A\-Blob\-Base\-::foo(...)} is an
implementation of {}\texttt{Blob\-Base\-::foo(...)} that provides most of the
needed behavor for ``type A'' blobs and defers the rest of the more specific
behavior to the pure virtual function
{}\texttt{Type\-A\-Blob\-Base\-::typeAFoo(...)} to be implemented by
subclasses.  These kinds of intermediate type 'a.i' subclasses are very common
in object oriented class hierarchies.  The type 'a.ii' concrete subclasses
{}\texttt{Internal\-Default\-Type\-A\-Blob} and
{}\texttt{Internal\-Default\-Type\-B\-Blob} provided by the library give good
default implementations of ``type A'' and ``type B'' Blob subclasses.  The
classes {}\texttt{External\-Type\-A\-Blob} and
{}\texttt{External\-Type\-A\-Blob} are type 'b.ii' subcalsses and are
implemented by external code developers to satisfy some more specific needs
than are provided by the library.  The subclass
{}\texttt{Internal\-Decorator\-Blob} is provided by the library to support a
common type of Blob decorator and represents a type 'a.i' subclass.  The
subclass {}\texttt{External\-Decorator\-Blob} is a more specialized decorator
implementation that is created and lives outside of the control of the
``BlobPack'' library develoeprs and is therefore a type 'b.i' subclass.

With this example Blob class hierarchy in place, now consider the impact of
refactoring the virtual function in a base interface
{}\texttt{Blobl\-Base\-::foo(...)} as described above.  Any subclasses that
are owned by or accessible by the library developers can be changed at a
reasonable cost in most cases.  In our example in Figure
{}\ref{fig:BlobBaseBeforeRefactoring}, this means tha all of the classes in
the ``BlobPack'' package can reasonably be refactored since they are under the
``BlockPack'' library developer's control.  Also, as will be shown, indirect
subclasses can also largely be insulated from changes to the base abstract
interface in many cases if they are derived from well-designed intermediate
subclasses which live in the library.

The key to insulating most concrete subclasses from changes to the top-level
virtual functions is then is to create a set of appropriate intermediate
subclasses, tailored to specific types of use cases, which are owned by the
library and define all of the virtual functions on the base class interface
and translate these to the more specific use cases with other virtual
functions.  This is the role of the {}\texttt{Type\-A\-Blob\-Base} and
{}\texttt{Type\-B\-Blob\-Base} subclasses shown in our example.  Specific
categories of clients can then drive from these tailored intermediate
subclasses and not have to directly implement any of the virtual functions in
the base class interface.

While the development and use of tailored intermediate subclasses can insulate
most types of derived subclasses from changes to the higher level virtual
functions, a remaining stumbling block are those inaccessible external
subclasses that directly derive from the base abstract interface (i.e.\ type
'b.i' subclasses as defined above).  Examples of these types of direct
subclasses would be classic ``Composite'' or ``Decorator'' subclasses that use
some form of direct delegation on subordinate objects, such as the
{}\texttt{External\-Decorator\-Blob} subclass shown in Figure
{}\ref{fig:BlobBaseBeforeRefactoring}.

{\bsinglespace
\begin{figure}
\begin{center}
%\fbox{
\includegraphics*[angle=270,scale=0.55
]{BlobBaseAfterRefactoring}
%}
\end{center}
\caption{
\label{fig:BlobBaseAfterRefactoring}
UML class diagram : Blob software after refactoring.  }
\end{figure}
\esinglespace}

To expand on this discussion, consider the refactored {}\texttt{Blob\-Base}
interface and subclasses shown in Figure {}\ref{fig:BlobBaseAfterRefactoring}.
Here, the refactored {}\texttt{Type\-A\-Blob\-Base} and
{}\texttt{Type\-B\-Blob\-Base} intermediate subclasses insulate the concrete
subclasses {}\texttt{Internal\-Default\-Type\-A\-Blob},
{}\texttt{Internal\-Default\-Type\-A\-Blob},
{}\texttt{External\-Type\-A\-Blob}, and {}\texttt{External\-Type\-A\-Blob}
from changes to the base interface and they only need to be recompiled.  The
situration for the necessarily direct concrete dectorator subclasses
{}\texttt{Internal\-Decorator\-Blob} and {}\texttt{External\-Decorator\-Blob}
is a little different in that they must be refactored as well in order to
remain 100 \% general decorator classes.  The
{}\texttt{Internal\-Decorator\-Blob} subclass is not much of a problem since
it is maintained by the ``BlobPack'' library developers and it's current
(nonmember) public interface will likely not be broken due to the refactoring.
The problematic subclasses are those external type 'b.i' subclasses that
directly derive from the base interface such as
{}\texttt{External\-Decorator\-Blob} that are out of the control of the
library developers.  In the most general case, these type 'b.i' subclasses
will have to be manually refactored by the external developers.  There are
strategies where the cost of performing such external refactorings can be
lessened but avoiding a refactoring altogether is usually not possible.  We
will not discuss specific strategies for minimizing the cost of such
refactorings any further here.

The point of this section was to really round out the discussion of the full
impact of changing the virtual function set in a base class interface in how
such a refactoring can be absorbed in the subclasses of the interface and at
what cost.  As described above, in many cases, intermedate subclasses can
insulate many different types of concrete subclasses from significant changes
to the base classes virtual functions and can therefore make such refactorings
reasonable and affordable.  However, in the absents of very sophisticated
refactoring tools for C++ (which simply do not exist at the time of this
writting and may never exist), we can not fully protect external subclass
developers for such refactorings.  It should be noted, however, that for many
types of more mature class libraries, that there should be relatively few
examples of direct external ``Composite'' or ``Decorator'' subclasses such as
{}\texttt{External\-Decorator\-Blob} which are the most significant problem
from a refactoring standpoint.  Note however, that modern Agile software
engineering methodologies really mandate the need for refactoring and
therefore we must actively plan for change and the refactorings that are
needed to manage complexity.

{}\textbf{TODO: I Have edited to here (2007/05/07)!}

%
\section{Nonmember Function Interfaces to Concrete Classes}
%

???

%
\subsection{Nonmember Function Constructors}
%

???


%
\section{Member verses Nonmember Functions in C++}
%

It is instructive to consider the implications of member and nonmember
functions in C++ and how these differ with other object oriented languages.
Specifically, we will consider three different object oriented languages: C++,
Java, and Python.  We can broadly classify languages as more strongly typed
and less strongly typed.  In a stronger typed language such as C++ and Java,
the semantics of an object are determined at compile time.  For example, in
C++ and Java, the set of member functions that are callable on a class object
like {}\texttt{BlobBase} is known before the program even starts to execute.
In fact, all of the member functions on a C++ and Java class must be declared
in a single header file within a single class declaration (e.g.\
{}\texttt{class BlobBase \{ ... \};}).  In Python, however, a member function
can be added to an object at any time while a Python program is executing.  As
for member and nonmember functions, Python and C++ can have nonmember
functions while Java can not.  Therefore, when one talks about member and
nonmember functions, conventions used in Java are mostly meaningless.

Okay, so C++ and Python both allow member and nonmember functions. So why is
there not a ``nonfriend nonmember function'' idiom for Python like there is
for C++?  To begin to answer this question, first consider that Python does
not have any true encapsulation.  If any piece of Python code wants to grab
the private data for a object, they can just do it.  Therefore, there are no
features like {}\texttt{private} and {}\texttt{friend} in a language like
Python without encapsulation.  Another difference between C++ and Python is
that in Python, any code can add a new member function to any Python object at
any time.  Therefore, Python code that uses the member function syntax
{}\texttt{obj.foo()} to invoke some operation is no less flexible then using a
nonmember function syntax like {}\texttt{foo(obj)}.  Therefore, since many
programmers think that object orientation means calling member functions such
as {}\texttt{obj.foo()}, there is no disadvantage to allowing them to do so.

The situation for C++ is quite different.  By allowing a client to use the
member function syntax such as {}\texttt{obj.foo()}, one is already placing
several restrictions on how that operation is implemented and gets invoked.
In particular, having a client use a member function (e.g.\
{}\texttt{obj.foo()}) to invoke an operation requires that:

\begin{enumerate}

{}\item{}The function must be declared as a member function on the class in a
single declaration (i.e. within {}\texttt{class ClassName \{ ... \};}) in a
single file.  Sure the function's definition can can be redefined by some
subclass but the object itself must determine how to perform the operation.

{}\item{}The function must be set at compile time and can not changed
dynamically.

\end{enumerate}

On the other hand, using the nonmember function syntax in C++
{}\texttt{foo(obj)} opens the door for a great many different possibilities
for how the operation gets invoked.  Some of the possibilities for the
implementation of a nonmember function are:

\begin{enumerate}

{}\item{}The nonmember function could be a direct call to the member function on an
object (e.g.\ {}\texttt{foo(obj)} means the same thing as
{}\texttt{obj.foo()}).  Therefore, the use of the nonmember function is as
least a flexible as directly calling a member function.  In addition, the
nonmember function syntax almost always uses less ASCII characters.  For
example, writing {}\texttt{foo(obj)} only takes eight ASCII characters to
write, while {}\texttt{obj.foo()}) takes nine ASCII characters.

{}\item{}The nonmember function could perform a few different types of tasks
before calling the member function on some object.  With this approach, we can
add different layers of capabilities in a distributed way.

{}\item{}The nonmember function could actually be involved in a sophisticated
type of multi-dispatch system where the exact operation to call would be
determined by the traits of the objects involved at runtime.  For example, a
nonmember function using multi-dispatch like {}\texttt{foo(objA,objB)} could
call one of a number of different types of operations based on the types of
the objects {}\texttt{objA} and {}\texttt{objB}.

\end{enumerate}

In addition, nonmember functions that are declared in the same namespace as
the types of the objects in their argument lists will be automatically looked
up and called without requiring namespace qualification\footnote{In some types
of templated code, calling a nonmember function without namespace
qualification does not always work but there are usually various work arounds
to make this manageable}.

If nonmember functions are so less flexible than member functions, then why
even bother using member functions at all?  Why not just use nonmember friend
functions in the place of member functions as is advocated in the ``pure
nonmember function interface'' idiom for all C++ classes?  Well, there are a
few reasons that you have to use member functions declared and defined within
the object.  First, some functions like constructors and the assignment
operator, are required to be member functions as are a few other operator
functions.  Second, if the C++ classes you are writing are expected to be very
stable or if changes to these classes can be easily propagated to all clients
using the class, then using member functions is attractive since it just
involves less typing.

However, other than for a bit of laziness and personal preference for writing
{}\texttt{obj.foo()} as apposed to {}\texttt{foo(obj)}, there really is not a
strong argument for not using the ``pure nonmember function interface'' idiom
described above.

Since Java does not have the concept of nonmember functions, once could use a
separate static class to declare these non-privileged functions and one could
therefore have the same benefits as in C++ when using the ``pure nonmember
function interface'' idiom.  However, since there would no longer be any
namespace lookup, client would have to explicitly qualify the class name when
calling the functions.  Also, there are many high-quality refactoring tools
for Java that make it much easier to propagate refactorings to client code.
Therefore, the lack of good refactoring tools, the convenience of automatic
namespace lookup, and other issues make the ``nonmember function interface''
more attractive for C++ than for Java or other object-oriented languages.

%
\section{Relationship between the Pure Nonmember Function Interface Idiom and Handle Classes in C++}
%

A handle class is a concrete class that is meant to mimic the object that it
wraps through a pointer to that object.  Typically, a handle class is used to
wrap an object that uses reference or pointer semantics, such as objects
represented through an abstract interface.  For example, a simple handle class
for a {}\texttt{BlobBase} object might look like:

ToDo: Show a Blob handle class.

The above handle class allows for multiple handle objects to reference the
same underlying {}\texttt{BlobBase} object and a handle object can be
reassigned after constructed.  There are many nuances to consider when one
develops a handle class.  However, a detailed treatment of handle classes is
beyond the scope of this discussion.

The ``pure nonmember function interface'' idiom and the ``handle'' idiom are
similar in several ways ... ToDo: finish this ...

However, the pure nonmember function interface idiom offers some potential
benefits over a strict handle interface:

\begin{enumerate}

{}\item{}\textit{Nonmember functions can be split into multiple files while
member functions on a handle class can not}: Splitting capabilities across
multiple files allows for greater segmentation in the capability set for a set
of objects, it reduces unnecessary dependences and allows for growth in the
set of capabilities without impacting current clients (or even require them to
be recompiled).

{}\item{}\textit{Nonmember functions do not suffer from some of the more
confusing aspects of handle classes}.  For example, a semantics of a handle
class must be carefully spelled out as to how objects can be shared, what the
copy constructor and assignment operator functions do, and other such details.
Nonmember functions do not have to deal with any of these issues.

\end{enumerate}

On the other hand, if extra state needs to be added to the object in order to
perform extended operations, then using a handle class might seem attractive.
However, if the handle class allows multiple handle objects or other clients
to point to the same underlying object, then allowing for extra data in the
handle object can be risky since that data could be easily invalidated.

There are cases, however, where the syntactic advantages of using a handle
class are compelling and therefore handles should be used.  Even if a handle
class is to be used, most operations performed with handle objects should be
implemented as nonmember functions for reasons of avoiding bloat of the handle
class and allowing for incremental and distributed capabilities.  Of course,
if one allows for both the use of member functions on the handle class and
nonmember functions, then this brings up all of the same issues as it did for
the interface class itself.  However, since a handle class should almost never
be used as a means of interoperability, one can be more lenient about what
functions are added as member functions and can therefore handle classes used
as a convenience can tolerate refactorings better.  However, since the member
functions on a handle class never need privileged access to the underlying
object, there will never need to be any changes to the handle classes
interface, only augmentations.

%
\section{Summary}
%

Here we have presented an sort of composite C++ idiom called the ``pure
nonmember function interface'' idiom which is composed out of two other
idioms, the non-virtual interface (NVI) idiom {}\cite[Item
39]{C++CodingStandards05} and the ``nonmember nonfriend function'' idiom
{}\cite[Item 44]{C++CodingStandards05}.  We argue that the proposed ``pure
nonmember function interface'' idiom is the logical union of these two other
idioms when issues of code evolution and refactoring are considered.

The ``nonmember nonfriend function'' idiom:

\begin{itemize}

{}\item results in maximum code encapsulation,

{}\item provides a uniform (nonmmeber) client interface,

{}\item insulates clients from refactorings to the virtual function structure
of abstract interfaces (and therefore makes such refactorings reasonable and
affordable), and

{}\item preserves the minimality and integrity of abstract interface even
after numerious changes in requirements and subsequent refactorings.

\end{itemize}

Where there are many advantages to the ``pure nonmember function interface''
idiom, it is not without cost.

Some of the potential disadvantages of a nonmember interface are given below.

\begin{itemize}

{}\item Calling the nonmember function may require explicit namespace
qualification (or a using declaration) and/or explicit template arguments in
order to get the right function to be called where a nonmember function call
never requires this.

{}\item The nonmember function interface requires a little more typing in that
the prototype for the friend function.

\end{itemize}

Since there are some disadvantages to developing and using a pure nonmember
function interface for an abstract or concrete class, one should not
automatically choose it over the more canonical member function interface.  If
a particular class is not widely used, is not widely accessible to clients,
and/or is unlikely to change, then developing a pure nonmember function
interface may be overkill and not worth the (all be it small) extra work.
However, if the face of uncertainty, one should lean toward using the pure
nonmember function interface since it allows great freedom in refactoring code
with minimal impact on clients.


% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}

% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%
%\appendix
%\input{apdx_CodeReformattingGuidelines.tex}

%\begin{SANDdistribution}
%\end{SANDdistribution}

\end{document}
