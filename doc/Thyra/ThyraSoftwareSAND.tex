\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{
Thyra Software
}
\author{
Roscoe A. Bartlett \\ Optimization/Uncertainty Estim \\ \\
... \\ \\
Sandia National Laboratories\footnote{
Sandia is a multiprogram laboratory operated by Sandia Corporation, a
Lockheed-Martin Company, for the United States Department of Energy
under Contract DE-AC04-94AL85000.}, Albuquerque NM 87185 USA, \\
}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2005-xxxx}
\SANDprintDate{January 12, 2005}
\SANDauthor{
Roscoe A. Bartlett \\ Optimization/Uncertainty Estim \\ \\
... \\ \\
}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
%\SANDreleaseType{Unlimited Release}
\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}

\raggedright

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
This is a design document for various interfaces and support software for
facilitating the interoperability between different types of software modules
primarily, but not limited to, Trilinos.  The term {}\textit{Thyra}, which
means ``interface'' or ``grand entrance'' in Greek, is used to encompass this
type of software.  This document describes the basic categories of interfaces
and support software and outlines how this software is organized into Trilinos
packages and subdirectories within packages.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgement section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
\clearpage
\section*{Acknowledgement}
The authors would like to thank ...

The format of this report is based on information found
in~\cite{Sand98-0730}.

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\setcounter{secnumdepth}{3}
\SANDmain % Start the main part of the report

\section{Introduction}

There are many different categories of interfaces and software that (will)
make up and are (or will be) closly related to Thyra.

There are multiple purposes for this document:
\begin{itemize}
%
{}\item Categorize current and planned interfaces and software related to Thyra
%
{}\item Document dependencies between various software categories to guide how
this software is partitioned into internal (or external) Trilinos
``packages''
%
\end{itemize}

Over time, this document will be morphed into an overview of current and
planned Thyra software and will provide a very brief outline for this
software.  However, the major effort to document this software should be
provided by online documentation (using Doxygen) and summaries can be created
from that effort.

These various categories are described in the next two sections followed by
UML diagram summaries.

%
\section{Thyra Abstract Interfaces}
%

The abstract interfaces in Thyra described in this section define the
foundation for all interoperability between various Trilinos and non-Trilinos
packages and related software.  These interfaces are subdivided into ANA
interfaces and non-ANA interfaces in the next two subsections.

\subsection{Thyra ANA Interfaces}

This set of interfaces is designed to support interoperability for ANAs only.
Figure~\ref{thyra:fig:ThyraANAInterfaces} shows these categories and their
interdependencies as UML packages (not to be confused with Trilinos packages).

%
\subsubsection{Operator/Vector Interfaces}
%

These are the basic C++ interface classes for vectors, vector spaces, linear
operators and multi-vectors.  Also included in this category is minimal
support software that allows the default definition of a multi-vector.
Included here is support software for concrete implementations for serial
vectors and multi-vectors.  These are needed to provide a default definition
for the domain space of multi-vectors for the default multi-vector
implementation.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Basic abstract linear algebra interfaces: {}\texttt{VectorBase},
{}\texttt{VectorSpaceBase}, {}\texttt{LinearOpBase}, and
{}\texttt{MultiVectorBase}
%
{}\item Adapter support subclasses for serial vectors, multi-vectors and
vector spaces:
%
{}\item Concrete implementations of serial vectors, multi-vectors and vector
spaces:
%
\end{itemize}

{}\textit{Current status:} This software currently is located in
{}\texttt{TSFCore/src/interfaces/Core}.

{}\textit{Dependencies:} None


%
\subsubsection{Operator Solve Interfaces}
%

These interfaces represent the highest-level interface to a linear solve.
These interfaces makes no assumption about how the underlying linear system is
solved and therefore can not have a status test that is based on any
algorithmic details such as iteration counts.

Examples of the types of linear operators that might support this interface
are:
%
\begin{itemize}
%
{}\item Block triangular linear operators.  In this operators the solve is
executed by performing one or more solves with the blocks along the diagonal:
Important examples include block diagonal, block lower triangular, and block
upper triangular operators.
%
{}\item Multipliciative operators: Another example is a multiplicative
operator such as $C = A B$ where $A$ and $B$ both support a solve operation.
The linear system $C x = b {}\rightarrow A B x = b$ can be solved by first
solving $A y = b$ and then solving $B x = y$.
%
{}\item Sherman-Morrison-Woodbury operator: As yet another example, consider
the operator $A = I + D D^T$ where $A\in\RE^{n {}\times n}$, $D\in\RE^{n
{}\times m}$ and $m {}\ll n$.  A linear solve with $A x = b$ can be solved as
$x = (I - D^T (I + D^T D)^{-1} D) b$ where $(I + D^T D)\in\RE^{m {}\times m}$
is a small dense positive-definite matrix that is easily formed, factored
(using Cholesky) and solved.
%
\end{itemize}

The convergence criteria used for these types of operator solves must be
purely based on the relative errors of the linear system (i.e.\ relative
residual error or relative solution error).  In the more general cases, it
will be non-trivial to guarantee that a relative error is strictly satisfied.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LinearOpWithSolveBase}: Highest level interface for an
operator that can support a linear solve function.  The {}\texttt{solve(...)} 
member function accepts a RHS {}\texttt{MultiVectorBase} object, and an
initial LHS {}\texttt{MultiVectorBase} object, then returns an approximate LHS
solution.  The convergence criteria is a simple tolerance (or set of
tolerances) for the relative residual or relative solution errors.  Tolerances
can be targeted to different blocks of RHSs to allow for different convergence
criteria.  This interface allows, for instance, the SVD of the RHSs to form
smaller blocks of RHS that can be passed to an atomic direct or iterative
linear solver.
%
\end{itemize}

{}\textit{Current status:} These interfaces are currently part of the
{}\texttt{Thyra} package.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\end{itemize}

{}\textbf{Note:} These interfaces do not depend in any way on the
{}\textit{Basic Iterative Linear Solver Interfaces} or the {}\textit{Linear
Solver Manager Interfaces} but concrete subclasses of these interfaces might
(see Item ???).

%
\subsubsection{Miscellaneous Extended Functionality Interfaces}
%

These are ``Strategy'' interfaces for performing various types of tasks that
are useful to ANA, or almost-ANA, code.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LinearOpAdjointerBase}: Given an input linear operator $A$,
return a new linear operator $B = A^H$ that is the adjoint (or perhaps
transpose).  A typical implementation for an input explicit sparse matrix is
that a new explicit sparse matrix object will be returned.  However, other
implementations are also possible.
%
{}\item {}\texttt{LinearOpSummerBase}: Given two or more input linear
operators create (or update) a linear operator that represents the scaled sum
(or difference) of them.  A typical implementation for explicit input sparse
matrix objects is the creation of an explicit output sparse matrix object.
However, other implementations are possible.
%
{}\item {}\texttt{LinearOpMultiplierBase}: Given two linear operators create
(or update) a linear operator that represents the scaled product of them.  A
typical implementation for explicit input sparse matrix objects is the
creation of an explicit output sparse matrix object.  However, other
implementations are possible.
%
{}\item {}\texttt{LinearOpBlockComposerBase}: Given two or more linear
operators create (or update) a block linear operator that represents the
composite linear operator.  A typical implementation for explicit input sparse
matrix objects is the creation of an explicit output sparse matrix object.
However, other more specialized implementations are possible.
%
{}\item {}\texttt{PreconditionerFactoryBase}: Given a linear operator $A$,
(possibly composed from one or more operators using the above extended
strategy interfaces) create (or update) a linear operator $P$ that improves
the conditioning of the input operator (i.e.\ $\kappa(P A) < {}\kappa(A)$).
Typically the underlying operator is an explicit sparse matrix but other
options are possible.  The preconditioners created by this object will
generally be of the algebraic variety but, again, other options is possible.
The abstract definition of a ``preconditioner'' is quite general.  The
creation of an abstract preconditioner from an abstract operator allows the
use of a single atomic iterative linear solver ANA such as provided through
the {}\textit{Basic Iterative Linear Solver Interfaces}.
%
{}\item {}\texttt{LinearOpWithSolveFactoryBase}: Given an input operator
(possibly composed from one or more operators using the above extended
strategy interfaces), create a new {}\texttt{Linear\-Op\-With\-Solve\-Base}
object the allows for solves with various RHSs.
%
\end{itemize}

Note: An issue that all of the above interfaces needs to deal with is if the
output linear operator will be dependent on the input linear operator.  If so,
then a {}\texttt{RefCountPtr} will have to be passed in for the input linear
operator.

The purpose of these various interfaces is to allow them to be stringed
together by an ANA in order to allow the composition of new types of linear
operators to generally be used in a linear solve.  The general idea is that an
ANA will transform one or more operators using the
{}\texttt{Linear\-Op\-Adjointer\-Base}, {}\texttt{Linear\-Op\-Summer\-Base},
{}\texttt{Linear\-Op\-Multiplier\-Base} and/or
{}\texttt{Linear\-Op\-Block\-Composer\-Base} strategy interfaces to form a new
operator $A$.  This new operator $A$ can then be used in one of several ways
to solve a linear system with $A$ and we list these from the lowest to the
highest level of use.  First, $A$ may be passed into a
{}\texttt{Preconditioner\-Factory\-Base} strategy object to create a
preconditioner $P$ to be used, along with $A$, with a basic iterative linear
solver through the {}\textit{Basic Iterative Linear Solver Interfaces}.
Second, a higher-level usage would be to pass the new operator $A$ into a
{}\textit{Linear\-Solver\-Base} object to perform an atomic linear solve using
a direct or iterative linear solver.  Third, the highest-level usage of $A$
would be to pass $A$ to a {}\texttt{Linear\-Op\-With\-Solve\-Factory\-Base}
strategy object to create a {}\texttt{Linear\-Op\-With\-Solve\-Base} object
which then allows for any arbitrary method to solve for linear systems.  Note
that this last use is the most approriate for most nonlinear ANA algorithms
since it allows the most flexibility in how a linear system is solved.

{}\textit{Current status:} Some software of this type is contained in
TSFExtended.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces} (Only for the {}\texttt{Linear\-Op\-With\-Solve\-Factory\-Base})
interface
\end{itemize}

%
\subsubsection{Basic Linear Solver Status Test Interfaces}
%

These interfaces represent abstractions for status tests that are mainly
targeted to iterative solvers but can also be used for direct solvers (with
iterative refinement) as well.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LinearStatusTestBase}: Status test interface that allows clients
to specify when to stop a single, atomic linear solver.
%
\end{itemize}

{}\textit{Current status:} A superset of this interface is contained in
{}\texttt{belos/belos\_new/src/interfaces}.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\end{itemize}

%
\subsubsection{Basic Iterative Linear Solver Interfaces}
%

These are the basic interfaces that are needed to abstract block iterative
linear solvers (such as those in Belos) for a client that already has the
operator, preconditioner, RHS and inital LHS ready to go.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{BasicIterativeLinearSolverBase}: Basic linear iteration
interface to set problem and invoke iterations
%
\end{itemize}

{}\textit{Current status:} A superset of this interface is contained in
{}\texttt{belos/belos\_new/src/interfaces}.

{}\textit{Dependencies:}
\begin{itemize}
%
{}\item {}\textit{Operator/Vector Interfaces}
%
{}\item {}\textit{Basic Linear Solver Status Test Interfaces}: These status
tests are used to tell the concrete iterative linear solver implementations
when to stop.
%
\end{itemize}

%
\subsubsection{Basic Iterative Eigen Solver Interfaces}
%

These represent interfaces for abstracting basic block eigen solvers (such as
are being developed in Anasazi) from a client that has operators and problem
multi-vectors already created and initialized.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{BasicIterativeEigenSolverBase}: Interface representing an eign
solver that allows the problem operator(s) and multi-vectors to be set and
have the solver iterations started.
%
{}\item {}\texttt{EigenStatusTestBase}: A status test interface that lets the eign
solver know when to stop iterating.
%
\end{itemize}

{}\textit{Current status:} Aspects of this interface are currently in
{}\texttt{anasazi/src}

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\end{itemize}
%
\subsubsection{Linear Solver Manager Interfaces}
%

These interfaces represent a higher-level interface to direct or iterative
linear solvers than what is represented by the {}\textit{Basic Iterative
Linear Solver Interfaces}.  However, it is assumed that the underlying solve
involves a single atomic direct or iterative solve.  As a result, the more
detailed {}\textit{Basic Linear Solver Status Test Interfaces} can be used.
Composite, non-atomic solves are not allowed (see the {}\textit{Operator Solve
Interfaces} supporting the more general case).  This type of interface (or
interfaces) should be appropriate as an intermediate utility layer that lies
below the {}\textit{Operator Solve Interfaces}.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LinearSolverBase}: High-level linear solver interface that
accepts a {}\texttt{Linear\-Op\-Base} object, a RHS
{}\texttt{Multi\-Vector\-Base} object, and an initial LHS
{}\texttt{Multi\-Vector\-Base} object, then returns an approximate solution
LHS vector.
%
\end{itemize}

{}\textit{Current status:} An interface of this type is represented by the
current {}\texttt{TSFExtended\-::Linear\-Solver\-Base} interface but is not
general for multi-vectors.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Basic Linear Solver Status Test Interfaces}
\end{itemize}

{}\textbf{Note:} These interfaces do not depend in any way on the
{}\textit{Basic Iterative Linear Solver Interfaces} but concrete subclasses of
these interfaces might (see Item ???).

%
\subsubsection{Model Evaluator Interfaces}
%

A single interface will represent a large number of different type of problems
from steady-state nonlinear equations to transient optimization problems.
This one interface will be the universal interoperability interface for NOX,
LOCA, Rythmos, MOOCHO and almost any other nonlinear ANA.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{ModelEvaluatorBase}: The one do-all interface to nonlinear
problems!
%
\end{itemize}

{}\textit{Current status:} The beginnings of this in the {}\texttt{thyra} package.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces}: Used to represent the state
Jacobian matrix and allow for Jacobian solves.
\end{itemize}

%
\subsubsection{Steady-State Nonlinear Equation Solver Interfaces}
%

These represent interfaces for steady-state nonlinear solvers capable of
solving steady-state nonlinear problems of the form represented through the
{}\textit{Model Evaluator Interfaces} described above.  A client should be
able to define the problem in an abstract way, define relative residual or
relative solution tolerances, and then invoke the nonlinear solver.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{NonlinearSolverBase}: This interface allows a client to set
a {}\texttt{ModelEvaluatorBase} object, specify relative residual or solution
error tolerances, and then invoke the nonlinear solver.
%
\end{itemize}

{}\textit{Current status:} A prototype for this interface currently exists in
the {}\texttt{thyra} package.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces}
\item {}\textit{Model Evaluator Interfaces}
\end{itemize}

%
\subsubsection{Transient Nonlinear Equation Solver Interfaces}
%

These represent interfaces for transient nonlinear solvers capable of solving
transient nonlinear problems of the form represented through the
{}\textit{Model Evaluator Interfaces} described above.  A client should be
able to define the problem in an abstract way, invoke the time integrator and
have some control over what occurs.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{TransientNonlinearSolverBase}: This interface allows a
client to set a {}\texttt{ModelEvaluatorBase} object and then invoke the
transient nonlinear solver.
%
{}\item {}\texttt{TransientNonlinearStatusTestBase}: Defines NOX-style status tests?
%
{}\item There will be a series of interfaces that are yet to be determined and
the above are purely speculative.
%
\end{itemize}

{}\textit{Current status:} Interfaces like this may be developed as part of
the {}\texttt{rythmos} package.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces}
\item {}\textit{Model Evauator Interfaces}
\end{itemize}

%
\subsection{Thyra Non-ANA Interfaces}
%

These are useful interfaces that are not needed for the development or
interoperability of ANAs.  Instead, these interfaces define APP-LAL and
LAL-LAL interactions.  These interfaces and their dependencies are shown in
Figure~\ref{thyra:fig:ThyraNonANAInterfaces}.

%
\subsubsection{SPMD Matrix/Vector Load/Access Interfaces}
%

These represent the basic interfaces for loading and/or accessing the entries
of distributed memory vectors and sparse matrices in an SPMD environment.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LoadableVectorBase}, {}\texttt{LoadableMatrixBase},
{}\texttt{AccessibleVectorBase}, {}\texttt{RowAccessibleMatrixBase}
%
\end{itemize}

{}\textit{Current status:} These interfaces currently exist in various
subdirectories of TSFExtended.

{}\textit{Dependencies:}
\begin{itemize}
\item None!
\end{itemize}

%
\subsubsection{SPMD Matrix/Vector Creational Interfaces}
%

These are interfaces that allow the creation of loadable vectors and sparse
matrices given basic element-to-process distribution information.  These allow
an APP code to create and fill vector and matrix objects without having to
know what concrete implementation is begin used.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{LoadableVectorFactoryBase}: Factory interface for creating
{}\texttt{LoadableVectorBase} objects.
%
{}\item {}\texttt{LoadableVectorFactoryFactoryBase}: Factory interface for
creating {}\texttt{LoadableVectorFactoryBase} objects given a distribution of
elements to processors.
%
{}\item {}\texttt{LoadableMatrixFactoryBase}: Factory interface for creating
{}\texttt{LoadableVectorFactoryBase} objects for the rows and columns.
%
\end{itemize}

{}\textit{Current status:} The interface
{}\texttt{TSFExtended::VectorTypeExtensions} is a ``Facade'' that represents
all of this conbined functionality.  However,
{}\texttt{TSFExtended::VectorTypeExtensions} creates ANA-related objects such
as {}\texttt{VectorSpaceBase} objects that my not be needed by an application
code.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{SPMD Matrix/Vector Load/Access Interfaces}
\end{itemize}

{}\textbf{Note}: The current interfaces in TSFExtended depend on the
{}\textit{Operator/Vector Interfaces} which may be considered a violation
of the separation of concerns between ANA and non-ANA (i.e.\ APP and LALxx)
software.  This should be corrected in Thyra if possible.

%
\section{Thyra-Related Support Software}
%

This section describes software that is not central to interoperability but
instead provides useful infrastructure and utilities that is very helpful none
the less.  This software is broken up into ANA and non-ANA subcategories in
the following subsections.

%
\subsection{Thyra ANA Support Software}
%

This is support software needed to provide concrete implementation of Thyra
interfaces for use by ANAs.  These categories of software and there
dependancies are shown in Figure~\ref{thyra:fig:ThyraANASupportSoftware}.

%
\subsubsection{Operator/Vector Adapter Support}
%

This category contains adapter support subclasses for such things as MPI-based
SPMD implementations, client/server and master/slave configurations.  Each
particualar type of adapter support are independent and not related.  For
example, there is no depandancies between a client/server proxy vector
subclass and support for MPI-based SPMD implementations.  Note, these adapter
support subclasses only contain functionality needed by the
{}\textit{Operator/Vector Interfaces} and not the {}\textit{SPMD Matrix/Vector
Load/Access Interfaces}.

{}\textit{Current status:} This software currently is located in
{}\texttt{TSFCore/src/adapters}.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\end{itemize}

%
\subsubsection{Concrete Operator/Vector Adapters}
%

These are specific concrete adapter subclasses for adapting such
implementations such as Epetra and PETSc to {}\textit{Operator/Vector
Interface} objects.

{}\textit{Current status:} This software currently is located in
{}\texttt{TSFCore/src/adapters}.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator/Vector Support}
\end{itemize}

%
\subsubsection{ANA Development Utilities for Operator/Vector Interfaces}
%

This category contains convenience software to make the development of ANAs
using the {}\textit{Operator/Vector Interfaces} easier but do not require
any more functionality that just what is in the {}\textit{Operator/Vector
Interfaces}.  There are many different subcategories of this software but a
few of the more important ones are:

\begin{itemize}

{}\item{}\textbf{Unit testing classes}: These are classes for testing
the basic interfaces {}\texttt{Vector\-Base}, {}\texttt{Multi\-Vector\-Base},
{}\texttt{Linear\-Op\-Base}, and {}\texttt{Vector\-Space\-Base}.

{}\item{}\textbf{``Composite'' subclasses}: Product vectors, block operators,
multiplicative operators, additive operators etc.  Note that with respect to
composite linear operators, these utility classes are distinctly different
than those part of the {}\textit{Miscellaneous Extended Functionality
Interfaces}.  The difference is that the composite operator subclasses
described here define new linear operators that are only used for operator
applications (i.e.\ {}\texttt{apply(...)}).  On the other hand, the linear
operators that are created by the strategy objects in the
{}\textit{Miscellaneous Extended Functionality Interfaces} ultimately will be
used to solve for linear systems or other more specialized use.

{}\item{}\textbf{Handle classes and operator overloading}: Support for
MATLAB-like linear algebra notation in C++.

{}\item{}\textbf{Miscellaneous utilities}: Explicit vector access utilities
etc.  These are simply utility classes that call the explicit element access
functions in the {}\texttt{Vector\-Base} and the
{}\texttt{Multi\-Vector\-Base} objects and do not involve, in any way, the
{}\textit{{SPMD Matrix/Vector Load/Access Interfaces}}.

\end{itemize}

{}\textit{Current status:} This software currently is located in
{}\texttt{TSFCore/src/utilities} and in some respects also in TSFExtended.

{}\textit{Dependencies:}
\begin{itemize}
{}\item{}\textit{Operator/Vector Interfaces}
\end{itemize}

%
\subsubsection{Basic Iterative Linear Solver Implementations}
%

These are concrete implementations of block iterative linear solvers that only
deal with objects through the {}\textit{Operator/Vector Interfaces}.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item \texttt{Thyra::BlockCg}: Thin adapter subclass for
{}\texttt{Belos::BlockCG}
%
{}\item \texttt{Thyra::BlockGmres}: Thin adapter subclass for
{}\texttt{Belos::BlockGmres}
%
{}\item Etc...
%
\end{itemize}

{}\textit{Current status:} Such adapters do not exist because the interfaces
do not exist but the implementations of block CG and GMRES in Belos should
support these fairly easily.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Basic Linear Solver Status Test Interfaces}
\item {}\textit{Basic Iterative Linear Solver Interfaces}
\end{itemize}

%
\subsubsection{Basic Iterative Eigens Solver Implementations}
%

These are concrete implementations of block iterative eigen solvers that only
deal with objects through the {}\textit{Operator/Vector Interfaces}.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Thin adapter subclasses around current Anasazi solvers.
%
{}\item Etc...
%
\end{itemize}

{}\textit{Current status:} Such adapters do not exist because the interfaces
do not exist but the implementations of block eigen solvers in Anasazi should
support these fairly easily.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Basic Iterative Eigen Solver Interfaces}
\end{itemize}

%
\subsubsection{Concrete (Iterative) Linear Solver Manager Subclasses}
%

These are concrete subclasses of the {}\textit{Linear Solver Manager
Interfaces} that build a ``Facade'' for a complete atomic iterative linear
solver out of lower-level abstract objects which will include a) one or more
{}\texttt{Preconditioner\-Factory\-Base} objects, and b) one or more
{}\texttt{Basic\-Iterative\-Linear\-Solver\-Base} objects.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Example: {}\texttt{IterativeLinearSolverManager} ??? 
%
{}\item ...
%
\end{itemize}

{}\textit{Current status:} Some code in TSFExtended has this flavor but is not
exactly what is proposed here.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Basic Linear Solver Status Test Interfaces}
\item {}\textit{Basic Iterative Linear Solver Interfaces}
\item {}\textit{Miscellaneous Extended Functionality Interfaces}
(i.e.\ {}\texttt{Preconditioner\-Factory\-Base})
\end{itemize}

%
\subsubsection{Concrete Steady-State Nonlinear Equation Solver Implementations}
%

These represent concrete implementations of steady-state nonlinear equation
solvers.  For the most part, these will be thin adapter subclasses around NOX
but some other, more specialized, implementations may be needed as well.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{NOXNonlinearSolver}???
%
\end{itemize}

{}\textit{Current status:} NOX will be the most prevalent concrete
implementation of steady-state nonlinear equation solvers but there may be
other more specialized examples.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces}
\item {}\textit{Steady-State Nonlinear Problem Interfaces}
\item {}\textit{Steady-State Nonlinear Equation Solver Interfaces}
\end{itemize}

%
\subsubsection{Concrete Transient Nonlinear Equation Solver Implementations}
%

These represent concrete implementations of transient (explicit and implicit)
nonlinear equation solvers.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item ANA implementations of explicit and implicit ODE and/or DAE solvers.
%
\end{itemize}

{}\textit{Current status:} Nothing like this currently exist but development
is planned for FY2005 in Rythmos.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Operator Solve Interfaces}
\item {}\textit{Steady-State Nonlinear Problem Interfaces} to define the time-step system
\item {}\textit{Steady-State Nonlinear Equation Solver Interfaces} to solve the time-step system
\item {}\textit{Transient Nonlinear Problem Interfaces} used to access problem
\item {}\textit{Transient Nonlinear Equation Solver Interfaces} implemented here
\end{itemize}

%
\subsection{Non-ANA Support Software}
%

This is support software that provides implementations for the
{}\textit{Non-ANA Interfaces} described above and do not (or at least should
not) depend on {}\textit{ANA} software or interfaces in any way.

%
\subsubsection{Utilities for use of SPMD Matrix/Vector Load/Access and Creational Interfaces}
%

This category contains convience software to make to use of the {}\textit{SPMD
Matrix/Vector Load/Access Interfaces} and the {}\textit{SPMD Matrix/Vector
Creational Interfaces} easier for some individuals to use.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Handle classes that support load/access and creational interfaces.
%
\end{itemize}

{}\textit{Current status:} These handles are basically the current
{}\texttt{TSFExtended\-::Vector}, {}\texttt{TSFExtended\-::LinearOperator},
{}\texttt{TSFExtended\-::VectorType} etc.\ handle classes that are in use in
Sundance and Split.

{}\textit{Dependencies:}
\begin{itemize}
{}\item{}\textit{SPMD Matrix/Vector Load/Access Interfaces}
{}\item{}\textit{SPMD Matrix/Vector Creational Interfaces}
\end{itemize}

%
\subsubsection{SPMD Matrix/Vector Load/Access and Creational Adapter Support}
%

This category would contain any support software that helps to create concrete
subclasss implementations of the {}\textit{SPMD Matrix/Vector Load/Access
Interfaces} or the {}\textit{SPMD Matrix/Vector Creational Interfaces} without
being specific to a particular concrete implementation (e.g.\ Epetra or
PETSc).

{}\textit{Current status:} As far as I know there is basically none of this
software present in TSFExtended.


{}\textit{Dependencies:}
\begin{itemize}
{}\item{}\textit{SPMD Matrix/Vector Load/Access Interfaces}
{}\item{}\textit{SPMD Matrix/Vector Creational Interfaces}
\end{itemize}

%
\subsubsection{Concrete SPMD Matrix/Vector Load/Access and Creational Subclasses}
%

These are concrete implementations of subclasses that support the
{}\textit{SPMD Matrix/Vector Load/Access Interfaces} or the {}\textit{SPMD
Matrix/Vector Creational Interfaces}.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Epetra adapters
%
{}\item PETSc adapters
%
{}\item LAPACK/BLAS adapters
%
{}\item ...
%
\end{itemize}

{}\textit{Current status:} This software is currently contained in TSFExtended
in classes such as {}\texttt{TSFExtended\-::Epetra\-Vector},
{}\texttt{TSFExtended\-::Epetra\-Matrix},
{}\texttt{TSFExtended\-::Epetra\-Vector\-Type},
{}\texttt{TSFExtended\-::Epetra\-Vector\-Space} etc.

{}\textit{Dependencies:}
\begin{itemize}
{}\item{}\textit{SPMD Matrix/Vector Load/Access Interfaces}
{}\item{}\textit{SPMD Matrix/Vector Creational Interfaces}
{}\item{}\textit{SPMD Matrix/Vector Load/Access and Creational Adapter
Support}
\end{itemize}

%
\subsection{Mixed ANA and Non-ANA Support Software}
%

This is software that combines elements of ANA and Non-ANA software in such a
way that can not be specifically seperated out into one category or the other.

%
\subsubsection{Concrete Miscellaneous Non-ANA Extended Functionality Subclasses}
%

These are concrete implementations of extended functionality that can not have
general ANA implementations.  Examples include algebraic and multi-level
algebraic preconditioners.

%
\subsubsection{Concrete (Direct) Linear Solver Manager Subclasses}
%

These are concrete subclasses of the {}\textit{Linear Solver Manager
Interfaces} that builds a linear solver using Amesos for instance.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{AmesosLinearSolverManager}: Takes wrapped Epetra objects for
a linear system and calls a direct linear solver through an Amesos interface.
%
{}\item {}\texttt{LAPACKLinearSolverManager}: Takes a dense matrix and solves
the linear system using an LAPACK solver.  Actually, there may be several
different concrete LAPACK subclasses for different matrix types (i.e.\ general
(GE), symmetric (SY), s.p.d.\ (PO) etc.).
%
{}\item ...
%
\end{itemize}

{}\textit{Current status:} There is currently nothing like this in TSFCore or
TSFExteneded (that I know of) but an LAPACK subclasss was in the old TSF.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Basic Linear Solver Status Test Interfaces}
\item {}\textit{Linear Solver Manager Interfaces}
\end{itemize}

%
\subsubsection{Steady-State Nonlinear Problem Adapter Support}
%

These include usefull C++ classes and other software that provide basic
support for developing concrete steady-state nonlinear problems but are
independent of a specific application or physics.  Examples include support
software for the SPMD Load/Access and Creational interfaces or perhaps
directly for Epetra in the near term.

{}\textit{Current status:} There is nothing quite like this in existance that
I know of but with {}\textit{SPMD Matrix/Vector Load/Access Interfaces} and
the {}\textit{SPMD Matrix/Vector Creational Interfaces} available, these types
of support subclasses would make since.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Linear Solver Manager Interfaces} or some of the 
lower level interfaces to linear solvers and preconditoner factories.
\item {}\textit{Steady-State Nonlinear Problem Interfaces}
\item {}\textit{SPMD Matrix/Vector Load/Access Interfaces}
\item {}\textit{SPMD Matrix/Vector Creational Interfaces}
\end{itemize}

{}\textbf{Note}: If applications directly use the {}\textit{Thyra Non-ANA
Interfaces} then application subclasses can be directly created from these
subclasses in a way as to be independent of a particualar set of data
structures such as Epetra.

{}\textbf{Note}: This software is listed in the mixed ANA and Non-ANA support
category but there are some scenarios where this my be put into the ANA-only
support category if there is no reliance on the {}\textit{Thyra Non-ANA
Interfaces}.  For example, preconditioner factories and linear problem manager
interfaces can remove all interdependance on the Non-ANA interfaces listed
above in some cases.

%
\subsubsection{Concrete Steady-State Nonlinear Problem Subclasses}
%

These are concrete implementations of steady-state nonlinear problems that are
tied to a particular application of class of applications.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item {}\texttt{Epetra::NonlinearProblemBase}: Defines a steady-state
Nonlinear problem purely in terms of Epetra objects (i.e.\ like
{}\texttt{NOX\-::Epetra\-::Interface}.
%
{}\item {}\texttt{Thyra::EpetraNonlinearProblem}: Adapts an
{}\texttt{Epetra\-::Nonlinear\-Problem\-Base} object into a
{}\texttt{Thyra\-::Nonlinear\-Problem\-Base} object.  This class should derive
from a more general support subclass that has a linear solver factory etc.
%
\end{itemize}

{}\textit{Current status:} A prototype for this software currently exists in
{}\texttt{TSFCore/src/adapters/aztecoo}

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Linear Solver Manager Interfaces} or some of the 
lower level interfaces to linear solvers and preconditoner factories.
\item {}\textit{Operator Solve Interfaces}
\item {}\textit{Steady-State Nonlinear Problem Interfaces}
\item {}\textit{Steady-State Nonlinear Problem Adapter Support} ???
\end{itemize}

{}\textbf{Note}: One can write prefectly good concrete subclasses in this
category without dependance on any of the {}\textit{Thyra Non-ANA Interfaces}
listed above.  Using the {}\textit{Thyra Non-ANA Interfaces} directly means
that application codes may be written in such a way as to not be specific to
Epetra or some other concrete data structures.

%
\subsubsection{Transient Nonlinear Problem Adapter Support}
%

These include usefull C++ classes and other software that provide basic
support for developing concrete transient nonlinear problems but is
independent of a specific application or physics.  Examples include support
software for the SPMD Load/Access and Creational interfaces or perhaps Epetra.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item
%
\end{itemize}

{}\textit{Current status:}

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\end{itemize}

%
\subsubsection{Concrete Transient Nonlinear Problem Subclasses}
%

These are concrete implementations of transient nonlinear problems that are
tied to a particular application of class of applications.

{}\textit{Representative members:}
\begin{itemize}
%
{}\item Example: {}\texttt{PremoTransientNonlinearProblem}
%
{}\item Example: {}\texttt{XyceTransientNonlinearProblem}
%
{}\item ...
%
\end{itemize}

{}\textit{Current status:} Nothing like this currently exists in the form
suggested here.

{}\textit{Dependencies:}
\begin{itemize}
\item {}\textit{Operator/Vector Interfaces}
\item {}\textit{Transient Nonlinear Problem Interfaces}
\item {}\textit{Transient Nonlinear Problem Adapter Support}
\end{itemize}

%
\section{Software Dependency Diagrams}
%

Here are several UML package diagrams that outline the various dependencies in
Thyra.

However, note that the UML packages in these diagrams do not translate
directly into C++ namespaces as is typically the case.  Instead, the UML
packages in this diagram simply represent collections of interrelated software
that is appropriate to put in different sub-directories and help to define
basic interdependencies.

{\bsinglespace
\begin{figure}[p]
\begin{center}
%\fbox{
\includegraphics*[scale=0.70]{ThyraANAInterfaces}
%}
\end{center}
\caption{
\label{thyra:fig:ThyraANAInterfaces}
Dependencies between different categories of {}\textit{Thyra ANA Interfaces}.
}
\end{figure}
\esinglespace}

{\bsinglespace
\begin{figure}[p]
\begin{center}
%\fbox{
\includegraphics*[scale=0.70]{ThyraNonANAInterfaces}
%}
\end{center}
\caption{
\label{thyra:fig:ThyraNonANAInterfaces}
Dependencies between different categories of {}\textit{Thyra Non-ANA Interfaces}.
}
\end{figure}
\esinglespace}

{\bsinglespace
\begin{figure}[p]
\begin{center}
%\fbox{
\includegraphics*[scale=0.70]{ThyraANASupportSoftware}
%}
\end{center}
\caption{
\label{thyra:fig:ThyraANASupportSoftware}
Dependencies between different categories of {}\textit{Thyra ANA Support Software}.
}
\end{figure}
\esinglespace}

%
\section{Partitioning of Thyra into Packages and Subdirectories}
%

In this section, we try to map the various categories of software described
above into Trilinos packages and subdirectories.  In the next subsection, a
detailed long-term plan for the directory structure is given along with some
minimal descriptions of what is contained in what directory or subdirectory.
In the subsection later, a current or soon-to-be-current subset of this full
directory structure is presented.  The purpose of having a long-term and a
short-term directory structure (with the short-term being a subset of the
long-term) is to allow the short-term description to be much more concise.

%
\subsection{Long-term directory structure}
%

In this section we show how the various categories of software described above
may be translated into Trilinos packages and subdirectories in the future.  It
is important to remember the basic dependancies represented here.  This
package and directory structure will be modified as time goes on.  A subset of
this directory structure that reflects current or soon-to-be-current structure
is shown in the next subsection.

\noindent{}\textbf{Trilinos packages and subdirectories:}
%

\bifthen
\>\texttt{thyra} \\
\>\>\texttt{doc}\\
\>\>\>Contains Doxyfile and index.doc for all of Thyra (roadmap) \\
\>\>\texttt{src} \\
\>\>\>\texttt{utils}\\
\>\>\>\>Contains some utility software not directly related to any category \\
\>\>\>\texttt{ana} \\
\>\>\>\>\texttt{doc}\\
\>\>\>\>\>Contains Doxyfile and index.doc for all Thyra ANA software \\
\>\>\>\>\texttt{rtop}\\
\>\>\>\>\>\texttt{doc}\\
\>\>\>\>\>\>Contains Doxyfile and index.doc for a doxygen collection \\
\>\>\>\>\>\texttt{base}\\
\>\>\>\>\>\>Contains Fundamentals of RTOp as well as some utilities \\
\>\>\>\>\>\texttt{ops\_lib}\\
\>\>\>\>\>\>Contains lots of standard and non-standard RTOp implementation \\
\>\>\>\>\texttt{operator\_vector} \\
\>\>\>\>\>\texttt{doc}\\
\>\>\>\>\>\>Contains Doxyfile and index.doc for this software \\
\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>Contains {}\textit{Operator/Vector Interfaces} \\
\>\>\>\>\>\texttt{extended\_interfaces} \\
\>\>\>\>\>\>Contains {}\textit{Operator Solver Interfaces} \\
\>\>\>\>\>\>Contains a subset {}\textit{Miscellaneous Extended Functionality Interfaces} \\
\>\>\>\>\>\>\>that depends only on the {}\textit{Operator/Vector Interfaces} \\
\>\>\>\>\>\texttt{ana\_support}\\
\>\>\>\>\>\>Contains {}\textit{ANA Development Utilitiies for Operator/Vector Interfaces} \\
\>\>\>\>\>\texttt{adapter\_support}\\
\>\>\>\>\>\>Contains {}\textit{Operator/Vector Adapter Support} \\
\>\>\>\>\>\>\texttt{serial}\\
\>\>\>\>\>\>\>Contains additional adapter support software for serial implementations \\
\>\>\>\>\>\>\texttt{mpi}\\
\>\>\>\>\>\>\>Contains adapter support software for MPI, SPMD implementations \\
\>\>\>\>\texttt{basic\_linear\_solvers} \\
\>\>\>\>\>\texttt{doc}\\
\>\>\>\>\>\>Contains Doxyfile and index.doc for this software \\
\>\>\>\>\>\texttt{status\_tests} \\
\>\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>\>Contains {}\textit{Basic Linear Solver Status Test Interfaces} \\
\>\>\>\>\>\>\texttt{implementations} \\
\>\>\>\>\>\>\>Contains {}\textit{Basic Linear Solver Status Test Implementations} \\
\>\>\>\>\>\texttt{iterative\_linear\_solvers} \\
\>\>\>\>\>\>\texttt{basic\_iterative\_linear\_solvers} \\
\>\>\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>\>\>Contains {}\textit{Basic Iterative Linear Solver Interfaces} \\
\>\>\>\>\>\>\texttt{linear\_solver\_managers} \\
\>\>\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>\>\>Contains {}\textit{Linear Solver Manager Interfaces} \\
\>\>\>\>\texttt{nonlinear} \\
\>\>\>\>\>\texttt{doc}\\
\>\>\>\>\>\>Contains Doxyfile and index.doc for this software \\
\>\>\>\>\>\texttt{model\_evaluator} \\
\>\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>\>Contains {}\textit{Model Evaluator Interfaces} \\
\>\>\>\>\>\>\texttt{ana\_support} \\
\>\>\>\>\>\>\>Contains general ANA support software for {}\textit{Model Evaluator Interfaces} \\
\>\>\>\>\>\texttt{solvers} \\
\>\>\>\>\>\>\texttt{interfaces} \\
\>\>\>\>\>\>\>Contains {}\textit{Steady-State Nonlinear Solver Interfaces} \\
\>\>\>\>\>\>\texttt{ana\_support} \\
\>\>\>\>\>\>\>Contains general ANA support software for {}\textit{Steady-State Nonlinear Solver Interfaces} \\
\>\>\>\texttt{nonana} ??? \\
\>\>\>\>\texttt{doc}\\
\>\>\>\>\>Contains Doxyfile and index.doc for all non-ANA Thyra software \\
\>\>\>\>\texttt{spmd\_matrix\_vector} ??? \\
\>\>\>\>\>\texttt{doc}\\
\>\>\>\>\>\>Contains Doxyfile and index.doc for this software \\
\>\>\>\>\>Contains {}\textit{SPMD Matrix/Vector Load/Access Interfaces} ??? \\
\>\>\>\>\>Contains {}\textit{SPMD Matrix/Vector Creational Interfaces} ??? \\
\>\>\texttt{example} \\
\>\>\>\texttt{utils}\\
\>\>\>\texttt{ana} \\
\>\>\>\>\texttt{rtop}\\
\>\>\>\>\texttt{operator\_vector} \\
\>\>\texttt{test} \\
\>\>\>\texttt{utils}\\
\>\>\>\texttt{ana} \\
\>\>\>\>\texttt{rtop}\\
\>\>\>\>\texttt{operator\_vector} \\
\\
\>\texttt{epetra} \\
\>\>\texttt{src} \\
\>\>\>\texttt{thyra} \\
\>\>\>\>Contains \texttt{EpetraLinearOp} subclass and support software \\
\\
\>\texttt{epetraext} \\
\>\>\texttt{src} \\
\>\>\>\texttt{nonlinear\_problems} \\
\>\>\>\>Contains application-centric \texttt{Epetra::NonlinearProblemBase} interface \\
\>\>\>\texttt{transient\_nonlinear\_problems} \\
\>\>\>\>Contains application-centric \texttt{Epetra::TransientNonlinearProblemBase} interface \\
\>\>\>\texttt{thyra} \\
\>\>\>\>\texttt{nonlinear\_problems} \\
\>\>\>\>\>Contains adapter(s) from \texttt{Epetra::NonlinearProblemBase} \\
\>\>\>\>\>to \texttt{Thyra::NonlinearProblemBase} \\
\>\>\>\>\texttt{transient\_nonlinear\_problems} \\
\>\>\>\>\>Contains adapter(s) from \texttt{Epetra::TransientNonlinearProblemBase}\\
\>\>\>\>\>to \texttt{Thyra::TransientNonlinearProblemBase} \\
\eifthen

%
\subsection{Short-term/current Trilinos package/directory structure}
%

In this section we show the current or the soon-to-be-current directory
structure of Thyra.  This structure is a subset of the long-term planned
directory structure in the previous section which contains some documentation.
A summary of the current or soon-to-be-current directory structure is shown in
Figure~\ref{thyra:fig:curr_dir_structure}.

\begin{figure}
\begin{verbatim}
Trilinos
|
|- packages
   |
   |- thyra
   |  |- doc
   |  |- src
   |  |  |- utils
   |  |  |- ana
   |  |     |- doc
   |  |     |- rtop
   |  |     |  |- doc
   |  |     |  |- base
   |  |     |  |- ops_lib
   |  |     |- operator_vector
   |  |     |  |- doc
   |  |     |  |- interfaces
   |  |     |  |- extended_interfaces
   |  |     |  |- ana_support
   |  |     |  |- adapter_support
   |  |     |     |- serial
   |  |     |     |- mpi
   |  |     |- nonlinear
   |  |        |- doc
   |  |        |- model_evaluator
   |  |        |  |- interfaces
   |  |        |  |- ana_support
   |  |        |- solvers
   |  |           |- interfaces
   |  |           |- ana_support
   |  |- example
   |  |  |- utils
   |  |  |- ana
   |  |     |- rtop
   |  |     |- operator_vector
   |  |     |- nonlinear
   |  |- test
   |     |- utils
   |     |- ana
   |        |- rtop
   |        |- operator_vector
   |        |- nonlinear
\end{verbatim}
\caption{
\label{thyra:fig:curr_dir_structure}
Current directory structure for Thyra-related Trilinos packages.
}
\end{figure}

\clearpage

% ---------------------------------------------------------------------- %
% References
%
\clearpage
%\bibliographystyle{plain}
%\bibliography{references}
%\addcontentsline{toc}{section}{References}

% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%
%\appendix

\begin{SANDdistribution}
% External
% Housekeeping copies necessary for every unclassified report:
\SANDdistInternal{1}{9018}{Central Technical Files}{8945-1}
\SANDdistInternal{2}{0899}{Technical Library}{9610}
\SANDdistInternal{2}{0612}{Review \& Approval Desk}{4916}
% If report has a Patent Caution or Patent Interest, add this:
%\SANDdistInternal{3}{0161}{Patent and Licensing Office}{4916}
\end{SANDdistribution}

\end{document}
