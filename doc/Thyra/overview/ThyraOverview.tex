\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}
%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}
\newtheorem{dumb_fact}{Dumb Fact}[section]

\raggedright

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{\center
Thyra Linear Operators and Vectors\\[2ex]
{\Large Overview of Interfaces and Support Software for
the Development and Interoperability of Abstract Numerical Algorithms}}

\author{
Roscoe A. Bartlett \\ Optimization/Uncertainty Estim}

\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2007-xxx}
\SANDprintDate{??? 2007}
\SANDauthor{
Roscoe A. Bartlett \\ Optimization and Uncertainty Quantification  \\ \\
}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for general release}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Engineering and scientific applications are becoming increasingly modular,
utilizing publicly defined interfaces to integrate third party tools and
libraries for services such as mesh generation, data partitioning, equation
solvers and optimization.  As a result, it is important to understand and
model the interactions between these various modules, and to develop good
abstract interfaces between them.  One category of modules that is becoming
increasingly important is abstract numerical algorithms (ANAs).  ANAs such as
linear and nonlinear equation solvers, methods for stability and bifurcation
analysis, uncertainty quantification methods and nonlinear programming solvers
for optimization are typically mathematically sophisticated but have
surprisingly little essential dependence on the details of what computer
system is being used or how matrices and vectors are stored and computed.  As
a result, using abstract interface capabilities in languages such as C++, we
can implement ANA software that it will work, unchanged, with a variety of
applications and linear algebra libraries.

In this paper, we provide an overview of the Thyra effort which at its most
basic level defines fundamental abstract linear operator and vector
interfaces.  These linear operator/vector interfaces provide the basic
functionality and interoperability for a broad range of ANAs.  Many other
higher-level abstractions are built on top of the Thyra operator/vector
interfaces. The Trilinos package {}\texttt{thyra} defines these different sets
of C++ interfaces and provides optional support software.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgement section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
\clearpage
\section*{Acknowledgment}
The authors would like to thank everyone on the Trilinos team for their
support in the Thyra effort.

The format of this report is based on information found
in~\cite{Sand98-0730}.

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% An optional preface or Foreword
%\clearpage
%\section{Preface}
%Although muggles usually have only limited experience with
%magic, and many even dispute its existence, it is worthwhile
%to be open minded and explore the possibilities.

% ---------------------------------------------------------------------- %
% An optional executive summary
%\clearpage
%\section{Summary}
%Once a certain level of mistrust and scepticism has
%been overcome, magic finds many uses in todays science
%and engineering. In this report we explain some of the
%fundamental spells and instruments of magic and wizardry. We
%then conclude with a few examples on how they can be used
%in daily activities at national Laboratories.

% ---------------------------------------------------------------------- %
% An optional glossary. We don't want it to be numbered
%\clearpage
%\section*{Nomenclature}
%\addcontentsline{toc}{section}{Nomenclature}
%\begin{itemize}
%\item[alohomora]
%spell to open locked doors and containers
%\end{itemize}

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\SANDmain % Start the main part of the report

\section{Introduction}

One area of steady improvement in large-scale engineering and
scientific applications is the increased modularity of application
design and development.  Specification of publicly-defined interfaces,
combined with the use of third-party software to satisfy critical
technology needs in areas such as mesh generation, data partitioning
and solution methods have been generally positive developments in
application design.  While the use of third party software introduces
dependencies from the application developer's perspective, it also
gives the application access to the latest technology in these areas,
amortizes library and tool development across multiple applications
and, if properly designed, gives the application easy access to more
than one option for each critical technology area, e.g., access to
multiple linear solver packages.

One category of modules that is becoming increasingly important is abstract
numerical algorithms (ANAs).  ANAs such as linear and nonlinear equation
solvers, methods for stability and bifurcation analysis, transient solvers,
uncertainty quantification methods, and nonlinear programming solvers for
optimization are typically mathematically sophisticated but have surprisingly
little essential dependence on the details of what computer system is being
used or how matrices and vectors are stored and computed.  Thus, by using
abstract interface capabilities in languages such as C++, we can implement ANA
software such that it will work, unchanged, with a variety of applications and
linear algebra libraries.

%Such an approach is often referred to as {\it
%generic programming}~\cite{ref:boost_generic_programming}.

Here we describe a set of abstract operator/vector interfaces that allows the
specification of ANAs from basic Krylov linear equation solvers all the way up
to interior-point methods for optimization.  At the core, we define a set of
basic operator/vector interfaces that form the the foundation for (i) ANA
development, (ii) the integration of an ANA into an application (APP) and
(iii) providing services to the ANA from a linear algebra library (LAL).  By
agreeing on a simple minimal common interface layer such as the Fundamental
Thyra ANA Operator/Vector Interfaces described here, we eliminate the
many-to-many dependency problem of ANA/APP interfaces.

%While these Thyra interfaces provide a mechanism to express all of the
%functionality required to be directly used in ANA development it does not
%attempt to provide a full collection of methods that directly support the
%anticipated functionality needs of ANAs.  Instead they rely on a simple but
%powerful reduction and transformation operator mechanism~\cite{ref:rtop_toms}
%that can be used to express any element-wise vector reduction or
%transformation operation.  Additional functionality to support both the
%development of ANAs and the implementation of the operator/vector interfaces
%is being added to the Thyra package all the time but this is not the focus of
%this discussion.

It is difficult to describe a set of linear algebra interfaces outside of the
context of some class of numerical problems.  For this purpose, we will
consider numerical algorithms where it is possible to implement all of the
required operations exclusively through well defined interfaces to vectors,
vector spaces, and linear operators and higher level abstractions built on
these.  The fundamental Thyra operator/vector interfaces described here are
the common denominator of all abstract numerical algorithms.

We assume that the reader has a basic understanding of vector
reduction/transformation operators (RTOp) {}\cite{ref:rtop_toms}, is
comfortable with object-orientation {}\cite{ref:gama_et_al_1995} and C++, and
knows how to read basic Unified Modeling Language (UML)
{}\cite{ref:uml_distilled_2nd_ed} class diagrams.  We also assume that the
reader has some background in large-scale numerics and will therefore be able
to appreciate the challenges that are addressed by Thyra.

Note that the online documentation for Thyra at

\hspace{4ex}{}\texttt{http://trilinos.sandia.gov/packages/thyra}

{}\noindent{}should be the definitive information source for Thyra.  This
document only tries to provide an overview of Thyra and explain the philosophy
behind it.

%
\section{Classification of linear algebra and other interfaces}
\label{thyra:sec:classification_of_lin_alg_itfc}
%

Although we will discuss APPs, ANAs and LALs in detail later in this section,
we want to briefly introduce these terms here to make them clear.  Also,
although there are certainly other types of modules in a large-scale
scientific/engineering application, we only focus on these three since they
are the ones more directly related to ANAs.
%
\begin{itemize}
%
{}\item Application (APP): The modules of an application that are not ANA or
LAL modules.  Typically this includes the code that is unique to the
application itself such as the code that formulates and generates the discrete
problem to be solved.  In general it would also include other third-party
software that is not an ANA or LAL module.
%
{}\item Abstract Numerical Algorithm (ANA): Software that drives a solution
process, e.g., an iterative linear or nonlinear solver.  This type of package
provides solutions to and requires services from the APP, and utilizes
services from one or more LALs.  It can usually be written so that it does not
depend on the details of the computer platform, or the details of how the APP
and LALs are implemented, so that an ANA can be used across many APPs and with
many LALs.
%
{}\item Linear Algebra Library (LAL): Software that provides the ability to
construct concrete linear algebra objects such as matrices and vectors.  A LAL
can also be a specific linear solver or preconditioner.
%
\end{itemize}

An important focus of this paper is to clearly identify the interactions
between APPs, ANAs and LALs for the purposes of defining the Thyra interfaces
and to differentiate the Thyra interfaces from other interfacing efforts.

The requirements for the linear algebra objects as imposed by an ANA are very
different from the requirements imposed by an APP code.  In order to
differentiate the various types of interfaces and the requirements associated
with each, consider Figure {}\ref{thyra:fig:ANA_LAL_APP}.  This figure shows
the three major categories of software modules that make up a complete
numerical application.  The first category is application (APP) software in
which the underlying data is defined for the problem.  This could be something
as simple as the right-hand-side and matrix coefficients of a single linear
system or as complex as a finite-element method for a 3-D nonlinear
PDE-constrained optimization problem.  The second category is linear algebra
library (LAL) software that implements basic linear algebra operations
{}\cite{ref:demmel_1997, ref:anderson_1995, ref:blackford_et_al_1997,
ref:aztec, ref:petsc, ref:trilinos}. These types of software include primarily
matrix-vector multiplication, the creation of a preconditioner (e.g.~ILU), and
may even include several different types of direct linear solvers.  The third
category is ANA software that drives the main solution process and includes
such algorithms as iterative methods for linear and nonlinear systems;
explicit and implicit methods for ODEs and DAEs; and nonlinear programming
(NLP) solvers {}\cite{ref:nocedal_wright_1999}.  There are many example
software packages {}\cite{ref:petsc,ref:aztec,ref:trilinos,ref:pvode,ref:tao}
that contain ANA software.

{\bsinglespace
\begin{figure}[p]
\begin{center}
%\fbox{
\includegraphics*[bb= 0.245in 2.95in 10.85in 8.60in,angle=0,scale=0.50
]{analal}
%}
\end{center}
\caption{
\label{thyra:fig:ANA_LAL_APP}
UML {}\cite{ref:booch_et_al_1999} class diagram : Interfaces between abstract numerical algorithm
(ANA), linear algebra library (LAL), and application (APP) software.
}
\end{figure}
\esinglespace}

The types of ANAs described here only require operations like matrix-vector
multiplication, linear solves and certain types of vector reduction and
transformation operations.  All of these operations can be performed with only
a very abstract view of vectors, vector spaces and linear operators.

An application code, however, has the responsibility of populating vector and
matrix objects and requires the passing of explicit function and gradient
value entries, sometimes in a distributed memory parallel environment.  This
is the purpose of an APP/LAL interface.  This involves a very different set of
requirements than those described above for the ANA/APP and ANA/LAL
interfaces.  Examples of APP/LAL interfaces include the FEI {}\cite{ref:fei}
and much of the ESI {}\cite{ref:esi_2001}.

Figure {}\ref{thyra:fig:ANA_LAL_APP} also shows a set of LAL/LAL interfaces
that allows linear algebra objects from one LAL to collaborate with the
objects from another LAL.  Theses interfaces are very similar to the APP/LAL
interfaces and the requirements for this type of interface is also not
addressed by Thyra.  The ESI {}\cite{ref:esi_2001} contains examples of
LAL/LAL interfaces.

%{}\textbf{ToDo:} Describe interactions between ANAs like a nonlinear equation
%solver needing linear equation solver and a nonlinear time integrator needing
%a nonlinear equation solver.

%
\section{Some Basic Requirements for Thyra}
\label{thyra:sec:Thyra_requirements}
%

Before describing the C++ interfaces for Thyra, some basic requirements are
stated.

\begin{enumerate}

{}\item Thyra interfaces should be portable to all the ASC
{}\cite{ref:doe_asci} platforms where ASC applications might run and to other
important platforms.

{}\item Thyra interfaces should provide for stable and accurate numerical
computations at a fundamental level.

{}\item Thyra should provide a minimal, but complete, interface that addresses
all the basic efficiency needs (in both speed and storage) which will result
in near-optimal implementations of all of the objects and all of the above
mentioned ANA algorithms that use these objects.

%All other types of
%nonessential but convenient functionality (e.g.~Matlab-like syntax using
%operator overloading, see Section~\ref{thyra:sec:operator_overloading}) will
%not be addressed by Thyra.  This extra functionality can be built on top the
%basic Thyra abstractions (e.g.~using TSF).

{}\item Maximally general ANAs developed with Thyra should be able to
transparently utilize different types of computing environments such as
SPMD\footnote{Single Program Multiple Data (SPMD): A single program running in
a distributed-memory environment on multiple parallel processors},
client/server\footnote{Client/Server: The ANA runs in a process on a client
computer and the APP and LAL run in processors on a server},
out-of-core\footnote{Out-of-core: The data for the problem is stored on disk
and is read from and written to back disk as needed}, and any combination of
these configurations.

{}\item The work required to implement adapter subclasses (see the ``Adapter''
pattern in {}\cite{ref:gama_et_al_1995}) for and with Thyra should be minimal
and straightforward for all of the existing related linear algebra and ANA
interfaces.  This requirement is facilitated by the fact that the Thyra
interfaces are minimal.

\end{enumerate}

A hand-coded program (e.g.~using Fortran 77 and MPI) should not provide any
significant gains in performance in any of the above categories in any
computing environment or configuration.  A hand-coded algorithm in Fortran 77
with MPI should not be able to provide significant improvements in storage
requirements, computational speed, or numerical stability.  There are many
numerical algorithms can can not be considered to be ``abstract'' (e.g.\
Gaussian Elimination) and therefore Thyra and like abstract interfaces should
not be used for such algorithms.  However, drawly the line between an ANA and
a non-ANA can be quite fuzzy in practice.

%
\section{Mathematical Foundation for Fundamental Thyra ANA Operator/Vector Interfaces}
\label{thyra:sec:Thyra_math_foundation}
%

Before describing the {}\textit{Thyra Fundamental ANA Operator/Vector
Interfaces} that form the foundation for all of the Thyra ANA interfaces in
more detail, we must first clearly define the mathematical foundation for the
abstractions of vectors, vector spaces, and linear operators.

All Thyra vectors belong to a vector space and are representable as an array
of scalar coefficients $\tilde{x}\in\RE^n$ and a (non-unique) basis
$E\in\RE^{n\times{}n}$ of the form
%
\begin{equation}
x = E \tilde{x}.
\end{equation}
%
For a given Thyra vector space, the basis representation
$E\in\RE^{n\times{}n}$ is non-unique but the symmetric positive definite
scalar (inner) product matrix
%
\begin{equation}
Q = E^H E
\end{equation}
%
where $Q\in\RE^{n\times{}n}$ is unique.  Given $Q\in\RE^{n\times{}n}$, the scalar product
is defined as
%
\begin{equation}
x^H y = \tilde{x}^H Q \tilde{y} = <\tilde{x},\tilde{y}>.
\end{equation}
%
For $Q\in\RE^{n\times{}n}$ to be full rank, $E\in\RE^{n\times{}n}$ must be
full rank.  Here we define a Euclidean vector space as one where
$E=I\in\RE^{n\times{}n}$ and $Q=E^H E=I\in\RE^{n\times{}n}$.

In Thyra, vector spaces and vectors are abstracted using the C++ base
interface classes {}\texttt{Thyra::\-Vector\-Space\-Base} and
{}\texttt{Thyra::\-Vector\-Base} respectively.  Vectors are created from a
vector space using the ``Abstract Factory'' design pattern using the nonmember
function {}\texttt{create\-Member(vecSpc)}.

In addition to vectors and vector spaces, Thyra also defines linear operators
which linearly map vectors from one vector space to another.  The definition of
a linear operator is strongly influenced by the definition of the scalar
product associated with the vector spaces and whether the mapping is between
Euclidean vectors $y = A x$ or between coefficient vectors $\tilde{y} =
\tilde{A} {}\tilde{x}$.
% (see [???] for more details).
In Thyra, vectors are a specialization of linear operators and therefore every
vector is also a linear operator.  Therefore, when one writes
%
\begin{equation}
z = x^H y
\end{equation}
%
then $x^H$ must be interpreted to be the adjoint linear operator of $x$.

Given this notation, the vector $x$ would be considered to live an Euclidean
vector space $x\in\RE^n$ while the vector $\tilde{x}$ would be considered to
live in the non-Euclidean vector space $\tilde{x}\in\mathcal{X}$ which is
defined by the scalar product matrix $Q\in\RE^{n\times{}n}$.  Therefore, it is
actually not clear whether an abstract vector object represents the Euclidean
vector $x\in\RE^n$ which just happens to be stored as a set of coefficients
$\tilde{x}\in\mathcal{X}$ or if it represents the coefficient vectors
$\tilde{x}\in\mathcal{X}$ themselves.  This ambiguity of the interpretation of
vectors and linear operators also results from the ambiguity of interpretation
of the vectors in that they can be thought of as the Euclidean linear operators
that only update the coefficient vectors or as linear operators that act
directly on vector coefficients.

The Fundamental Thyra ANA Operator/Vector Interfaces require that every Thyra
vector be represented as a finite-dimensional set of scalar coefficients and
that the scalar product $<\tilde{x},\tilde{y}>$ be equivalent to the two-sided
application some finite-dimensional symmetric positive definite matrix
$Q\in\RE^{n\times{}n}$ such that $<\tilde{x},\tilde{y}> = \tilde{x}^H Q
{}\tilde{y}$.  The Thyra interfaces do not try to pretend that its vectors are
infinite dimensional or that they admit more general implementations as
allowed by infinite dimensional Hilbert spaces.
%[???].
While every Thyra vector must be stored as a set of scalar coefficients the
interfaces make no assumptions whatsoever about where or how those
coefficients are stored.  A fully general ANA can make no assumptions about
how vectors are stored or laid out in memory, only that those coefficients do
exist and that the coefficients can be exposed to reduction and transformation
operators (see {}\cite{ref:rtop_toms}).

While accessing the elements of a vector is ill advised in a general ANA, the
Thyra vector interface supports acquiring direct views of any range of vector
coefficient data (see
{}\texttt{Thyra::\-Vector\-Base\-::\-acquireDetachedView(...)}).

Again, thyra does not try to hide the fact that a vector is simply a set of
scalar coefficients associated with some basis.  Thyra does not even really
try to keep the client from accessing the actual coefficients of the vectors
since it can access them with an RTOp object if desired.  What Thyra does do
is to abstract where the vector coefficients live and what native data
structure is used to hold the coefficients.  None of vector coefficients may
even be directly be head in main memory in the process where the ANA is
running but there is aways a (perhaps very inefficient) mechanism to get a
view of them.  ANAs that want to be maximally general and efficient should not
try to directly access the vector elements explicitly and many ANAs do not
need to.  However, there are perfectly reasonable ANAs that do need to access
the explicit vector coefficients for vectors from certain vector spaces (such
as vectors in the design space in some reduced-space optimization algorithms)
and Thyra provides efficient and yet 100\% general ways to access these
coefficients.  Every Thyra vector space also has a finite dimension that is
accessible as a property of the vector space and in integer value.

While Thyra requires vectors to be finite dimensional and the vector
coefficients must be accessible (if to none other than to RTOps), it allows
complete freedom in the implementation of scalar products of general linear
operators that map vectors from one vector space to another.

%
\section{Overview of Fundamental Thyra ANA Operator/Vector Interfaces}
\label{thyra:sec:Thyra_core_overview}
%

{\bsinglespace
\begin{figure}[p]
\begin{center}
%\fbox{
\includegraphics*[bb= 0.0in 0.0in 3.3in 4.4in,scale=0.40
]{UML1}
%}%fbox
%\fbox{
\includegraphics*[scale=0.65]{ThyraOperatorVector}
%}%fbox
\end{center}
\caption{
\label{thyra:fig:basic_op_vec_itfc}
UML class diagram : The fundamental Thyra ANA operator/vector interfaces }
\end{figure}
\esinglespace}

The Fundamental Thyra ANA Operator/Vector Interfaces are shown in Figure
{}\ref{thyra:fig:basic_op_vec_itfc}.
%  Complete C++ class declarations for
%these interfaces are given in Appendix {}\ref{app:thyra_classes}.
The key abstractions include vectors, vector spaces, and linear operators.
All of the interfaces are templated on the {}\texttt{Scalar} type (the UML
notation for templated classes is not used in the figure for the sake of
improving readability).

Vector space is the foundation for all other abstractions.  Vector spaces are
abstracted through the {}\texttt{\textit{Vector\-Space\-Base}} interface.  A
{}\texttt{\textit{Vector\-Space\-Base}} object acts primarily as an ``Abstract
Factory'' {}\cite{ref:gama_et_al_1995} that creates vector objects (which are
the ``products'' in the ``Abstract Factory'' design pattern).

Vectors are abstracted through the {}\texttt{\textit{Vector\-Base}} interface.
The {}\texttt{\textit{Vector\-Base}} interface is very minimal and really only
defines one nontrivial function {}\texttt{\textit{applyOp(\-...)}}.  The
{}\texttt{\textit{applyOp(\-...)}} function accepts user-defined
(i.e.~ANA-defined) reduction/transformation operator (RTOp) objects through
the templated RTOp C++ interface {}\texttt{\textit{RTOpPack::RTOpT}}.  An ever
increasing set of concrete implementations of RTOps is provided along with
wrapper convenience functions in the ANA support code collection.  The set of
operations is also easily extensible.  Every {}\texttt{\textit{Vector\-Base}}
object provides access to its {}\texttt{\textit{Vector\-Space\-Base}} (that
was used to create the {}\texttt{\textit{Vector\-Base}} object) through the
function {}\texttt{space()}.

The {}\texttt{\textit{Vector\-Space\-Base}} interface also provides the
ability to create {}\texttt{\textit{Multi\-Vector\-Base}} objects through the
{}\texttt{\textit{createMembers(numMembers)}} function.  A
{}\texttt{\textit{Multi\-Vector\-Base}} is a tall thin dense matrix where each
column in the matrix is a {}\texttt{\textit{Vector\-Base}} object which is
accessible through the {}\texttt{\textit{col(...)}} function.
{}\texttt{\textit{Multi\-Vector\-Base}}s are needed for near-optimal processor
cache performance (in serial and parallel programs) and to minimize the number
of global communications in a distributed parallel environment.  The
{}\texttt{\textit{Multi\-Vector\-Base}} interface is useful in many different
types ANAs such as block Krylov methods.  The interface class
{}\texttt{\textit{Vector\-Base}} is derived from
{}\texttt{\textit{Multi\-Vector\-Base}} so that every
{}\texttt{\textit{Vector\-Base}} is a {}\texttt{\textit{Multi\-Vector\-Base}}.
This simplifies the development of ANAs in that any ANA that can handle
{}\texttt{\textit{Multi\-Vector\-Base}} objects should automatically be able
to accept {}\texttt{\textit{Vector\-Base}} objects as well.

{}\texttt{\textit{Vector\-Space\-Base}} declares a virtual function called
{}\texttt{\textit{scalarProd(x,y)}} which computes the scalar product $<x,y>$
for the vector space.  There is also a {}\texttt{\textit{Multi\-Vector\-Base}}
version {}\texttt{\textit{Vector\-Space\-Base\-::scalarProds(...)}}  (not
shown in the figure) that computes the scalar products of each set of column
vectors in two multi-vectors.  Finally,
{}\texttt{\textit{Vector\-Space\-Base}} also includes the ability to determine
the compatibility of vectors from different vector spaces through the function
{}\texttt{\textit{isCompatible(vecSpc)}}.  This is useful primarily for error
checking and debugging.
%(see Section~\ref{thyra:sec:vec_spc_compatibility}).

Another important type of linear algebra abstraction is a linear operator
which is represented by the interface class
{}\texttt{\textit{Linear\-Op\-Base}}.  The
{}\texttt{\textit{Linear\-Op\-Base}} interface is used to represent quantities
such as a Jacobian matrix. A {}\texttt{\textit{Linear\-Op\-Base}} object
defines a linear mapping from vectors in one vector space (called the
{}\texttt{domain}) to vectors in another vector space (called the
{}\texttt{range}).  Every {}\texttt{\textit{Linear\-Op\-Base}} object provides
access to these vector spaces through the functions {}\texttt{domain()} and
{}\texttt{range()}.  The exact form of this mapping, as implemented by the
function {}\texttt{\textit{apply(\-...)}}, is
%
\begin{equation}
Y = \alpha \, M \, X + \beta Y
\label{thyra:equ:apply_vec}
\end{equation}
%
where $M$ is a {}\texttt{\textit{Linear\-Op\-Base}} object; $X$ and $Y$ are
{}\texttt{\textit{Multi\-Vector\-Base}} objects; and $\alpha$ and $\beta$ are
{}\texttt{Scalar} objects.

A {}\texttt{\textit{Linear\-Op\-Base}} object can also, optionally, support
the transpose (or adjoint) operation:
%
\begin{equation}
Y = \alpha \, op(M) \, X + \beta Y
\label{thyra:equ:apply_transpose_vec}
\end{equation}
%
through the function {}\texttt{\textit{apply\-Transpose(\-...)}}, where $M$ is
a {}\texttt{\textit{Linear\-Op\-Base}} object; $op(M)$ is $M^T$ or $M^H$ (as
determined by the $conj$ argument); $X$ and $Y$ are
{}\texttt{\textit{Multi\-Vector\-Base}} objects; and $\alpha$ and $\beta$ are
{}\texttt{Scalar} objects.  The function
{}\texttt{\textit{applyTranspose(EConj)}} will return false if a particular
form of the transpose is not supported.

If the adjoint is supported, then it must satisfy the adjoint property
Specifically, for any two vectors $w\in\mathcal{D}$ (domain space) and
$u\in\mathcal{R}$ (range space), the adjoint operation must obey the adjoint
property
\[
  <u,A v>_{\mathcal{R}} =\!= <A^H u, v>_{\mathcal{D}}.
\]

%The implications of allowing vector spaces with non-euclidean scalar products
%is explored more deeply in Appendix~???.

Another important part of this design is the fact that
{}\texttt{\textit{Multi\-Vector\-Base}} derives from
{}\texttt{\textit{Linear\-Op\-Base}} and therefore every multi-vector object
is also a linear operator.  This is an elegant way to support the notions of
block inner products and block updates.

A block inner product is specified as
\[
Z = Y^H X
\]
where $Y$, $X$ and $Z$ are all multi-vectors.  Note that since $Y$ is a linear
operator then $Y^H X$ is not simply the block dot product involving the
coefficients but instead must be consistent with the scalar product for the
range of $Y$.

A block update takes the form
\[
Z =\alpha Y X + \beta Z
\]
where $Y$, $X$ and $Z$ are all multi-vectors and $\alpha$ and $\beta$ are
scalars.

Also note that since {}\texttt{\textit{Multi\-Vector\-Base}} derives from
{}\texttt{\textit{Linear\-Op\-Base}} and {}\texttt{\textit{Vector\-Base}}
derives from {}\texttt{\textit{Multi\-Vector\-Base}}, therefore, every vector
object is also a linear operator.  While this may not be a terribly useful
feature it does mean that one must interpret $y^H x$ to be the same as $<y,x>$
and not just the dot product when the space is non-euclidean.

%
\section{Summary}
%

The Fundamental Thyra Operator/Vector Interfaces provide the intersection of
all of the functionality required of linear operators and vectors by a variety
of abstract numerical algorithms ranging from iterative linear solvers all the
way up to optimizers.  By adopting Thyra as a standard interface layer,
interoperability between applications, linear algebra libraries, and abstract
numerical algorithms in advanced scientific computing environments becomes
automatic to a large extent.

% ---------------------------------------------------------------------- %
% References
%
\clearpage
% If hyperref is included, then \phantomsection is already defined.
% If not, we need to define it.
\providecommand*{\phantomsection}{}
\phantomsection
\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{references}

% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%

%\appendix
%\input{apdx_ThyraOperatorVectorClassDecl}


% ---------------------------------------------------------------------- %
% References
%

\begin{SANDdistribution}[NM]
% \SANDdistCRADA	% If this report is about CRADA work
% \SANDdistPatent	% If this report has a Patent Caution or Patent Interest
% \SANDdistLDRD	% If this report is about LDRD work
% External Address Format: {num copies}{Address}
%\SANDdistExternal{}{}
%\bigskip
%% The following MUST BE between the external and internal distributions!
%\SANDdistClassified % If this report is classified
% Internal Address Format: {num copies}{Mail stop}{Name}{Org}
%\SANDdistInternal{}{}{}{}
% Mail Channel Address Format: {num copies}{Mail Channel}{Name}{Org}
%\SANDdistInternalM{}{}{}{}
%\SANDdistInternal{2}{MS 9018}{Central Technical Files}{8944}
%\SANDdistInternal{2}{MS 0899}{Technical Library}{4536}
\end{SANDdistribution}

\end{document}
