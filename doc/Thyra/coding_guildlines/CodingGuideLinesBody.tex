%
\section{Introduction}
%

This document deals with C++ coding guidelines that are based primarily on the
book ``C++ Coding Standards'' by Sutter and Alexandrescu
{}\cite{C++CodingStandards05} (and outlined in Appendix
{}\ref{sec:cpp_coding_standards}).  These guidelines are specifically designed
to address the development of object-oriented numerical libraries and to
utilize the tools in the Trilinos package {}\texttt{Teuchos}.  While the main
purpose of of this document is to define guidelines for Thyra software (for
both interfaces and adapters), it is also general enough to be applied to many
other projects that, for instance, might interact with Thyra.

The goal of this document is not to restate what is in
{}\cite{C++CodingStandards05} but instead to fill in some gaps intentionally
left by the authors and to provide amendments to specific items in the book
and tailor them for numerical libraries.  The zeroth item (first item, zero
based) ``Don't sweat the small stuff'' intentionally avoids specific
recommendations on issues such as the conventions for naming identifiers and
the formatting of code since these are arbitrary.  While issues related to
coding style are much less important that other issues, there are arguments
for adopting consistent coding style and some of these arguments are outlined
in Appendix {}\ref{sec:arguments-for-consistent-style}.  Therefore, one of the
purposes of this document is to suggest reasonable and minimal guidelines for
naming conventions and code formatting that provide for enough code uniformity
to facilitate collaborative code development, code reviews, and maintenance.

More important than code formatting, a consistent set of naming conventions
for C++ classes, functions, variables, and other entities also helps to
improve collaborative software development and quality.  Also, since clients
of the software must interact with these names, it is even more important that
a set of naming conventions be used as consistently as makes sense.

Lastly, more important general C++ coding guidelines are covered that append
and amend those described in {}\cite{C++CodingStandards05}.  While formatting
and naming recommendations do not affect the meaning of C++ code, other coding
guidelines do and therefore they will recieve more attention and should be
considered more seriously.

The rest of the main document is organized as follows.  An alpha-numeric
convention for naming the various guidelines described contained in this
document is described in Section {}\ref{sec:alpha_numeric_designations}.
Then, general naming conventions are presented in Section
{}\ref{sec:NamingConventions} and they help provide a context for later code
examples.  This fillowed in Section {}\ref{sec:NOSF} with guidelines for
naming and organizing source files.  Next, important general C++ coding
guidelines are described in Section
{}\ref{thyracodingguidelines:codingguidelines:sec} that affect software
quality in critical and nontrivial ways.  Unlike naming conventions and code
formatting, these guidelines are difficult to follow after a significant piece
of code has been developed.  Following this, reasonable and minimal formatting
guidelines are covered in Section
{}\ref{thyracodingguidelines:formatting:sec}.  Finally, guilelines for Doxygen
documentation are provided in Section {}\ref{sec:DocumentionGuidelines}.

Several appendicies are included that deal with a number of topics.  The
guidelines presented in this document are summarized in Appendix
{}\ref{sec:summary_guidelines}.  Similarly, the 101 guidelines from
{}\cite{C++CodingStandards05} are listed in Appendix
{}\ref{sec:cpp_coding_standards} along with specifying which items are
ammended or invalidated by the guidelines in the current document.  Appendix
{}\ref{sec:misc_amendments} discusses the items from
{}\cite{C++CodingStandards05} that are ammended or invalidated here.  Most
importantly, a clarification of the use of {}\texttt{using} declarations is
given that is both stronger in some ways and weaker in other ways than what is
described in Item 59 in {}\cite{C++CodingStandards05}.  Appendix
{}\ref{sec:arguments-for-consistent-style} gives arguments for adopting a
consisting code formatting style in a single devleopment team or single
project (which is more consistent with current Agile devleopment methods).
Lastly, Appendix {}\ref{sec:reformatting-guidelines} gives guidelines for when
one developer can legitimately reformat a source file written by another
developer when a more consistent code formatting style is not agreed upon.

%
\section{Alpha-numeric item designations}
\label{sec:alpha_numeric_designations}
%

Specific items in this document are to be refereed to using numerated acronyms
starting with {}\textbf{\index{TCDG}} and the version number (e.g.\ 1.0).  For
example, the first naming convention guideline can be refereed to as
{}\textbf{TCDG 1.0 NC 1}.  In this way, these short precise alpha-numeric
designation such as {}\textbf{TCDG 1.0 NC 3} can be used in code reviews as
short-hand references to specific guidelines.  The version number of the
coding standard is important in order to allow changes in future coding
guidelines and allow the numbers to change from version to version (e.g.\
{}\textbf{NC 1} in {}\textbf{TCDG 1.0} might become {}\textbf{NC 3} in
{}\textbf{TCDG 1.1}).

In addition, this document is based on {}\cite{C++CodingStandards05} and those
guildelines will be refereed to using an enumerated acronym such as
{}\textbf{CPPCS Item 15} (for ``Use const proactively'' for instance).

%
\section{Naming conventions (NC)}
\label{sec:NamingConventions}
%

C++ classes, functions, variables, data members etc. should be named and used
in a fairly consistent manner.  The following guidelines are consistent with
common practice as exemplified in {}\cite{EffectiveC++3rd05}.

\begin{enumerate}

{}\item\NCClassNames: Names for C++ classes and structs should generally be
capitalized and seperate words should be concatenated and capitalized.  For
example:

{\small\begin{verbatim}
  class SomeClass {...};
\end{verbatim}}

{}\item\NCNamespaceNames: C++ namespaces should follow the same naming convention
as C++ classes and namespace names should not contain too many acronyms and
should not be too short or too common.  For example:

{\small\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}}

{}\item\NCEnumNames: Enumeration type names should follow the same convention as
for class and struct names but they should also begin with the capital letter
'E' to signify that this type is an enum.  Enumeration values should be all
upper-case with underscores between words and should use a common prefix for
scoping within the enum type.  Also, enum values should use the default value
assignment defined by the compiler in general as this aids their use as
indexes into zero-based arrays.  For example:

{\small\begin{verbatim}
  enum ESolveStatus {
    SOLVE_STATUS_CONVERGED
    ,SOLVE_STATUS_UNCONVERGED
    ,SOLVE_STATUS_UNKNOWN
  };
\end{verbatim}}

{}\textit{Justification}: Using a capital 'E' for {}\texttt{enum}s allows the
definition of other types with the same basic name that contain other data.
For example, {}\texttt{ESolveStatus} in an {}\texttt{enum} enumerating the
different types of solve status and {}\texttt{SolveStatus} is a C++ struct
that contains an {}\texttt{ESolveStatus} member along with some other data.
The use of the scoping prefix (i.e.\ {}\texttt{SOLVE\-\_STATUS\_} above) is
also recommended in {}\cite[Section 11.4]{CodeComplete2nd04}.

{}\textit{rabartl note:} The convention of using the prefix 'E' is what is
used in Thyra currently but it is somewhat unconventional.  This can be
changed pretty easily but the scoping aspect is very useful in general and
should be kept in my opinion.

{}\item\NCObjectNames: Formal function arguments and other object identifiers
should, in general, start with a lower-case letter and then use capitalization
for following words with no underscores between words in general.  For
example:

{\small\begin{verbatim}
  ClassType1   obj;
  ClassType2   objectForMyThing;
  ClassType3   objectForYourThing;
\end{verbatim}}

{}\textit{Exception:} Indentifiers that have mathematical symbols in them such
as {}\texttt{x}, {}\texttt{J}, and {}\texttt{alpha} should use lower case
names separated by underscores {}\texttt{\_}.  For example:

{\small\begin{verbatim}
  Vector curr_x;
  Matrix curr_J;
  Scalar curr_alpha;
\end{verbatim}}

{}\textit{Justification:} The Java convention {}\texttt{objectIdentifierName}
using capitalization with no underscores produces shorter readable identifiers
for English names but does not work well for identifiers with math sybmols.
With math symbols, it is important to maintain the case of the symbol as
{}\texttt{x} and {}\texttt{X} may mean something totally different
mathematically and it is confusing and/or ambiguous to write either
{}\texttt{currx} or {}\texttt{currX}.  In these cases, it is far better to use
underscores and write {}\texttt{curr\_x} as shown above.  While in it is
considered bad practice to differentiate variable names by case alone (see
``Don't differentiate variable names solely by capitalization'' in
{}\cite[Section 11.7]{CodeComplete2nd04}), this is very common in math and
mathematical software should support this.

{}\item\NCDataMemberNames: Names for data members within a class should use the
same naming convention as for other object identifier names but should end
with an underscore.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}}

{}\textit{Exception}: Simple C++ structs that do not need to maintain an
invariant with public data members and no member functions (other than
constructors) should not contain underscores.  For example:

{\small\begin{verbatim}
  struct SolveStatus {
    ESolveStatus solveStatus;
    double achievedTol;
    std::string message;
    ...
  };
\end{verbatim}}

{}\textit{Exception:} Indentifiers that have mathematical symbols in them such
as {}\texttt{x}, {}\texttt{J}, and {}\texttt{alpha} should use lower case
names separated by underscores {}\texttt{\_}.  For example:

{\small\begin{verbatim}
  Vector curr_x_;
  Matrix curr_J_;
  Scalar curr_alpha_;
\end{verbatim}}

{}\textit{Justification:} See {}\textbf{NC 4} above.

{}\item\NCFunctionNames: Names for class member functions should use the same
naming convention as for object identifier.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    void someMemberFunction(...);
  };
\end{verbatim}}

{}\textit{Exception:} Indentifiers that have mathematical symbols in them such
as {}\texttt{x}, {}\texttt{J}, and {}\texttt{alpha} should use lower case
names separated by underscores {}\texttt{\_}.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    const Vector& get_x() const;
    const Matrix& get_J() const;
    Scalar get_alpha() const;
  };
\end{verbatim}}

{}\textit{Justification:} See {}\textbf{NC 4} above.

{}\item\NCBaseDefaultClassNames: In general, the top-level C++ base class for some
abstraction should use the postfix {}\texttt{Base} appended to the class name
(e.g.\ {}\texttt{Vector\-Base}) and the base class should contain (almost) no
implementations and certainly no object data (see Item 36 in
{}\cite{C++CodingStandards05}).  If a default implementation of some of the
aspects of the base class are desired (to make it easer to define concrete
subclasses), then they should be put in a derived node subclass with the
postfix {}\texttt{DefaultBase} (e.g.\ {}\texttt{Vector\-Default\-Base}).  Any
default concrete implementation of an abstraction should generally use the
prefix {}\texttt{Default} appended to the beginning of the name along with any
other important prefixes (e.g.\ {}\texttt{DefaultSpmdVector}).  For example:

{\small\begin{verbatim}
  // Pure virtual base class 
  class VectorBase
    : ... // Other base classes
  {
  public:
    virtual void someFunc(...) const = 0;
    ...
  };

  // Node base class with some default implementations
  class VectorDefaultBase
   : virtual public VectorBase
  {
  public:
    void someFunc(...) const; // default implementation
    ...
  private:
    ...
  };

  // A general default implementation for SPMD vectors
  class DefaultSpmdVector
    : virtual public VectorDefaultBase // use some default implementations
  {
  public:
    void someFunc(...) const; // Specialized overrides
    ...
  private:
    ...
  };
\end{verbatim}}

{}\item\NCConstNonconstAccessFunctionName: In general, functions that return
objects that are contained within a wrapper object should have the prefix
{}\texttt{nonconst} added to the function that returns the non-const reference
(or pointer) to the contained object.  For example,

{\small\begin{verbatim}
  class SomeClass {
  public:
    RCP<Part> getNonconstPart();
    RCP<const Part> getPart() const;
    ...
  };
\end{verbatim}}

{}\textit{Justification}: The choice to name the access functions
{}\texttt{getNonconstPart()} and {}\texttt{getPart()} as opposed to
{}\texttt{getPart()} and {}\texttt{getConstPart()} is somewhat arbitrary.
However, using {}\texttt{nonconst} should be preferred in order to make it
more explicit that a non-const object reference is bing requested.  Also, a
constant view of a part of an object is always cheaper that returning a
non-constant view of the part (see the discussion of the ``generalized view''
idiom) and therefore to be safe and error on the side of efficiency, the
non-constant access function should be harder to call than the constant access
function.

\end{enumerate}

%
\section{Naming and organization of source files (NOSF)}
\label{sec:NOSF}
%

Since most C++ code is organized around classes, the file structure should
also primarily be organized around classes and the nonmember functions that
interact with these classes.  The primary goal of these file naming guidelines
is to create file names that are globally unique and will therefore facilitate
{}\texttt{\#include}s without need for directory paths in the
{}\texttt{\#include} statement.  The basic idea is that a source file should
be named based on what it has, not where it is.  The following guidelines help
to determine how to organize code into source files and how to name those
source files.  The directory structure of source files is beyond the scope of
this document.

\begin{enumerate}

{}\item\NOSFFileExtension: These file names avoid common
problems with portability to various Unix and Windows platforms and enable
better tools support.

{}\item\NOSFClassFiles: As a general rule of thumb, assign the source code for any
major C++ class and supporting code to a single set of header and source
files.  The file name should be composed out of the namespace names enclosing
the classes and other code along with the class name itself.  For instance,
for the class {}\texttt{NameSpaceA\-::InnerNamespace\-::SomeClass}, the header
and source files would be named
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]}.  This
convention assures that the file names will be globally unique.

{}\item\NOSFIncludeGuards: All header files, without exception, should use include
guards {}\cite[Item 24]{C++CodingStandards05}.  For example, the file
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp} would have the basic
structure:

{\small\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

This is a very minor amendment to Item 24 in {}\cite{C++CodingStandards05}.

{}\item\NOSFTemplateFiles: ToDo: Fill this in once we do explicit instantiation and
figure this out ???.

\end{enumerate}

%
\section{Coding guidelines}
\label{thyracodingguidelines:codingguidelines:sec}
%

Coding guidelines, unlike formatting guidelines, greatly influence the meaning
of C++ programs and therefore require a high priority level.  The book ``C++
Coding Standards'' {}\cite{C++CodingStandards05} that this document is
primarily based on provides many good and important coding guidelines that
should be followed and by default all of the items in this book are assumed in
this document.  Here, we provide additional coding guidelines and, in some
cases, amend items in {}\cite{C++CodingStandards05}.  Where this document is
silent, {}\cite{C++CodingStandards05} is to be considered the authoritative
source for guidance.  Some miscellaneous amendments to the items in
{}\cite{C++CodingStandards05} are given in Appendix
{}\ref{sec:misc_amendments}.
%ToDo: Write an appendix of ammendments to some of the items in ``C++ Coding Standards''.

%
\subsection{General coding guidelines (GCG)}
%

Below several different general coding guidelines are discussed.  These
guidelines affect software quality in a major way and are not just a matter of
personal preference or style.

\begin{enumerate}

{}\item\GCGTestForException: For developer errors, prefer to throw exceptions
drived from {}\texttt{std\-::logic\-\_error} instead of using the
{}\texttt{assert(...)}  macro as recommended in {}\cite[Item
68]{C++CodingStandards05}.  A ``logic error'' would be treated differently
from a real runtime error and would therefore come with different assumptions
about the state of the object after the exception was thrown.  In particular,
a ``real error'' (i.e. not just an internal developer error) should always
provide the basic guarantee to leave the object in a valid state {}\cite[Item
71]{C++CodingStandards05}, while code that throws a ``logic error'' can not
make any such guarantees in general.  Therefore, objects that throw exceptions
derived from {}\texttt{std\-::logic\-\_error} should generally be viewed as
unusable and should be deleted immediately.  To enable debugging, a breakpoint
can always be placed on function
{}\texttt{Test\-For\-Exception\-\_break()}\footnote{In {}\texttt{gdb}, a
breakpoint would be set as {}\texttt{b Test\-For\-Exception\-\_break()}.} 
which will be called just before an exception is thrown through these macros.
In the future, more sophisticated features like automatically attaching a
debugger or printing the call stack may be added for some systems.  Therefore
throwing an exception derived from {}\texttt{std\-::logic\-\_error} using
these macros should be preferred to using the {}\texttt{assert(...)} macro as
it gives us more control over what happens when one of these types of
programming errors occurs.  Also, these exception macros make it much easier
to generate good error messages that you would get from a simple use of the
{}\texttt{assert(...)} macro.

{}\item\GCGAvoidRawPointers: The tools mentioned below which include
{}\texttt{Teuchos::\-Ptr}, {}\texttt{Teuchos::\-RCP},
{}\texttt{Teuchos::\-Array}, {}\texttt{Teuchos::\-Array\-RCP}, and
{}\texttt{Teuchos::\-Array\-View} allow most code to be written without any
explicit raw C++ pointers.  Also, in general, perfer to use
{}\texttt{std\-::string} instead of {}\texttt{char*} or {}\texttt{const
char*}.  In debug mode, these classes allow for full runtime checking that
result in exceptions being thrown and excellent error messages (i.e.\ instead
of segfaults).  Indexing and other unchecked operations with
{}\texttt{std\-::string} objects is much less common in numerical code and
therefore is less likely to result in memory-usage errors inside of numerical
code.

{}\item\GCGTeuchosPtr: The class {}\texttt{Teuchos\-::Ptr} simply takes the place
of a raw pointer to a single object but is always default initialized to NULL.
In debug mode, it throws exceptions when trying to dereference a null pointer.
Using this class helps to eliminate all needs for checking for NULL to avoid
undefined behavior when one dereferences a NULL pointer.

{}\item\GCGTeuchosRCP: Replace all references to the class
{}\texttt{boost::\-shared\_ptr} in all items in {}\cite{C++CodingStandards05}
with {}\texttt{Teuchos::\-RCP}.

{}\item\GCGTeuchosArrayView: This class allows all of the useful capabilities of a
{}\texttt{std::vector} which do not include adding or removing entries.  In
debug mode, all of the access functions (including iterators) are fully
checked.  In optimized mode, unchecked raw pointers are used.

{}\item\GCGTeuchosArray: While {}\texttt{Teuchos::\-Array} gets all of its real
functionality from {}\texttt{std::\-vector}, prefer to use
{}\texttt{Teuchos::\-Array} as we provide more capabilities and (debug)
checking.  For instance {}\texttt{Teuchos::\-Array::\-operator[]} is range
checked in debug mode regardless whether there is an underling checked STL
implementation or not (see {}\cite[Item 83]{C++CodingStandards05}).  In debug
mode, the iterator is also runtime checked.  In addition,
{}\texttt{Teuchos\-::Array} will automatically convert into an
{}\texttt{Teuchos\-::ArrayView} object safely when used in function calls.

{}\item\GCGTeuchosArrayRCP: Note that {}\texttt{Teuchos::ArrayRCP} does
{}\underline{not} take the place of a contiguous container class such as
{}\texttt{Teuchos::\-Array}.  A {}\texttt{Teuchos::ArrayRCP} object can not
change the size of the array, it can only provide for reference counted
sharing of an array of data of fixed size and provide subviews of contiguous
parts of the managed array.  All access to data (both through
{}\texttt{Teuchos::\-ArrayRCP::\-operator[]} and iterators) is runtime checked
in a debug build.

{}\item\GCGTeuchosMap: While in optimized mode, {}\texttt{Teuchos\-::Map} is
equivalent to {}\texttt{std\-::map}, in debug mode {}\texttt{Teuchos\-::Map}
uses a simplified data-structure with fully checking of access and iterators.
This class uses {}\texttt{Teuchos\-::Array}, {}\texttt{Teuchos::List} and
others to build a fully checked (but slower) implementation.

{}\item\GCGTeuchosAs: The templated C++ function
{}\texttt{Teuchos::as<T\_to>(T\_from)} and the class specializations that it
calls will contain runtime tests, in debug mode, for the results of a
conversion to ensure correctness.  This includes the conversion of strings
into numbers (i.e.\ replacing {}\texttt{atof()} and {}\texttt{atoi()}) as well
as conversions that can result in loss of precision or meaning (such as
{}\texttt{double} to {}\texttt{int}, {}\texttt{long int} to {}\texttt{int},
{}\texttt{int} to {}\texttt{char}, {}\texttt{unsigned int} to {}\texttt{int},
etc.).  The optimized implementations of these conversion functions are
typically unchecked for speed.  A version this function which always does
runtime checking is also available called
{}\texttt{Teuchos\-::asSafe\-<\-T\_to\->\-(\-T\_from\-)} in order to validate
user data.

{}\textit{Justification}: Unchecked conversions are the result of many
different types of errors and a fully safe program needs to be able to check
all such potentially unsafe conversions at runtime.  The implicit conversion
rules allowed in C which where carried over to C++ can result in very unsafe
code.

{}\item\GCGNamespaceClassFuncDefs: The member functions of a class should be
defined in the same order as their declarations and should generally be
defined within a namespace enclosure.  For example, given the declaration of

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.hpp

  namespace SomeNamespace {

  class SomeClass {
  public:
    void someFunc();
    ...
  };

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest and one of the tersest ways to define the member functions in the
source file is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.cpp

  namespace SomeNamespace {

  void SomeClass::someFunc()
  {
    ...
  }

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using the namespace enclosure instead of a
{}\texttt{using namespace SomeNamesapce} directive insures that you can never
accidentally provide another definition for some other class member function
in another namespace.  Explicit namespace qualification is not needed since if
one misspells any part of the prototype, then the compiler will issue an error
message.

{}\item\GCGNamespaceFuncDefs: For example, for the nonmember function prototype

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.hpp

  namespace SomeNamespace {

  void someFunc( const int data );

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest way to define the nonmember function is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.cpp

  void Thyra::someFunc( const int data )
  {
    ...
  }

  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using explicit namespace qualification avoids
problems of spelling and other mistakes that can accidentally result in the
definition of a new function {}\cite[Section 8.2]{stroustrup97}.  Such a
mistake is caught at link time but it can be very hard to figure out the root
cause of the problem when this happens.

{}\item\GCGFuncArgsOrder: For example:

{\small\begin{verbatim}
  void someFunc(
    const T1 &arg1,              // Input
    const Ptr<T2> &arg2,         // Input/Output
    const Ptr<T3> &arg3,         // Output
    const int arg4 = 0           // Optional input argument with defualt vlaue
    );
\end{verbatim}}

This ordering of arguments is only a general suggestion as a different
ordering of arguments may be chosen based on other criteria.  See Section
{}\ref{sec:func_arguments} for a description of the use of the {}\texttt{Ptr}
class.

{}\item\GCGNomemberObjectFuncs: For example:

{\small\begin{verbatim}
  void someModifyingFunc(
    SomeClass &obj,
    const int arg1,
    ...
    );

  void someNonModifyingFunc(
    const SomeClass &obj,
    const int arg1,
    ...
    );
\end{verbatim}}

Note that in the case of {}\texttt{someModifyingFunc(...)}, the output
argument is listed first instead of after the input argument(s) which breaks
typical convention of having input/output arguments (which all objects that
are modified are) come after input arguments.  However, this is more
consistent with estabilshed convention such as in Python and other languages
where the {}\texttt{self} argument is always the first explicit (or implicit)
argument.  Note that this is also a situation where a non-const reference
argument makes the most sense.

{}\item\GCGEnumFuncArgs: While the built-in type {}\texttt{bool} is very convenient
to use as a formal function argument, it also allows for conversions from
every built-in type and every pointer type.  While using an enumeration type
and its values is more verbose, it is also self documenting and is safer.  For
example, what does the third argument mean in the following example?

{\small\begin{verbatim}
  apply( A, 2.0, true, x, y );
\end{verbatim}}

When the {}\texttt{bool} argument is changed to an enum, the function call
becomes:

{\small\begin{verbatim}
  apply( A, 2.0, USE_TRANSPOSE, x, y );
\end{verbatim}}

the meaning is much more clear.  Therefore, when self documentation and
compile-time safety are important, perfer to define and use {}\texttt{enum}s
over {}\texttt{bool}s as formal function arguments (see {}\cite[Section
12.6]{CodeComplete2nd04}).

{}\item\GCGTeuchosParamterListAcceptor: The {}\texttt{Teuchos\-::Parameter\-List}
class provides many useful features that make it easy to accept user options
in a flexible and fully validated way (see Teuchos documentation for more
details).  The {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} interface
defines a consistent flexible protocol for setting and managing a parameter
list.

{}\item\GCGStdStream: Sending output directly to {}\texttt{std\-::cout} or
{}\texttt{std\-::cerr} destroys the flexibility of numerical software and does
not perform well in SPMD programs.  Instead, produce output using one of the
following approaches.

\begin{itemize}

{}\item\GCGTeuchosFancyOStream: A {}\texttt{Teuchos\-::Fancy\-OStream} class object
can wrap any {}\texttt{std\-::ostream} object and helps to produce structured
indented output and to create more readable output in an SPMD program (even
when every processor produces output).

{}\item\GCGTeuchosDescribable: The {}\texttt{Teuchos\-::Describable} interface is
the appropriate way to allow clients to print the current state of an object
in a flexible way.  The verbosity of the output is controlled by an input enum
parameter.

{}\item\GCGTeuchosVerboseObject: Clients can set the output stream and the
verbosity level through a parameter list (see the
{}\texttt{Teuchos\-::ParameterListAcceptor} interface described above) or can
set them directly in code.  If no output stream is set, then
{}\texttt{Teuchos\-::Verbose\-Object\-Base\-::get\-Default\-OStream()} will be
used.

{}\item\GCGTeuchosVerboseObjectBaseDefaultOStream: The stream provided by
{}\texttt{*Teuchos\-::Verbose\-Object\-Base\-::get\-Default\-OStream()} is
setup by default to do clean printing in an SPMD program and can also be setup
through a {}\texttt{Teuchos\-::Command\-Line\-Processor} object to control how
output is produced and formatted.

\end{itemize}

{}\item\GCGTemplateHeaders: ToDo: Merge this with the above item on layout of files
for implicit and explicit template instantiation once we figure out how to do
this with explicit and implicit instantiation ???

{}\item\GCGStandardCppHeaders: Only include the C++ {}\texttt{<cX>} versions of the
standard C {}\texttt{<X.h>} headers.  For example, include {}\texttt{<cmath>},
{}\texttt{<cstdlib>}, and {}\texttt{<cassert>} instead of {}\texttt{<math.h>},
{}\texttt{<stdlib.h>}, and {}\texttt{<assert.h>}.  Avoid all uses of
{}\texttt{using namespace std} directives and instead prefer explicit
namespace qualification such as {}\texttt{std::sqrt} or using declarations
such as {}\texttt{using std::sqrt} only within function definitions.  See
{}\cite[Section ???]{stroustrup97} for a complete list of the standard C++
versions of the standard C headers.

{}\textit{Justification}: See Appendix {}\ref{sec:misc_amendments} for a
clarification of Item 59 in {}\cite{C++CodingStandards05} dealing with the
issue of {}\texttt{using} declarations and directives.


\end{enumerate}

%
\subsection{Specification of formal arguments for C++ functions}
\label{sec:func_arguments}
%

Here we describe a convention for the specification of the formal arguments
for C++ functions that leads to C++ code that maximizes compile-time and
run-time checking, yields near optimal performance, and is highly self
documenting.  A key component to this specification is that no raw C++
pointers are used.  Raw pointers are the cause of almost all memory usage
problems in C++.  Raw C++ references, on the other hand, are safe to use as
long as the object reference they are being used to point to is valid and no
persisting association exists.  All of these classes perform runtime checks of
correct memory usage when enabled at configure time (i.e., using
{}\texttt{--enable-teuchos-debug} with {}\texttt{configure}).  In optimized
builds, however, these classes perform no debug checking and yield the same
performance achieved using raw C++ pointers.  The classes {}\texttt{RCP} and
{}\texttt{ArrayRCP} always implement reference counting in optimized and debug
builds and therefore impart necessary extra overhead that never goes away
(unless you don't use them).  The other classes {}\texttt{Ptr} and
{}\texttt{ArrayView} do not use any reference counting in an optimized build
and therefore really do result in little to no overhead in an optimized build.

Tables {}\ref{fig:func_args_value_type} and {}\ref{fig:func_args_ref_type}
give conventions for passing single objects and arrays of objects for
value-type {}\index{Types!Value Type} and reference-type
{}\index{Types!Reference Type} objects, respectively.  In this specification,
the classes {}\texttt{Teuchos\-::Ptr}, {}\texttt{Teuchos\-::RCP},
{}\texttt{Teuchos\-::ArrayRCP}, and {}\texttt{Teuchos\-::ArrayView} are used
as a means to pass objects of another type (shown as {}\texttt{S} and
{}\texttt{A} in Tables {}\ref{fig:func_args_value_type} and
{}\ref{fig:func_args_ref_type}).  This specification addresses the four
different properties that must be considered when passing an object to a
function: 1) does the object use value semantics or reference semantics, 2) is
the object changeable (const) or changeable (nonconst), 3) is this
establishing a persisting or non-persisting association, and 4) is the object
optional or required.  All of these properties are directly expressed in the
C++ code in all cases shown in Tables {}\ref{fig:func_args_value_type} and
{}\ref{fig:func_args_ref_type} except for whether an argument or object is
required or optional and therefore must be documented in the function's
interface specification (i.e.\ in a doxygen documentation {}\texttt{param}
field).  Here we state that by default, an argument will be assumed to be
required unless otherwise stated.  The only exception for this implicit
assumption for non-null objects is {}\texttt{const Ptr<const T>\&} for single,
non-changeable, non-persisting, objects where these always mean that the
argument is optional.

Note that an array of value objects just stores the objects themselves and
passes them through an {}\texttt{ArrayView<S>} or {}\texttt{ArrayView<const
S>} object.  An array of reference objects, however, can not directly store
the objects themselves and instead must store an array to (smart) pointers to
the objects using {}\texttt{ArrayView<const Ptr<const A> >\&} for
non-persisting associations or {}\texttt{ArrayView<const RCP<const A> >\&} for
persisting associations.  The {}\texttt{const} can be removed from the either
{}\texttt{Ptr}/{}\texttt{RCP} or {}\texttt{A} depending on what is allowed to
change or not change during the function call.

Note that in the case of {}\texttt{RCP} and {}\texttt{ArrayRCP}, that these
can be treaded as output objects in their own right.  For example, passing an
{}\texttt{RCP<T>} object into a function to be set to point to a different
{}\texttt{A} object would be specified in the function prototype as
{}\texttt{const Ptr<RCP<T> >\&} or {}\texttt{RCP<T>\&} depending on
preference.  Note that it never makes sense for {}\texttt{Ptr} or
{}\texttt{ArrayView} to be set in this way since such a function call would
almost always be establishing a persisting association with the embedded
objects and therefore would require using {}\texttt{RCP} or
{}\texttt{ArrayRCP}.

{}\textbf{ToDo:} Describe why using the Ptr class for single, changeable,
required, non-persisting objects makes sense (cite references on this).

{}\textbf{ToDo:} Describe now the Array class can be used.


\begin{table}[p]
%
%\fbox{
\begin{center}
%
%\begin{minipage}{{}\textwidth}
%
\input{PassingValueObjects}
%
%
%\end{minipage}
%
\end{center}
%} % end fbox
\caption{\label{fig:func_args_value_type}
C++ declarations for passing small concrete objects (i.e.\ with value
semantics) to and from functions where {}\texttt{S} is a place holder for an
actual built-in or user-defined data type.  By default, all objects of type
{}\texttt{Ptr}, {}\texttt{RCP}, {}\texttt{ArrayRCP}, and {}\texttt{ArrayView}
are assumed to be non-null unless explicitly stated in the documentation for
the function.  In other words, documentation must be added to state that an
argument is optional; the default is that the argument is required.}
%
\end{table}


\begin{table}[p]
%
%\fbox{
\begin{center}
\input{PassingReferenceObjects}
\end{center}
\caption{\label{fig:func_args_ref_type}
C++ declarations for passing abstract objects (i.e.\ with reference or pointer
semantics) or large concrete objects (i.e.\ that are expensive to copy) to and
from functions where {}\texttt{A} is a place holder for an actual C++ base
class.  By default, all objects of type {}\texttt{Ptr}, {}\texttt{RCP},
{}\texttt{ArrayRCP}, and {}\texttt{ArrayView} are assumed to be non-null
unless explicitly stated in the documentation for the function. This includes
{}\texttt{Ptr} and {}\texttt{RCP} objects embedded in an array.  In other
words, documentation must be added to state that an argument is optional; the
default is that the argument is required.}
%} % end fbox
\end{table}


%
\section{Formating of source code}
\label{thyracodingguidelines:formatting:sec}
%

At the minimum, source code should be formatted consistently within a single
file or a set of tightly coupled files {}\cite[Item 0]{C++CodingStandards05}.
Ideally, source code should be formatted consistently enough across a code
project so as not to cause undue difficulty in shared maintenance and in
performing code reviews {}\cite{CodeComplete2nd04}.  Some consistency in
formatting helps and to facilitate multiple ownership and shared development
of a collection of software, such as in Extreme Programming (XP)
{}\cite{ExtremeProgrammingExplained99} (see Appendix
{}\ref{sec:arguments-for-consistent-style} for an outline of the arguments for
adopting a consistent code formatting style).  By ``formatting'' we generally
refer to the use of whitespace in the line-to-line formating of the program or
in the ordering of lines of code such that the meaning of the program to the
compiler is unchanged\footnote{While technically changing the name of a class,
function or variable changes the meaning of a program, if name changes are
done in such a way as to avoid name collisions, then naming conventions also
do not affect the meaning of the program and are therefore very much related
to other formatting issues such as the treatment of ``whitespace''.}  The
handling of indentation styles can largely be automated\footnote{Emacs
supports multiple file-specific formatting styles for C++ and tools like
Artistic Style {}\cite{ArtisticStyle} can format source files from the command
line.  A flavor of the {}\texttt{vi} editor may also support indentation
styles. } which allows individual developers to work with any style they would
like like for files that they create but also makes it easy for developers to
edit files created by other developers and keep to their styles as well.
Appendix {}\ref{sec:reformatting-guidelines} gives some guidelines for how
individuals should conduct themselves where more than one coding formatting
style is in use within a project.

Our main goal in this section is to try to provide reasonable recommendations
for those formating issues that are largely a matter of style and personal
preference but at the same time affect the overall readability of the code and
promote pair programming and joint ownership of the code
{}\cite{ExtremeProgrammingExplained99}.  The formatting and indentation
guidelines presented here are largely consistent with the recommendations in
{}\cite[Chapter 31]{CodeComplete2nd04} and try to reduce the amount of ``right
drift'' that can occur with some common formatting and indentation styles.

The indentation guidelines outlined below can be largely automatically
supported by Emacs and are used by the custom style ``thyra'' defined in the
emacs package file cc-thyra-styles.el\footnote{See
{}\texttt{Trilinos/packages/thyra/emacs/README} for a description of the
``thyra'' Emacs style}.  Other custom sytles can also be added to this file
and used as well.  Any of these styles can be listed in each source file and
therefore anyone using Emacs can automatically use a particular indentation
style without having to fight the editor to manually reformat code to abide by
a foreign style.

%
\subsection{General principles for formatting of source code (FSCP)}
%

Some general principles of good formatting, based on the discussion in
{}\cite[Section 31.1]{CodeComplete2nd04}, are:

\begin{enumerate}

{}\item\FSCPShowLogicalStructure: It is somewhat subjective what formatting sytles
``show the logical structure'' of code but McConnell makes some good argments
for some styles over others.  However, it is up the group of programmers to
decide as a group what style items ``show the logical structure''.

{}\item\FSCPImproveReadability: There are specific studies cited in
{}\cite[Chapter 31]{CodeComplete2nd04} that provide good evidience to prefer
some styles over others.

{}\item\FSCPRetainFormatting: Changing one line of code should not require changes to
other lines of code to maintain the formatting style.

{}\item\FSCPFollowCommonIdioms: When there is no good technical argument for
one formatting sytle choice over another, then the style choice that is the
most common should be used\footnote{The measure of the commonality of a
particular style choice can be determined according to a local software
development community or the larger developer community.}.  This is not
advocated per-say in {}\cite[Chapter 31]{CodeComplete2nd04} but it is a good
idea in general to follow popular idioms when there are several equally good
choices and therefore the decision is arbitrary.  However, not selecting a
single style choice can create artificial complexity in the code from
irregularity in formatting.

\end{enumerate}

%
\subsection{Specific source code formatting principles (FSC)}
%

Below, specific recommendations are spelled out that try to conform to common
practices but also try to avoid excessive ``right drift'':

\begin{enumerate}

{}\item\FSCConsistentInFile: Consistent formatting includes the placment of
braces, the number spaces to indent etc.  {}\textit{Justification}: This is
recommended in {}\cite[Item 0]{C++CodingStandards05}.

{}\item\FSCEightyCharWide: Keeping most of the source code within the first 80
character columns helps to make the code more readable and helps to facilitate
side-by-side two-column editing and comparisons of source code.  Most of the
style and indentation guidelines described below help to avoid code that
extends beyond the 80th column too rapidly. {}\textit{Justification}:
``Studies show that up to ten-word text widths are optimal for eye tracking''
{}\cite[Item 0]{C++CodingStandards05}.  Also, some developers are still stuck
with 80 column wide terminals.

{}\item\FSCIndentSpaces: The amount of spaces to use per indentation level is
up to the individual developer but an indentation of only {}\textit{two
spaces} is recommended (and is set in the `Emacs `thyra'' indentation style).
A study showed that an indentation offset of two-to-four spaces was optimal
for code reading comprehension {}\cite[Section 31.2]{CodeComplete2nd04}.
Whatever indentation amount is used, it should be consistent in at least each
source and header file {}\cite[Item 0]{C++CodingStandards05} (which can be
enforced using a custom Emacs indentation style).  Emacs by default will put
in a tab when the tab-width is equal to the number of indentation spaces.
Emacs can be told to always use spaces instead of tabs by setting:

{\small\begin{verbatim}
  (setq indent-tabs-mode nil)
\end{verbatim}}

in the indentation style (as is done in the ``thyra'' style).  However, it is
easy to support different preferences for the amount of spaces to indent by
using a user-defined indentation style for Emacs (sorry {}\texttt{vi} users).

{}\textit{Justification}: ``Some teams legitimately choose to ban tabs
... when misused, turn indenting into out-denting and non-denting.''
{}\cite[Item 0]{C++CodingStandards05}.

{}\item\FSCTwoVertialSpaces.

{}\textit{Justification}: Using two black spaces is preferable to long lines
with some filler like '-' or '=' or other separators and they clearly separate
the entities and are easier to maintain (see {}\cite[Section
31.8]{CodeComplete2nd04}).

{}\item\FSCNoNamespaceIndent: Indenting for namespace enclosures results in
unnecessary, and in some cases excessive, indentation.  Instead, for example,
use:

{\small\begin{verbatim}
  namespace MyNameSpace {


  namespace MyInnerNamespace {


  class SomeClass {..};


  void someFunc(...) {...}


  } // namespace MyInnerNamespace


  } // namespace MyNameSpace
\end{verbatim}}

Above, note that two vertical blank lines are used between each of the major
enteties (see above item).

{}\textit{Justification}: While indentation within namespaces is helpful in
small example code fragments, it provides little help in showing namespace
structure in more realistic code.  The use of commented end braces is
generally sufficient to show namespace structure and will not result in
excessively indented code.  In addition, typically, each file will only
contain code from one (or more nested) namespace and therefore indenting for
namespaces provides no useful information.  Not indenting for namespace
enclosures is also consistent with the ``ansi'', the ``kr'', and the ``linux''
styles as defined by Artistic Style {}\cite{ArtisticStyle}.

{}\item\FSCClassDeclarationLayout.

\begin{figure}
%
{\small\begin{verbatim}
  class SomeClass {

    // Friends

    friend void foo();

    friend class SomeOtherClass;

  public:

    // Public types

    typedef int integral_type;

    // Public member functions

    void func1();

  protected:

    // Protected member functions

    void func2();

  private:

    // Private types

    typedef std::vector<int> int_array_t;

    // Private data members

    int data1_;
    int_array_t array1_;

    // Private member functions

    void func3();

  };
\end{verbatim}}
%
\caption{\label{fig:class_decl_layout}
Suggested layout of C++ class declaration complete with ordering of sections,
indentation, and line spacing.}
%
\end{figure}

{}\textit{Justification}: This ordering of sections and data members is quite
common {}\cite[Section 31.8]{CodeComplete2nd04}.  Above, we show private
member functions after private data members since private data members are
more prominent and more common in the class implementations than are private
member functions.  Also, private types (where typedefs are most common) must
be listed before they are used in the declaration of the private data members.
Note that public types used in public member functions must be listed above
(or at least forward declared) before the public member functions that use
them.

{}\item\FSCFunctionProtypes: Below, guidelines for formatting short function
prototypes and long prototypes are given.  These guidelines seek to produce
function prototypes that are fairly tight (i.e. not too much whitespace
explosion), are robust to modifications, and keep code inside of the 80th
character column.  This indentation style can (and should) also be applied to
function definitions and function calls.

  \begin{enumerate}

  {}\item\FSCShortFunctionPrototypesOneLine: For example,

  {\small\begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}}

  or 

  {\small\begin{verbatim}
  ReturnType someFunction(int arg=0);
  \end{verbatim}}

  or some other style for whitespace within '(...)' but the opening '(' should
  come directly after the function name in all cases.

  {}\item\FSCLongFunctionPrototypesIndent: Function prototypes that can not
  approximately fit on a single line in the first 80 character columns should
  have the function arguments listed starting on the second line with one unit
  of indentation (e.g. two spaces) from the function return type and function
  name line.  For example, several different valid formats for a longer
  function prototype are:

  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4 = "" );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction( int arg1, bool arg2,
    double* arg3[], const std::string &arg4 = "" );
  \end{verbatim}}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  The arguments can begin on the same
  line as the type + function name line or can start on the next line.  The
  ending parenthesis ')' can appear on the same line as the last line of
  arguments or can appear alone on the last line.  Other formats are possible
  also and can be appropriate in different situations.

  {}\textit{Justification}: See {}\cite[Section 31.1]{CodeComplete2nd04}.
  
  {}\item\FSCFunctionReturn: A function prototype's return type should appear
  on the same line as the function name unless it is excessively long and
  would result in the return type + function name line to extend past the 80th
  character column.  When the return type + function name is too long, then it
  can be listed on separate lines with no indent, for example, as:
  
  {\small\begin{verbatim}
  Teuchos::RCP<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}

  However, listing the function return type on a separate line even in cases
  of shorter prototypes is also okay.

  \end{enumerate}

{}\item\FSCOrderFunctionDefinitions: For example, one should order the
definitions of a set of member functions the same as the ordering of the
declarations in the class definition.  Maintaining the ordering of definitions
and declarations makes the code more readable and more maintainable.  For
example, if the function definitions are ordered the same as the declarations,
it can be easy to see if a function definition is missing (i.e.\ which could
be the cause of the link error that you are seeing).

{}\item\FSCBracePlacement: Two basic styles of brace placement and indentation
in control structures are recommend here.  The first general style is a
modification of the K\&R style{}\cite{ArtisticStyle} where the brace comes
immediately after the control statement on the same line shown as:

{\small\begin{verbatim}
  // Modified K&R Style (recommended)
  if(someCondition) {
    ...
  }
  else {
    ...
  }
\end{verbatim}}

Note that the pure K\&R style (for example, as defined by Artistic Style
{}\cite{ArtisticStyle}) shown as:

{\small\begin{verbatim}
  // Pure K&R Style (*NOT* recommended)
  if(someCondition) {
    ...
  } else {
    ...
  }
\end{verbatim}}

is not recommended.  Even through pure K\&R style meets McConnell's strict
pictorial definition of ``emulation of pure block style'' (i.e.\ the
equivalent to pure block format such as in Visual Basic) which he says is
good, he actually recommends the above modified K\&R style (as do we since we
feel it is more readable).

The second general style that is recommended is the ``ANSI''
style{}\cite{ArtisticStyle} where the opening brace begins flush on the next
line from the control statement shown as:

{\small\begin{verbatim}
  // ANSI Style (recommended)
  if(someCondition)
  {
    ...
  }
  else
  {
    ...
  }
\end{verbatim}}

Both the modified K\&R and the ANSI styles help to avoid right drift.  The
modified K\&R style creates tighter code vertically and seems to be preferred
by many communities and authors but variations of the ANSI style are also very
common.  Note that the ANSI style seems to have a distinct advantage in cases
where the control statement is continued over multiple lines.  For example,
the modified K\&R style with line continuations looks like:

{\small\begin{verbatim}
  // Modified K&R Style with line continuations (*NOT* recommended)
  if( someLongCondition &&
    anotherVeryLongCondition &&
    theLongestConditionThatWillFitOnOneLine ) {
    // Statements
    ...
  }
\end{verbatim}}

{}\noindent{}and it is hard to argue that this shows the logical structure of
code.  One could argue that the ANSI style which looks like:

{\small\begin{verbatim}
  // ANSI Style with line continuations (recommended)
  if( someLongCondition &&
    anotherVeryLongCondition &&
    theLongestConditionThatWillFitOnOneLine )
  {
    // Statements
    ...
  }
\end{verbatim}}

better shows the logical structure of the code in clearly separating the
control structure logic from the inner block of code.

Note that while the modified K\&R style meets McConnell's blessing of
``showing the logical structure of code'' where he refers to it as ``emulating
pure block'' format that he cites the ANSI styles as violating this principle
{}\cite[Section 31.1]{CodeComplete2nd04}.  However, it is somewhat subjective
what styles ``show the logical structure'' and McConnell himself seems to
contradict himself at times (see the formatting of if/else statements below).

When choosing between one of these to styles, try to be consistent at least
within a single file.  However, for control statements that extend over a
single line, prefer the ``ANSI'' style.

Below, the application of the modified K\&R style and the ANSI styles are
shown in the context of several different types of C++ loop and control
structures.

  \begin{enumerate}

  {}\item\textit{Formatting if/else if/else
  statements}: When applied to if statements, the two recommended styles are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  if(someCondition) {
    ...
  }
  else if(someOtherCondition) {
    ...
  }
  else {
    ...
  }
  \end{verbatim}}
  
  {}\noindent{}and:
  
  {\small\begin{verbatim}
  // ANSI Style (recommended)
  if(someCondition)
  {
    ...
  }
  else if(someOtherCondition)
  {
    ...
  }
  else
  {
    ...
  }
  \end{verbatim}}

  {}\item\textit{Formatting switch/case statements}:
  The two recommended formats for switch/case statements are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  switch(someEnumValue) {
    case ENUM_VALUE1:
      ...
      break;
    case ENUM_VALUE2:
      ...
      break;
    default:
      TEST_FOR_EXCEPT("Should never get there!");
  }
  \end{verbatim}}

  {}\noindent{}and

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  switch(someEnumValue)
  {
    case ENUM_VALUE1:
      ...
      break;
    case ENUM_VALUE2:
      ...
      break;
    default:
      TEST_FOR_EXCEPT("Should never get there!");
  }
  \end{verbatim}}

  As shown above, every switch structure should have a {}\texttt{default} case
  that throws an exception (see ``use the default clause to detect errors''
  in {}\cite[Section 15.1]{CodeComplete2nd04}).

  Also, if needed, the case blocks can be wrapped in braces as:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  switch(someEnumValue) {
    case ENUM_VALUE1: {
      ...
      break;
    }
    case ENUM_VALUE2: {
      ...
      break;
    }    
    default: {
      TEST_FOR_EXCEPT("Should never get there!");
    }
  }
  \end{verbatim}}

  {}\noindent{}and

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  switch(someEnumValue)
  {
    case ENUM_VALUE1:
    {
      ...
      break;
    }
    case ENUM_VALUE2:
    {
      ...
      break;
    }    
    default:
    {
      TEST_FOR_EXCEPT("Should never get there!");
    }
  }
  \end{verbatim}}

  {}\item\textit{Formatting for and while loops}: The two recommended styles
  for formatting for loops are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  for ( int i = 0; i < size; ++i ) {
    ...
  }
  \end{verbatim}}

  {}\noindent{}and:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  for ( int i = 0; i < size; ++i )
  {
    ...
  }
  \end{verbatim}}

  Note that line continuations are often needed for a for loops control
  structure, especially if long type names or variable names are used.  In
  these cases, the ANSI style is recommended as:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  for (
    std::vector<SomeVeryLongClassName>::const_iterator itr = longVarName.begin();
    itr != someLongVariableName.end();
    ++itr )
  {
    ...
  }
  \end{verbatim}}

  Similarly, while loops should be formatted as:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  while ( someCondition ) {
    ...
  }
  \end{verbatim}}

  {}\noindent{}and:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  while ( someCondition )
  {
    ...
  }
  \end{verbatim}}

  \end{enumerate}

\end{enumerate}

%
\section{Doxygen documentation guidelines}
\label{sec:DocumentionGuidelines}
%

Here a set of reasonable guidelines is stated for writing Doxygen (and plain
old) documentation for classes, functions, etc.\ that makes the specification
clear but is not too verbose or hard to maintain.  Other types of higher-level
documentation are also needed, such as design documents and tutorials, but
guidelines for these higher-level types of documentation are not covered here.

%
\subsection{Goals for function and class level documentation (DOXG)}
%

\begin{enumerate}

{}\item\DOXGVariableLevelOfDetail: Important interfaces or widely disseminated
concrete classes or functions require an appropriate level of precise
documentation.  Concrete implementations that are less widely disseminated can
provide less (or none in some cases) Doxygen documentation if the
implementation code itself is sufficiently easy to understand.  However, major
parts of an implementation should have at least some plain old (i.e.\
non-Doxygen) documentation to describe the basics of what is going on.

{}\item\DOXGFullyDocumentInterfaces: In the case of important abstract
interfaces, the full specification of behavior for the compliant objects
(i.e. invariants, preconditions, postconditions) must be clearly stated
{}\cite[Item 69]{C++CodingStandards05}.  In some cases, this must be done
completely within the Doxygen documentation for the interface.  In other
cases, a standard unit testing function or class can be used to help specify
the behavior of the interface.  In fact, compiled and verified unit testing
code may be superior to standard Doxygen documentation since it can not be
ignored or become invalid.  On the other hand, it may be difficult for readers
to wade through unit testing code to find the specification of behavior and
therefore both Doxygen documentation and unit testing code should be used to
provide the fullest benefit.  Also, Doxygen documentation can automatically
include bits and pieces of compiled and tested code using the
{}\texttt{$\backslash$dontinclude} Doxygen commands.

{}\item\DOXGFullyDocumentUserIntefaces: This item is an amendment to the above
item as a special case for ``user'' interfaces.  A "user" could be someone
that simply writes client code to the interface or one that provides
implementations of the interface or both.  User's should not be expected to
study unit testing code to figure out the preconditions and/or postconditions
for a function call.

{}\item\DOXGWrongDocumentationBad: Documentation must be maintained as code is
changed and therefore excessive or unnecessary documentation degrades the
quality of code.  However, documentation with small errors is generally better
than no documentation at all.

{}\item\DOXGDoNotRepeat: We should strive for a single source for
documentation for an entity and not repeat the same documentation over and
over again.  This is critical to insure that the documentation can be
successfully maintained.

{}\item\DOXGDocumentationMaintainItself: Any significant fragments of code
that are shown in the Doxygen-generated HTML documentation should come from
compiled and tested code.  This can be accomplished by using the
{}\texttt{$\backslash$dontinclude} Doxygen command to read in code fragments
automatically.  In this way, the compiler and our test suite can be used to
help verify the code fragments in our Doxygen documentation.

\end{enumerate}

%
\subsection{General doxygen documentation principles (DOX)}
%

Now that some of the general goals for our Doxygen documentation have been
presented, more detailed guidelines are given below:

\begin{enumerate}

{}\item\DOXWriteInHeaders: Writing Doxygen documentation comments directly
attached to the classes, functions and other entities helps make the
documentation as tightly tied to the code as possible (see ``Keep comments
close to the code they describe'' in {}\cite[Section
32.5]{CodeComplete2nd04}).  This has the unfortunate side-effect of requiring
complete recompilations whenever documentation is modified but the overall
benefit is usually worth the disadvantages.  Note that the Doxygen
documentation can be stripped out of Doxygen-generated hyper-linked versions
of the code, leaving clean C++ code without the clutter of detailed
documentation.  Therefore, developers should browse Doxygen-generated source
code instead of the source code directly when looking at the code and
performing code reviews.

{}\item\DOXUseCentralizedDefintions: Use clear and consistent naming of
arguments in multiple functions (within the same class and across as many
classes and functions as makes sense) and provide a centralized definition of
these arguments if possible to avoid repeating detailed definitions in each
individual function's documentation.  This helps to avoid duplicate
documentation that is likely not to be maintained correctly.  In the case of
classes, this means providing some common definitions in the main ``detailed''
documentation section for the class.  In the case of nonmember functions, this
might involve a common Doxygen group or module (i.e.\ using the
{}\texttt{$\backslash$defgroup} command) for the set of functions.  In the
case of collections of nonmember functions, it may be difficult to expect
readers to find the common definitions, but links to the common documentation
are possible using a variety of approaches.

{}\item\DOXUseCentralizedPrePostConditions: For common arguments that are
shared among many functions, define the most common preconditions for them in
a central place and avoid listing them on a function-by-function basis unless
they change for an individual function.  For a C++ class, place descriptions
for these common arguments in the main class documentation under a
{}\texttt{$\backslash$section} named ``Common Function Arguments and
Pre/Post-Conditions''.  Only include preconditions for these arguments in
specific function documentation sections if it is different from the most
common preconditions.

{}\item\DOXAddBrief: The {}\texttt{$\backslash$brief} field is used to provide
the short one-line documentation string that is included in the function
summary section of classes, groups, namespaces etc.  Even if no text
documentation is needed/wanted, add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment so that Doxygen will include the class, function, or other entity in
the HTML documentation.  Note that this is important when the Doxygen
configuration option {}\texttt{EXTRACT\-\_ALL} is set to {}\texttt{NO}.

{}\item\DOXAllOrNoneParam: All arguments should be listed in
{}\texttt{$\backslash$param} fields with at least the [in], [out], or [in/out]
specifications and these should have at least a very short description.  Or,
if the function arguments are clear and trivial (and/or have already been
defined in the common documentation section), then no
{}\texttt{$\backslash$param} fields should be included at all.  If any of the
arguments in a function's documentation are listed in
{}\texttt{$\backslash$param} fields then all arguments should be listed in
{}\texttt{$\backslash$param} fields.

{}\item\DOXReturnsOnlyIfNeeded: Don't add a {}\texttt{$\backslash$returns}
description of the return value if it is already clearly specified in the
{}\texttt{$\backslash$brief} description of the function.  However, if the
nature of the return value is at all complex, then include a
{}\texttt{$\backslash$returns} field to describe it.  When referring to the
return argument, refer to it as {}\texttt{returnVal}.  By consistently using
the identifier {}\texttt{returnVal} for the return value, user's will
immediately know what this is referring to.

{}\item\DOXPreferPostconditionsInParam: The postconditions for output
arguments can be listed directly in the {}\texttt{$\backslash$param} field for
the argument if they only involve just that argument in a fairly simple way.
Otherwise, if the postconditions are more complex or involve multiple
arguments in order to specify, then they can be listed in the Postconditions
list.  It may be difficult to objectively determine the best place to list the
postconditions for an output argument.

{}\item\DOXOrderOfDocFieds: A consistent ordering of sections of documentation
within a function makes it easier for readers to find what they are looking
for.

{}\item\DOXUseRelatesForNonmemberFunctions: If a nonmember function is most
closely related to a single class, use the {}\texttt{$\backslash$relates}
field to cause the documentation for the function to be listed with the
classes documentation.  This makes it easier for readers to find out
everything that they can do with a class object (or set of class objects) just
by looking at a single HTML page and a single summary list of functions (which
includes member and nonmember related functions).

{}\item\DOXDocumentInitialVirtualOnly: Only provide detailed documentation of
the initial declaration of a virtual function in the class where it is first
defined as {}\texttt{virtual}.  In general, documentation should not be
included for the overrides of virtual functions in derived classes.  Doxygen
automatically puts in a link to the original virtual function in the base
class so readers are just one click away for seeing the detailed
documentation.  Always add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment for every class and every function that should be included in the HTML
documentation but where no text documentation is wanted or needed.

{}\item\DOXAggregateOverrides: For example, the overrides of the virtual
functions for the {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} interface
would look like:

{\small\begin{verbatim}

  class SomeClass : public Teuchos::ParameterListAcceptor {
  public:

    ...

    /** \name Overriden from Teuchos::ParameterListAccpetor */
    //@{

    /** \brief . */
    void setParameterList(
      Teuchos::RCP<Teuchos::ParameterList> const& paramList);
    /** \brief . */
    Teuchos::RCP<Teuchos::ParameterList> getParameterList();
    /** \brief . */
    Teuchos::RCP<Teuchos::ParameterList> unsetParameterList();
    /** \brief . */
    Teuchos::RCP<const Teuchos::ParameterList> getParameterList() const;
    /** \brief . */
    Teuchos::RCP<const Teuchos::ParameterList> getValidParameters() const;

    //@}

    ...

  };

\end{verbatim}}

{}\item\DOXAutogenerateExampleCode: Any significant fragment of example code
that is shown in Doxygen HTML documentation or a latex document needs to come
from compiled and tested code that can be updated automatically.  These C++
code fragments can be selectively inserted automatically into Doxygen
documentation using the {}\texttt{$\backslash$dontinclude} Doxygen command.

{}\item\DOXAutogenerateSampleOutput: Sample output included in Doxygen
documentation should be generated automatically by the test harness code and
should be written to files that are included in the source directory.  The
sample output in these files can then be inserted into the Doxygen HTML
documentation automatically using the {}\texttt{$\backslash$verbinclude}
Doxygen command.  Similar approaches can also be used for latex documentation.

\end{enumerate}
