%
\section{Introduction}
%

Any successful collaborative software project (or any other type of
collaborative project for that matter) is benefited by some degree of
uniformity while still allowing individuals to express there individuality and
apply their personal preferences.  This document deals with C++ coding style
and guidelines that is based primarily on the book ``C++ Coding Standards'' by
Sutter and Alexandrescu {}\cite{C++CodingStandards05}.  These guidelines are
specifically designed to address the development of object-oriented numerical
libraries and to utilize the tools in the Trilinos package {}\texttt{Teuchos}.
While the main purpose of of this document is to define guidelines for Thyra
software (for both interfaces and adapters), it is also general enough to be
applied to many other projects that, for instance, might interact with Thyra.

The goal of this document is not to restate what is in
{}\cite{C++CodingStandards05} but instead to fill in some gaps intentionally
left by the authors and to provide exceptions and amendments to specific items
in the book that is more appropriate for the types of software that we create
and the environment in which we work.

The zeroth item (first item, zero based) ``Don't seat the small stuff''
intentionally avoids specific recommendations on issues such as the
conventions for naming identifiers and the formatting of code since these are
arbitrary.  However, in Item 0, the authors do state:

\begin{quote}

Do use consistent formatting within each source file or even each project,
because it's jarring to jump around among several styles in the same piece of
code.

\end{quote}

In {}\cite{CodeComplete2nd04}, Steve McConnell makes a strong argument for
groups to adopt a consistent coding standard, which includes reasonable
guidelines for the formatting of source code.

Therefore, one of the purpose of this document is to suggest reasonable and
minimal guidelines for ``consistent formatting'' for C++ code that can
facilitate collaborative code development and maintenance.

%
% RAB: This needs to be discussed and I need to look more into this once
% I get my XP book, 2nd edition.
%
% Consistent code
% formatting in a team of developers is a feature of the Extreme Programming
% (XP) approach to software development {}\cite{ExtremeProgramming}.

Even more important that code formatting, a consistent set of naming
conventions for C++ classes, functions, variables, and other entities also
helps to improve collaborative software development and quality.  Also, since
clients of the software must interact with these names, it is even more
important that a set of naming conventions be used as consistently as makes
sense.

Lastly, more important C++ coding guidelines are covered that append and amend
to those described in {}\cite{C++CodingStandards05}.  While formatting and
naming recommendations do not affect the meaning of C++ code, other coding
guidelines do and therefore they will recieve more attention and should be
taken more seriously.

%
\section{Naming conventions}
%

C++ classes, functions, variables, data members etc. should be named and used
in a fairly consistent manner.  The following guidelines are consistent with
accepted practice as exemplified in [???,???,???,???].

\begin{enumerate}

{}\item\textit{C++ class and struct names}: Names for C++ classes and structs
should generally be capitalized and seperate words should be concatenated and
capitalized.  For example:

{\small\begin{verbatim}
  class SomeClassName {...};
\end{verbatim}}

{}\item\textit{C++ namespace names}: C++ namespaces should follow the same
naming convention as C++ classes and namespace names should not contain too
many acronyms and should not be too short or too common.  For example:

{\small\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}}

{}\item\textit{C++ enum type names and enum values}: Enumeration type names
should follow the same convention as for class and struct names but they
should also begin with the capital letter 'E' to signify that this type is an
enum.  Enumeration values should be all upper-case with underscores between
words and should use a common prefix for semi-namespacing with the enum type.
Also, enum values should use the default value assignment defined by the
compiler in general as this aids their use as indexes into zero-based arrays.
For example:

{\small\begin{verbatim}
  enum ESolveStatus {
    SOLVE_STATUS_CONVERGED
    ,SOLVE_STATUS_UNCONVERGED
    ,SOLVE_STATUS_UNKNOWN
  };
\end{verbatim}}

{}\textit{Justification}: Using a capital 'E' for {}\texttt{enum}s allows the
definition of other types with the same basic name that contain other data.
For example, {}\texttt{ESolveStatus} in an {}\texttt{enum} enumerating the
different types of solve status and {}\texttt{SolveStatus} is a C++ struct
that contains an {}\texttt{ESolveStatus} member along with some other data.

{}\textit{rabartl note:} This convention is what is used in Thyra currently but it
is somewhat unconventional.  This can be changed pretty easily but the
quasi-namespacing aspect is very useful in general and should be kept in my
opinion.

{}\item\textit{C++ object instance identifier names}: Formal function
arguments and other object identifiers should, in general, start with a
lower-case letter and then use capitalization for following words with no
underscores between words in general.  For example:

{\small\begin{verbatim}
  ClassType1   obj;
  ClassType2   objectForMyThing;
  ClassType3   objectForYourThing;
\end{verbatim}}

{}\item\textit{C++ class/struct data member names}: Names for data members
within a class should use the same naming convention as for other object
identifier names but should end with an underscore.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}}

{}\textit{Exception}: Simple C++ structs with public data members and no
member functions (other than constructors) should not contain an underscore.
For example:

{\small\begin{verbatim}
  struct SolveStatus {
    ESolveStatus solveStatus;
    double achievedTol;
    std::string message;
    ...
  };
\end{verbatim}}

{}\item\textit{Naming of C++ pure abstract base classes, default
implementation bases, and default implementation classes}: In general, the
top-level C++ base class for some abstraction, such as a vector, should use
the postfix {}\texttt{Base} appended to the class name (e.g.\
{}\texttt{Vector\-Base}) and the base class should contain (almost) no
implementations and certainly no object data (see Item 36 in
{}\cite{C++CodingStandards05}).  If a default implementation of some of the
aspects of the base class are desired (to make it easer to define concrete
subclasses), then they should be put in a derived node subclass with the
postfix {}\texttt{DefaultBase} (e.g.\ {}\texttt{Vector\-Default\-Base}).  Any
default concrete implementation of an abstraction should generally use the
prefix {}\texttt{Default} appended to the beginning of the name along with any
other important prefixes (e.g.\ {}\texttt{DefaultSpmdVector}).  For example:

{\small\begin{verbatim}
  // Pure virtual base class 
  class VectorBase
    : ... // Other base classes
  {
  public:
    virtual void someFunc(...) const = 0;
    ...
  };

  // Node base class with some default implementations
  class VectorDefaultBase
   : virtual public VectorBase
  {
  public:
    void someFunc(...) const; // default implementation
    ...
  private:
    ...
  };

  // A general default implementation for SPMD vectors
  class DefaultSpmdVector
    : virtual public VectorDefaultBase // use some default implementations
  {
  public:
    void someFunc(...) const; // Specialized overrides
    ...
  private:
    ...
  };
\end{verbatim}}



\end{enumerate}

%
\section{Naming and organization of source files}
%

Since most C++ code is organized around classes, the file structure should
also primarily be organized around classes and the nonmember functions that
interact with these classes.  The primary goal of these file naming guidelines
is to create file names that are globally unique and will therefore facilitate
{}\texttt{\#include}s without need for directory paths in the
{}\texttt{\#include} statement.  The basic idea is that a source file should
be named based on what it has, not where it is.  The following guidelines help
to determine how to organize code into source files and how to name those
source files.  The directory structure of source files is beyond the scope of
this document.

\begin{enumerate}

{}\item\textit{File extension names}: Use the file extensions {}\texttt{*.hpp}
for C++ header files, {}\texttt{*.cpp} for C++ source files, {}\texttt{*.h}
for C header files, {}\texttt{*.c} for C source files, and {}\texttt{*.f} for
Fortran 77 source files.  These file names avoid common problems with
portability to various Unix and Windows platforms.

{}\item\textit{Only one major C++ class and supporting code per header and
source file}: As a general rule of thumb, assign the source code for any major
C++ class and supporting code to a single set of header and source files.  The
file name should be composed out of the namespace names enclosing the classes
and other code along with the class name itself.  For instance, for the class
{}\texttt{NameSpaceA\-::InnerNamespace\-::SomeClass}, the header and source
files would be named
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]}.

{}\item\textit{Use include guards in all header files}: All header files,
without exception, should use include guards [???].  For example, the file
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp} would have the basic
structure:

{\small\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

This is a amendment to Item 24 in {}\cite{C++CodingStandards05}

\end{enumerate}

%
\section{Nonsytle coding guidelines}
\label{thyracodingguidelines:codingguidelines:sec}
%

Coding guidelines, unlike formatting guidelines, do change the meaning of C++
programs and therefore require a high level of priority.  The book ``C++
Coding Standards'' {}\cite{C++CodingStandards05} that this document is
primarily based on provides many good and important coding guidelines that
should be followed and by default all of the items in this book are assumed in
this document.  Here, we provide additional coding guidelines and, in some
cases, amend items in {}\cite{C++CodingStandards05}.  Where this document is
silent, {}\cite{C++CodingStandards05} is to be considered the authoritative
source for guidance.

%
\subsection{General coding guidelines}
%

Below several different general coding guidelines are discussed.  These
guidelines affect software quality in a major way and are not just a matter of
personal preferences and styles.

\begin{enumerate}

{}\item\textit{Use the macro TEST\-\_FOR\-\_EXCEPTION(...) and its related
macros for reporting all errors, even programming errors}: For developer
errors, prefer to throw exceptions drived from
{}\texttt{std\-::logic\-\_error} instead of using the {}\texttt{assert(...)}
macro as recommended in {}\cite[Item 68]{C++CodingStandards05}.  A ``logic
error'' would be treated differently from a real runtime error and would
therefore come with different assumptions about the state of the object after
the exception was thrown.  In particular, a ``real error'' (i.e. not just an
internal developer error) should always provide the basic guarantee to leave
the object in a valid state {}\cite[Item 71]{C++CodingStandards05}, while code
that throws a ``logic error'' can not make any such guarantees in general.
Therefore, objects that throw exceptions derived from
{}\texttt{std\-::logic\-\_error} should generally be viewed as unusable and
should be deleted immediately.  To enable debugging, a breakpoint can always
be placed on function {}\texttt{Test\-For\-Exception\-\_break()}\footnote{In
{}\texttt{gdb}, a breakpoint would be set as {}\texttt{b
Test\-For\-Exception\-\_break()}.} which will be called just before an
exception is thrown through these macros.  In the future, more sophisticated
features like automatically attaching a debugger or printing the call stack
may be added for some systems.  Therefore throwing an exception derived from
{}\texttt{std\-::logic\-\_error} should be preferred to using
{}\texttt{assert(...)} macro as it gives us more control over what happens
when one of these types of programming errors occurs.

{}\item\textit{Avoid the use of raw C++ pointers in all but the lowest level
code}: The tools mentioned below which include {}\texttt{Teuchos::\-Ptr},
{}\texttt{Teuchos::\-Ref\-Count\-Ptr}, {}\texttt{Teuchos::\-Array},
{}\texttt{Teuchos::\-Array\-Ref\-Count\-Ptr}, and
{}\texttt{Teuchos::\-Array\-View} allow most code to be written without any
explicit raw C++ pointers.  Also, in general, perfer to use
{}\texttt{std\-::string} instead of {}\texttt{char*} or {}\texttt{const
char*}.  In debug mode, these classes allow for full runtime checking that
result in exceptions being thrown and excellent error messages (i.e.\ instead
of segfaults).  Indexing and other unchecked operations with
{}\texttt{std\-::string} objects is much less common in numerical code and
therefore is less likely to produce error inside of numerical code.

{}\item\textit{Use Teuchos::Ptr as function arguments in the place of raw C++
pointers to single objects where no persisting association exists}: ???

{}\item\textit{Use Teuchos::ArrayView as function arguments in the place of
pointers into raw arrays where no persisting association exists}: ???

{}\item\textit{Prefer Teuchos::Array to std::vector as a contiguous general
purpose data container}: While {}\texttt{Teuchos::\-Array} gets all of its
real functionality from {}\texttt{std::\-vector}, prefer to use
{}\texttt{Teuchos::\-Array} as we can provide more capabilities and built-in
optional checking.  For instance {}\texttt{Teuchos::\-Array::\-operator[]} is
range checked in debug mode regardless whether there is an underling checked
STL implementation or not (see {}\cite[Item 83]{C++CodingStandards05}).  In
addition, {}\texttt{Teuchos\-::Array} will automatically convert into an
{}\texttt{Teuchos\-::ArrayView} object safely when used in function calls.

{}\item\textit{Use Teuchos::RefCountPtr for memory management of single
dynamically allocated objects and for handling persisting
{}\cite{RefCountPtrBeginnersGuide} associations}: Replace all references to
the class {}\texttt{boost::\-shared\_ptr} in all items in
{}\cite{C++CodingStandards05} with {}\texttt{Teuchos::\-RefCountPtr}.

{}\item\textit{Use Teuchos::ArrayRefCountPtr for memory management of
dynamically allocated objects stored in contiguous arrays of data and for
persisting associations involving contiguous arrays}: Note that
{}\texttt{Teuchos::ArrayRefCountPtr} does {}\underline{not} take the place of
a contiguous container class such as {}\texttt{Teuchos::\-Array} or
{}\texttt{std::\-vector}.  A {}\texttt{Teuchos::ArrayRefCountPtr} object can
not change the size of the array, it can only provide for reference counted
sharing of an array of data of fixed size.

{}\item\textit{Use namespace enclosure for the definition of member functions
of a C++ class}: The member functions of a class should be defined in the same
order as their declarations and should generally be defined within a namespace
enclosure.  For example, given the declaration of

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.hpp

  namespace SomeNamespace {

  class SomeClass {
  public:
    void someFunc();
    ...
  };

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest and one of the tersest ways to define the member functions in the
source file is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.cpp

  namespace SomeNamespace {

  void SomeClass::someFunc()
  {
    ...
  }

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using the namespace enclosure instead of a
{}\texttt{using namespace SomeNamesapce} directive insures that you can never
accidentally provide another definition for some other class member function
in another namespace.  Explicit namespace qualification is not needed since if
one misspells any part of the prototype, then the compiler will issue an error
message.

{}\item\textit{Use explicit namespace qualification for the definition of all
nonmember C++ functions}: For example, for the nonmember function prototype

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.hpp

  namespace SomeNamespace {

  void someFunc( const int data );

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest way to define the nonmember function is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.cpp

  void Thyra::someFunc( const int data )
  {
    ...
  }

  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using explicit namespace qualification avoids
problems of spelling and other mistakes that can accidentally result in the
definition of a new function {}\cite[Section 8.2]{stroustrup00}.  Such a
mistake is caught at link time but can be very hard to figure out the root
cause of the problem.

%
\subsection{Specification of formal arguments for C++ member and nonmember functions}
%

Here a convention for the specification of the formation arguments for C++
member or nonmember functions is defined that leads to C++ code that is
consistent looking, maximizes compile-time and run-time checking, and is as
auto-documenting as possible.

ToDo: Fill this in once I have written and tested Teuchos::ArrayView and
Teuchos::Ptr classes.  No raw pointers!

\end{enumerate}
%
\section{Formating of source code}
\label{thyracodingguidelines:formatting:sec}
%

At the minimum, source code should be formatted consistently within a single
file or a set of tightly coupled files {}\cite[Item 0]{C++CodingStandards05}.
Ideally, source code should be formatted consistently enough across a code
project so as not to cause undue difficultly in shared maintenance and in
performing code reviews {}\cite{CodeComplete2nd04}.  Some consistency in
formatting helps and to facilitate multiple ownership and shared development
of a collection of software, such as in Extreme Programming (XP)
{}\cite{ExtremeProgramming}.  By ``formatting'' we generally refer to the use
of whitespace in the line-to-line formating of the program or in the ordering
of lines of code such that the meaning of the program to the compiler is
unchanged\footnote{While technically changing the name of a class, function or
variable changes the meaning of a program, if name changes are done in such a
way as to avoid name collisions, then naming conventions also do not affect
the meaning of the program and are therefore very much related to other
formatting issues such as the treatment of ``whitespace''.}  The handling of
indentation styles can largely be automated\footnote{Emacs supports multiple
file-specific formatting styles for C++ and tools like Artistic Style
{}\cite{ArtisticStyle} can format source files from the command line.  A
flavor of the {}\texttt{vi} editor may also support indentation styles. } 
which allows individual developers to work with any style they would like like
for files that they create but also makes it easy for developers to edits
files created by other developers and keep to their styles as well.  Later,
coding guidelines that do affect the meaning of a program are described in
Section {}\ref{thyracodingguidelines:codingguidelines:sec}.

Our main goal in this section is to try to provide reasonable recommendations
for those formating issues that are largely a matter of style and personal
preference but at the same time affect the overall readability of the code and
promote pair programming and joint ownership of the code
{}\cite{ExtremeProgramming}.  The formatting and indentation guidelines
presented here are largely consistent with the recommendations in
{}\cite[Chapter 31]{CodeComplete2nd04} and try to reduce the amount of ``right
drift'' that can occur with some common formatting and indentation styles.

These indentation guidelines outlined below can be largely automatically
supported by Emacs and are used by the custom style ``thyra'' defined in the
emacs package file cc-thyra-styles.el\footnote{See
{}\texttt{Trilinos/packages/thyra/emacs/README} for a description of the
``thyra'' Emacs style}.  Other custom sytles can also be added to this file
and used as well.  Any of these styles can be listed in each source file and
therefore anyone using Emacs can automatically use a particular indentation
style without having to fight the editor and manually reformat code.

Some general principles of good formatting, as described in {}\cite[Section
31.1]{CodeComplete2nd04}, are:

\begin{enumerate}

{}\item\textit{Formatting should accurately and consistently show the logical
structure of the code}: It is somewhat subjective what formatting sytles
``show the logical structure'' of code but McConnell makes some good argments
for some styles over others.  However, it is up the group of programmers to
decide as a group what style items ``show the logical structure''.

{}\item\textit{Formatting should improve the readability of the code for most
people}: There are specific studies cited in {}\cite[Chapter
31]{CodeComplete2nd04} that provide good evidience to prefer some styles over
others.

{}\item\textit{Formatted code should retain its formatting well in the face of
modification; especially those performed by automatic tools}: Changing one
line of code should not require changes to other lines of code to maintain the
formatting style.

{}\item\textit{Formatting style should follow the most most typical idioms
unless one of the above principles are broken}: Where there is no good
technical argument for one formatting sytle item over another, then the one
that is ``more common'' should be chosen.  This is not advocated per-say
in{}\cite[Chapter 31]{CodeComplete2nd04} but it is good idea to follow popular
idioms in general where there are several equally good choices and therefore
the decision is arbitrary of which to chose from.

\end{enumerate}

Below, specific recommendations are spelled out that try to conform to common
practices but also try to avoid excessive ``right drift'':

\begin{enumerate}

{}\item\textit{The formatting style in any single file or group of closely
related files should be the same}: This is recommended in {}\cite[Item
0]{C++CodingStandards05}.

{}\item\textit{Try to keep all text within the first 80 character columns}:
Keeping most of the source code within the first 80 character columns helps to
make the code more readable and helps to facilitate side-by-side two-column
editing and comparisons of source code.  Most of the style and indentation
guidelines described below help to avoid code that extends beyond the 80th
column too rapidly. {}\textit{Justification}: ``Studies show that up to
ten-word text widths are optimal for eye tracking'' {}\cite[Item
0]{C++CodingStandards05}.  Also, some developers are still stuck with 80
column wide terminals.

{}\item\textit{Indent with spaces and not tabs}: The amount of spaces to use
per indentation level is up to the individual developer but an indentation of
only {}\textit{two spaces} is recommended (and is set in the `Emacs `thyra''
indentation style).  A study showed that an indentation offset of two-to-four
spaces was optimal for code reading comprehension {}\cite[Section
31.2]{CodeComplete2nd04}.  Whatever indentation amount is used, it should be
consistent in at least each source and header file {}\cite[Item
0]{C++CodingStandards05} (which can be enforced using a custom Emacs
indentation style).  Emacs by default will put in a tab when the tab-width is
equal to the number of indentation spaces.  Emacs can be told to always use
spaces instead of tabs by setting:

{\small\begin{verbatim}
  (setq indent-tabs-mode nil)
\end{verbatim}}

in the in the indentation style (as is done in the ``thyra'' style).  However,
it is easy to support different preferences for the amount of spaces to indent
by using a user-defined indentation style for Emacs (sorry {}\texttt{vi}
users).

{}\textit{Justification}: ``Some teams legitimately choose to ban tabs
... when misused, turn indenting into out-denting and non-denting.''
{}\cite[Item 0]{C++CodingStandards05}.

{}\item\textit{Do not indent source code inside of namespace enclosures,
instead use commented end brackets}: Indenting for namespace enclosures
results unnecessary, and in some cases excessive, indentation.  Instead use,

{\small\begin{verbatim}
  namespace MyNameSpace {
  namespace MyInnerNamespace {

  class SomeClass {..};

  void someFunc(...) {...}

  } // namespace MyInnerNamespace
  } // namespace MyNameSpace
\end{verbatim}}

{}\textit{Justification}: While indentation within namespaces is helpful in
small example code fragments, it provides little help in showing namespace
structure in more realistic code.  The use of commented end blocks is
generally sufficient to show namespace structure and will not result in
excessively indented code.  In addition, typically, each file will only
contain code from one (or more nested) namespace and therefore indenting for
namespaces provides no useful information.  Not indenting for namespace
enclosures is also consistent with the ``ansi'', the ``kr'' and the ``linux''
styles as defined by Artistic Style {}\cite{ArtisticStyle}.

{}\item\textit{C++ class and struct declaration indentation and layout}: C++
class declarations should generally be laid out with {}\texttt{public}
members coming before {}\texttt{protected} members coming before
{}\texttt{private} members and indented as:

{\small\begin{verbatim}
  class SomeClass {
  public:
    // Public member functions
    void func1();
  protected:
    // Public member functions
    void func2();
  private:
    // Private types
    typedef std::vector<int> int_array_t;
    // Private data members
    int data1_;
    int_array_t array1_;
    // Private member functions
    void func3();
  };
\end{verbatim}}

{}\textit{Justification}: This ordering of sections and data members is quite
common [???,???].  Above, we show private member functions after private data
members since private data members are more prominent and more common in the
class implementations than are private member functions.  Also, private types
(where typedefs are most common) must be listed before they are used in the
declaration of the private data members.  Note that public types used in
public member functions must be listed above (or at least forward declared)
before the public member functions that use them.

{}\item\textit{Formating of function prototypes, function definitions and
function calls}: Below, guidelines for formatting short function prototypes
and long prototypes are given.  These guidelines seek to result in prototypes
that are fairly tight (i.e. not too much whitespace explosion) while still
keeping code inside of 80 character columns.  This indentation style can (and
should) also be applied to function definitions and function calls.

  \begin{enumerate}

  {}\item\textit{List short function prototypes on one line if possible}: For
  example,

  {\small\begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}}

  or 

  {\small\begin{verbatim}
  ReturnType someFunction(int arg=0);
  \end{verbatim}}

  or some other style for whitespace within '(...)' but the opening '(' should
  come directly after the function name in all cases.

  {}\item\textit{Indent arguments on continuation lines one offset for longer
  prototypes}: Function prototypes that can not approximately fit on a single
  line in the first 80 character columns should have the function arguments
  listed starting on the second line with one unit of indentation (e.g. two
  spaces) from the function return type and function name line.  For example,
  several different valid formats for a longer function prototype are:

  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4 = "" );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction( int arg1, bool arg2,
    double* arg3[], const std::string &arg4 = "" );
  \end{verbatim}}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  The arguments can begin on the same
  line as the type + function name line on can start on the next line.  The
  ending parenthesis ')' can appear on the same line as the last line of
  arguments or can appear alone on the last line.  Other formats are possible
  also and can be appropriate in different situations.

  {}\textit{Justification}: See {}\cite[Section 31.1]{CodeComplete2nd04}.
  
  This indentation style for function argumentshelps to avoid massive ``right
  drift'' in many types of cases and simplifies maintenance.

  {}\item\textit{Return types can be listed on same line as the function name
  unless the line is too long}: A function prototype's return type should
  appear on the same line as the function name unless it is excessively long
  and would result in the return type + function name line to extend past the
  80th column.  When the return type + function name is too long, then it can
  be listed on separate lines with no indent, for example, as:
  
  {\small\begin{verbatim}
  Teuchos::RefCountPtr<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}

  However, listing the function return type an a separate line even in cases
  of shorter prototypes is just fine too.

  \end{enumerate}

{}\item\textit{Order the definitions of C++ entities the same as the order of
the declarations of those entities}: For example, one should order the
definitions of a set of member functions the same as the ordering of there
declarations in the class definition.  Maintaining the ordering of definitions
and declarations makes the code more readable and more maintainable.  For
example, if the function definitions are ordered the same as the declarations,
it can be easy to see if a function definition is missing (i.e.\ which could
be the cause of the link error that you are seeing).

{}\item\textit{Formatting if/else if/else statements}: ???

{}\item\textit{Formatting switch/case statements}: ???

{}\item\textit{Formatting for and while loops}: ???

\end{enumerate}

%
\section{Doxygen documentation guidelines}
%

Here a set of reasonable guidelines is stated for writing Doxygen (and plain
old) documentation for classes, functions, etc.\ that makes the specification
clear but is not too verbose or hard to maintain.  Other types of higher-level
documentation are also needed such as design documents and tutorials but
guidelines for these are not covered here.

%
\subsection{Goals for function and class level documentation}
%

\begin{enumerate}

{}\item\textit{Level of documentation should vary depending on the prominence
and/or the role of the software entity or collection}: Important interfaces or
widely disseminated concrete classes or functions require an appropriate level
of precise documentation.  Concrete implementations that are less widely
disseminated can provide less (or none in some cases) Doxygen documentation if
the implementation code itself is sufficiently easy to understand.  However,
major parts of an implementation should have at least some plain old (i.e.\
non-Doxygen) documentation to describe the basics of what is going on.

{}\item\textit{Important abstract interfaces must be fully specified
independent of any single concrete implementation}: In the case of important
abstract interfaces, the full specification of behavior for the compliant
objects (i.e. asserts, preconditions, postconditions) must be clearly stated
{}\cite[Item 69]{C++CodingStandards05}.  In some cases, this must be done
completely within the Doxygen documentation.  In other cases, a standard unit
testing function or class can be used to help specify the behavior of the
interface.  In fact, compiled and verified unit testing code may be superior
to standard Doxygen documentation since it can't ignored or become invalid.
On the other hand, it may be difficult for readers to wade through unit
testing code to find the specification of behavior and therefore both Doxygen
documentation and unit testing code should be used to provide for the fully
benefit.  Also, Doxygen documentation can automatically include bits and
pieces of compiled and tested code using the
{}\texttt{$\backslash$dontinclude} commands.

{}\item\textit{Behavior of "user level" interfaces must be completely
specified by the Doxygen documentation and/or higher-level documentation}:
This item is an amendment to the above item as a special case for ``user''
interfaces.  A "user" could be someone that simply writes client code to the
interface or one that provides implementations to the interface or both.
User's should not be expected to study unit testing code to figure out the
preconditions and/or postconditions for a function call.

{}\item\textit{Wrong documentation is (almost) worse than no documentation at
all}: Documentation must be maintained as code is changed and therefore
excessive or unnecessary documentation degrades the quality of a code.
However, some documentation with some small errors/omissions is better than no
documentation at all.

{}\item\textit{The same documentation should not be repeated if possible}: We
should strive for a single source for documentation and not repeat the same
documentation over and over again.  This is critical to insure that the
documentation can be successfully maintained.

{}\item\textit{The documentation should maintain itself as much as possible
and be testable as much as possible}: Any significant fragments of code that
are shown in the Doxygen-generated HTML documentation should come from
compiled and tested code.  This can be accomplished by using the
{}\texttt{$\backslash$dontinclude} Doxygen command to read in code fragments
automatically.  In this way, the compiler and our test suite can be used to
help verify at least parts of our documentation.

\end{enumerate}

%
\subsection{General doxygen documentation principles}
%

Now that some of the general goals for our Doxygen documentation have been
presented, more details guidelines are given below:

\begin{enumerate}

{}\item\textit{Write Doxygen documentation directly in header files with
documented entities}: Write Doxygen documentation comments directly attached
to the classes, functions and other entities to make the documentation as
tightly tied to the code as possible.  This has the unfortunate side-effect of
requiring complete recompilations whenever documentation is modified but the
overall benefit should be worth the downsides.  Note that the Doxygen
documentation can be stripped out of Doxygen-generated hyper-linked versions of
the code, leaving clean C++-only code without the extra clutter of detailed
documentation.  Therefore, developers should browse Doxygen-generated source
code instead of the source code directly when looking at the code and
performing code reviews.

{}\item\textit{Use a centralized set of definitions for common arguments when
possible}: Use clear and consistent naming of arguments in multiple functions
(within the same class and across as many classes and functions as makes
sense) and provide a centralized definition of these arguments if possible to
avoid repeating detailed definitions in each individual function's
documentation.  This helps to avoid duplicate documentation that is likely not
to be maintained correctly.  In the case of classes, this means providing some
common definitions in the main ``detailed'' documentation section.  In the
case of nonmember functions, this might involve a common Doxygen group (i.e.\
{}\texttt{$\backslash$defgroup}) for the set of functions.  In the case of
collections of nonmember functions, it may be difficult to expect readers to
find the common definitions but links to the common documentation are possible
using a variety of approaches.

{}\item\textit{Provide common preconditions/postconditions along with the
common documentation for common arguments when possible}: For common arguments
that are shared among many functions, define the most common preconditions for
them in a central place and avoid listing them on a function-by-function basis
unless they change for that function.  For a C++ class, place these common
arguments in the main documentation section under a
{}\texttt{$\backslash$section} named ``Common Function Arguments and
Pre/Post-Conditions''.  Only include preconditions for these arguments in
specific function documentation sections if it is different from the most
common preconditions.

{}\item\textit{Add a {}\texttt{$\backslash$brief} description for every entity
that is documented}: The {}\texttt{$\backslash$brief} field is used to provide
the short one-line documentation string that is included in the function
summary section of classes, groups, namespaces etc.  Even if no text
documentation is needed/wanted, add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment so that Doxygen will include the class, function, or other entity in
the HTML documentation.

{}\item\textit{Add {}\texttt{$\backslash$param} field for all arguments or
none of the arguments in a function; no partial {}\texttt{$\backslash$param}
field lists}: All arguments should be listed in {}\texttt{$\backslash$param}
fields with at least the [in], [out], or [in/out] specifications and these
should have at least a very short description.  Or, if the function arguments
are clear and trivial (and/or have already been defined in the common
documentation section), then no {}\texttt{$\backslash$param} fields should be
included at all.  If any of the arguments are listed in
{}\texttt{$\backslash$param} fields then all arguments should be listed in
{}\texttt{$\backslash$param} fields.

{}\item\textit{Only add a {}\texttt{$\backslash$returns} field only if
necessary}: Don't add a {}\texttt{$\backslash$returns} description of the
return value if it is already clearly specified in the
{}\texttt{$\backslash$brief} description of the function.  However, if the
nature of the return value is at all complex, then include a
{}\texttt{$\backslash$returns} field to describe it.  When referring to the
return argument, refer to it as {}\texttt{returnVal}.

{}\item\textit{Prefer specifying postconditions for output arguments in their
{}\texttt{$\backslash$param} field in general, and otherwise list them in the
'Postconditions' list}: The postconditions for output arguments can be listed
directly in the {}\texttt{$\backslash$param} field for the argument if they
only involve just that argument in a fairly simple way.  Otherwise, if the
postconditions are more complex or involve multiple arguments in order to
specify, then they can be listed in the Postconditions list.  It may be
difficult to objectively determine where to list the postconditions for output
arguments.

{}\item\textit{Order the documentation fields as {}\texttt{$\backslash$brief},
{}\texttt{$\backslash$param}, Preconditions, Postconditions, then
{}\texttt{$\backslash$returns}; omitting those that do not apply}: A
consistent ordering of sections of documentation for a class and within a
function makes it easier for readers to find what they are looking for.

{}\item\textit{If possible, try to use {}\texttt{$\backslash$relates} to
associate nonmember functions with a single class}: If a nonmember function
is most closely related to a single class, use the
{}\texttt{$\backslash$relates} field to cause the documentation for the
function to be listed with the classes documentation.  This makes it easier
for readers to find out everything that they can do with a class object (or
set of class objects) just by looking at a single HTML page and a single
summary list of functions (which includes member and nonmember related
functions).

{}\item\textit{Provide detailed documentation for only the initial declaration
of a virtual function}: Only provide detailed documentation of the initial
declaration of a virtual function in the class where it is first defined as
{}\texttt{virtual}.  In general, documentation should not be included for the
overrides of virtual functions in derived classes.  Doxygen automatically puts
in a link to the original virtual function in the base class so readers are
just one click away for seeing the detailed documentation.  Always add an
empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment for every class and every function that should be included in the HTML
documentation but where no text documentation is wanted or needed.

{}\item\textit{Group the overrides of virtual functions into groups according
what their base class}: For example, the overrides of the virtual functions
for the {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} would look like:

{\small\begin{verbatim}

  class SomeClass : public Teuchos::ParameterListAcceptor {
  public:

    ...

    /** \name Overriden from Teuchos::ParameterListAccpetor */
    //@{

    /** \brief . */
    void setParameterList(
      Teuchos::RefCountPtr<Teuchos::ParameterList> const& paramList);
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> getParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> unsetParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getParameterList() const;
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getValidParameters() const;

    //@}

    ...

  };

\end{verbatim}}

{}\item\textit{Example source code used in Doxygen-generated and other forms
of documentation should be extracted automatically from code that is compiled
and tested nightly}: Any significant fragment of code example that is shown in
Doxygen HTML documentation or a latex document needs to come from compiled and
tested code that can be updated automatically.  These C++ code fragments can
be selectively inserted automatically into Doxygen documentation using the
Doxygen {}\texttt{$\backslash$dontinclude} command.

{}\item\textit{Sample output should be generated automatically from compiled
and tested code}: Sample output included in Doxygen documentation should be
generated automatically by the test harness code and should be written to
files that included in the source directory.  The sample output in these files
can then be inserted into the Doxygen HTML documentation automatically using
the Doxygen {}\texttt{$\backslash$verbinclude} command.  Similar approaches
can also be used for latex documentation.

\end{enumerate}
