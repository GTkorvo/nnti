
%
\section{C++ Naming Conventions}
%

Classes, functions, variables, data members etc. should be named and used in a
consistent way.  The following guidelines are consistent with accepted
practice as exemplified in [???,???,???,???].

\begin{enumerate}

{}\item\textit{C++ class and struct names}: Names for C++ classes and structs
should generally be capitalized and words should be concatenated and
capitalized.  For example:

{\small\begin{verbatim}
  class SomeClassName {...};
\end{verbatim}}

{}\item\textit{C++ namespace names}: C++ namespaces should follow the same
naming convention as C++ classes and namespace names should not contain to
many acronyms and should not be too short.  For example:

{\small\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}}

{}\item\textit{C++ enum type names and enum values}: Enumeration type names
should follow the same convention as for class and struct names but they
should also begin with the capital letter 'E' to signify that this type is an
enum.  Enumeration values should be all upper-case with underscores between
words and should use a common prefix for semi-namespacing with the enum type.
Also, enum values should use the default value assignment defined by the
compiler in general as this aids their as indexes into arrays.  For example:

{\small\begin{verbatim}
  enum ESolverType {
    SOLVER_TYPE_SOLVER1
    ,SOLVER_TYPE_SOLVER2
    ,SOLVER_TYPE_SOLVER3
    ...
  };
\end{verbatim}}

{}\item\textit{C++ object instance identifier names}: Formal function
arguments and other object identifiers should, in general, start with a
lower-case letter and then use capitalization of following words and the
words with no underscores.  For example:

{\small\begin{verbatim}
    ClassType1   obj;
    ClassType2   objectForMyThing;
    ClassType3   objectForYourThing;
\end{verbatim}}
{}\item\textit{C++ class/struct data member names}: Names for data members
within a class should use the same naming convention as for other object
identifier names but should end with an underscore.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}}

\end{enumerate}

%
\section{Naming and Organization of Source Files}
%

Since most C++ code is organized around classes, the file structure should
also be organized around classes and the non-member functions that interact
with these classes.  The following guidelines help to determine how to
organize code into source files and how to name those source files.  The
directory structure of source files is beyond the scope of this document.

\begin{enumerate}

{}\item\textit{File extension names}: Use the file extensions {}\texttt{*.hpp}
for C++ header files, {}\texttt{*.cpp} for C++ source files, {}\texttt{*.h}
for C header files, {}\texttt{*.c} for C source files, and {}\texttt{*.f} for
Fortran 77 source files.  These file names avoid common problems with
portability to various Unix and Windows platforms.

{}\item\textit{One major class and supporting code per header and source
file}: As a general rule of thumb, assign the source code for any many C++
class and supporting code to a single set of header and source files.  The
file name should be composed out of the namespace names enclosing the classes
and other code along with the class name itself.  For example, the class
<tt>NameSpaceA\-::InnerNamespace\-::SomeClass</tt>, the header and source
files would be named
<tt>NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]</tt>.

{}\item\textit{Use include guards in all header files}: All header files,
without exception, should use include guards [???].  For example, the file
<tt>NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp</tt> would have the basic
structure:

{\small\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

\end{enumerate}

%
\section{Formating of Source Code}
%

Source code should be formatted in a consistent way across a code project.
This results in a consistent collection of source code that helps and to
facilitate multiple ownership and shared development.  By ``formatting'' we
generally referee to the use of whitespace in the line-to-line formating of
the program or in the ordering of lines of code such that the meaning of the
program to the compiler is unchanged.  Later, guidelines that do affect the
meaning of a program are described.

Our main goal in this section is to try to provide recommendations and
preferences for those formating issues that are largely a matter of style and
personal preference.  However, to achieve consistency and foster shared
ownership of code, we need to try to stick to a fairly consistent way of
formating source code.  Also, the indentation guidelines presented here try to
reduce the amount of ``right drift'' that can occur with some common
formatting and indentation styles.

These indentation guidelines can largely automatically be supported by emacs
by setting the following set of options in the {}\texttt{.emacs}
initialization file:

{\small\begin{verbatim}
(custom-set-variables
 '(c-basic-offset 2)
 '(c-default-style "stroustrup")
 '(c-label-minimum-indentation 0)
 '(c-offsets-alist (quote ((block-open . +) (case-label . +)
    (inextern-lang . 0) (innamespace . 0))))
 '(c-tab-always-indent t)
 '(case-fold-search t)
 '(current-language-environment "English")
 '(fill-column 78)
 '(font-lock-auto-fontify t)
 '(font-lock-maximum-decoration t)
 '(font-lock-mode t nil (font-lock))
 '(font-lock-use-colors nil)
 '(font-lock-use-fonts t)
 '(indent-tabs-mode nil)
 '(line-number-mode t)
 '(load-home-init-file t t)
 '(make-backup-files nil)
 '(query-user-mail-address nil)
 '(require-final-newline t)
 '(tab-width 2)
 '(transient-mark-mode t)
 '(truncate-lines t)
 '(user-mail-address "rabartl@sandia.gov"))
(custom-set-faces
 '(default ((t (:family "Clean" :size "12pt"))) t))

(setq minibuffer-max-depth nil)
\end{verbatim}}

Below, specific recommendations are spelled out.

\begin{enumerate}

{}\item\textit{Try to keep all text within the first 80 character columns}:
Keeping most of the source code within the first 80 character columns helps to
make the code more readable and helps to facilitate side-by-side two-column
editing and comparisons of source code.  Most of the style and indentation
guidelines described below help to avoid code that extends beyond the 80th
column too rapidly.

{}\item\textit{Indent with spaces and not tabs}: The amount of spaces to use
per indentation level up to the individual developer but an indentation of
only {}\textit{two spaces} is recommended (and is set in the above
{}\texttt{.emacs} initialization file commands).  Emacs by default will put in
a tab when the tab-width is equal to the number of indentation spaces.  Emacs
can be told to always use spaces instead of tabs by setting:

{\small\begin{verbatim}
    (indent-tabs-mode nil)
\end{verbatim}}

in the {}\texttt{.emacs} file as shown above.

{}\item\textit{Don't indent source code inside of namespace enclosures, instead
using commented end brackets to show namespace enclosures}: Indenting for
namespace enclosures results in excessive indentation.  For example, use:

{\small\begin{verbatim}
  namespace MyNameSpace {
  namespace MyInnerNamespace {

  class SomeClass {..};

  void someFunc(...) {...}

  } // namespace MyInnerNamespace
  } // namespace MyNameSpace
\end{verbatim}}

While indentation within namespaces is helpful in small example code
fragments, it provides little help in showing namespace structure in more
realistic code.  The use of commented end blocks is generally sufficient to
show namespace structure and will not result in excessively indented code.

{}\item\textit{C++ class and struct declaration indentation and layout}: C++
class declarations should generally be laid out with {}\texttt{public}
members coming before {}\texttt{protected} members coming before
{}\texttt{private} members and indented as:

{\small\begin{verbatim}
  class SomeClass {
  public:
    // Public member functions
    void func1();
  protected:
    // Public member functions
    void func2();
  private:
    // Private types
    typedef std::vector<int> int_array_t;
    // Private data members
    int data1_;
    int_array_t array1_;
    // Private member functions
    void func3();
  };
\end{verbatim}}

This ordering of sections and data members is quite common and is shown in
[???,???].  Above, we show private member functions after private data members
since the private data members are more important prominent and more common in
the classes implementation than are the private member functions.  Also,
private types (where typedefs are most common) must be listed before they are
used in the declaration of the private data members.  Note that public types
used in public member functions must be listed above (or at least forward
declared) before the public member functions that use them.

{}\item\textit{Formating of function prototypes}:

  \begin{enumerate}

  {}\item\textit{Short prototypes}: Short function prototypes can be listed
  on a single line.  For example,

  {\small\begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}}

  {}\item\textit{Longer prototypes}: Function prototypes can can not fit on a
  single line in the first 80 character columns should have the function
  arguments listed starting on the second line with one unit of indent
  (i.e. two spaces) from the function return and name line.  For example,
  several different valid formattings for a function prototype are:

  {\small\begin{verbatim}
  ReturnType someFunction(
    int                  arg1
    ,bool                arg2
    ,double*             arg3[]
    ,const std::string   &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1
    ,bool arg2
    ,double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4 = "" );
  \end{verbatim}}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  Comas separating function arguments
  can appear at the end of the argument names or at the beginning of new
  lines.  The ending parenthesis ')' can appear on the same line as the last
  line of arguments or can appear alone on the last line.  Other formats are
  possible also and can be appropriate in different situations.

  {}\item\textit{Return types should be listed on same line as function name
  unless too long}: A function prototype's return type should appear on the
  same line as the function name unless it is excessively long and would
  result in the return value + function name line to extend past the 80th
  column.  When the return type + function name is too long, then it can be
  listed on separate lines with no indent, for example, as:
  
  {\small\begin{verbatim}
  Teuchos::RefCountPtr<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}

  \end{enumerate}

{}\item\textit{Order the definitions of C++ entities the same as the order of
the declarations of those entities}: For example, one should order the
definitions of a set of member functions the same as the ordering of there
declarations.  Maintaining the ordering of definitions and declarations makes
the more readable and more maintainable.  For example, if the function
definitions are ordered the same as the declarations, it can be easy to see if
a function definition is missing (i.e. that could be the cause of the link
error that you are seeing).

{}\item\textit{Formatting of if/else statements}: ???

{}\item\textit{Formatting of switch/case statements}: ???

{}\item\textit{Formatting of for loops}: ???

{}\item\textit{Formatting of variable definitions}: ???

\end{enumerate}

%
\section{C++ Coding Guidelines}
%

Here we assume that the reader is familiar with the most standard C++
programming idioms as described in [???,???,???] and it is not our goal to
repeat all of those here.  For instance, developers should follow all 50 items
in the book ``Effective C++'' but these will not be repeated here.

%
\subsection{General Coding Guidelines}
%

Below several different general coding guidelines are discussed.  These
guidelines are more a matter of real measures of software quality and less a
matter of simply different personal preferences of style.

\begin{enumerate}

{}\item\textit{Use Teuchos::RefCountPtr for memory management of single
dynamically allocated objects}: ???

{}\item\textit{Use Teuchos::ArrayRefCountPtr for memory management of
dynamically allocated arrays objects stored in contiguous arrays of data}: ???

{}\item\textit{Definition of member functions of a C++ class}: ???

{}\item\textit{Definition of non-member C++ functions}: ???

{}\item\textit{Do not use public data members in C++ classes}: See [???]

{}\item\textit{Only use public data members in the most trivial of C++
structs}: For example:

{\small\begin{verbatim}
  struct SomeStruct {
    int     data1;
    double  data2;
    string  data3;
  };
\end{verbatim}}

{}\item\textit{Never used protected data members}: Protected data members are
a major source of design and maintenance problems.  In fact, the C++
standards committee even considered removing support protected class data
members from the C++ standard [???].

{}\item\textit{Avoid the use of {}\texttt{friends} in all but the rarest of
cases}: ???

{}\item\textit{Prefer nonmember functions to member functions to implement a
behavior on an object if possible}: If a particular functionality on an object
can be implemented in an efficient way strictly given the object's public interface ...

{}\item\textit{Always prefer exception handling to the use of error codes in
all but the rarest of cases}: ??? use the Teuchos macros
{}\texttt{TEST\-\_FOR\-\_EXCEPT(condition)},
{}\texttt{TEST\-\_FOR\-\_EXCEPTION(condition)}, or
{}\texttt{TEST\-\_FOR\-\_EXCEPTION\-\_PURE\-\_MSG(condition)} to throw an
exception instead of a raw {}\texttt{throw}.

{}\item\textit{Avoid the use of {}\texttt{using namespace} directives and
instead use selective {}\texttt{using namespace\-::member} declarations or
{}\texttt{typedef} declarations instead}: Inserting using directives such as:

{\small\begin{verbatim}
  namespace MyNameSpace {

  using namespace Namespace1;
  using namespace Namespace2;

  } // namespace MyNameSpace

\end{verbatim}}

is inviting name collisions, ambiguity errors, and downright unforeseen
surprises and should be avoided as much as possible.  Instead, be selective of
what names from a namespace that you want to inject into your namespaces, or
your scopes.  For example, a common set of selective {}\texttt{using}
declarations might be:

{\small\begin{verbatim}
  namespace MyNameSpace {
    using Teuchos::RefCountPtr;
    using Teuchos::rcp;
    using Teuchos::rcp_dynamic_cast;
    using Teuchos::rcp_const_cast;
    ...
  };
\end{verbatim}}

{}\item\textit{Use std::string for string objects instead of raw char* array
in all but the rarest of cases}: ???

{}\item\textit{Use forward declarations as much as possible and aggregate
these into common header files when appropriate}: Using forward declarations
helps to avoid repeated unnecessary recompilations as much as possible [???].

\end{enumerate}

%
\subsection{Specification of formal arguments for C++ member and nonmember functions}
%

Here a convention for the specification of the formation arguments for C++
member or non-member function is defined that leads C++ code that is
consistent looking, maximizes compile-time checking, and is as
auto-documenting as possible.

ToDo: Fill this in!

%
\section{Doxygen Documentation Guidelines}
%

We need to come up with a set of reasonable guidelines for writing Doxygen
(and plain old) documentation for classes, functions, etc.\ that makes the
specification clear but is not too verbose or hard to maintain.

%
\subsection{Goals of function and class level documentation}
%

\begin{enumerate}

{}\item\textit{Level of documentation should vary depending on the prominence
and/or the role of the software entity or collection}: Important interfaces or
widely disseminated concrete classes or functions require an appropriate level
of precise documentation.  Concrete implementations that are less widely
disseminated can less (or none in some cases) Doxygen documentation if the
implementation code itself is sufficiently easy to understand.  However, major
parts of an implementation should have at least some plain old documentation
to describe the basics of what is going on.

{}\item\textit{Important abstract interface must be fully specified
independent of any single concrete implementation}: In the case of important
abstract interfaces, the full specification of behavior for the compliant
objects (i.e. asserts, preconditions, postconditions) must be clearly stated.
In some cases, this must be done completely within the Doxygen documentation.
In other cases, a standard unit testing function or class can be used to help
specify the behavior of the interface.  In fact, the compiled and tested unit
testing code may be superior to standard Doxygen documentation since it can't
ignored or become invalid.  On the other hand, it may be difficult for readers
to wade through unit testing code to find the specification of behavior and
therefore both Doxygen documentation and unit testing code should be used to
provide for the fully benefit.

{}\item\textit{Behavior of "user level" interfaces must be completely
specified by the Doxygen documentation and/or higher-level documentation}: A
"user" could be one that simply writes client code to the interface or one
that provides implementations to the interface or both.  User's should not be
expected to study unit testing code to figure out the preconditions and/or
postconditions for a function call.

{}\item\textit{Wrong documentation is (almost) worse than no documentation at
all}: Documentation must be maintained as code is changed and therefore
excessive or unnecessary documentation degrades the quality of a code.
However, some documentation with some small errors/omissions is better than no
documentation at all.

{}\item\textit{The same documentation should not be repeated if possible}: We
should strive for a single source for documentation and not repeat the same
documentation over and over again.  This is critical to insure that the
documentation can be successfully maintained.

{}\item\textit{The documentation should maintain itself as much as possible
and be testable as much as possible}: Any significant fragments of code that
are shown in the Doxygen-generated HTML documentation should come from compiled
and tested code.  This can be accomplished by using the
{}\texttt{$\backslash$dontinclude} Doxygen command to read in code fragments
automatically.  In this way, the compiler and our test suite can be used to
help verify our documentation.

\end{enumerate}

%
\subsection{General Doxygen Documentation Principles}
%

\begin{enumerate}

{}\item\textit{Write Doxygen documentation directly in header files with
documented entities}: Write Doxygen documentation comments directly attached to
the classes, functions and other entities to make the documentation as tightly
tied to the code as possible.  This has the unfortunate side-effect of
requiring complete recompilations whenever documentation is modified but the
overall benefit should be worth the downsides.

{}\item\textit{Use a centralized set of definitions for common arguments when
possible}: Use clear and consistent naming of arguments in multiple functions
(within the same class and across as many classes and functions as makes
sense) and provide a centralized definition of these arguments if possible
to avoid repeating detailed definitions in each individual function.  This
helps to avoid duplicate documentation that is likely not to be maintained
correctly.  In the case of classes, this means providing some common
definitions in the main documentation section.  In the case of non-member
functions, this might involve a common group for the function.  In the case
of collections of non-member functions, it may be difficult to expect readers
to find the common definitions but links to the common documentation might be
possible.

{}\item\textit{Provide common preconditions/postconditions along with the
common documentation for common arguments when possible}: For common arguments
that are shared among many functions, define the most common preconditions for
them in a central place and avoid listing them over and over again unless they
change.  For a C++ class, place these common arguments in the main
documentation section under a {}\texttt{$\backslash$section} named ``Common
Function Arguments and Pre/Post-Conditions''.  Only include preconditions for
these arguments in specific function documentation sections if it is different
from the most common preconditions.

{}\item\textit{Add a {}\texttt{$\backslash$brief} description for every entity
that is documented}: The {}\texttt{$\backslash$brief} field is used to provide
the short one-line documentation string that is included in the function
summary section of classes, groups, namespaces etc.  Even if no text
documentation is needed/wanted, add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment so that Doxygen will include the class, function, or other entity in
the HTML documentation.

{}\item\textit{Add {}\texttt{$\backslash$param} field for all arguments or
none of the arguments in a function, but no partial
{}\texttt{$\backslash$param} fields}: All arguments should be listed in
{}\texttt{$\backslash$param} fields with at least the [in], [out], or [in/out]
specifications and these should have at least a very short description.  Or,
if the function arguments are clear and trivial, then no
{}\texttt{$\backslash$param} fields should be included at all.  If any of the
arguments are listed in {}\texttt{$\backslash$param} fields then all
arguments should be listed in {}\texttt{$\backslash$param} fields.

{}\item\textit{Only add a {}\texttt{$\backslash$returns} field only if
necessary}: Don't add a {}\texttt{$\backslash$returns} description of the
return value if it is already clearly specified in the
{}\texttt{$\backslash$brief} description of the function.  However, if the
nature of the return value is at all complex, then include a
{}\texttt{$\backslash$returns} field to describe it.  When referring to the
return argument, refer to it as {}\texttt{returnVal}.

{}\item\textit{Prefer specifying postconditions for return arguments in their
{}\texttt{$\backslash$param} field in general, and otherwise list in the
'Postconditions' list}: The postconditions for return arguments can be listed
directly in the {}\texttt{$\backslash$param} field for the argument if they
only involve just that argument in a fairly simple way.  Otherwise, if the
postconditions are more complex or involve multiple arguments in order to
specify, then they can be listed in the Postconditions list.  It may be
difficult to objectively determine where to list the postconditions for return
arguments.

{}\item\textit{Order the documentation fields as {}\texttt{$\backslash$brief},
{}\texttt{$\backslash$param}, Preconditions, Postconditions,
then {}\texttt{$\backslash$returns}; omitting those that do not apply}: A
consistent ordering of sections of documentation for a class and within a
function make it easier to readers to find what they are looking for.

{}\item\textit{If possible, try to use {}\texttt{$\backslash$relates} to
associate non-member functions with a single class}: If a non-member function
is most closely related to a single class, use the
{}\texttt{$\backslash$relates} field to cause the documentation for the
function to be listed with the classes documentation.  This makes it easier
for readers to find out everything that they can do with a class object (or
set of class objects) just by looking at a single HTML page and a single
summary list of functions (which includes member and non-member related
functions).

{}\item\textit{Provide detailed documentation for only the initial declaration
of a virtual function}: Only provide detailed documentation of the initial
declaration of a virtual function in the class where it is first defined as
{}\texttt{virtual}.  In general, documentation should not be included for the
overrides of virtual functions in derived classes.  Doxygen automatically puts
in a link to the original virtual function in the base class so readers are
just one click away for seeing the detailed documentation.  Always add an
empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment for every class and every function that should be included in the HTML
documentation but where not text documentation is wanted or needed.

{}\item\textit{Group the overrides of virtual functions into groups according
what their base class}: For example, the overrides of the virtual functions
for the {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} would look like:

{\small\begin{verbatim}

  class SomeClass : public Teuchos::ParameterListAcceptor {
  public:

    ...

    /** \name Overriden from Teuchos::ParameterListAccpetor */
    //@{

    /** \brief . */
    void setParameterList(
      Teuchos::RefCountPtr<Teuchos::ParameterList> const& paramList);
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> getParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> unsetParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getParameterList() const;
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getValidParameters() const;

    //@}

    ...

  };

\end{verbatim}}

{}\item\textit{Example source code should come automatically from nightly
compiled and tested code}: Any significant fragment of code example that is
shown in Doxygen HTML documentation or a latex document needs to come from a
compiled and tested code that can be updated automatically.  These C++ code
fragments can be selectively inserted automatically using the Doxygen
{}\texttt{$\backslash$dontinclude} command.

{}\item\textit{Sample output should be generated automatically from compiled
and tested code}: Sample output included in Doxygen documentation should be
generated automatically by the test harness code and should be written to
files that included in the source directory.  The sample output in these files
can then be inserted into the Doxygen HTML documentation automatically using
the Doxygen {}\texttt{$\backslash$verbinclude} command.

\end{enumerate}
