
%
\section{C++ Naming Conventions}
%

Classes, functions, variables, data members etc. should be named and used in a
consistent way.  The following guildlines are consistent with accepted
practice as exemplified in [???,???,???,???].

\begin{enumerate}

{}\item\textit{C++ class and struct names}: Names for C++ classes and structs
should generally be capitalized and words should be concatenated and
capitalized.  For example:

\begin{verbatim}
  class SomeClassName {...};
\end{verbatim}

{}\item\textit{C++ namespace names}: C++ namespaces should follow the same
naming convension as C++ classes and namespace names should not contain to
many acronyms and should not be too short.  For example:

\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}

{}\item\textit{C++ enum type names and enum values}: Enumeration type names
should follow the same convention as for class and struct names but they
should also begin with the capital letter 'E' to signify that this type is an
enum.  Enumeration values should be all upper-case with underscores between
words and should use a common prefix for semi-namespacing with the enum type.
Also, enum values should use the default value assignment defined by the
compiler in general as this aids their as indexes into arrays.  For example:

\begin{verbatim}
  enum ESolverType {
    SOLVER_TYPE_SOLVER1
    ,SOLVER_TYPE_SOLVER2
    ,SOLVER_TYPE_SOLVER3
    ...
  };
\end{verbatim}

{}\item\textit{C++ object instance identifier names}: Formal function
arguments and other object identifiers should, in general, start with a
lower-case letter and then use capitailization of following words and the
words with no underscores.  For example:

\begin{verbatim}
    ClassType1   obj;
    ClassType2   objectForMyThing;
    ClassType3   objectForYourThing;
\end{verbatim}
{}\item\textit{C++ class/struct data member names}: Names for data members
within a class should use the same naming convention as for other object
identifier names but should end with an underscore.  For example:

\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}

\end{enumerate}

%
\section{Naming and Organization of Source Files}
%

Since most C++ code is organized around classes, the file structure should
also be organized around classes and the non-member functions that interact
with these classes.  The following guildelines help to determine how to
organize code into source files and how to name those source files.  The
directory structure of source files is beyond the scope of this document.

\begin{enumerate}

{}\item\textit{File extension names}: Use the file extensions {}\texttt{*.hpp}
for C++ header files, {}\texttt{*.cpp} for C++ source files, {}\texttt{*.h}
for C header files, {}\texttt{*.c} for C source files, and {}\texttt{*.f} for
Fortran 77 source files.  These file names avoid common problems with
portability to various Unix and Windows platforms.

{}\item\textit{One major class and supporting code per header and source
file}: As a general rule of thumb, assign the source code for any many C++
class and supporting code to a single set of header and source files.  The
file name should be composed out of the namespace names enclusing the classes
and other code along with the class name itself.  For example, the class
<tt>NameSpaceA\-::InnerNamespace\-::SomeClass</tt>, the header and source
files would be named
<tt>NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]</tt>.

{}\item\textit{Use include guards in all header files}: All header files,
without exception, should use include guards [???].  For example, the file
<tt>NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp</tt> would have the basic
structure:

\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

\end{enumerate}

%
\section{Formating of Source Code Files}
%

Source code should be formatted in a consistent way across a code project.
This results in a consistent collection of source code helps and to facilitate
multiple ownership of source code.  Our main goal is to try to provide
recommendations and preferences for those formating issues that are laragely a
matter of style and personal preference.  However, to achieve consistency and
foster shared ownership of coee, we need to try to stick to a faily consistent
way of formating source code.  Also, the indentation guidelines presented here
try to reduce the amount of ``right drift'' that can occur with some common
formatting and indentation styles.


These indentation guidelines can largely automatically be supported by emacs
by setting the following set of options in the {}\texttt{.emacs}
initialization file:

\begin{verbatim}
(custom-set-variables
 '(c-basic-offset 2)
 '(c-default-style "stroustrup")
 '(c-label-minimum-indentation 0)
 '(c-offsets-alist (quote ((block-open . +) (case-label . +)
    (inextern-lang . 0) (innamespace . 0))))
 '(c-tab-always-indent t)
 '(case-fold-search t)
 '(current-language-environment "English")
 '(fill-column 78)
 '(font-lock-auto-fontify t)
 '(font-lock-maximum-decoration t)
 '(font-lock-mode t nil (font-lock))
 '(font-lock-use-colors nil)
 '(font-lock-use-fonts t)
 '(indent-tabs-mode nil)
 '(line-number-mode t)
 '(load-home-init-file t t)
 '(make-backup-files nil)
 '(query-user-mail-address nil)
 '(require-final-newline t)
 '(tab-width 2)
 '(transient-mark-mode t)
 '(truncate-lines t)
 '(user-mail-address "rabartl@sandia.gov"))
(custom-set-faces
 '(default ((t (:family "Clean" :size "12pt"))) t))

(setq minibuffer-max-depth nil)
\end{verbatim}

Below, specific recommendations are spelled out.

\begin{enumerate}

{}\item\textit{Try to keep all text within the first 80 character columns}:
Keeping most of the source code within the first 80 character columns helps to
make the code more readable and helps to facilite side-by-side two-column
editing and comparisons of source code.  Most of the sytle and indentation
guidelines described below help to avoid code that extends beyond the 80th
column too rapidly.

{}\item\textit{Indent with spaces and not tabs}: The amount of spaces to use
per indentation level up to the individual developer but an indentation of
only {}\textit{two spaces} is recommended (and is set in the above
{}\texttt{.emacs} initalization file commands).  Emacs by default will put in
a tab when the tab-width is equal to the number of indentation spaces.  Emacs
can be told to always use spaces instead of tabs by setting:

\begin{verbatim}
    (indent-tabs-mode nil)
\end{verbatim}

in the {}\texttt{.emacs} file as shown above.

{}\item\textit{Don't indent souce code inside of namespace enclosures, instead
using commented end brackets to show namespace enclosures}: Indenting for
namespace enclosures results in excessive indentation.  For example, use:

\begin{verbatim}
  namespace MyNameSpace {
  namespace MyInnerNamespace {

  class SomeClass {..};

  void someFunc(...) {...}

  } // namespace MyInnerNamespace
  } // namespace MyNameSpace
\end{verbatim}

While indentation within namespaces is helpful in small example code
fragments, it provides little help in showing namespace structure in more
realistic code.  The use of commented end blocks is generally sufficient to
show namespace structure and will not result in excessively indented code.

{}\item\textit{Formating of function prototypes}:


  \begin{enumerate}

  {}\item\textit{Short prototypes}: Short function prototypes can be listed
  on a single line.  For example,

  \begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}

  {}\item\textit{Longer prototypes}: Function prototypes can can not fit on a
  single line in the first 80 character columns should have the function
  arguments listed starting on the second line with one unit of indent
  (i.e. two spaces) from the function return and name line.  For example,
  several different valid formatings for a function prototype are:

  \begin{verbatim}
  ReturnType someFunction(
    int                  arg1
    ,bool                arg2
    ,double*             arg3[]
    ,const std::string   &arg4  = ""
    );
  \end{verbatim}
  
  or
  
  \begin{verbatim}
  ReturnType someFunction(
    int arg1
    ,bool arg2
    ,double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}
  
  or
  
  \begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}
  
  or
  
  \begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  Comas separating function arguments
  can appear at the end of the argument names ore at the begining of new
  lines.  Other formats are possible also and can be appropriate in different
  cases.

  {}\item\textit{Return types should be listed on same line as function name
  unless too long}: A function prototypes's return type should appear on the
  same line as the function name unless it is excessively long and would
  result in the return value + function name line to extend past the 80
  column.  When the return type + function name are too long, then can be
  listed on separate lines with no indent, for example, as:
  
  \begin{verbatim}
  Teuchos::RefCountPtr<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}

  \end{enumerate}

{}\item\textit{Foraming of if/else statements}: ???

{}\item\textit{Foraming of switch/case statements}: ???

{}\item\textit{Foraming of for loops}: ???

\end{enumerate}

%
\section{C++ Coding Guildelines}
%

Here we assume that the reader is familiar with the most standard C++
programming idioms as described in [???,???,???] and it is not our goal to
repeat all of those here.  For instance, developers should follow all 50 items
in the book ``Effective C++'' but these will not be repeated here.

%
\subsection{Genearal Coding Guidelines}
%

Below several different general coding guildelines are discussed.  These
guidelines are more a matter of real measures of software quality and less a
matter of simply different personal preferences of style.

\begin{enumerate}

{}\item\textit{C++ class and struct declaration indentation and layout}: C++
classes should generally be layed with with {}\texttt{public} members comming
before {}\texttt{protected} members comming before {}\texttt{private} members
and indented as:

\begin{verbatim}
  class SomeClass {
  public:
    // Public member functions
    void func1();
  protected:
    // Public member functions
    void func2();
  private:
    // Private types
    typedef std::vector<int> int_array_t;
    // Private data members
    int data1_;
    int_array_t array1_;
    // Private member functions
    void func3();
  };
\end{verbatim}

This ordering of sections and data members is quite common and is shown in
[???,???].  Above, we show private member functions after private data members
since the private data members are more important prominate and more common in
the classes implementation than are the private member functions.  Also,
private types (where typedefs are most common) must be listed before they are
used in the declaration of the private data members.  Note that public types
used in public member functions must be listed above (or at least forward
declared) before the public member functions that use them.

{}\item\textit{Use Teuchos::RefCountPtr for memory management of single
dynamically allocated objects}: ???

{}\item\textit{Use Teuchos::ArrayRefCountPtr for memory management of
dynamically allocated arrays objects stored in contiguous arrays of data}: ???

{}\item\textit{Definition of member functions of a C++ class}: ???

{}\item\textit{Definition of non-member C++ functions}: ???

{}\item\textit{Do not use public data members in C++ classes}: See [???]

{}\item\textit{Only use public data members in the most trivial of C++
structs}: For example:

\begin{verbatim}
  struct SomeStruct {
    int     data1;
    double  data2;
    string  data3;
  };
\end{verbatim}

{}\item\textit{Never used protected data members}: Protected data members are
a major source of design and maintainance problems.  In fact, the C++
standards committee even considered removing support protected class data
members from the C++ standard [???].

{}\item\textit{Avoid the use of {}\texttt{friends} in all but the rarest of
cases}: ???

{}\item\textit{Prefer nonmember functions to member functions to implement a
behavor on an object if possible}: If a particular functionality on an object
can be implemented in an efficient way strictly given the object's public interface ...

{}\item\textit{Always prefer exception handling to the use of error codes in
all but the rarest of cases}: ??? use the Teuchos macros
{}\texttt{TEST\-\_FOR\-\_EXCEPT(condition)},
{}\texttt{TEST\-\_FOR\-\_EXCEPTION(condition)}, or
{}\texttt{TEST\-\_FOR\-\_EXCEPTION\-\_PURE\-\_MSG(condition)} to throw an
exception instead of a raw {}\texttt{throw}.

{}\item\textit{Avoid the use of {}\texttt{using namespace} directives and
instead use selective {}\texttt{using namespace\-::member} declarations or
{}\texttt{typedef} declarations instead}: Inserting using directives such as:

\begin{verbatim}
  namespace MyNameSpace {

  using namespace Namespace1;
  using namespace Namespace2;

  } // namespace MyNameSpace

\end{verbatim}

is inviting name collisions, abiguity errors, and downright unforeseen
suprises and should be avoided as much as possible.  Instead, be selective of
what names from a namespace that you want to inject into your namespaces, or
your scopes.  For example, a common set of selective {}\texttt{using}
declarations might be:

\begin{verbatim}
  namespace MyNameSpace {
    using Teuchos::RefCountPtr;
    using Teuchos::rcp;
    using Teuchos::rcp_dynamic_cast;
    using Teuchos::rcp_const_cast;
    ...
  };
\end{verbatim}

{}\item\textit{Use std::string for string objects instead of raw char* array
in all but the rarest of cases}: ???

{}\item\textit{Use forward declarations as much as possible and aggregate
these into common header files when appropriate}: Using forward declarations
helps to avoid repeated unnecessary recompilations as much as possible [???].

\end{enumerate}

%
\subsection{Specification of formal arguments for C++ member and nonmember functions}
%

Here a convention for the specification of the formation arguments for C++
member or non-member function is defined that leads C++ code that is
consistent looking, maximizes compile-time checking, and is as
auto-documenting as possible.

ToDo: Fill this in!

%
\section{Doxygen Documention Guidelines}
%

We need to come up with a set of reasonable guidelines for writing doxygen
(and plain old) documentation for classes, functions, etc.\ that makes the
specification clear but is not too verbose or hard to maintain.

%
\subsection{Goals of function and class level documentation}
%

\begin{enumerate}

{}\item\textit{Level of documentation should vary depending on the prominence
and/or the role of the software entity or collection}: Important interfaces or
widely disseminated concrete classes or functions require an appropriate level
of precise documentation.  Concrete implementations that are less widely
disseminated can less (or none in some cases) doxygen documentation if the
implementation code itself is sufficiently easy to understand.  However, major
parts of an implementation should have at least some plain old documentation
to describe the basics of what is going on.

{}\item\textit{Important abstract interface must be fully specified
independent of any single concrete implementation}: In the case of important
abstract interfaces, the full specification of behavior for the compilent
objects (i.e. asserts, preconditions, postconditions) must be clearly stated.
In some cases, this must be done completely within the Doxygen documentation.
In other cases, a standard unit testing function or class can be used to help
specify the behavior of the interface.  In fact, the compiled and tested unit
testing code may be superior to standard doxygen documentation since it can't
ignored or become invalid.  On the other hand, it may be difficult for readers
to wade through unit testing code to find the specification of behavior and
therefore both doxygen documentation and unit testing code should be used to
provide for the fully benefit.

{}\item\textit{Behavior of "user level" interfaces must be completely
specified by the doxygen documentation and/or higher-level documentation}: A
"user" could be one that simply writes client code to the interface or one
that provides implementations to the interface or both.  User's should not be
expected to study unit testing code to figure out the preconditions and/or
postconditions for a function call.

{}\item\textit{Wrong documentation is (almost) worse than no documentation at
all}: Documentation must be maintained as code is changed and therefore
essessive or unnecessary documentation degrades the quality of a code.
However, some documentation with some small errors/omissions is better than no
documentation at all.

{}\item\textit{The documentation should maintain itself as much as possible
and be testable as much as possible}: ???

\end{enumerate}

%
\subsection{General Doxygen Documentation Principles}
%

\begin{enumerate}

{}\item\textit{Write doxygen documentation directly in header files with
documented entities}: Write doxygen documention comments directly attached to
the classes, functions and other entities to make the documentation as tightly
tied to the code as possible.  This has the unfortunate side-effect of
requiring complete recompilations whenever documentation is modified but the
overall benefit should be worth the downsides.

{}\item\textit{Use a centralized set of definitions for common arguments when
possible}: Use clear and consistent naming of arguments in multiple functions
(within the same class and across as many classes and functions as makes
sense) and provide a centerialized definition of these arguments if possible
to avoid repeating detailed definitions over and over again in each individual
functions.  In the case of classes, this means providing some common
definitions in the main documentation section.  In the case of non-member
functions, this might involve a commong group for the function.  In the case
of collections of non-member functions, it may be difficult to expect readers
to find the common definitions but links to the common documentation might be
possible.

{}\item\textit{Provide common preconditions/postconditions along with the
common documentation for common arguments when possible}: For common arguments
that are shared among many functions, define the most common preconditions for
them in a central place and avoid listing them over and over again unless they
change.  For a C++ class, place these common arguments in the main
documentation section under a {}\texttt{$\backslash$section} named ``Common
Function Arguments and Pre/Post-Conditions''.  Only include preconditions for
these arguments in specific function documentation sections if it is different
from the most common preconditions.

{}\item\textit{Add a {}\texttt{$\backslash$brief} description for every entity
that is documented}: The {}\texttt{$\backslash$brief} field is used to provide
the short one-line documentation string that is included in the function
summary section of classes, groups, namespaces etc.

{}\item\textit{Add {}\texttt{$\backslash$param} field for all arguments or
none of the arguments in a function, but no partial
{}\texttt{$\backslash$param} fields}: All arguments should be listed in
{}\texttt{$\backslash$param} fields with at least the [in], [out], or [in/out]
specifications and these should have at least a very short description.  Or,
if the function arguments are clear and trival, then no
{}\texttt{$\backslash$param} fields should be included at all.  If any of the
arguments are listed in {}\texttt{$\backslash$params} fields then all
arguments should be listed in {}\texttt{$\backslash$params} fields.

{}\item\textit{Only add a {}\texttt{$\backslash$returns} field only if
necessary}: Don't add a {}\texttt{$\backslash$returns} description of the
return value if it is already clearly specified in the
{}\texttt{$\backslash$brief} description of the function.  However, if the
nature of the return value is at all complex, then include a
{}\texttt{$\backslash$returns} field to describe it.  When refereing to the
return argument, rever to it as {}\texttt{returnVal}.

{}\item\textit{Prefer specifying postconditions for return arguments in their
{}\texttt{$\backslash$param} field in general, and otherwise list in the
'Postconditions' list}: The postconditions for return arguments can be listed
directly in the {}\texttt{$\backslash$params} field for the argument if they
only involve just that argument in a faily simple way.  Otherwise, if the
postconditions are more complex or involve multiple arguments in order to
specify, then they can be listed in the Postconditions list.  It may be
difficult to objectively determine where to list the postconditions for return
arguments.

{}\item\textit{Order the documentation fields as {}\texttt{$\backslash$brief},
{}\texttt{$\backslash$param}, Preconditions, Postconditions,
{}\texttt{$\backslash$return}; ommiting thoses that do not apply}: A
consistent ordering of sections of documentation for a class and within a
function make it easier to readers to find what they are looking for.

{}\item\textit{If possible, try to use {}\texttt{$\backslash$relates} to
associate non-member functions with a single class}: If a non-member function
is most closely related to a single class, use the
{}\texttt{$\backslash$relates} field to cause the documentation for the
function to be listed with the classes documentation.  This makes it easier
for readers to find out everything that they can do with a class object (or
set of class objects) just by looking at a single HTML page and a single
summary list of functions (which includes member and non-member related
functions).

{}\item\textit{Example source code should come automatically from nightly
compiled and tested code}: Any significant fragment of code example that is
shown in Doxygen HTML documentation or a latex document needs to come from a
compiled and tested code that can be updated automatically.  These C++ code
fragements can be selectively inserted automatically using the Doxygen
{}\texttt{$\backslash$dontinclude} command.

{}\item\textit{Sample output should be generated automatically from compiled
and tested code}: Sample output included in Doxygen documentation should be
generated automatically by the test harness code and should be written to
files that included in the source directory.  The sample output in these files
can then be inserted into the Doxygen HTML documentation automatically using
the Doxygen {}\texttt{$\backslash$verbinclude} command.

\end{enumerate}
