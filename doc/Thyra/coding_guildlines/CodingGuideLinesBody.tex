%
\section{Introduction}
%

Any successful collaborative software project (or any other type of
collaborative project for that matter) is benefited by some degree of
uniformity while still allowing for individuals to express there individuality
and apply their personal preferences.  This document deals with C++ coding
style and guidelines that is based primarily on the book ``C++ Coding
Standards'' by Sutter and Alexandrescu {}\cite{C++CodingStandards05}.  The
goal of this document is not to restate what is in this book but instead to
fill in some gaps intentionally left by the authors and to provide exceptions
and amendments to specific items in the book.

The zeroth item (first item, zero based) ``Don't seat the small stuff''
intentionally avoids specific recommendations on issues such as the conventions
for naming identifiers and the formatting of code since these are arbitrary.
However, in Item 0, they do state:

\begin{quote}

Do use consistent formatting within each source file or even each project,
because it's jarring to jump around among several styles in the same piece of
code.

\end{quote}

Therefore, the main purpose of this document is to define reasonable and
minimal guidelines for ``consistent formatting'' for C++ code that can
facilitate collaborative code development and maintenance.  Consistent code
formatting in a team of developers a feature of the Extreme Programming (XP)
approach to software development {}\cite{ExtremeProgramming}.  In addition to
code formatting, a consistent set of naming conventions for C++ classes,
functions, variables, and other entities also helps to improve collaborative
software development and quality.  Lastly, more important C++ coding
guidelines are covered that append and amend to those described in
{}\cite{C++CodingStandards05}.  While formatting recommendations that do not
affect the meaning of C++ code will not be enforced, coding guidelines that do
should be taken much more seriously.

%
\section{C++ Naming Conventions}
%

Classes, functions, variables, data members etc. should be named and used in a
consistent way.  The following guidelines are consistent with accepted
practice as exemplified in [???,???,???,???].

\begin{enumerate}

{}\item\textit{C++ class and struct names}: Names for C++ classes and structs
should generally be capitalized and words should be concatenated and
capitalized.  For example:

{\small\begin{verbatim}
  class SomeClassName {...};
\end{verbatim}}

{}\item\textit{C++ namespace names}: C++ namespaces should follow the same
naming convention as C++ classes and namespace names should not contain too
many acronyms and should not be too short.  For example:

{\small\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}}

{}\item\textit{C++ enum type names and enum values}: Enumeration type names
should follow the same convention as for class and struct names but they
should also begin with the capital letter 'E' to signify that this type is an
enum.  Enumeration values should be all upper-case with underscores between
words and should use a common prefix for semi-namespacing with the enum type.
Also, enum values should use the default value assignment defined by the
compiler in general as this aids their use as indexes into zero-based arrays.
For example:

{\small\begin{verbatim}
  enum ESolveStatus {
    SOLVE_STATUS_CONVERGED
    ,SOLVE_STATUS_UNCONVERGED
    ,SOLVE_STATUS_UNKNOWN
  };
\end{verbatim}}

{}\textit{Justification}: Using a capital 'E' for {}\texttt{enum}s allows the
definition of other types with the same basic name that contain other data.
For example, {}\texttt{ESolveStatus} in an {}\texttt{enum} enumerating the
different types of solve status and {}\texttt{SolveStatus} is a C++ struct
that contains an {}\texttt{ESolveStatus} member along with some other data.

{}\item\textit{C++ object instance identifier names}: Formal function
arguments and other object identifiers should, in general, start with a
lower-case letter and then use capitalization for following words with no
underscores between words in general.  For example:

{\small\begin{verbatim}
  ClassType1   obj;
  ClassType2   objectForMyThing;
  ClassType3   objectForYourThing;
\end{verbatim}}

{}\item\textit{C++ class/struct data member names}: Names for data members
within a class should use the same naming convention as for other object
identifier names but should end with an underscore.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}}

{}\textit{Exception}: Simple C++ structs with public data members and no
member functions (other than constructors) should not contain an underscore.
For example:

{\small\begin{verbatim}
  struct SolveStatus {
    ESolveStatus solveStatus;
    double achievedTol;
    std::string message;
    ...
  };
\end{verbatim}}

{}\item\textit{Naming of C++ pure abstract base classes, default
implementation bases, and default implementation classes}: In general, the
top-level C++ base class for some abstraction, such as a vector, should use
the postfix {}\texttt{Base} appended to the class name (e.g.\
{}\texttt{Vector\-Base}) and the base class should contain (almost) no
implementations and certainly no object data (see Item 36 in
{}\cite{C++CodingStandards05}).  If default implementations are desired to make
it easer to define concrete subclasses, then they should be put in a node
subclass with the postfix {}\texttt{DefaultBase} (e.g.\
{}\texttt{Vector\-Default\-Base}).  Any default concrete implementations of an
abstraction should generally use the prefix {}\texttt{Default} appended to the
beginning of the name along with any other important prefixes (e.g.\
{}\texttt{DefaultSpmdVector}).  For example:

{\small\begin{verbatim}
  // Pure virtual base class 
  class VectorBase
    : ... // Other base classes
  {
  public:
    virtual void someFunc(...) const = 0;
    ...
  };

  // Node base class with some default implementations
  class VectorDefaultBase
   : virtual public VectorBase
  {
  public:
    void someFunc(...) const; // default implementation
    ...
  private:
    ...
  };

  // A general default implementation for SPMD vectors
  class DefaultSpmdVector
    : virtual public VectorDefaultBase // use some default implementations
  {
  public:
    void someFunc(...) const; // Specialized overrides
    ...
  private:
    ...
  };
\end{verbatim}}



\end{enumerate}

%
\section{Naming and Organization of Source Files}
%

Since most C++ code is organized around classes, the file structure should
also primarily be organized around classes and the nonmember functions that
interact with these classes.  The primary goal of the file naming guidelines
is to create file names that are globally unique and will therefore facilitate
{}\texttt{\#include}s without need for directory paths in the
{}\texttt{\#include} statement.  The basic idea is that a source file should be
named based on what it has, not where it is.  The following guidelines help to
determine how to organize code into source files and how to name those source
files.  The directory structure of source files is beyond the scope of this
document.

\begin{enumerate}

{}\item\textit{File extension names}: Use the file extensions {}\texttt{*.hpp}
for C++ header files, {}\texttt{*.cpp} for C++ source files, {}\texttt{*.h}
for C header files, {}\texttt{*.c} for C source files, and {}\texttt{*.f} for
Fortran 77 source files.  These file names avoid common problems with
portability to various Unix and Windows platforms.

{}\item\textit{One major class and supporting code per header and source
file}: As a general rule of thumb, assign the source code for any major C++
class and supporting code to a single set of header and source files.  The
file name should be composed out of the namespace names enclosing the classes
and other code along with the class name itself.  For instance, for the class
{}\texttt{NameSpaceA\-::InnerNamespace\-::SomeClass}, the header and source
files would be named
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]}.

{}\item\textit{Use include guards in all header files}: All header files,
without exception, should use include guards [???].  For example, the file
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp} would have the basic
structure:

{\small\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

This is a amendment to Item 24 in {}\cite{C++CodingStandards05}

\end{enumerate}

%
\section{Formating of Source Code}
\label{thyracodingguidelines:formatting:sec}
%

At the minimum, source code should be formatted consistently within a single
file or a set of tightly coupled files {}\cite[Item 0]{C++CodingStandards05}.
Ideally, source code should be formatted consistently enough across a code
project so as not to cause undue difficultly in the share maintenance
responsibilities and in performing code reviews.  Some consistency in
formatting helps and to facilitate multiple ownership and shared development
of a collection of software, such as in Extreme Programming (XP)
{}\cite{ExtremeProgramming}.  By ``formatting'' we generally refer to the use
of whitespace in the line-to-line formating of the program or in the ordering
of lines of code such that the meaning of the program to the compiler is
unchanged\footnote{While technically changing the name of a class, function
or variable changes the meaning of a program, if name changes are done in such
a way as to avoid name collisions, then naming conventions also do not affect
the meaning of the program and are therefore very much related to other
formatting issues such as the treatment of ``whitespace''.}  While handling of
indentation styles can largely be automated {}\cite{ArtisticStyle} and
therefore allow individual developers to work with any style they would like
locally, there are other style issues that are not so easily amiable to
tools.  Later, coding guidelines that do affect the meaning of a program are
described in Section {}\ref{thyracodingguidelines:codingguidelines:sec}.

Our main goal in this section is to try to provide reasonable recommendations
and preferences for those formating issues that are largely a matter of style
and personal preference but at the same time affect the overall readability of
the code and promote pair programming and joint ownership of the code
{}\cite{ExtremeProgramming}.  The formatting and indentation guidelines
presented here try to reduce the amount of ``right drift'' that can occur with
some common formatting and indentation styles.

These indentation guidelines outlined below can be largely automatically
supported by Emacs by setting the following set of options in the
{}\texttt{.emacs} initialization file:
%
{\small\begin{verbatim}
  (custom-set-variables
   '(c-basic-offset 2)
   '(c-default-style "stroustrup")
   '(c-label-minimum-indentation 0)
   '(c-offsets-alist (quote ((block-open . +) (case-label . +)
      (inextern-lang . 0) (innamespace . 0))))
   '(c-tab-always-indent t)
   '(case-fold-search t)
   '(current-language-environment "English")
   '(fill-column 78)
   '(font-lock-auto-fontify t)
   '(font-lock-maximum-decoration t)
   '(font-lock-mode t nil (font-lock))
   '(font-lock-use-colors nil)
   '(font-lock-use-fonts t)
   '(indent-tabs-mode nil)
   '(line-number-mode t)
   '(load-home-init-file t t)
   '(make-backup-files nil)
   '(query-user-mail-address nil)
   '(require-final-newline t)
   '(tab-width 2)
   '(transient-mark-mode t)
   '(user-mail-address "rabartl@sandia.gov"))
  (custom-set-faces
   '(default ((t (:family "Clean" :size "12pt"))) t))
  
  (setq minibuffer-max-depth nil)
\end{verbatim}}
%
Below, specific recommendations are spelled out that try to conform to common
practices but also try to avoid ``right drift'':

\begin{enumerate}

{}\item\textit{Try to keep all text within the first 80 character columns}:
Keeping most of the source code within the first 80 character columns helps to
make the code more readable and helps to facilitate side-by-side two-column
editing and comparisons of source code.  Most of the style and indentation
guidelines described below help to avoid code that extends beyond the 80th
column too rapidly. {}\textit{Justification}: ``Studies show that up to
ten-word text widths are optimal for eye tracking'' {}\cite[Item
0]{C++CodingStandards05}.  Also, some developers are still stuck with 80
column wide terminals.

{}\item\textit{Indent with spaces and not tabs}: The amount of spaces to use
per indentation level is up to the individual developer but an indentation of
only {}\textit{two spaces} is recommended (and is set in the above
{}\texttt{.emacs} initialization file options).  Whatever indentation amount
is used, it should be consistent in at least each source and header file
{}\cite[Item 0]{C++CodingStandards05}.  Emacs by default will put in a tab
when the tab-width is equal to the number of indentation spaces.  Emacs can be
told to always use spaces instead of tabs by setting:

{\small\begin{verbatim}
  (indent-tabs-mode nil)
\end{verbatim}}

in the {}\texttt{.emacs} file as shown above.

{}\textit{Justification}: ``Some teams legitimately choose to ban tabs
... when misused, turn indenting into out-denting and non-denting.''
{}\cite{C++CodingStandards05}.

{}\item\textit{Do not indent source code inside of namespace enclosures,
instead use commented end brackets}: Indenting for namespace enclosures
results unnecessary, and in some cases excessive, indentation.  Instead use,

{\small\begin{verbatim}
  namespace MyNameSpace {
  namespace MyInnerNamespace {

  class SomeClass {..};

  void someFunc(...) {...}

  } // namespace MyInnerNamespace
  } // namespace MyNameSpace
\end{verbatim}}

{}\textit{Justification}: While indentation within namespaces is helpful in
small example code fragments, it provides little help in showing namespace
structure in more realistic code.  The use of commented end blocks is
generally sufficient to show namespace structure and will not result in
excessively indented code.  In addition, typically, each file will only
contain code from one (or more nested) namespace and therefore indenting for
namespaces provides no useful information.

{}\item\textit{C++ class and struct declaration indentation and layout}: C++
class declarations should generally be laid out with {}\texttt{public}
members coming before {}\texttt{protected} members coming before
{}\texttt{private} members and indented as:

{\small\begin{verbatim}
  class SomeClass {
  public:
    // Public member functions
    void func1();
  protected:
    // Public member functions
    void func2();
  private:
    // Private types
    typedef std::vector<int> int_array_t;
    // Private data members
    int data1_;
    int_array_t array1_;
    // Private member functions
    void func3();
  };
\end{verbatim}}

{}\textit{Justification}: This ordering of sections and data members is quite
common [???,???].  Above, we show private member functions after private data
members since private data members are more prominent and more common in the
class implementations than are private member functions.  Also, private types
(where typedefs are most common) must be listed before they are used in the
declaration of the private data members.  Note that public types used in
public member functions must be listed above (or at least forward declared)
before the public member functions that use them.

{}\item\textit{Formating of function prototypes, function definitions and
function calls}: Below, guidelines for formatting short function prototypes
and long prototypes are given.  These guidelines seek to result in prototypes
that are fairly tight (i.e. not too much whitespace explosion) while still
keeping code inside of 80 character columns.  This indentation style can (and
should) also be applied to function definitions and function calls.

  \begin{enumerate}

  {}\item\textit{Short prototypes}: Short function prototypes can be listed
  on a single line.  For example,

  {\small\begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}}

  or 

  {\small\begin{verbatim}
  ReturnType someFunction(int arg=0);
  \end{verbatim}}

  or some other style for whitespace within '(...)' but the opening '(' should
  come directly after the function name in all cases.

  {}\item\textit{Longer prototypes}: Function prototypes that can not
  approximately fit on a single line in the first 80 character columns should
  have the function arguments listed starting on the second line with one unit
  of indentation (i.e. two spaces) from the function return type and function
  name line.  For example, several different valid formats for a longer
  function prototype are:

  {\small\begin{verbatim}
  ReturnType someFunction(
    int                  arg1
    ,bool                arg2
    ,double*             arg3[]
    ,const std::string   &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1
    ,bool arg2
    ,double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4 = "" );
  \end{verbatim}}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  Comas separating function arguments
  can appear at the end of the argument names or at the beginning of new
  lines.  The ending parenthesis ')' can appear on the same line as the last
  line of arguments or can appear alone on the last line.  Other formats are
  possible also and can be appropriate in different situations.

  {}\textit{Justification}: The formatting of longer function prototypes shown
  above differs from the most typical formatting which is to put at least the
  first function argument on the same line as the function name and to align
  other arguments up to the function opening '(' (see
  {}\cite{JointStrikeFighterC++CodingStandard}) which looks like:
  
  {\small\begin{verbatim}
  ReturnType someFunction( int arg1,
                           bool arg2,
                           double* arg3[],
                           const std::string &arg4  = "" );
  \end{verbatim}}
  
  The problem with the above indentation style is that is naturally leads to
  lots of right drift, extending well past the 80th column in many cases.
  This is especially apparent in class member function definitions that use
  this same formatting style.  For example, if you have templated code, avoid
  {}\textbf{using} directives {}\cite[Item 59]{C++CodingStandards05}, and have
  any kind of long function name then you can end up with definitions that
  look like:
  
  {\small\begin{verbatim}

  void MultiVectorBase<Scalar>::acquireDetachedView( const Range1D& rowRng,  
                                                     const Range1D& colRng,  
                                                     RTOpPack::ConstSubMultiVectorView< Scalar >* sub_mv ) const
  {
    ...
  }
  \end{verbatim}}
  
  which leads to very long lines while the above proposed indentation style
  leads to:
  
  {\small\begin{verbatim}
  void MultiVectorBase<Scalar>::acquireDetachedView(
    const Range1D& rowRng,  
    const Range1D& colRng,  
    RTOpPack::ConstSubMultiVectorView< Scalar >* sub_mv
    ) const
  {
    ...
  }
  \end{verbatim}}
  
  The indentation style for function arguments recommended above helps to
  avoid massive ``right drift'' in many types of cases.

  {}\item\textit{Return types can be listed on same line as the function name
  unless the line is too long}: A function prototype's return type should
  appear on the same line as the function name unless it is excessively long
  and would result in the return type + function name line to extend past the
  80th column.  When the return type + function name is too long, then it can
  be listed on separate lines with no indent, for example, as:
  
  {\small\begin{verbatim}
  Teuchos::RefCountPtr<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}

  However, listing the function return type an a separate line even in cases
  of shorter prototypes is just fine too.

  \end{enumerate}

{}\item\textit{Order the definitions of C++ entities the same as the order of
the declarations of those entities}: For example, one should order the
definitions of a set of member functions the same as the ordering of there
declarations in the class definition.  Maintaining the ordering of definitions
and declarations makes the code more readable and more maintainable.  For
example, if the function definitions are ordered the same as the declarations,
it can be easy to see if a function definition is missing (i.e. that could be
the cause of the link error that you are seeing).

{}\item\textit{Formatting of code blocks}: ???

\end{enumerate}

%
\section{C++ Coding Guidelines}
\label{thyracodingguidelines:codingguidelines:sec}
%

Coding guidelines, unlike formatting guidelines, do change the meaning of C++
programs and therefore require a high level of priority.  The book ``C++
Coding Standards'' {}\cite{C++CodingStandards05} that this document is
primarily based on provides many good and important coding guidelines that
should be followed and by default all of the items in this book are assumed in
this document.  Here, we provide additional coding guidelines and, in some
cases, amend items in {}\cite{C++CodingStandards05}.  There, where this
document is silent, {}\cite{C++CodingStandards05} is to be considered the
authoritative source for guidance.

%
\subsection{General Coding Guidelines}
%

Below several different general coding guidelines are discussed.  These
guidelines are more a matter of real measures of software quality and less a
matter of simply different personal preferences of style.

\begin{enumerate}

{}\item\textit{Use the macro TEST\-\_FOR\-\_EXCEPTION(...) and its related
macros for reporting all errors, even programming errors}: For developer
errors, prefer to derive the exception class thrown from
{}\texttt{std\-::logic\-\_error} instead of using the {}\texttt{assert(...)}
macro as recommended in {}\cite[Item 68]{C++CodingStandards05}.  A ``logic
error'' would be treated differently from a real runtime error and would
therefore come with different assumptions about the state of the object after
the exception was thrown.  In particular, a ``real error'' (i.e. not just an
internal developer error) should always provide the basic guarantee to leave
the object in a valid state {}\cite[Item 71]{C++CodingStandards05}, while code
that throws a ``logic error'' can not make any such guarantees in general.
Therefore, objects that throw exceptions derived from
{}\texttt{std\-::logic\-\_error} should generally be viewed as unusable and
should be thrown away.  To enable debugging, a breakpoint can always be placed
on {}\texttt{Test\-For\-Exception\-\_break()} which will be called just before
an exception is thrown through these macros.  In the future, more
sophisticated features like automatically attaching a debugger or printing
the call stack may be added for some systems.  Therefore throwing an exception
derived from {}\texttt{std\-::logic\-\_error} should be preferred to using
{}\texttt{assert(...)} macro as it gives us more control over what happens
when one of these types of programming errors occurs.

{}\item\textit{Avoid the use of raw C++ pointers in all but the lowest level
code}: The tools mentioned below which include {}\texttt{Teuchos::\-Ptr},
{}\texttt{Teuchos::\-Ref\-Count\-Ptr}, {}\texttt{Teuchos::\-Array},
{}\texttt{Teuchos::\-Array\-Ref\-Count\-Ptr}, and
{}\texttt{Teuchos::\-Array\-View} allow most code to be written without any
explicit raw C++ pointers.  Also, use {}\texttt{std\-::string} instead of
{}\texttt{char*} or {}\texttt{const char*}.  In debug mode, these classes
allow for full runtime checking that result in exceptions being thrown and
excellent error messages (i.e.\ instead of segfaults).  Indexing and other
unchecked operations with {}\texttt{std\-::string} objects is much less common
in numerical code and therefore is less of an issue for numerical libraries.

{}\item\textit{Use Teuchos::Ptr as function arguments in the place of raw C++
pointers to single objects where no persisting association exists}: ???

{}\item\textit{Use Teuchos::ArrayView as function arguments in the place of
pointers into raw arrays where no persisting association exists}: ???

{}\item\textit{Prefer Teuchos::Array to std::vector}: While
{}\texttt{Teuchos::\-Array} gets all of its real functionality from
{}\texttt{std::\-vector}, prefer to use {}\texttt{Teuchos::\-Array} as we can
provide more capabilities and built-in optional checking.  For instance
{}\texttt{Teuchos::\-Array::\-operator[]} is range checked in debug mode
regardless whether there is an underling checked STL implementation or not
(see {}\cite[Item 83]{C++CodingStandards05}).  In addition,
{}\texttt{Teuchos\-::Array} will automatically convert into an
{}\texttt{Teuchos\-::ArrayView} object safely when used in function call.

{}\item\textit{Use Teuchos::RefCountPtr for memory management of single
dynamically allocated objects and for handling persisting associations}:
Replace all references to the class {}\texttt{boost::\-shared\_ptr} in all
items in {}\cite{C++CodingStandards05} with {}\texttt{Teuchos::\-RefCountPtr}.

{}\item\textit{Use Teuchos::ArrayRefCountPtr for memory management of
dynamically allocated arrays objects stored in contiguous arrays of data for
persisting associations involving these arrays}: Note that
{}\texttt{Teuchos::ArrayRefCountPtr} does {}\underline{not} take the place of
a contiguous container class such as {}\texttt{Teuchos::\-Array} or
{}\texttt{std::\-vector}.  A {}\texttt{Teuchos::ArrayRefCountPtr} object can
not change the size of the container, it can only provide for reference
counted sharing of an array of data of fixed size.

{}\item\textit{Definition of member functions of a C++ class}: The member
functions of a class should be defined in the same order as their declarations
and should generally use namespace enclosure.  For example, given the
declaration of

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.hpp

  namespace SomeNamespace {

  class SomeClass {
  public:
    void someFunc();
    ...
  };

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest and one of the tersest ways to define the member functions in the
source file is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.cpp

  namespace SomeNamespace {

  void SomeClass::someFunc()
  {
    ...
  }

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using the namespace enclosure instead of a
{}\texttt{using namespace SomeNamesapce} directive insures that you can never
accidentally provide another definition for some other class member function
in another namespace.  Explicit namespace qualification is not needed since if
one misspells any part of the prototype, then the compiler will issue an error
message.

{}\item\textit{Definition of nonmember C++ functions}: All nonmember
functions should be defined using explicit namespace qualification.  For
example, for the nonmember function prototype

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.hpp

  namespace SomeNamespace {

  void someFunc( const int data );

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest way to define the nonmember function is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.cpp

  void Thyra::someFunc( const int data )
  {
    ...
  }

  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using explicit namespace qualification avoids
problems of spelling and other mistakes that can result in the definition of a
new function accidentally {}\cite[Section 8.2]{stroustrup00}.  Such a mistake
is caught at link time but can be very hard to figure out the root cause of
the problem.

%
\subsection{Specification of formal arguments for C++ member and nonmember functions}
%

Here a convention for the specification of the formation arguments for C++
member or nonmember function is defined that leads to C++ code that is
consistent looking, maximizes compile-time checking, and is as
auto-documenting as possible.

ToDo: Fill this in once I have written and tested Teuchos::ArrayView and
Teuchos::Ptr classes.  No raw pointers!

\end{enumerate}

%
\section{Doxygen Documentation Guidelines}
%

Here a set of reasonable guidelines is stated for writing Doxygen (and plain
old) documentation for classes, functions, etc.\ that makes the specification
clear but is not too verbose or hard to maintain.  Other types of higher-level
documentation are also needed such as design documents and tutorials but
guidelines for these are not covered here.

%
\subsection{Goals for function and class level documentation}
%

\begin{enumerate}

{}\item\textit{Level of documentation should vary depending on the prominence
and/or the role of the software entity or collection}: Important interfaces or
widely disseminated concrete classes or functions require an appropriate level
of precise documentation.  Concrete implementations that are less widely
disseminated can provide less (or none in some cases) Doxygen documentation if
the implementation code itself is sufficiently easy to understand.  However,
major parts of an implementation should have at least some plain old (i.e.\
non-Doxygen) documentation to describe the basics of what is going on.

{}\item\textit{Important abstract interfaces must be fully specified
independent of any single concrete implementation}: In the case of important
abstract interfaces, the full specification of behavior for the compliant
objects (i.e. asserts, preconditions, postconditions) must be clearly stated
{}\cite[Item 69]{C++CodingStandards05}.  In some cases, this must be done
completely within the Doxygen documentation.  In other cases, a standard unit
testing function or class can be used to help specify the behavior of the
interface.  In fact, compiled and verified unit testing code may be superior
to standard Doxygen documentation since it can't ignored or become invalid.
On the other hand, it may be difficult for readers to wade through unit
testing code to find the specification of behavior and therefore both Doxygen
documentation and unit testing code should be used to provide for the fully
benefit.  Also, Doxygen documentation can automatically include bits and
pieces of compiled and tested code using the
{}\texttt{$\backslash$dontinclude} commands.

{}\item\textit{Behavior of "user level" interfaces must be completely
specified by the Doxygen documentation and/or higher-level documentation}:
This item is an amendment to the above item as a special case for ``user''
interfaces.  A "user" could be someone that simply writes client code to the
interface or one that provides implementations to the interface or both.
User's should not be expected to study unit testing code to figure out the
preconditions and/or postconditions for a function call.

{}\item\textit{Wrong documentation is (almost) worse than no documentation at
all}: Documentation must be maintained as code is changed and therefore
excessive or unnecessary documentation degrades the quality of a code.
However, some documentation with some small errors/omissions is better than no
documentation at all.

{}\item\textit{The same documentation should not be repeated if possible}: We
should strive for a single source for documentation and not repeat the same
documentation over and over again.  This is critical to insure that the
documentation can be successfully maintained.

{}\item\textit{The documentation should maintain itself as much as possible
and be testable as much as possible}: Any significant fragments of code that
are shown in the Doxygen-generated HTML documentation should come from
compiled and tested code.  This can be accomplished by using the
{}\texttt{$\backslash$dontinclude} Doxygen command to read in code fragments
automatically.  In this way, the compiler and our test suite can be used to
help verify at least parts of our documentation.

\end{enumerate}

%
\subsection{General Doxygen Documentation Principles}
%

Now that some of the general goals for our Doxygen documentation have been
presented, more details guidelines are given below:

\begin{enumerate}

{}\item\textit{Write Doxygen documentation directly in header files with
documented entities}: Write Doxygen documentation comments directly attached
to the classes, functions and other entities to make the documentation as
tightly tied to the code as possible.  This has the unfortunate side-effect of
requiring complete recompilations whenever documentation is modified but the
overall benefit should be worth the downsides.  Note that the Doxygen
documentation can be stripped out of Doxygen-generated hyper-linked versions of
the code, leaving clean C++-only code without the extra clutter of detailed
documentation.  Therefore, developers should browse Doxygen-generated source
code instead of the source code directly when looking at the code and
performing code reviews.

{}\item\textit{Use a centralized set of definitions for common arguments when
possible}: Use clear and consistent naming of arguments in multiple functions
(within the same class and across as many classes and functions as makes
sense) and provide a centralized definition of these arguments if possible to
avoid repeating detailed definitions in each individual function's
documentation.  This helps to avoid duplicate documentation that is likely not
to be maintained correctly.  In the case of classes, this means providing some
common definitions in the main ``detailed'' documentation section.  In the
case of nonmember functions, this might involve a common Doxygen group (i.e.\
{}\texttt{$\backslash$defgroup}) for the set of functions.  In the case of
collections of nonmember functions, it may be difficult to expect readers to
find the common definitions but links to the common documentation are possible
using a variety of approaches.

{}\item\textit{Provide common preconditions/postconditions along with the
common documentation for common arguments when possible}: For common arguments
that are shared among many functions, define the most common preconditions for
them in a central place and avoid listing them on a function-by-function basis
unless they change for that function.  For a C++ class, place these common
arguments in the main documentation section under a
{}\texttt{$\backslash$section} named ``Common Function Arguments and
Pre/Post-Conditions''.  Only include preconditions for these arguments in
specific function documentation sections if it is different from the most
common preconditions.

{}\item\textit{Add a {}\texttt{$\backslash$brief} description for every entity
that is documented}: The {}\texttt{$\backslash$brief} field is used to provide
the short one-line documentation string that is included in the function
summary section of classes, groups, namespaces etc.  Even if no text
documentation is needed/wanted, add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment so that Doxygen will include the class, function, or other entity in
the HTML documentation.

{}\item\textit{Add {}\texttt{$\backslash$param} field for all arguments or
none of the arguments in a function; no partial {}\texttt{$\backslash$param}
field lists}: All arguments should be listed in {}\texttt{$\backslash$param}
fields with at least the [in], [out], or [in/out] specifications and these
should have at least a very short description.  Or, if the function arguments
are clear and trivial (and/or have already been defined in the common
documentation section), then no {}\texttt{$\backslash$param} fields should be
included at all.  If any of the arguments are listed in
{}\texttt{$\backslash$param} fields then all arguments should be listed in
{}\texttt{$\backslash$param} fields.

{}\item\textit{Only add a {}\texttt{$\backslash$returns} field only if
necessary}: Don't add a {}\texttt{$\backslash$returns} description of the
return value if it is already clearly specified in the
{}\texttt{$\backslash$brief} description of the function.  However, if the
nature of the return value is at all complex, then include a
{}\texttt{$\backslash$returns} field to describe it.  When referring to the
return argument, refer to it as {}\texttt{returnVal}.

{}\item\textit{Prefer specifying postconditions for output arguments in their
{}\texttt{$\backslash$param} field in general, and otherwise list them in the
'Postconditions' list}: The postconditions for output arguments can be listed
directly in the {}\texttt{$\backslash$param} field for the argument if they
only involve just that argument in a fairly simple way.  Otherwise, if the
postconditions are more complex or involve multiple arguments in order to
specify, then they can be listed in the Postconditions list.  It may be
difficult to objectively determine where to list the postconditions for output
arguments.

{}\item\textit{Order the documentation fields as {}\texttt{$\backslash$brief},
{}\texttt{$\backslash$param}, Preconditions, Postconditions, then
{}\texttt{$\backslash$returns}; omitting those that do not apply}: A
consistent ordering of sections of documentation for a class and within a
function makes it easier for readers to find what they are looking for.

{}\item\textit{If possible, try to use {}\texttt{$\backslash$relates} to
associate nonmember functions with a single class}: If a nonmember function
is most closely related to a single class, use the
{}\texttt{$\backslash$relates} field to cause the documentation for the
function to be listed with the classes documentation.  This makes it easier
for readers to find out everything that they can do with a class object (or
set of class objects) just by looking at a single HTML page and a single
summary list of functions (which includes member and nonmember related
functions).

{}\item\textit{Provide detailed documentation for only the initial declaration
of a virtual function}: Only provide detailed documentation of the initial
declaration of a virtual function in the class where it is first defined as
{}\texttt{virtual}.  In general, documentation should not be included for the
overrides of virtual functions in derived classes.  Doxygen automatically puts
in a link to the original virtual function in the base class so readers are
just one click away for seeing the detailed documentation.  Always add an
empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment for every class and every function that should be included in the HTML
documentation but where no text documentation is wanted or needed.

{}\item\textit{Group the overrides of virtual functions into groups according
what their base class}: For example, the overrides of the virtual functions
for the {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} would look like:

{\small\begin{verbatim}

  class SomeClass : public Teuchos::ParameterListAcceptor {
  public:

    ...

    /** \name Overriden from Teuchos::ParameterListAccpetor */
    //@{

    /** \brief . */
    void setParameterList(
      Teuchos::RefCountPtr<Teuchos::ParameterList> const& paramList);
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> getParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> unsetParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getParameterList() const;
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getValidParameters() const;

    //@}

    ...

  };

\end{verbatim}}

{}\item\textit{Example source code used in Doxygen-generated and other forms
of documentation should be extracted automatically from code that is compiled
and tested nightly}: Any significant fragment of code example that is shown in
Doxygen HTML documentation or a latex document needs to come from compiled and
tested code that can be updated automatically.  These C++ code fragments can
be selectively inserted automatically into Doxygen documentation using the
Doxygen {}\texttt{$\backslash$dontinclude} command.

{}\item\textit{Sample output should be generated automatically from compiled
and tested code}: Sample output included in Doxygen documentation should be
generated automatically by the test harness code and should be written to
files that included in the source directory.  The sample output in these files
can then be inserted into the Doxygen HTML documentation automatically using
the Doxygen {}\texttt{$\backslash$verbinclude} command.  Similar approaches
can also be used for latex documentation.

\end{enumerate}
