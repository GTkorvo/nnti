%
\section{Introduction}
%

This document deals with C++ coding guidelines that are based primarily on the
book ``C++ Coding Standards'' by Sutter and Alexandrescu
{}\cite{C++CodingStandards05}.  These guidelines are specifically designed to
address the development of object-oriented numerical libraries and to utilize
the tools in the Trilinos package {}\texttt{Teuchos}.  While the main purpose
of of this document is to define guidelines for Thyra software (for both
interfaces and adapters), it is also general enough to be applied to many
other projects that, for instance, might interact with Thyra.

The goal of this document is not to restate what is in
{}\cite{C++CodingStandards05} but instead to fill in some gaps intentionally
left by the authors and to provide amendments to specific items in the book
and tailor them for numerical libraries.  The zeroth item (first item, zero
based) ``Don't sweat the small stuff'' intentionally avoids specific
recommendations on issues such as the conventions for naming identifiers and
the formatting of code since these are arbitrary.  While issues related to
coding style are much less important that other issues, there are arguments
for adopting consistent coding style and some of these arguments are outlined
in Appendix {}\ref{sec:arguments-for-consistent-style}.  Therefore, one of the
purposes of this document is to suggest reasonable and minimal guidelines for
naming conventions and code formatting that provide for enough code uniformity
to facilitate collaborative code development and maintenance.

More important that code formatting, a consistent set of naming conventions
for C++ classes, functions, variables, and other entities also helps to
improve collaborative software development and quality.  Also, since clients
of the software must interact with these names, it is even more important that
a set of naming conventions be used as consistently as makes sense.

Lastly, more important general C++ coding guidelines are covered that append
and amend to those described in {}\cite{C++CodingStandards05}.  While
formatting and naming recommendations do not affect the meaning of C++ code,
other coding guidelines do and therefore they will recieve more attention and
should be taken more seriously.

In rest of this document is organized as follows.  First, naming conventions
are presented since they help provide a context for code examples later.
Next, important general C++ coding guidelines are described that affect
software quality in critical and nontrivial ways.  Unlike naming conventions
and code formatting, these guidelines are difficult to follow after a
significant piece of code has been developed.  Lastly, reasonable and minimal
formatting guidelines are covered.

%
\section{Naming conventions}
%

C++ classes, functions, variables, data members etc. should be named and used
in a fairly consistent manner.  The following guidelines are consistent with
common practice as exemplified in {}\cite{EffectiveC++3rd05}.

\begin{enumerate}

{}\item\textit{C++ class and struct names}: Names for C++ classes and structs
should generally be capitalized and seperate words should be concatenated and
capitalized.  For example:

{\small\begin{verbatim}
  class SomeClass {...};
\end{verbatim}}

{}\item\textit{C++ namespace names}: C++ namespaces should follow the same
naming convention as C++ classes and namespace names should not contain too
many acronyms and should not be too short or too common.  For example:

{\small\begin{verbatim}
  namespace MyNameSpace {
  ...
  } // namespace MyNameSpace 
\end{verbatim}}

{}\item\textit{C++ enum type names and enum values}: Enumeration type names
should follow the same convention as for class and struct names but they
should also begin with the capital letter 'E' to signify that this type is an
enum.  Enumeration values should be all upper-case with underscores between
words and should use a common prefix for scoping within the enum type.  Also,
enum values should use the default value assignment defined by the compiler in
general as this aids their use as indexes into zero-based arrays.  For
example:

{\small\begin{verbatim}
  enum ESolveStatus {
    SOLVE_STATUS_CONVERGED
    ,SOLVE_STATUS_UNCONVERGED
    ,SOLVE_STATUS_UNKNOWN
  };
\end{verbatim}}

{}\textit{Justification}: Using a capital 'E' for {}\texttt{enum}s allows the
definition of other types with the same basic name that contain other data.
For example, {}\texttt{ESolveStatus} in an {}\texttt{enum} enumerating the
different types of solve status and {}\texttt{SolveStatus} is a C++ struct
that contains an {}\texttt{ESolveStatus} member along with some other data.
The use of the scoping prefix (i.e.\ {}\texttt{SOLVE\-\_STATUS\_} above) is
also recommended in {}\cite[Section 11.4]{CodeComplete2nd04}.

{}\textit{rabartl note:} This convention is what is used in Thyra currently
but it is somewhat unconventional.  This can be changed pretty easily but the
scoping aspect is very useful in general and should be kept in my opinion.

{}\item\textit{C++ object instance identifier names}: Formal function
arguments and other object identifiers should, in general, start with a
lower-case letter and then use capitalization for following words with no
underscores between words in general.  For example:

{\small\begin{verbatim}
  ClassType1   obj;
  ClassType2   objectForMyThing;
  ClassType3   objectForYourThing;
\end{verbatim}}

{}\item\textit{C++ class/struct data member names}: Names for data members
within a class should use the same naming convention as for other object
identifier names but should end with an underscore.  For example:

{\small\begin{verbatim}
  class SomeClass {
  public:
    ...
  private:
    int someDataMember_;
  };
\end{verbatim}}

{}\textit{Exception}: Simple C++ structs that do not need to maintain an
invariant with public data members and no member functions (other than
constructors) should not contain underscores.  For example:

{\small\begin{verbatim}
  struct SolveStatus {
    ESolveStatus solveStatus;
    double achievedTol;
    std::string message;
    ...
  };
\end{verbatim}}

{}\item\textit{Naming of C++ pure abstract base classes, default
implementation bases, and default implementation classes}: In general, the
top-level C++ base class for some abstraction should use the postfix
{}\texttt{Base} appended to the class name (e.g.\ {}\texttt{Vector\-Base}) and
the base class should contain (almost) no implementations and certainly no
object data (see Item 36 in {}\cite{C++CodingStandards05}).  If a default
implementation of some of the aspects of the base class are desired (to make
it easer to define concrete subclasses), then they should be put in a derived
node subclass with the postfix {}\texttt{DefaultBase} (e.g.\
{}\texttt{Vector\-Default\-Base}).  Any default concrete implementation of an
abstraction should generally use the prefix {}\texttt{Default} appended to the
beginning of the name along with any other important prefixes (e.g.\
{}\texttt{DefaultSpmdVector}).  For example:

{\small\begin{verbatim}
  // Pure virtual base class 
  class VectorBase
    : ... // Other base classes
  {
  public:
    virtual void someFunc(...) const = 0;
    ...
  };

  // Node base class with some default implementations
  class VectorDefaultBase
   : virtual public VectorBase
  {
  public:
    void someFunc(...) const; // default implementation
    ...
  private:
    ...
  };

  // A general default implementation for SPMD vectors
  class DefaultSpmdVector
    : virtual public VectorDefaultBase // use some default implementations
  {
  public:
    void someFunc(...) const; // Specialized overrides
    ...
  private:
    ...
  };
\end{verbatim}}

{}\item\textit{Naming of const and non-const access functions}: In general,
functions that return objects that are contained within a wrapper object
should have the prefix {}\texttt{nonconst} added to the function that returns
the non-const reference (or pointer) to the contained object.  For example,

{\small\begin{verbatim}
  class SomeClass {
  public:
    RefCountPtr<Part> getNonconstPart();
    RefCountPtr<const Part> getPart() const;
    ...
  };
\end{verbatim}}

{}\textit{Justification}: The choice to name the access functions
{}\texttt{getNonconstPart()} and {}\texttt{getPart()} as opposed to
{}\texttt{getPart()} and {}\texttt{getConstPart()} is somewhat arbitrary.
However, the former recommended convention of using {}\texttt{nonconst} should
be preferred since access to parts is typically through constant objects which
will therefore give access constant parts and having a shorter function name
is advantageous.  Also, a constant view of a part of an object is always
cheaper that returning a non-constant view of the part (see the discussion of
the ``generalized view'' idiom) and therefore to be safe and error on the side
of efficiency, the non-constant access function should be harder to call than
the constant access function.

\end{enumerate}

%
\section{Naming and organization of source files}
%

Since most C++ code is organized around classes, the file structure should
also primarily be organized around classes and the nonmember functions that
interact with these classes.  The primary goal of these file naming guidelines
is to create file names that are globally unique and will therefore facilitate
{}\texttt{\#include}s without need for directory paths in the
{}\texttt{\#include} statement.  The basic idea is that a source file should
be named based on what it has, not where it is.  The following guidelines help
to determine how to organize code into source files and how to name those
source files.  The directory structure of source files is beyond the scope of
this document.

\begin{enumerate}

{}\item\textit{File extension names}: Use the file extensions {}\texttt{*.hpp}
for C++ header files, {}\texttt{*.cpp} for C++ source files, {}\texttt{*.h}
for C header files, and {}\texttt{*.c} for C source files.  These file names
avoid common problems with portability to various Unix and Windows platforms.

{}\item\textit{Only one major C++ class with supporting code per header and
source file}: As a general rule of thumb, assign the source code for any major
C++ class and supporting code to a single set of header and source files.  The
file name should be composed out of the namespace names enclosing the classes
and other code along with the class name itself.  For instance, for the class
{}\texttt{NameSpaceA\-::InnerNamespace\-::SomeClass}, the header and source
files would be named
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.[hpp,cpp]}.  This
convention assures that the file names will be globally unique.

{}\item\textit{Use internal include guards in all header files}: All header
files, without exception, should use include guards {}\cite[Item
24]{C++CodingStandards05}.  For example, the file
{}\texttt{NameSpaceA\-\_InnerNamespace\-\_SomeClass.hpp} would have the basic
structure:

{\small\begin{verbatim}
  // @HEADER
  // ...
  // @HEADER

  #ifndef NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
  #define NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP

  #include "SomeFile.hpp"

  ...

  #endif // NAMESPACEA_INNERNAMESPACE_SOMECLASS_HPP
\end{verbatim}}

Above, the comment {}\texttt{//
NAMESPACEA\-\_INNERNAMESPACE\-\_SOMECLASS\-\_HPP} after the final
{}\texttt{\#endif} helps to show the preprocessor structure in the file and is
helpful in cases where other {}\texttt{\#ifdef} or {}\texttt{\#if} structures
are used.

This is a very minor amendment to Item 24 in {}\cite{C++CodingStandards05}.

{}\item\textit{Partition template code into different files to allow for both
implicit and explicit instantiation}: ??? ToDo: Fill this in once we do
explicit instantiation and figure this out ???

\end{enumerate}

%
\section{Coding guidelines}
\label{thyracodingguidelines:codingguidelines:sec}
%

Coding guidelines, unlike formatting guidelines, greatly influence the meaning
of C++ programs and therefore require a high priority level.  The book ``C++
Coding Standards'' {}\cite{C++CodingStandards05} that this document is
primarily based on provides many good and important coding guidelines that
should be followed and by default all of the items in this book are assumed in
this document.  Here, we provide additional coding guidelines and, in some
cases, amend items in {}\cite{C++CodingStandards05}.  Where this document is
silent, {}\cite{C++CodingStandards05} is to be considered the authoritative
source for guidance.  Some miscellaneous amendments to the items in
{}\cite{C++CodingStandards05} are given in Appendix
{}\ref{sec:misc_amendments}.
%ToDo: Write an appendix of ammendments to some of the items in ``C++ Coding Standards''.

%
\subsection{General coding guidelines}
%

Below several different general coding guidelines are discussed.  These
guidelines affect software quality in a major way and are not just a matter of
personal preference or style.

\begin{enumerate}

{}\item\textit{Use the macro TEST\-\_FOR\-\_EXCEPTION(...) and its related
macros for reporting all errors, even developer programming errors}: For
developer errors, prefer to throw exceptions drived from
{}\texttt{std\-::logic\-\_error} instead of using the {}\texttt{assert(...)}
macro as recommended in {}\cite[Item 68]{C++CodingStandards05}.  A ``logic
error'' would be treated differently from a real runtime error and would
therefore come with different assumptions about the state of the object after
the exception was thrown.  In particular, a ``real error'' (i.e. not just an
internal developer error) should always provide the basic guarantee to leave
the object in a valid state {}\cite[Item 71]{C++CodingStandards05}, while code
that throws a ``logic error'' can not make any such guarantees in general.
Therefore, objects that throw exceptions derived from
{}\texttt{std\-::logic\-\_error} should generally be viewed as unusable and
should be deleted immediately.  To enable debugging, a breakpoint can always
be placed on function {}\texttt{Test\-For\-Exception\-\_break()}\footnote{In
{}\texttt{gdb}, a breakpoint would be set as {}\texttt{b
Test\-For\-Exception\-\_break()}.} which will be called just before an
exception is thrown through these macros.  In the future, more sophisticated
features like automatically attaching a debugger or printing the call stack
may be added for some systems.  Therefore throwing an exception derived from
{}\texttt{std\-::logic\-\_error} using these macros should be preferred to
using the {}\texttt{assert(...)} macro as it gives us more control over what
happens when one of these types of programming errors occurs.  Also, these
exception macros make it much easier to generate good error messages that you
would get from a simple use of the {}\texttt{assert(...)} macro.

{}\item\textit{Avoid the use of raw C++ pointers in all but the lowest level
code}: The tools mentioned below which include {}\texttt{Teuchos::\-Ptr},
{}\texttt{Teuchos::\-Ref\-Count\-Ptr}, {}\texttt{Teuchos::\-Array},
{}\texttt{Teuchos::\-Array\-Ref\-Count\-Ptr}, and
{}\texttt{Teuchos::\-Array\-View} allow most code to be written without any
explicit raw C++ pointers.  Also, in general, perfer to use
{}\texttt{std\-::string} instead of {}\texttt{char*} or {}\texttt{const
char*}.  In debug mode, these classes allow for full runtime checking that
result in exceptions being thrown and excellent error messages (i.e.\ instead
of segfaults).  Indexing and other unchecked operations with
{}\texttt{std\-::string} objects is much less common in numerical code and
therefore is less likely to produce error inside of numerical code.

{}\item\textit{Use Teuchos::Ptr as function arguments in the place of raw C++
pointers to single objects where no persisting association exists}: The class
{}\texttt{Teuchos\-::Ptr} simply takes the place of a raw pointer to a single
object, but in debug mode, it is initalized to NULL by default and throws
exceptions when trying to dereference a null pointer.  Using this class helps
to eliminate all needs for checking for NULL to avoid undefined behavior when
one dereferences a NULL pointer.

{}\item\textit{Use Teuchos::RefCountPtr for memory management of single
dynamically allocated objects and for handling persisting
{}\cite{RefCountPtrBeginnersGuide} associations}: Replace all references to
the class {}\texttt{boost::\-shared\_ptr} in all items in
{}\cite{C++CodingStandards05} with {}\texttt{Teuchos::\-RefCountPtr}.

{}\item\textit{Use Teuchos::ArrayView as function arguments in the place of
pointers into raw arrays or other container classes where no persisting
association exists and the array does not need to be resized}: This class
allows all of the useful capabilities of a {}\texttt{std::vector} which do not
include adding or removing entries.  In debug mode, all of the access
functions (including iterators) are fully checked.  In optimized mode,
unchecked raw pointers are used.

{}\item\textit{Prefer Teuchos::Array to std::vector as a contiguous general
purpose data container}: While {}\texttt{Teuchos::\-Array} gets all of its
real functionality from {}\texttt{std::\-vector}, prefer to use
{}\texttt{Teuchos::\-Array} as we can provide more capabilities and built-in
optional checking.  For instance {}\texttt{Teuchos::\-Array::\-operator[]} is
range checked in debug mode regardless whether there is an underling checked
STL implementation or not (see {}\cite[Item 83]{C++CodingStandards05}).  In
addition, {}\texttt{Teuchos\-::Array} will automatically convert into an
{}\texttt{Teuchos\-::ArrayView} object safely when used in function calls.

{}\item\textit{Use Teuchos::ArrayRefCountPtr for memory management of
dynamically allocated objects stored in contiguous arrays of data and for
persisting associations involving contiguous arrays}: Note that
{}\texttt{Teuchos::ArrayRefCountPtr} does {}\underline{not} take the place of
a contiguous container class such as {}\texttt{Teuchos::\-Array} or
{}\texttt{std::\-vector}.  A {}\texttt{Teuchos::ArrayRefCountPtr} object can
not change the size of the array, it can only provide for reference counted
sharing of an array of data of fixed size and provide subviews of contiguous
parts of the managed array.

{}\item\textit{Prefer Teuchos::Map to std::map as a general associative
container}: While in optimized mode, {}\texttt{Teuchos\-::Map} is equivalent
to {}\texttt{std\-::map}, in debug mode {}\texttt{Teuchos\-::Map} uses a
simplified data-structure with fully checking of access and iterators.  This
class uses {}\texttt{Teuchos\-::Array},
{}\texttt{Teuchos\-::Array\-Ref\-Count\-Ptr} and others to build a fully
checked (but slower) implementation.

{}\item\textit{Use the template function
{}\texttt{Teuchos::as<T\_to>(T\_from)} for all conversion of data types that
may result in loss of precision or in an incorrect conversion}: The templated
C++ function {}\texttt{Teuchos::as<T\_to>(T\_from)} and its specializations
will contain runtime tests, in debug mode, for the results of a conversion to
ensure correctness.  This includes the conversion of strings into numbers
(i.e.\ replacing {}\texttt{atof()} and {}\texttt{atoi()}) as well as
conversions that can result in loss of precision or meaning (such as
{}\texttt{double} to {}\texttt{int}, {}\texttt{long int} to {}\texttt{int},
{}\texttt{int} to {}\texttt{char}, {}\texttt{unsigned int} to {}\texttt{int},
etc.).  The optimized versions of these conversion functions could be
unchecked conversions.  An always checked version like
{}\texttt{Teuchos\-::safeAs\-<\-T\_to\->\-(\-T\_from\-)} is available as well
in order to validate user data.  {}\textit{Justification}: Unchecked
conversions are the result of many different types of errors and a fully safe
program needs to be able to check all such potentially unsafe conversions at
runtime.  The implicit conversion rules allowed in C which where carried over
to C++ can result in very unsafe code.  ToDo: This function has not be
implemented yet and it could be a good deal of work to write all of the needed
implementations but this is needed for safe code.

{}\item\textit{Use namespace enclosure for the definition of member functions
of a C++ class}: The member functions of a class should be defined in the same
order as their declarations and should generally be defined within a namespace
enclosure.  For example, given the declaration of

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.hpp

  namespace SomeNamespace {

  class SomeClass {
  public:
    void someFunc();
    ...
  };

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest and one of the tersest ways to define the member functions in the
source file is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_SomeClass.cpp

  namespace SomeNamespace {

  void SomeClass::someFunc()
  {
    ...
  }

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using the namespace enclosure instead of a
{}\texttt{using namespace SomeNamesapce} directive insures that you can never
accidentally provide another definition for some other class member function
in another namespace.  Explicit namespace qualification is not needed since if
one misspells any part of the prototype, then the compiler will issue an error
message.

{}\item\textit{Use explicit namespace qualification for the definition of all
nonmember C++ functions}: For example, for the nonmember function prototype

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.hpp

  namespace SomeNamespace {

  void someFunc( const int data );

  } // namespace SomeNamespace
  ----------------------------------
\end{verbatim}}

the safest way to define the nonmember function is

{\small\begin{verbatim}
  ----------------------------------
  // SomeNamespace_someFunc.cpp

  void Thyra::someFunc( const int data )
  {
    ...
  }

  ----------------------------------
\end{verbatim}}

{}\textit{Justification}: Using explicit namespace qualification avoids
problems of spelling and other mistakes that can accidentally result in the
definition of a new function {}\cite[Section 8.2]{stroustrup97}.  Such a
mistake is caught at link time but it can be very hard to figure out the root
cause of the problem when this happens.

{}\item\textit{Prefer {}\texttt{enum}s to {}\texttt{bool}s as formal function
arguments when conversion mistakes are likely}: While the built-in type
{}\texttt{bool} is very convenient to use as a formal function argument, it
also allows for conversions from every built-in type and every pointer type.
While using an enumeration type and its values is more verbose, it is also
self documenting and is safer.  For example, what does the third argument mean
in the following example?

{\small\begin{verbatim}
  apply( A, 2.0, true, x, y );
\end{verbatim}}

When the {}\texttt{bool} argument is changed to an enum, the function call
becomes:

{\small\begin{verbatim}
  apply( A, 2.0, USE_TRANSPOSE, x, y );
\end{verbatim}}

the meaning is much more clear.  Therefore, when self documentation and
compile-time safety are important, perfer to define and use {}\texttt{enum}s
over {}\texttt{bool}s as formal function arguments.

{}\item\textit{Structure the includes in template header files to avoid
problems in mutually dependent (i.e. circular)code}: ??? ToDo: Merge this with
the above item on layout of files for implicit and explicit template
instantiation once we figure out how to do this with explicit and implicit
instantiation ???

\end{enumerate}

%
\subsection{Specification of formal arguments for C++ member and nonmember functions}
%

Here we describe a convention for the specification of the formation arguments
for C++ functions that leads to C++ code that is consistent looking, maximizes
compile-time and run-time checking, and is as auto-documenting as possible.

ToDo: Fill this in once I have written and tested Teuchos::ArrayView and
Teuchos::Ptr classes.  No raw pointers!
%
\section{Formating of source code}
\label{thyracodingguidelines:formatting:sec}
%

At the minimum, source code should be formatted consistently within a single
file or a set of tightly coupled files {}\cite[Item 0]{C++CodingStandards05}.
Ideally, source code should be formatted consistently enough across a code
project so as not to cause undue difficulty in shared maintenance and in
performing code reviews {}\cite{CodeComplete2nd04}.  Some consistency in
formatting helps and to facilitate multiple ownership and shared development
of a collection of software, such as in Extreme Programming (XP)
{}\cite{ExtremeProgrammingExplained99} (see Appendix
{}\ref{sec:arguments-for-consistent-style} for an outline of the arguments for
adopting a consistent code formatting style).  By ``formatting'' we generally
refer to the use of whitespace in the line-to-line formating of the program or
in the ordering of lines of code such that the meaning of the program to the
compiler is unchanged\footnote{While technically changing the name of a class,
function or variable changes the meaning of a program, if name changes are
done in such a way as to avoid name collisions, then naming conventions also
do not affect the meaning of the program and are therefore very much related
to other formatting issues such as the treatment of ``whitespace''.}  The
handling of indentation styles can largely be automated\footnote{Emacs
supports multiple file-specific formatting styles for C++ and tools like
Artistic Style {}\cite{ArtisticStyle} can format source files from the command
line.  A flavor of the {}\texttt{vi} editor may also support indentation
styles. } which allows individual developers to work with any style they would
like like for files that they create but also makes it easy for developers to
edit files created by other developers and keep to their styles as well.
Appendix {}\ref{sec:reformatting-guidelines} gives some guidelines for how
individuals should conduct themselves where more than one coding formatting
style is in use within a project.

Our main goal in this section is to try to provide reasonable recommendations
for those formating issues that are largely a matter of style and personal
preference but at the same time affect the overall readability of the code and
promote pair programming and joint ownership of the code
{}\cite{ExtremeProgrammingExplained99}.  The formatting and indentation
guidelines presented here are largely consistent with the recommendations in
{}\cite[Chapter 31]{CodeComplete2nd04} and try to reduce the amount of ``right
drift'' that can occur with some common formatting and indentation styles.

The indentation guidelines outlined below can be largely automatically
supported by Emacs and are used by the custom style ``thyra'' defined in the
emacs package file cc-thyra-styles.el\footnote{See
{}\texttt{Trilinos/packages/thyra/emacs/README} for a description of the
``thyra'' Emacs style}.  Other custom sytles can also be added to this file
and used as well.  Any of these styles can be listed in each source file and
therefore anyone using Emacs can automatically use a particular indentation
style without having to fight the editor to manually reformat code to abide by
a foreign style.

Some general principles of good formatting, based on the discussion in
{}\cite[Section 31.1]{CodeComplete2nd04}, are:

\begin{enumerate}

{}\item\textit{Formatting should accurately and consistently show the logical
structure of the code}: It is somewhat subjective what formatting sytles
``show the logical structure'' of code but McConnell makes some good argments
for some styles over others.  However, it is up the group of programmers to
decide as a group what style items ``show the logical structure''.

{}\item\textit{Formatting should improve the readability of the code for most
people}: There are specific studies cited in {}\cite[Chapter
31]{CodeComplete2nd04} that provide good evidience to prefer some styles over
others.

{}\item\textit{Formatted code should retain its formatting well in the face of
modification; especially those performed by automatic tools}: Changing one
line of code should not require changes to other lines of code to maintain the
formatting style.

{}\item\textit{Formatting style should follow the most common idiom unless one
of the above principles are violated}: When there is no good technical
argument for one formatting sytle item over another, then the style that is
the most common\footnote{The measure of the commonality of a particular style
element can be chosen according to a local software development community or
the larger developer community.} should be chosen.  This is not advocated
per-say in {}\cite[Chapter 31]{CodeComplete2nd04} but it is a good idea in
general to follow popular idioms when there are several equally good choices
and therefore the decision is arbitrary.

\end{enumerate}

Below, specific recommendations are spelled out that try to conform to common
practices but also try to avoid excessive ``right drift'':

\begin{enumerate}

{}\item\textit{The formatting style in any single file or group of closely
related files should be the same}: Consistent formatting includes the placment
of braces, the number spaces to indent etc.  {}\textit{Justification}: This is
recommended in {}\cite[Item 0]{C++CodingStandards05}.

{}\item\textit{Try to keep all text within the first 80 character columns}:
Keeping most of the source code within the first 80 character columns helps to
make the code more readable and helps to facilitate side-by-side two-column
editing and comparisons of source code.  Most of the style and indentation
guidelines described below help to avoid code that extends beyond the 80th
column too rapidly. {}\textit{Justification}: ``Studies show that up to
ten-word text widths are optimal for eye tracking'' {}\cite[Item
0]{C++CodingStandards05}.  Also, some developers are still stuck with 80
column wide terminals.

{}\item\textit{Indent with spaces and not tabs}: The amount of spaces to use
per indentation level is up to the individual developer but an indentation of
only {}\textit{two spaces} is recommended (and is set in the `Emacs `thyra''
indentation style).  A study showed that an indentation offset of two-to-four
spaces was optimal for code reading comprehension {}\cite[Section
31.2]{CodeComplete2nd04}.  Whatever indentation amount is used, it should be
consistent in at least each source and header file {}\cite[Item
0]{C++CodingStandards05} (which can be enforced using a custom Emacs
indentation style).  Emacs by default will put in a tab when the tab-width is
equal to the number of indentation spaces.  Emacs can be told to always use
spaces instead of tabs by setting:

{\small\begin{verbatim}
  (setq indent-tabs-mode nil)
\end{verbatim}}

in the indentation style (as is done in the ``thyra'' style).  However, it is
easy to support different preferences for the amount of spaces to indent by
using a user-defined indentation style for Emacs (sorry {}\texttt{vi} users).

{}\textit{Justification}: ``Some teams legitimately choose to ban tabs
... when misused, turn indenting into out-denting and non-denting.''
{}\cite[Item 0]{C++CodingStandards05}.

{}\item\textit{Do not indent source code inside of namespace enclosures,
instead use commented end braces}: Indenting for namespace enclosures results
in unnecessary, and in some cases excessive, indentation.  Instead, for
example, use:

{\small\begin{verbatim}
  namespace MyNameSpace {
  namespace MyInnerNamespace {

  class SomeClass {..};

  void someFunc(...) {...}

  } // namespace MyInnerNamespace
  } // namespace MyNameSpace
\end{verbatim}}

{}\textit{Justification}: While indentation within namespaces is helpful in
small example code fragments, it provides little help in showing namespace
structure in more realistic code.  The use of commented end braces is
generally sufficient to show namespace structure and will not result in
excessively indented code.  In addition, typically, each file will only
contain code from one (or more nested) namespace and therefore indenting for
namespaces provides no useful information.  Not indenting for namespace
enclosures is also consistent with the ``ansi'', the ``kr'', and the ``linux''
styles as defined by Artistic Style {}\cite{ArtisticStyle}.

{}\item\textit{C++ class declarations should generally be laid out with
{}\texttt{public} members coming before {}\texttt{protected} members coming
before {}\texttt{private} members and indented as:}

{\small\begin{verbatim}
  class SomeClass {
  public:
    // Public member functions
    void func1();
  protected:
    // Public member functions
    void func2();
  private:
    // Private types
    typedef std::vector<int> int_array_t;
    // Private data members
    int data1_;
    int_array_t array1_;
    // Private member functions
    void func3();
  };
\end{verbatim}}

{}\textit{Justification}: This ordering of sections and data members is quite
common {}\cite[Section 31.8]{CodeComplete2nd04}.  Above, we show private
member functions after private data members since private data members are
more prominent and more common in the class implementations than are private
member functions.  Also, private types (where typedefs are most common) must
be listed before they are used in the declaration of the private data members.
Note that public types used in public member functions must be listed above
(or at least forward declared) before the public member functions that use
them.

{}\item\textit{List sort function prototypes on one line and longer protypes
on multiple lines, indenting arguments one unit}: Below, guidelines for
formatting short function prototypes and long prototypes are given.  These
guidelines seek to produce function prototypes that are fairly tight (i.e. not
too much whitespace explosion), are robust to modifications, and keep code
inside of the 80th character column.  This indentation style can (and should)
also be applied to function definitions and function calls.

  \begin{enumerate}

  {}\item\textit{List short function prototypes on one line if possible}: For
  example,

  {\small\begin{verbatim}
  ReturnType someFunction( int arg = 0 );
  \end{verbatim}}

  or 

  {\small\begin{verbatim}
  ReturnType someFunction(int arg=0);
  \end{verbatim}}

  or some other style for whitespace within '(...)' but the opening '(' should
  come directly after the function name in all cases.

  {}\item\textit{For longer prototypes, indent arguments on continuation lines
  one unit}: Function prototypes that can not approximately fit on a single
  line in the first 80 character columns should have the function arguments
  listed starting on the second line with one unit of indentation (e.g. two
  spaces) from the function return type and function name line.  For example,
  several different valid formats for a longer function prototype are:

  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1,
    bool arg2,
    double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4  = ""
    );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction(
    int arg1, bool arg2, double* arg3[],
    const std::string &arg4 = "" );
  \end{verbatim}}
  
  or
  
  {\small\begin{verbatim}
  ReturnType someFunction( int arg1, bool arg2,
    double* arg3[], const std::string &arg4 = "" );
  \end{verbatim}}

  As shown above, the function arguments can be listed separately on different
  lines, or in groups on sets of lines.  The arguments can begin on the same
  line as the type + function name line or can start on the next line.  The
  ending parenthesis ')' can appear on the same line as the last line of
  arguments or can appear alone on the last line.  Other formats are possible
  also and can be appropriate in different situations.

  {}\textit{Justification}: See {}\cite[Section 31.1]{CodeComplete2nd04}.
  
  {}\item\textit{Return types can be listed on same line as the function name
  unless the line is too long}: A function prototype's return type should
  appear on the same line as the function name unless it is excessively long
  and would result in the return type + function name line to extend past the
  80th character column.  When the return type + function name is too long,
  then it can be listed on separate lines with no indent, for example, as:
  
  {\small\begin{verbatim}
  Teuchos::RefCountPtr<ReturnType>
  someVeryLongAndVeryImportantFunction(
    int arg1, bool arg2, double* arg3[]
    ,const std::string &arg4  = ""
    );
  \end{verbatim}}

  However, listing the function return type on a separate line even in cases
  of shorter prototypes is also okay.

  \end{enumerate}

{}\item\textit{Order the definitions of C++ entities the same as the order of
the declarations of those entities}: For example, one should order the
definitions of a set of member functions the same as the ordering of the
declarations in the class definition.  Maintaining the ordering of definitions
and declarations makes the code more readable and more maintainable.  For
example, if the function definitions are ordered the same as the declarations,
it can be easy to see if a function definition is missing (i.e.\ which could
be the cause of the link error that you are seeing).

{}\item\textit{Use ``modified K\&R'' or ``ANSI'' style for the lacement of
braces and indentation of control structures}: Two basic styles of brace
placement and indentation in control structures are recommend here.  The first
general style is a modification of the K\&R style{}\cite{ArtisticStyle} where
the brace comes immediately after the control statement on the same line shown
as:

{\small\begin{verbatim}
  // Modified K&R Style (recommended)
  if(someCondition) {
    ...
  }
  else {
    ...
  }
\end{verbatim}}

Note that the pure K\&R style (for example, as defined by Artistic Style
{}\cite{ArtisticStyle}) shown as:

{\small\begin{verbatim}
  // Pure K&R Style (*not* recommended)
  if(someCondition) {
    ...
  } else {
    ...
  }
\end{verbatim}}

is not recommended.  Even through pure K\&R style meets McConnell's strict
pictorial definition of ``emulation of pure block style'' (i.e.\ the
equivalent to pure block format such as in Visual Basic) which he says is
good, he actually recommends the above modified K\&R style (as do we since we
feel it is more readable).

The second general style that is recommended is the ``ANSI''
style{}\cite{ArtisticStyle} where the opening brace begins flush on the next
line from the control statement shown as:

{\small\begin{verbatim}
  // ANSI Style (recommended)
  if(someCondition)
  {
    ...
  }
  else
  {
    ...
  }
\end{verbatim}}

Both the modified K\&R and the ANSI styles help to avoid right drift.  The
modified K\&R style creates tighter code vertically and seems to be preferred
by many communities and authors but variations of the ANSI style are also very
common.  Note that the ANSI style seems to have a distinct advantage in cases
where the control statement is continued over multiple lines.  For example,
the modified K\&R style with line continuations looks like:

{\small\begin{verbatim}
  // Modified K&R Style with line continuations (*not* recommended)
  if( someLongCondition &&
    anotherVeryLongCondition &&
    theLongestConditionThatWillFitOnOneLine ) {
    // Statements
    ...
  }
\end{verbatim}}

{}\noindent{}and it is hard to argue that this shows the logical structure of
code.  One could argue that the ANSI style which looks like:

{\small\begin{verbatim}
  // ANSI Style with line continuations (recommended)
  if( someLongCondition &&
    anotherVeryLongCondition &&
    theLongestConditionThatWillFitOnOneLine )
  {
    // Statements
    ...
  }
\end{verbatim}}

better shows the logical structure of the code in clearly separating the
control structure logic from the inner block of code.

Note that while the modified K\&R style meets McConnell's blessing of
``showing the logical structure of code'' where he refers to it as ``emulating
pure block'' format that he cites the ANSI styles as violating this principle
{}\cite[Section 31.1]{CodeComplete2nd04}.  However, it is somewhat subjective
what styles ``show the logical structure'' and McConnell himself seems to
contradict himself at times (see the formatting of if/else statements below).

When choosing between one of these to styles, try to be consistent at least
within a single file.  However, for control statements that extend over a
single line, prefer the ``ANSI'' style.

Below, the application of the modified K\&R style and the ANSI styles are
shown in the context of several different types of C++ loop and control
structures.

  \begin{enumerate}

  {}\item\textit{Formatting if/else if/else statements}: When applied to if
  statements, the two recommended styles are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  if(someCondition) {
    ...
  }
  else if(someOtherCondition) {
    ...
  }
  else {
    ...
  }
  \end{verbatim}}
  
  {}\noindent{}and:
  
  {\small\begin{verbatim}
  // ANSI Style (recommended)
  if(someCondition)
  {
    ...
  }
  else if(someOtherCondition)
  {
    ...
  }
  else
  {
    ...
  }
  \end{verbatim}}

  {}\item\textit{Formatting switch/case statements}: The two recommended
  formats for switch/case statements are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  switch(someEnumValue) {
    case ENUM_VALUE1:
      ...
      break;
    case ENUM_VALUE2:
      ...
      break;
    default:
      TEST_FOR_EXCEPT("Should never get there!");
  }
  \end{verbatim}}

  {}\noindent{}and

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  switch(someEnumValue)
  {
    case ENUM_VALUE1:
      ...
      break;
    case ENUM_VALUE2:
      ...
      break;
    default:
      TEST_FOR_EXCEPT("Should never get there!");
  }
  \end{verbatim}}

  As shown above, every switch structure should have a {}\texttt{default} case
  that throws an exception (see ``use the default clause to detect errors''
  in {}\cite[Section 15.1]{CodeComplete2nd04}).

  Also, if needed, the case blocks can be wrapped in braces as:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  switch(someEnumValue) {
    case ENUM_VALUE1: {
      ...
      break;
    }
    case ENUM_VALUE2: {
      ...
      break;
    }    
    default: {
      TEST_FOR_EXCEPT("Should never get there!");
    }
  }
  \end{verbatim}}

  {}\noindent{}and

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  switch(someEnumValue)
  {
    case ENUM_VALUE1:
    {
      ...
      break;
    }
    case ENUM_VALUE2:
    {
      ...
      break;
    }    
    default:
    {
      TEST_FOR_EXCEPT("Should never get there!");
    }
  }
  \end{verbatim}}

  {}\item\textit{Formatting for and while loops}: The two recommended styles
  for formatting for loops are:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  for ( int i = 0; i < size; ++i ) {
    ...
  }
  \end{verbatim}}

  {}\noindent{}and:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  for ( int i = 0; i < size; ++i )
  {
    ...
  }
  \end{verbatim}}

  Note that line continuations are often needed for a for loops control
  structure, especially if long type names or variable names are used.  In
  these cases, the ANSI style is recommended as:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  for (
    std::vector<SomeVeryLongClassName>::const_iterator itr = longVarName.begin();
    itr != someLongVariableName.end();
    ++itr )
  {
    ...
  }
  \end{verbatim}}

  Similarly, while loops should be formatted as:

  {\small\begin{verbatim}
  // Modified K&R Style (recommended)
  while ( someCondition ) {
    ...
  }
  \end{verbatim}}

  {}\noindent{}and:

  {\small\begin{verbatim}
  // ANSI Style (recommended)
  while ( someCondition )
  {
    ...
  }
  \end{verbatim}}

  \end{enumerate}

\end{enumerate}

%
\section{Doxygen documentation guidelines}
%

Here a set of reasonable guidelines is stated for writing Doxygen (and plain
old) documentation for classes, functions, etc.\ that makes the specification
clear but is not too verbose or hard to maintain.  Other types of higher-level
documentation are also needed, such as design documents and tutorials, but
guidelines for these higher-level types of documentation are not covered here.

%
\subsection{Goals for function and class level documentation}
%

\begin{enumerate}

{}\item\textit{Level of documentation should vary depending on the prominence
and/or the role of the software entity or collection}: Important interfaces or
widely disseminated concrete classes or functions require an appropriate level
of precise documentation.  Concrete implementations that are less widely
disseminated can provide less (or none in some cases) Doxygen documentation if
the implementation code itself is sufficiently easy to understand.  However,
major parts of an implementation should have at least some plain old (i.e.\
non-Doxygen) documentation to describe the basics of what is going on.

{}\item\textit{Important abstract interfaces must be fully specified
independent of any single concrete implementation}: In the case of important
abstract interfaces, the full specification of behavior for the compliant
objects (i.e. invariants, preconditions, postconditions) must be clearly
stated {}\cite[Item 69]{C++CodingStandards05}.  In some cases, this must be
done completely within the Doxygen documentation.  In other cases, a standard
unit testing function or class can be used to help specify the behavior of the
interface.  In fact, compiled and verified unit testing code may be superior
to standard Doxygen documentation since it can't ignored or become invalid.
On the other hand, it may be difficult for readers to wade through unit
testing code to find the specification of behavior and therefore both Doxygen
documentation and unit testing code should be used to provide the fullest
benefit.  Also, Doxygen documentation can automatically include bits and
pieces of compiled and tested code using the
{}\texttt{$\backslash$dontinclude} Doxygen commands.

{}\item\textit{Behavior of "user level" interfaces must be completely
specified by the Doxygen documentation and/or higher-level documentation}:
This item is an amendment to the above item as a special case for ``user''
interfaces.  A "user" could be someone that simply writes client code to the
interface or one that provides implementations to the interface or both.
User's should not be expected to study unit testing code to figure out the
preconditions and/or postconditions for a function call.

{}\item\textit{Wrong documentation is (almost) worse than no documentation at
all}: Documentation must be maintained as code is changed and therefore
excessive or unnecessary documentation degrades the quality of code.  However,
documentation with small errors is generally better than no documentation at
all.

{}\item\textit{The same documentation should not be repeated if possible}: We
should strive for a single source for documentation for an entity and not
repeat the same documentation over and over again.  This is critical to insure
that the documentation can be successfully maintained.

{}\item\textit{The documentation should maintain itself as much as possible
and be testable as much as possible}: Any significant fragments of code that
are shown in the Doxygen-generated HTML documentation should come from
compiled and tested code.  This can be accomplished by using the
{}\texttt{$\backslash$dontinclude} Doxygen command to read in code fragments
automatically.  In this way, the compiler and our test suite can be used to
help verify the code fragments in our Doxygen documentation.

\end{enumerate}

%
\subsection{General doxygen documentation principles}
%

Now that some of the general goals for our Doxygen documentation have been
presented, more details guidelines are given below:

\begin{enumerate}

{}\item\textit{Write Doxygen documentation directly in header files with
documented entities}: Write Doxygen documentation comments directly attached
to the classes, functions and other entities to make the documentation as
tightly tied to the code as possible.  This has the unfortunate side-effect of
requiring complete recompilations whenever documentation is modified but the
overall benefit should be worth the downsides.  Note that the Doxygen
documentation can be stripped out of Doxygen-generated hyper-linked versions
of the code, leaving clean C++ code without the clutter of detailed
documentation.  Therefore, developers should browse Doxygen-generated source
code instead of the source code directly when looking at the code and
performing code reviews.

{}\item\textit{Use a centralized set of definitions for common arguments when
possible}: Use clear and consistent naming of arguments in multiple functions
(within the same class and across as many classes and functions as makes
sense) and provide a centralized definition of these arguments if possible to
avoid repeating detailed definitions in each individual function's
documentation.  This helps to avoid duplicate documentation that is likely not
to be maintained correctly.  In the case of classes, this means providing some
common definitions in the main ``detailed'' documentation section for the
class.  In the case of nonmember functions, this might involve a common
Doxygen group or module (i.e.\ using the {}\texttt{$\backslash$defgroup}
command) for the set of functions.  In the case of collections of nonmember
functions, it may be difficult to expect readers to find the common
definitions, but links to the common documentation are possible using a
variety of approaches.

{}\item\textit{Provide common preconditions/postconditions along with the
common documentation for common arguments when possible}: For common arguments
that are shared among many functions, define the most common preconditions for
them in a central place and avoid listing them on a function-by-function basis
unless they change for an individual function.  For a C++ class, place
descriptions for these common arguments in the main class documentation under
a {}\texttt{$\backslash$section} named ``Common Function Arguments and
Pre/Post-Conditions''.  Only include preconditions for these arguments in
specific function documentation sections if it is different from the most
common preconditions.

{}\item\textit{Add a {}\texttt{$\backslash$brief} description for every entity
that should be seen by the user}: The {}\texttt{$\backslash$brief} field is
used to provide the short one-line documentation string that is included in
the function summary section of classes, groups, namespaces etc.  Even if no
text documentation is needed/wanted, add an empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment so that Doxygen will include the class, function, or other entity in
the HTML documentation.  Note that this is important when the Doxygen
configuration option {}\texttt{EXTRACT\-\_ALL} is set to {}\texttt{NO}.

{}\item\textit{Add a {}\texttt{$\backslash$param} field for all of the
arguments or none of the the arguments in a function; do not define partial
{}\texttt{$\backslash$param} field lists}: All arguments should be listed in
{}\texttt{$\backslash$param} fields with at least the [in], [out], or [in/out]
specifications and these should have at least a very short description.  Or,
if the function arguments are clear and trivial (and/or have already been
defined in the common documentation section), then no
{}\texttt{$\backslash$param} fields should be included at all.  If any of the
arguments in a function's documentation are listed in
{}\texttt{$\backslash$param} fields then all arguments should be listed in
{}\texttt{$\backslash$param} fields.

{}\item\textit{Only add a {}\texttt{$\backslash$returns} field if necessary}:
Don't add a {}\texttt{$\backslash$returns} description of the return value if
it is already clearly specified in the {}\texttt{$\backslash$brief}
description of the function.  However, if the nature of the return value is at
all complex, then include a {}\texttt{$\backslash$returns} field to describe
it.  When referring to the return argument, refer to it as
{}\texttt{returnVal}.  By consistently using the identifier
{}\texttt{returnVal} for the return value, user's will immediately know what
this is referring to.

{}\item\textit{Prefer specifying postconditions for output arguments in their
{}\texttt{$\backslash$param} field; otherwise specify their postconditions in
the 'Postconditions' list}: The postconditions for output arguments can be
listed directly in the {}\texttt{$\backslash$param} field for the argument if
they only involve just that argument in a fairly simple way.  Otherwise, if
the postconditions are more complex or involve multiple arguments in order to
specify, then they can be listed in the Postconditions list.  It may be
difficult to objectively determine the best place to list the postconditions
for an output argument.

{}\item\textit{Order the documentation fields in function documentation as
{}\texttt{$\backslash$brief}, {}\texttt{$\backslash$param}, Preconditions,
Postconditions, then {}\texttt{$\backslash$returns}; omitting those that do
not apply}: A consistent ordering of sections of documentation within a
function makes it easier for readers to find what they are looking for.

{}\item\textit{If possible, try to use {}\texttt{$\backslash$relates} to
associate nonmember functions with a single class}: If a nonmember function
is most closely related to a single class, use the
{}\texttt{$\backslash$relates} field to cause the documentation for the
function to be listed with the classes documentation.  This makes it easier
for readers to find out everything that they can do with a class object (or
set of class objects) just by looking at a single HTML page and a single
summary list of functions (which includes member and nonmember related
functions).

{}\item\textit{Provide detailed documentation for only the initial declaration
of a virtual function}: Only provide detailed documentation of the initial
declaration of a virtual function in the class where it is first defined as
{}\texttt{virtual}.  In general, documentation should not be included for the
overrides of virtual functions in derived classes.  Doxygen automatically puts
in a link to the original virtual function in the base class so readers are
just one click away for seeing the detailed documentation.  Always add an
empty
%
{\small\begin{verbatim}
  /** \brief . */
  void someFunction();
\end{verbatim}}
%
comment for every class and every function that should be included in the HTML
documentation but where no text documentation is wanted or needed.

{}\item\textit{Group the overrides of virtual functions into groups according
what their base class}: For example, the overrides of the virtual functions
for the {}\texttt{Teuchos\-::Parameter\-List\-Acceptor} would look like:

{\small\begin{verbatim}

  class SomeClass : public Teuchos::ParameterListAcceptor {
  public:

    ...

    /** \name Overriden from Teuchos::ParameterListAccpetor */
    //@{

    /** \brief . */
    void setParameterList(
      Teuchos::RefCountPtr<Teuchos::ParameterList> const& paramList);
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> getParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<Teuchos::ParameterList> unsetParameterList();
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getParameterList() const;
    /** \brief . */
    Teuchos::RefCountPtr<const Teuchos::ParameterList> getValidParameters() const;

    //@}

    ...

  };

\end{verbatim}}

{}\item\textit{Example source code used in Doxygen-generated and other forms
of documentation should be extracted automatically from code that is compiled
and tested nightly}: Any significant fragment of example code that is shown in
Doxygen HTML documentation or a latex document needs to come from compiled and
tested code that can be updated automatically.  These C++ code fragments can
be selectively inserted automatically into Doxygen documentation using the
{}\texttt{$\backslash$dontinclude} Doxygen command.

{}\item\textit{Sample output should be generated automatically from compiled
and tested code}: Sample output included in Doxygen documentation should be
generated automatically by the test harness code and should be written to
files that are included in the source directory.  The sample output in these
files can then be inserted into the Doxygen HTML documentation automatically
using the {}\texttt{$\backslash$verbinclude} Doxygen command.  Similar
approaches can also be used for latex documentation.

\end{enumerate}
