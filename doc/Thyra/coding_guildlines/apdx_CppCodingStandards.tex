%
\section{Summary of ``C++ Coding Standards'' (CPPCS) with Ammendments}
\label{sec:cpp_coding_standards}
%

Below, the 101 items in ``C++ Coding Standards'' by Sutter and Alexandrescu
{}\cite{C++CodingStandards05} are listed along with items that are ammended or
invalidated in the Thyra coding guidelines.

\begin{description}

{}\item[Organizational and Policy Issues]:

  \begin{description}

  {}\item[Item 0]: Don't sweat the small stuff. (Or: Know what not to
  standardize.)

  [\textbf{Ammended}, see Section {}\ref{thyracodingguidelines:formatting:sec}
  and Appendix {}\ref{sec:arguments-for-consistent-style}]

  {}\item[Item 1]: Compile cleanly at high warning levels

  {}\item[Item 2]: Use an automated build system.

  {}\item[Item 3]: Use a version control system.

  {}\item[Item 4]: Invest in code reviews

  \end{description}

{}\item[Design Style]:

  \begin{description}

  {}\item[Item 5]: Give one entity one cohesive responsibility.

  {}\item[Item 6]: Correctness, simplicity, and clarity come first.

  {}\item[Item 7]: Know when and how to code for scalability.

  {}\item[Item 8]: Don't optimize prematurely.

  {}\item[Item 9]: Don't pessimize prematurely.

  {}\item[Item 10]: Minimize global and shared data.

  {}\item[Item 11]: Hide information.

  {}\item[Item 12]: Know when and how to code for concurrency.

  {}\item[Item 13]: Ensure resources are owned by objects. Use explicit RAII
  and smart pointers.
    \begin{itemize}
    {}\item Replace {}\texttt{tr1::shared\_ptr} with {}\texttt{Teuchos::RCP}
    \end{itemize}

  \end{description}

{}\item[Coding Style]:

  \begin{description}

  {}\item[Item 14]: Prefer compile- and link-time errors to run-time errors.

  {}\item[Item 15]: Use const proactively.

  {}\item[Item 16]: Avoid macros.

  {}\item[Item 17]: Avoid magic numbers.

  {}\item[Item 18]: Declare variables as locally as possible.

  {}\item[Item 19]: Always initialize variables.

  {}\item[Item 20]: Avoid long functions. Avoid deep nesting.

  {}\item[Item 21]: Avoid initialization dependencies across compilation units.

  {}\item[Item 22]: Minimize definitional dependencies. Avoid cyclic dependencies.

  {}\item[Item 23]: Make header files self-sufficient.

  {}\item[Item 24]: Always write internal \#include guards. Never write
  external \#include guards

  \end{description}

{}\item[Functions and Operators]:

  \begin{description}

  {}\item[Item 25]: Take parameters appropriately by value, (smart) pointer,
  or reference.
  
  [\textbf{Ammended} by Section {}\ref{sec:func_arguments}]

  {}\item[Item 26]: Preserve natural semantics for overloaded operators.

  {}\item[Item 27]: Prefer the canonical forms of arithmetic and assignment
  operators.

  {}\item[Item 28]: Prefer the canonical form of ++ and --. Prefer calling the
  prefix forms.

  {}\item[Item 29]: Consider overloading to avoid implicit type conversions.

  {}\item[Item 30]: Avoid overloading '\&\&', '$||$', or ',' (comma).

  {}\item[Item 31]: Don't write code that depends on the order of evaluation
  of function arguments.

  \end{description}

{}\item[Class Design and Inheritance]:

  \begin{description}

  {}\item[Item 32]: Be clear what kind of class you're writing.

  {}\item[Item 33]: Prefer minimal classes to monolithic classes.

  {}\item[Item 34]: Prefer composition to inheritance.

  {}\item[Item 35]: Avoid inheriting from classes that were not designed to be
  base classes.

  {}\item[Item 36]: Prefer providing abstract interfaces.

  {}\item[Item 37]: Public inheritance is substitutability. Inherit, not to
  reuse, but to be reused.

  {}\item[Item 38]: Practice safe overriding.

  {}\item[Item 39]: Consider making virtual functions nonpublic, and public
  functions nonvirtual.

  {}\item[Item 40]: Avoid providing implicit conversions.

  {}\item[Item 41]: Make data members private, except in behaviorless
  aggregates (C-style structs).

  {}\item[Item 42]: Don't give away your internals.

  {}\item[Item 43]: Pimpl judiciously.

  {}\item[Item 44]: Prefer writing nonmember nonfriend functions.

  {}\item[Item 45]: Always provide new and delete together.

  {}\item[Item 46]: If you provide any class-specific new, provide all of the
  standard forms (plain, in-place, and nothrow).

  \end{description}

{}\item[Construction, Destruction, and Copying]:

  \begin{description}

  {}\item[Item 47]: Define and initialize member variables in the same order.

  {}\item[Item 48]: Prefer initialization to assignment in constructors.

  {}\item[Item 49]: Avoid calling virtual functions in constructors and destructors.

  {}\item[Item 50]: Make base class destructors public and virtual, or
  protected and nonvirtual.

  {}\item[Item 51]: Destructors, deallocation, and swap never fail.

  {}\item[Item 52]: Copy and destroy consistently.

  {}\item[Item 53]: Explicitly enable or disable copying.

  {}\item[Item 54]: Avoid slicing. Consider Clone instead of copying in base
  classes.

  {}\item[Item 55]: Prefer the canonical form of assignment.

  {}\item[Item 56]: Whenever it makes sense, provide a no-fail swap (and
  provide it correctly).

  \end{description}

{}\item[Namespaces and Modules]:

  \begin{description}

  {}\item[Item 57]: Keep a type and its nonmember function interface in the
  same namespace.

  {}\item[Item 58]: Keep types and functions in separate namespaces unless
  they are specifically intended to work together.

  {}\item[Item 59]: Don't write namespace usings in a header file or before an
  \#include.

  [\textbf{Ammended}, see Appendix {}\ref{sec:misc_amendments}]

  {}\item[Item 60]: Avoid allocating and deallocating memory in different
  modules.

  [\textbf{Invalidated}, see Appendix {}\ref{sec:misc_amendments}]

  {}\item[Item 61]: Don't define entities with linkage in a header file.

  {}\item[Item 62]: Don't allow exceptions to propagate across module
  boundaries.

  [\textbf{Invalidated}, see Appendix {}\ref{sec:misc_amendments}]

  {}\item[Item 63]: Use sufficiently portable types in a module's
  interface.

  [\textbf{Invalidated}, see Appendix {}\ref{sec:misc_amendments}]

  \end{description}

{}\item[Templates and Genericity]:

  \begin{description}

  {}\item[Item 64]: Blend static and dynamic polymorphism judiciously.

  {}\item[Item 65]: Customize intentionally and explicitly.

  {}\item[Item 66]: Don't specialize function templates.

  {}\item[Item 67]: Don't write unintentionally nongeneric code.

  \end{description}

{}\item[Error Handling and Exceptions]:

  \begin{description}

  {}\item[Item 68]: Assert liberally to document internal assumptions and
  invariants

  {}\item[Item 69]: Establish a rational error handling policy, and follow it
  strictly.

  {}\item[Item 70]: Distinguish between errors and non-errors.

  {}\item[Item 71]: Design and write error-safe code.

  {}\item[Item 72]: Prefer to use exceptions to report errors.

  {}\item[Item 73]: Throw by value, catch by reference.

  {}\item[Item 74]: Report, handle, and translate errors appropriately.

  {}\item[Item 75]: Avoid exception specifications.

  \end{description}

{}\item[STL: Containers]:

  \begin{description}

  {}\item[Item 76]: Use vector by default. Otherwise, choose an appropriate
  container.

  {}\item[Item 77]: Use vector and string instead of arrays.

  {}\item[Item 78]: Use vector (and {}\texttt{string::c\_str}) to exchange
  data with non-C++ APIs.

  {}\item[Item 79]: Store only values and smart pointers in containers.

  {}\item[Item 80]: Prefer {}\texttt{push\_back} to other ways of expanding a
  sequence.

  {}\item[Item 81]: Prefer range operations to single-element operations.

  {}\item[Item 82]: Use the accepted idioms to really shrink capacity and
  really erase elements.

  \end{description}

{}\item[STL: Algorithms]:

  \begin{description}

  {}\item[Item 83]: Use a checked STL implementation.

  {}\item[Item 84]: Prefer algorithm calls to handwritten loops.

  {}\item[Item 85]: Use the right STL search algorithm.

  {}\item[Item 86]: Use the right STL sort algorithm.

  {}\item[Item 87]: Make predicates pure functions.

  {}\item[Item 88]: Prefer function objects over functions as algorithm and
  comparer arguments.

  {}\item[Item 89]: Write function objects correctly.

  \end{description}

{}\item[Type Safety]:

  \begin{description}

  {}\item[Item 90]: Avoid type switching; prefer polymorphism.

  {}\item[Item 91]: Rely on types, not on representations.

  {}\item[Item 92]: Avoid using {}\texttt{reinterpret\_cast}.

  {}\item[Item 93]: Avoid using {}\texttt{static\_cast} on pointers.

  {}\item[Item 94]: Avoid casting away const.

  {}\item[Item 95]: Don't use C-style casts.

  {}\item[Item 96]: Don't memcpy or memcmp non-PODs.

  {}\item[Item 97]: Don't use unions to reinterpret representation.

  {}\item[Item 98]: Don't use varargs (ellipsis).

  {}\item[Item 99]: Don't use invalid objects. Don't use unsafe functions.

  {}\item[Item 100]: Don't treat arrays polymorphically.

  \end{description}

\end{description}
