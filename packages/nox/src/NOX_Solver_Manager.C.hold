// $Id$ 
// $Source$ 

// Nonlinear Solver Package (NLSPACK)
// COPYRIGHT (2002) Sandia Corporation.
// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
// license for use of this work by or on behalf of the U.S. Government.
// LICENSE & WARRANTY INFORMATION in README.txt and LICENSE.txt.
// CONTACT T. Kolda (tgkolda@sandia.gov) or R. Pawlowski (rppawlo@sandia.gov)

#include "NOX_Solver_Manager.H"	// class definition
#include "NOX_Utils.H"		// for static function doPrint

// Header files for different solvers
#include "NOX_Solver_Newton.H"		// Newton's method


using namespace NOX;
using namespace NOX::Solver;

Manager::Manager(Abstract::Group& initialguess, 
				     Parameter::List& p) :
  ptr(NULL),
  workgroup(NULL)
{
  setup(initialguess, workspace, p);
}

Manager::Manager(Abstract::Group& initialguess, 
				     Parameter::List& p) :
  ptr(NULL),
  workgroup(NULL)
{
  workgroup = initialguess.clone();
  setup(*workgroup, initialguess, p);
}

void Manager::setup(Abstract::Group& initialguess, 
			       Abstract::Group& workspace, 
			       Parameter::List& p) 
{
  NLS_Utilities::setUtilities(p);

  string method = p.getParameter("Nonlinear Solver", "Newton");

  if (NLS_Utilities::doPrint(0)) 
    cout << "Nonlinear Solver: " << method << endl; 
  
  if (method == "Newton") {
    ptr = new NLS_Newton(initialguess, workspace, p);
  } 
  else {
    cout << "ERROR: invalid choice for nonlinear solver "
	 << "in Manager constructor" << endl;
    throw 1;
  }
}

Manager::~Manager()
{
  delete ptr;
  delete workgroup;
}

void Manager::resetInputParameters(Parameter::List& p)
{
  /* NOTE FROM TAMMY: May want to add a hook at some point to be able
     to switch nonlinear solver methods mid-stream. */
  ptr->resetInputParameters(p);
}

::Status Manager::getStatus()
{
  return ptr->getStatus();
}

::Status Manager::iterate()
{
  return ptr->iterate();
}

::Status Manager::solve()
{
  return ptr->solve();
}

Abstract::Group& Manager::getSolutionGroup() const
{
  return ptr->getSolutionGroup();
}

Abstract::Group& Manager::getPreviousSolutionGroup() const
{
  return ptr->getPreviousSolutionGroup();
}

int Manager::getNumIterations() const
{
  return ptr->getNumIterations();
}

bool Manager::getOutputParameters(string& name, Parameter::Entry& p) const
{
  return ptr->getOutputParameters(name, p);
}




