#include "NOX.H"
#include "NOX_Epetra.H"
// Trilinos Objects
#ifdef HAVE_MPI
#include "Epetra_MpiComm.h"
#else
#include "Epetra_SerialComm.h"
#endif
#include "Epetra_Map.h"
#include "Epetra_Vector.h"
#include "Epetra_RowMatrix.h"
#include "Epetra_CrsMatrix.h"
#include "Epetra_Map.h"
#include "Epetra_LinearProblem.h"
#include "AztecOO.h"

#include "GenericEpetraProblem.H"

GenericEpetraProblem::GenericEpetraProblem(Epetra_Comm& comm, 
                                           int numGlobalNodes) :
  Comm(&comm),
  NumGlobalNodes(numGlobalNodes),
  StandardMap(0),
  OverlapMap(0),
  xptr(0),
  initialSolution(0),
  auxSolution(0),
  AA(0),  
  A(0) 
{

  // Commonly used variables
  int i;
  MyPID = Comm->MyPID();      // Process ID
  NumProc = Comm->NumProc();  // Total number of processes

  // Construct data layout
  createMaps();

  // Construction and initialization of mesh and solution vectors are
  // left to the derived problem class.
}


void GenericEpetraProblem::createMaps()
{

  if (NumGlobalNodes > 0)
  { 
    // Construct a Source Map that puts approximately the same 
    // number of equations on each processor 
    
    // Begin by distributing nodes fairly equally
    StandardMap = new Epetra_Map(NumGlobalNodes, 0, *Comm);
  
    // Get the number of nodes owned by this processor
    NumMyNodes = StandardMap->NumMyElements();
  
    // Construct an overlap node map for the finite element fill
    // For single processor jobs, the overlap and standard maps are the same
    if (NumProc == 1) { 
      OverlapMap = new Epetra_Map(*StandardMap);
    } else {
      
      int OverlapNumMyNodes;
      int OverlapMinMyNodeGID;
      OverlapNumMyNodes = NumMyNodes + 2;
      if ((MyPID == 0) || (MyPID == NumProc - 1))
        OverlapNumMyNodes --;
  
      if (MyPID==0)
        OverlapMinMyNodeGID = StandardMap->MinMyGID();
      else
        OverlapMinMyNodeGID = StandardMap->MinMyGID() - 1;
      
      int* OverlapMyGlobalNodes = new int[OverlapNumMyNodes];
      
      for (int i = 0; i < OverlapNumMyNodes; i ++)
        OverlapMyGlobalNodes[i] = OverlapMinMyNodeGID + i;
      
      OverlapMap = new Epetra_Map(-1, OverlapNumMyNodes,
                              OverlapMyGlobalNodes, 0, *Comm);
  
      delete [] OverlapMyGlobalNodes;
  
    } // End Overlap node map construction ********************************
  
    Importer = new Epetra_Import(*OverlapMap, *StandardMap);

#ifdef DEBUG
    // Output to check progress so far
    printf("NumMyNodes, NumGlobalNodes --> %d\t%d\n",NumMyNodes, NumGlobalNodes);
  
    cout << *StandardMap << endl;
    cout << *OverlapMap << endl;
    Importer->Print(cout);
#endif
  }

  return;
}


// Destructor
GenericEpetraProblem::~GenericEpetraProblem()
{
  delete A; A = 0;
  delete AA; AA = 0;
  delete initialSolution; initialSolution = 0;
  delete auxSolution; auxSolution = 0;
  delete Importer; Importer = 0;
  delete OverlapMap; OverlapMap = 0;
  delete StandardMap; StandardMap = 0;
}

void GenericEpetraProblem::outputResults(NOX::Solver::Manager& solver, 
                   NOX::Parameter::List& printParams)
{
  // Output the parameter list
  NOX::Utils utils(printParams);
  if (utils.isPrintProcessAndType(NOX::Utils::Parameters)) {
    cout << endl << "Final Parameters" << endl
	 << "****************" << endl;
    solver.getParameterList().print(cout);
    cout << endl;
  }

  // Get the Epetra_Vector with the final solution from the solver
  const NOX::Epetra::Group& finalGroup = 
      dynamic_cast<const NOX::Epetra::Group&>(solver.getSolutionGroup());
  const Epetra_Vector& finalSolution = 
      (dynamic_cast<const NOX::Epetra::Vector&>
        (finalGroup.getX())).getEpetraVector();

  // Print solution
  char file_name[25];
  FILE *ifp;
  int NumMyElements = finalSolution.Map().NumMyElements();
  (void) sprintf(file_name, "output.%d",finalSolution.Map().Comm().MyPID());
  ifp = fopen(file_name, "w");
  for (int i=0; i<NumMyElements; i++)
    fprintf(ifp,"%d  %E\n",finalSolution.Map().MinMyGID()+i,finalSolution[i]);
  fclose(ifp);
}

Epetra_Vector& GenericEpetraProblem::getMesh()
{
  assert( xptr != 0 ); // Solution vector had better exist

  return *xptr;
}

Epetra_Vector& GenericEpetraProblem::getSolution()
{
  assert( initialSolution != 0 ); // Solution vector had better exist

  return *initialSolution;
}

Epetra_CrsGraph& GenericEpetraProblem::getGraph()
{
  if(AA)
    return *AA;
  else
  {
    cout << "ERROR: No valid Matrix Graph exists for this problem !!" << endl;
    return *AA;
  }
}

Epetra_CrsMatrix& GenericEpetraProblem::getJacobian()
{
  if(A)
    return *A;
  else
  {
    cout << "ERROR: No valid Jacobian exists for this problem !!" << endl;
    return *A;
  }
}

void GenericEpetraProblem::setSolution(const Epetra_Vector& data)
{
  // Ensure that the derived problem class created the solution vector
  if(!initialSolution)
  {
    cout << "ERROR: No solution vector exists for this problem !!" << endl;
    throw "GenericEpetraProblem ERROR";
  }

  *initialSolution = data;
}

void GenericEpetraProblem::setAuxillarySolution(const Epetra_Vector& data)
{
  // Create the auxillary vector if needed
  if(!auxSolution)
    auxSolution = new Epetra_Vector(data);
  else
    *auxSolution = data;
}

bool GenericEpetraProblem::computePrecMatrix(const Epetra_Vector& solnVector,
                               Epetra_RowMatrix& matrix)
{
  cout << "WARNING: computePrecMatrix not implemented for this problem !!"
       << endl;

  return false;
}
    
bool GenericEpetraProblem::computePreconditioner(
                                   const Epetra_Vector& solnVector,
                                   Epetra_Operator& precOperator)
{
  cout << "WARNING: computePreconditioner not implemented for this problem !!"
       << endl;

  return false;
}

