<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>

<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 4.1.3_U1 sun4m) [Netscape]">
   <META NAME="sandia.approved" CONTENT="SAND99-1377">
   <META NAME="author" CONTENT="karen devine, kddevin@sandia.gov">

   <TITLE>Zoltan User's Guide:  Migration Query Functions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<div ALIGN=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp; |&nbsp; <a href="ug_alg.html">Next</a>&nbsp; |&nbsp; <a href="ug_query_lb.html">Previous</a></i></b></div>


<H2>
<A NAME="Migration Query Functions"></A>Migration Query Functions</H2>
The following query functions must be registered to use any of the migration
tools described in <A HREF="ug_interface_mig.html">Migration Functions</A>:
<BLOCKQUOTE><B><A HREF="#LB_OBJ_SIZE_FN">LB_OBJ_SIZE_FN</A></B>
<BR><B><A HREF="#LB_PACK_OBJ_FN">LB_PACK_OBJ_FN</A></B>
<BR><B><A HREF="#LB_UNPACK_OBJ_FN">LB_UNPACK_OBJ_FN</A></B></BLOCKQUOTE>
Optional, additional query functions for migration may also be registered:
<BLOCKQUOTE><B><A HREF="#LB_PRE_MIGRATE_FN">LB_PRE_MIGRATE_FN</A></B>
<br><B><A HREF="#LB_MID_MIGRATE_FN">LB_MID_MIGRATE_FN</A></B>
<BR><B><A HREF="#LB_POST_MIGRATE_FN">LB_POST_MIGRATE_FN</A></B></BLOCKQUOTE>

<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>

<TD><A NAME="LB_OBJ_SIZE_FN"></A>typedef int <B>LB_OBJ_SIZE_FN</B>(void
*<I> data</I>,<I> </I>int<I> *ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>

<TD> FUNCTION <B><I>Obj_Size</I></B>(<I>data, ierr</I>)&nbsp;
<BR>INTEGER(LB_INT) :: Obj_Size&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(IN) :: data&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_OBJ_SIZE_FN</B> query function returns the size
(in bytes) of the data buffer that is needed to pack all of a single object's
data. It is assumed that all objects to be packed in a single <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
call are of the same size. When this assumption is not true, the maximum
size of the objects to be packed should be returned by <B>LB_OBJ_SIZE_FN</B>.
This assumption may be relaxed in future releases of the library.
<BR>&nbsp;
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_OBJ_SIZE_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</TD>

<TD>The size (in bytes) of the required data buffer.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>

<TD><A NAME="LB_PRE_MIGRATE_FN"></A>typedef void <B>LB_PRE_MIGRATE_FN</B>(void
*<I> data</I>, int <I>num_import</I>, <B>LB_GID </B>*<I> import_global_ids</I>,
<B>LB_LID</B> *<I> import_local_ids</I>, int *<I> import_procs</I>, int
<I>num_export</I>, <B>LB_GID </B>*<I> export_global_ids</I>, <B>LB_LID
</B>*<I> export_local_ids</I>, int *<I> export_procs</I>,<I> </I>int<I>
*ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>

<TD> SUBROUTINE <B><I>Pre_Migrate</I></B>(<I>data, num_import,
import_global_ids, import_local_ids, import_procs, num_export,
export_global_ids, export_local_ids, export_procs, ierr</I>)&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(INOUT) :: data&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN) :: num_import, num_export&nbsp;
<BR>&lt;<I>type-gid</I>>, INTENT(IN), DIMENSION(*) :: import_global_ids, export_global_ids&nbsp;
<BR>&lt;<I>type-lid</I>>, INTENT(IN), DIMENSION(*) :: import_local_ids, export_local_ids&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN), DIMENSION(*) :: import_procs, export_procs&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-gid</I>> can be either INTEGER(LB_INT) or TYPE(LB_GID)&nbsp;
<BR>&lt;<I>type-lid</I>> can be either INTEGER(LB_INT) or TYPE(LB_LID)&nbsp;
<BR>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_PRE_MIGRATE_FN</B> query function performs any
pre-processing desired by the application. If it is registered, it is called
at the beginning of the <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
routine. The arguments passed to <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
are made available for use in the pre-processing routine.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_PRE_MIGRATE_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_import</I></TD>

<TD>The number of objects that will be received by this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_global_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the global IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_local_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the local IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_procs</I></TD>

<TD>An array of size <I>num_import</I> listing the processor IDs of the
source processors. This array may be NULL, as the processor does not necessarily
need to know from which processors it will be receiving objects.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_export</I></TD>

<TD>The number of objects that will be sent from this processor to other
processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_global_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the global IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_local_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the local IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_procs</I></TD>

<TD>An array of size <I>num_export</I> listing the processor IDs of the
destination processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>No pre-processing is done if an <B>LB_PRE_MIGRATE_FN</B> is not registered.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>

<TD><A NAME="LB_MID_MIGRATE_FN"></A>typedef void <B>LB_MID_MIGRATE_FN</B>(void
*<I> data</I>, int <I>num_import</I>, <B>LB_GID </B>*<I> import_global_ids</I>,
<B>LB_LID</B> *<I> import_local_ids</I>, int *<I> import_procs</I>, int
<I>num_export</I>, <B>LB_GID </B>*<I> export_global_ids</I>, <B>LB_LID
</B>*<I> export_local_ids</I>, int *<I> export_procs</I>,<I> </I>int<I>
*ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>

<TD> SUBROUTINE <B><I>Mid_Migrate</I></B>(<I>data, num_import,
import_global_ids, import_local_ids, import_procs, num_export,
export_global_ids, export_local_ids, export_procs, ierr</I>)&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(INOUT) :: data&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN) :: num_import, num_export&nbsp;
<BR>&lt;<I>type-gid</I>>, INTENT(IN), DIMENSION(*) :: import_global_ids, export_global_ids&nbsp;
<BR>&lt;<I>type-lid</I>>, INTENT(IN), DIMENSION(*) :: import_local_ids, export_local_ids&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN), DIMENSION(*) :: import_procs, export_procs&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-gid</I>> can be either INTEGER(LB_INT) or TYPE(LB_GID)&nbsp;
<BR>&lt;<I>type-lid</I>> can be either INTEGER(LB_INT) or TYPE(LB_LID)&nbsp;
<BR>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_MID_MIGRATE_FN</B> query function performs any
processing desired by the application between the packing and unpacking of
objects being migrated. If it is registered, it is called
after export objects are packed in <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>; imported objects are unpacked after the 
<b>LB_MID_MIGRATE_FN</b> query function is called.
The arguments passed to <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
are made available for use in the processing routine.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_MID_MIGRATE_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_import</I></TD>

<TD>The number of objects that will be received by this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_global_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the global IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_local_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the local IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_procs</I></TD>

<TD>An array of size <I>num_import</I> listing the processor IDs of the
source processors. This array may be NULL, as the processor does not necessarily
need to know from which processors it will be receiving objects.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_export</I></TD>

<TD>The number of objects that will be sent from this processor to other
processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_global_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the global IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_local_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the local IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_procs</I></TD>

<TD>An array of size <I>num_export</I> listing the processor IDs of the
destination processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>No processing is done if an <B>LB_MID_MIGRATE_FN</B> is not registered.</TD>
</TR>
</TABLE>
&nbsp;

<BR>
<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>
<TD><A NAME="LB_POST_MIGRATE_FN"></A>typedef void <B>LB_POST_MIGRATE_FN</B>(void
*<I> data</I>, int <I>num_import</I>, <B>LB_GID </B>*<I> import_global_ids</I>,
<B>LB_LID</B> *<I> import_local_ids</I>, int *<I> import_procs</I>, int
<I>num_export</I>, <B>LB_GID </B>*<I> export_global_ids</I>, <B>LB_LID
</B>*<I> export_local_ids</I>, int *<I> export_procs</I>,<I> </I>int<I>
*ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>
<TD> SUBROUTINE <B><I>Post_Migrate</I></B>(<I>data, num_import,
import_global_ids, import_local_ids, import_procs, num_export,
export_global_ids, export_local_ids, export_procs, ierr</I>)&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(INOUT) :: data&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN) :: num_import, num_export&nbsp;
<BR>&lt;<I>type-gid</I>>, INTENT(IN), DIMENSION(*) :: import_global_ids, export_global_ids&nbsp;
<BR>&lt;<I>type-lid</I>>, INTENT(IN), DIMENSION(*) :: import_local_ids, export_local_ids&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN), DIMENSION(*) :: import_procs, export_procs&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-gid</I>> can be either INTEGER(LB_INT) or TYPE(LB_GID)&nbsp;
<BR>&lt;<I>type-lid</I>> can be either INTEGER(LB_INT) or TYPE(LB_LID)&nbsp;
<BR>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_POST_MIGRATE_FN</B> query function performs any
post-processing desired by the application. If it is registered, it is
called at the end of the <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
routine. The arguments passed to <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
are made available for use in the post-processing routine.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_POST_MIGRATE_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_import</I></TD>

<TD>The number of objects that will be received by this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_global_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the global IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_local_ids</I></TD>

<TD>An array of size <I>num_import</I> listing the local IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; import_procs</I></TD>

<TD>An array of size <I>num_import</I> listing the processor IDs of the
source processors. This array may be NULL, as the processor does not necessarily
need to know from which processors it will be receiving objects.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; num_export</I></TD>

<TD>The number of objects that will be sent from this processor to other
processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_global_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the global IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_local_ids</I></TD>

<TD>An array of size <I>num_export</I> listing the local IDs of objects
to be sent from this processor.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; export_procs</I></TD>

<TD>An array of size <I>num_export</I> listing the processor IDs of the
destination processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>No post-processing is done if an <B>LB_POST_MIGRATE_FN</B> is not registered.</TD>
</TR>
</TABLE>
&nbsp;
<BR>
<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>

<TD><A NAME="LB_PACK_OBJ_FN"></A>typedef void <B>LB_PACK_OBJ_FN</B>(void
*<I> data</I>, <B>LB_GID</B> <I>global_id</I>, <B>LB_LID</B><I>local_id</I>,
int <I>dest_proc</I>, int <I>size</I>, char *<I> buf</I>,<I> </I>int<I>
*ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>

<TD> SUBROUTINE <B><I>Pack_Obj</I></B>(<I>data, global_id, local_id,
dest_proc, size, buf, ierr</I>)&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(IN) :: data&nbsp;
<BR>&lt;<I>type-gid</I>>, INTENT(IN) :: global_id&nbsp;
<BR>&lt;<I>type-lid</I>>, INTENT(IN) :: local_id&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN) :: dest_proc, size&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT), DIMENSION(*) :: buf&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-gid</I>> can be either INTEGER(LB_INT) or TYPE(LB_GID)&nbsp;
<BR>&lt;<I>type-lid</I>> can be either INTEGER(LB_INT) or TYPE(LB_LID)&nbsp;
<BR>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_PACK_OBJ_FN</B> query function allows the application
to tell the load-balancing library how to copy all needed data for a given
object into a communication buffer. The object's data can then be sent
to another processor as part of data migration. It may also perform other
computation, such as removing the object from the processor's data structure.
This routine is called by <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
for each object to be sent to another processor.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_PACK_OBJ_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; global_id</I></TD>

<TD>The global ID of the object for which data should be copied into the
communication buffer.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; local_id</I></TD>

<TD>The local ID of the object for which data should be copied into the
communication buffer.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; dest_proc</I></TD>

<TD>The destination processor ID (i.e., the processor to which the object
is being sent)</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; size</I></TD>

<TD>The size (in bytes) of the communication buffer for the specified object
(as returned by the <B><A HREF="#LB_OBJ_SIZE_FN">LB_OBJ_SIZE_FN</A></B>
query function).</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; buf</I></TD>

<TD>The starting address of the communication buffer into which the object's
data should be packed.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">
<TABLE WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE>C:</TD>

<TD><A NAME="LB_UNPACK_OBJ_FN"></A>typedef void <B>LB_UNPACK_OBJ_FN</B>(void
*<I> data</I>, <B>LB_GID</B> <I>global_id</I>, int <I>size</I>, char *<I>
buf</I>,<I> </I>int<I> *ierr</I>);&nbsp;
<BR>&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</TD>

<TD> SUBROUTINE <B><I>Unpack_Obj</I></B>(<I>data, global_id,
size, buf, ierr</I>)&nbsp;
<BR>&lt;<I>type-data</I>>, INTENT(INOUT) :: data&nbsp;
<BR>&lt;<I>type-gid</I>>, INTENT(IN) :: global_id&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN) :: size&nbsp;
<BR>INTEGER(LB_INT), INTENT(IN), DIMENSION(*) :: buf&nbsp;
<BR>INTEGER(LB_INT), INTENT(OUT) :: ierr&nbsp;

<P>&lt;<I>type-gid</I>> can be either INTEGER(LB_INT) or TYPE(LB_GID)&nbsp;
<BR>&lt;<I>type-data</I>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<I>x</I>)
where <I>x</I> is 1, 2, 3 or 4. See the section on
<A HREF="ug_fortran_api.html#fortran ug api query"> Fortran query functions</A>
for an explanation.&nbsp;
</TD>
</TR>
</TABLE>

<HR WIDTH="100%">An <B>LB_UNPACK_OBJ_FN</B> query function allows the application
to tell the load-balancing library how to copy all needed data for a given
object from a communication buffer into the application's data structure.
This operation is needed as the final step of importing objects during
data migration. The query function may also perform other computation,
such as building request lists for related data. This routine is called
by <B><A HREF="ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
for each object to be received by the processor. (Note: a local ID for
the object is not included in this function, as the local ID is local to
the exporting, not the importing, processor.)
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Function Type:</B></TD>

<TD><B>LB_UNPACK_OBJ_FN_TYPE</B></TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; data</I></TD>

<TD>Pointer to user-defined data.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; global_id</I></TD>

<TD>The global ID of the object whose data has been received in the communication
buffer.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; size</I></TD>

<TD>The size (in bytes) of the object's data in the communication buffer.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; buf</I></TD>

<TD>The starting address of the communication buffer for this object.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; ierr</I></TD>

<TD>Error code to be set by function.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">[<A HREF="ug.html">Table of Contents</A>&nbsp; |&nbsp;
<A HREF="ug_alg.html">Next:&nbsp; Algorithms</A>&nbsp; |&nbsp; <A HREF="ug_query_lb.html">Previous:&nbsp;
Load-Balancing Query Functions</A>]
</BODY>
</HTML>
