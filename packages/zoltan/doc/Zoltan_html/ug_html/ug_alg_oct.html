<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <META NAME="sandia.approved" CONTENT="SAND99-1377">
   <META NAME="author" CONTENT="karen devine, kddevin@sandia.gov">
   <TITLE>Zoltan User's Guide:  Octree Partitioning</TITLE>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/ug_header.gif" ALT="Zoltan User's Guide" ></H3></DIV>

<H2>
<A NAME="Octree"></A>Octree/Space-Filling Curve (SFC) Partitioning</H2>
The Octree Partitioning algorithm is based upon work in load balancing
for parallel mesh generation at Rensselaer Polytechnic Institute [<A HREF="ug_refs.html#flaherty">Flaherty,
Loy et al.</A>]. It was implemented in the library by Luis Gervasio, Department
of Computer Science, Rensselaer Polytechnic Institute, as his summer project
in 1998 [<A HREF="ug_refs.html#gervasio">Gervasio</A>].An octree is a spatial
decomposition of the computational domain in which the root of the tree,
representing the entire domain, is recursively divided by two in each coordinate
direction (producing eight or four "child" octants in 3D or 2D, respectively)
until each subregion holds at most an application-specified number of objects.
These subregions are represented by the leaves of the octree. The octree
data structure is widely used in mesh generation and adaptive mesh refinement
[<U><A HREF="ug_refs.html#baehmann">Baehmann et al.</A></U>, <U><A HREF="ug_refs.html#shephard">Shephard
and Georges</A></U>].The octree resulting from such a spatial decomposition
of the domain can be used to partition an application's work [<A HREF="ug_refs.html#edwards">Edwards</A>,
<A HREF="ug_refs.html#pilkington">Pilkington and Baden</A>, <A HREF="ug_refs.html#warren">Warren
and Salmon</A>]. To partition an octree, a traversal of the tree is used
to define a global ordering on the leaves of the octree. This global ordering
is often referred to as a Space-Filling Curve (SFC). The leaves of the
octree can be easily assigned to processors in a manner which equally distributes
work by assigning slices of the ordered list to processors. Different tree-traversal
algorithms produce different global orderings or SFCs, with some SFCs having
better connectivity and partition quality properties than others. Currently,
Morton Indexing (i.e., Z-curve), Grey Code, and Hilbert SFCs are supported.
Morton Indexing and Grey Code SFCs are the simplest (and currently, the
fastest) of the SFC algorithms, but they produce lower-quality partitions
than the Hilbert SFC. Further work will be performed to improve the performance
of the Hilbert SFC algorithm implemented in the library.
<BR>&nbsp;
<TABLE WIDTH="100%" NOSAVE >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Method String:</B></TD>

<TD><B>OCTPART</B></TD>
</TR>

<TR>
<TD><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>OCT_DIM</I></TD>

<TD>Specifies whether the 2D or 3D Octree algorithms should be used. The
3D algorithms can be used for 2D problems, but much memory will be wasted
to allow for a non-existent third dimension. Similarly, a 2D algorithm
can be used for 3D surface meshes provided that the surface can be projected
to the <I>xy</I>-plane without overlapping points.&nbsp;
<BR>2 = use 2D algorithm; 3 = use 3D algorithm.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; OCT_METHOD</I></TD>

<TD>The SFC to be used.&nbsp;
<BR>0 = Morton Indexing; 1 = Grey Code; 2 = Hilbert.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>OCT_GRANULARITY</I></TD>

<TD>The maximum number of objects to allow in a leaf octant of the octree.
These objects will be assigned as a group to a processor, so this parameter
defines the granularity of the load-balancing problem.Values greater than
or equal to one are allowable.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>OCT_OUTPUT_LEVEL</I></TD>

<TD>Amount of output the load-balancing algorithm should produce.&nbsp;
<BR>0 = no statistics; 1 = statistics summary; 2 = debugging information.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><I>OCT_DIM</I> = 3</TD>
</TR>

<TR>
<TD></TD>

<TD><I>OCT_METHOD</I> = 0</TD>
</TR>

<TR>
<TD></TD>

<TD><I>OCT_GRANULARITY</I> = 1</TD>
</TR>

<TR>
<TD></TD>

<TD><I>OCT_OUTPUT_LEVEL</I> = 1</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Required Query Functions:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_NUM_OBJ_FN">LB_NUM_OBJ_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_OBJ_LIST_FN">LB_OBJ_LIST_FN</A></B>
or <B><A HREF="ug_query_lb.html#LB_FIRST_OBJ_FN">LB_FIRST_OBJ_FN</A></B>/<B><A HREF="ug_query_lb.html#LB_NEXT_OBJ_FN">LB_NEXT_OBJ_FN</A></B>
pair</TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_NUM_GEOM_FN">LB_NUM_GEOM_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_GEOM_FN">LB_GEOM_FN</A></B></TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">[<A HREF="ug.html">Table of Contents</A>&nbsp; |&nbsp;
<A HREF="ug_examples.html">Next:&nbsp; Examples of Library Usage</A>&nbsp;
|&nbsp; <A HREF="ug_alg_jostle.html">Previous:&nbsp;&nbsp; Jostle</A>]
</BODY>
</HTML>
