<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  Introduction</title>
<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>
</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_usage.html">Next</a>&nbsp; |&nbsp; <a href="ug.html">Previous</a></i></b></div>

<h2>
<a NAME="Introduction"></a>Introduction</h2>

<blockquote><a href="#Motivation">Project Motivation</a>
<br><a href="#Load-Balancing Tools">Load-Balancing Tools</a>
<br><a href="#Migration Tools">Migration Tools</a></blockquote>
<a NAME="Motivation"></a>Over the past decade, the use of parallel computing
to solve large-scale scientific problems has grown immensely. Many traditional
numerical methods, such as finite difference and finite element methods,
have been shown to be effective and efficient in parallel computing environments;
see [<a href="ug_refs.html#attaway">Attaway et al.</a>] and [<a href="ug_refs.html#mpsalsa-gordonbell">Devine
et al.</a>] for two examples. They have typically been implemented in an
MIMD fashion, with portions of the problem domain being assigned uniquely
to individual processors. This static decomposition of the domain is done
as a pre-processing step to the actual computation either by the application
itself or by some static partitioning tool such as 
<a href="http://www.cs.sandia.gov/CRF/chac.html">Chaco</a>,
<a href="http://www-users.cs.umn.edu/~karypis/metis/">METIS</a>
or <a href="http://www.gre.ac.uk/jostle/">Jostle</a>.
<p>As the desire for simulations with greater complexity and resolution
arises, new numerical schemes have been developed, such as adaptive numerical
methods, multiphysics simulations, and adaptive physics models. In these
applications, the amount of work per processor can vary over time. For
example, in adaptive finite element methods, the number of degrees of freedom
within a processor can increase or decrease as the method requires greater
or lower accuracy in a region of the problem domain. The changing processor
work-loads make a static decomposition of the domain insufficient; a dynamic
load-balancing strategy is needed to readjust work-loads as the computation
proceeds.
<p>Several important differences exist between static and dynamic load-balancing
strategies. Dynamic strategies are complicated by the fact that they must
be implemented in parallel without interfering with the scalability of
the application. Thus, they must use little memory and execute quickly.
Also because they run side-by-side with an application, dynamic strategies
must use a subroutine interface, rather than the file-based interface used
by most static partitioners. Additionally, dynamic load-balancing algorithms
should be "incremental"; that is, small changes in the processor work loads
should produce only small changes in the decomposition so that little data
movement is required to establish the new decomposition. Most static decomposition
strategies do not explicitly enforce this incremental property; good dynamic
strategies must either implicitly or explicitly enforce it.
<p>In the past, most dynamic load-balancing strategies have been implemented
on a case-by-case basis within application programs. Typically, a single
strategy was implemented in an application, relying heavily upon the data
structures of the particular application. This approach has two disadvantages.
First, because its implementation relies heavily upon a single application,
the load-balancing algorithm is not easily re-used by other applications.
Second, because the application developer is usually interested more in
the physics of the simulation than in the performance of dynamic load-balancing
algorithms, only one algorithm is implemented and comparisons to other
load-balancing methods are not performed to find, perhaps, a more effective
strategy.&nbsp; See [<a href="ug_refs.html#hendrickson-devine">Hendrickson
and Devine</a>] for a more thorough discussion of these issues.
<p>The goal of the Zoltan Dynamic Load-Balancing Library project is to
provide application developers a general-purpose dynamic load-balancing
tool that can be easily used by a variety of applications. The library
consists of several different dynamic load-balancing algorithms and is
designed so that new algorithms can easily be added to the library. An
object-oriented library interface separates the data structures of the
load-balancing routines from those of the application. The library's routines
gather information (such as lists of objects to be balanced, their weights,
and their coordinates) from the application through a series of query functions.
These simple query functions must be provided by the application and "registered"
with the library. In this manner, the library never directly accesses the
application's data structures. Use of the library in a different application
requires only that the new application supply its own set of query functions
to the load-balancing library. Once the appropriate query functions are
registered with the load-balancing library, the application can easily
select from a number of load-balancing algorithms and invoke load balancing
at the appropriate places in its computation. While some extra memory and
function-call overhead is required by this call-back protocol, the generality
and ease of use of the library obtained by it is well justified.
<p>The Zoltan library consists of two parts: dynamic load-balancing tools
that compute new decompositions based on current processor work loads,
and migration tools that perform the communication needed to move
data to establish a new decomposition. Each set of tools is described below.

<p>Also included with the Zoltan package is a sample application, 
<i>zdrive</i>.
The <i>zdrive</i> program reads graph and/or coordinate information from
either NemesisI or 
<a href="http://www.cs.sandia.gov/CRF/chac.html">Chaco</a>
input files, runs Zoltan using this input, and 
writes simple output files containing information about the resulting
decomposition.  It allows load-balancing algorithm developers 
to test changes to Zoltan without having to run Zoltan in 
a large application code.  Application developers can use the <i>zdrive</i>
code to see examples of function calls to Zoltan and the implementation of 
geometric and graph-based query functions.
For information
on how to build and use <i>zdrive</i>, see the <a href="../dev_html/dev_driver.html">Test
Driver</a> section of the <a href="../dev_html/dev.html">Zoltan Developer's
Guide</a>.
<h2>
<a NAME="Load-Balancing Tools"></a>Load-Balancing Tools</h2>
Within the Zoltan library, many algorithms for dynamically determining
new processor decompositions can be implemented. Information needed by
the algorithms is obtained through queries to the application's data structures
using application defined and registered query routines. Zoltan's query routines
include geometric queries (supplying information such as coordinates
for objects), graph-based queries (supplying such information as edge lists
for objects in the communication graph of the computation), and tree-based
queries (supplying information about the parent-child relationships in
the refinement tree generated by an adaptive
mesh-refinement application).
<p>A typical interaction between an application and the dynamic load-balancing
tools is shown in the <a href="#lb_interaction.gif">figure</a> below. Through
a call to <b><a href="ug_interface_init.html#LB_Create">LB_Create</a></b>,
the application creates a load-balancing data structure, which is storage
space to hold pointers to registered functions and load-balancing data.
This structure is passed to a number of load-balancing functions. The application
then selects a load-balancing method to be used (Recursive Coordination
Bisection, "RCB," in the example) through a call to <b><a href="ug_interface_lb.html#LB_Set_Method">LB_Set_Method</a></b>.
Several query functions needed by the RCB algorithm are registered through
calls to <b><a href="ug_interface_init.html#LB_Set_Fn">LB_Set_Fn</a></b>.
These query functions include application-defined functions to return the
number of objects on the processor (<i>user_return_num_elems_fn</i>), a
list of the objects (<i>user_return_elem_list_fn</i>), and the coordinates
for a given object (<i>user_return_coords_fn</i>). When the application 
needs load balancing, 
it calls <b><a href="ug_interface_lb.html#LB_Balance">LB_Balance</a></b>
to compute a new decomposition on the processors.
<p>The load-balancing library then follows pointers to the registered query
functions to build the data structures needed for the RCB algorithm. An
array of data is built, with one entry for each object owned by the processor.
The number of objects is determined by following the <i>Get_Num_Obj</i>
pointer to the <i>user_return_num_elems_fn</i>. Storage is allocated for
the objects, and lists of the objects' identification numbers are obtained
by following the <i>Get_Obj_List</i> function pointer to the <i>user_return_elem_list_fn</i>.
Then, for each object, the object's coordinates are obtained through calls
through the <i>Get_Geom</i> function pointer to the registered function
<i>user_return_coords_fn</i>.
Once the data structures are built, the load-balancing library can perform
the RCB decomposition and return arrays of information describing the new
decomposition to the application.
<br>&nbsp;
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><a NAME="lb_interaction.gif"></a>Application&nbsp;
<table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td>.<tt>..</tt>
<br><tt>/* <i>Register method and application query functions</i> */</tt>
<br><tt>lb = LB_Create(MPI_COMM_WORLD);</tt>
<br><tt>LB_Set_Method(lb, "RCB");</tt>
<br><tt>LB_Set_Fn(lb,LB_GEOM_FN_TYPE,(void (*)())user_return_coords_fn,NULL);</tt>
<br><tt>LB_Set_Fn(lb,LB_NUM_OBJ_FN_TYPE,(void (*)())user_return_num_elems_fn,NULL);</tt>
<br><tt>LB_Set_Fn(lb,LB_OBJ_LIST_FN_TYPE,(void (*)())user_return_elem_list_fn,NULL);</tt>
<br><tt>...</tt>
<br><tt>/* <i>Call the load balancer</i> */</tt>
<br><tt>LB_Balance(lb,&amp;new,&amp;num_imp,&amp;imp_glob_ids,&amp;imp_loc_ids,&amp;imp_procs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;num_exp,&amp;exp_glob_ids,&amp;exp_loc_ids,&amp;exp_procs);</tt></td>
</tr>
</table>
&nbsp;</td>
</tr>

<tr>
<td>
<center><img SRC="figures/arrow.gif" height=48 width=112></center>
</td>
</tr>

<tr>
<td>
<div align=right>Dynamic Load Balancer</div>
&nbsp;
<div ALIGN=right><table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td><tt>...</tt>
<br><tt>/* <i>call registered functions to build </i> */</tt>
<br><tt>/* <i>load-balancing data structures</i> */</tt>
<br><tt>num_objs = lb->Get_Num_Obj(lb->Get_Num_Obj_Data, </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;ierr);&nbsp;</tt>
<p><tt>/* <i>allocate memory for global and local IDs </i>*/</tt>
<br><tt>lb->Get_Obj_List(lb->Get_Obj_List_Data, global_ids,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
local_ids, 0, NULL, &amp;ierr);&nbsp;</tt>
<br><tt>for (i = 0; i &lt; num_objs; i++) {</tt>
<br><tt>&nbsp;&nbsp; lb->Data[i].Global_Tag = global_ids[i];</tt>
<br><tt>&nbsp;&nbsp; lb->Data[i].Local_Tag = local_ids[i];</tt>
<br><tt>&nbsp;&nbsp; lb->Get_Geom(lb->Get_Geom_Data, global_ids[i],&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
local_ids[i], lb->Data[i].Coords,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;ierr);</tt>
<br><tt>}</tt>
<br><tt>/* <i>perform balancing on lb->Data</i> */</tt>
<br><tt>...</tt></td>
</tr>
</table></div>
&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM><i>Example of interaction between the application
and the load balancer.</i></caption>
</table>

<h2>
<a NAME="Migration Tools"></a>Migration Tools</h2>
Data migration is, unfortunately, an extremely application-dependent part
of establishing new decompositions. It involves gathering objects from
the data structures on one processor, sending those objects to a new processor,
inserting the objects into the new processor's data structures, and removing
the objects from the original processor. In addition, auxiliary data may
have to be sent to the new processor to support the objects migrated there.
For example, in a finite element application, the "objects" used in load
balancing may be elements. But when elements are migrated to new processors,
the nodes associated with those elements must also be sent to the new processors,
increasing the dependence of data migration on the application.
<p>A general-purpose load-balancing library can not perform all the operations
required for data migration in all applications. However, it can assist
an application with the communication required for data migration. As a
result of the load-balancing algorithm, the library knows where data must
be sent to establish the new decomposition and can perform all needed communication
using communication tools within the library. The application, then, must
specify how to gather data associated with migrating objects and how to
insert that data into the new processor's data structures. Following the
registered query-function design of the dynamic load-balancing tools, migration
tools can then be provided to the application. An example of the interaction
between the application and the migration tools is shown in the <a href="#mig_interaction.gif">figure</a>
below. The application registers three additional query functions: a function
that returns the size (in bytes) of the data buffer needed to gather all
of <i>one object's</i> data (<i>user_elem_size_fn</i>), a function that packs
<i>one object's</i> data into a buffer (<i>user_pack_one_elem_fn</i>), 
and a function
that unpacks <i>one object's</i> data and inserts it into the new processor's
data structure (<i>user_unpack_one_elem_fn</i>).
<p>The migration tools then use these registered functions with the
results of the load-balancing algorithm to move data between processors.
The migration tools follow the <i>Get_Obj_Data_Size</i> function pointer
to <i>user_elem_size_fn</i> to obtain the size of the data buffer needed
for an object's data. They allocate appropriately sized import and export
buffers. Through repeated calls to the <i>Pack_Object</i> function (<i>user_pack_one_elem_fn</i>),
the migration tools fill the export buffer with data for each object
to be exported. The migration tools then send the export buffer data
to other processors and receive import data from other processors. Then,
for each object imported, the migration help tools call the registered
<i>Unpack_Object</i>
function (<i>user_unpack_one_elem_fn</i>) to unpack the data from the import
buffer and insert it in the processor's data structure. Under this model,
the application developer does not have to implement additional communication
routines to perform data migration; the migration tools handle all
communication required for data movement.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><a NAME="mig_interaction.gif"></a>Application&nbsp;
<table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td><tt>...</tt>
<br><tt>/* <i>Register packing and unpacking functions</i> */</tt>
<br><tt>LB_Set_Fn(lb,LB_OBJ_SIZE_FN_TYPE,(void (*)())user_elem_size_fn,NULL);</tt>
<br><tt>LB_Set_Fn(lb,LB_PACK_OBJ_FN_TYPE,(void (*)())user_pack_one_elem_fn,NULL);</tt>
<br><tt>LB_Set_Fn(lb,LB_UNPACK_OBJ_FN_TYPE,(void (*)())user_unpack_one_elem_fn,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);</tt>
<br><tt>...</tt></td>
</tr>
</table>
&nbsp;</td>
</tr>

<tr>
<td>
<center><img SRC="figures/arrow.gif" height=48 width=112></center>
</td>
</tr>

<tr>
<td>
<div align=right>Migration Tools</div>
&nbsp;
<div ALIGN=right><table BORDER=2 COLS=1 WIDTH="80%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt>...</tt>
<br><tt>size = lb->Get_Obj_Size(lb->Get_Obj_Size_Data,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;ierr);</tt>
<br><tt>/* <i>pack all objects for export</i> */</tt>
<br><tt>for each object i being exported</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lb->Pack_Obj(lb->Pack_Obj_Data,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exp_global_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exp_local_id[i], exp_procs[i], </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size, export_buf[i], &amp;ierr);&nbsp;</tt>
<p><tt>/* <i>perform communication using map</i> */</tt>
<br><tt>communicate(lb->Comm_Map, export_buf, </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;import_buf);</tt>
<p><tt>/* <i>unpack all imported objects</i> */</tt>
<br><tt>for each object i received</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lb->Unpack_Obj(lb->Unpack_Obj_Data, </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
imp_global_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size, import_buf[i], &amp;ierr);</tt>
<br><tt>...</tt></td>
</tr>
</table></div>
&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM><i>Example of interaction between the application
and the migration tools.</i></caption>
</table>

<p>The migration tools are separate modules from the dynamic load-balancing
tools. Thus, an application does not have to use the migration tools
even though it uses the dynamic load-balancing tools to compute a new decomposition.
If the application has its own migration routines, it can use them in conjunction
with the load-balancing routines in the load-balancing library.
<br>&nbsp;
<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_usage.html">Next:&nbsp;
Using the Library</a>&nbsp; | <a href="ug.html">Previous:&nbsp; Table of
Contents</a>]
</body>
</html>
