<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  ParMETIS Interface</title>
<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! Zoltan is distributed under the GNU Lesser General Public License 2.1.     !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>
</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_alg_jostle.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_irb.html">Previous</a></i></b></div>

<h2>
<a NAME="ParMETIS"></a>ParMETIS</h2>
<a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
is a parallel library for graph partitioning (for static load balancing)
and repartitioning (for dynamic load balancing) developed at the University
of Minnesota by Karypis, Schloegel and Kumar [<a href="ug_refs.html#parmetis">Karypis
and Kumar</a>]. ParMETIS is therefore strictly speaking not a method but
rather a collection of methods. In the Zoltan context, ParMETIS is a method
with many sub-methods. Zoltan provides an interface to all the ParMETIS
(sub-)methods.&nbsp; The user selects which ParMETIS method to use through
the parameter PARMETIS_METHOD. Most of the ParMETIS methods are based on
either multilevel Kernighan-Lin partitioning or a diffusion algorithm.
The names of the ParMETIS methods used by Zoltan are identical to those
in the ParMETIS library. For further information about the various ParMETIS
methods and parameters, please consult the ParMETIS User's Guide.
<p>Graph partitioning is a useful abstraction for load balancing. The main
idea is to represent the computatiional application as a weighted graph.
The nodes or vertices in the graph correspond to objects in Zoltan.&nbsp;
Each object may have a weight that normally represents the amount of computation.
The edges or arcs in the graph usually correspond to communication costs.
In graph partitioning, the problem is to find a partitioning of the graph
(that is,&nbsp; each vertex is assigned to one out of <i>k</i> possible
sets called partitions) that minimizes the cut size (weight) subject to
the partitions having approximately equal size (weight). In repartitioning,
it is assumed that a partitioning already exists. The problem is to find
a good partitioning that is also "similar" in some sense to the existing
partitioning. This keeps the migration cost low. All the problems described
above are NP-hard so no efficient exact algorithm is known. We remark that
in Zoltan, the number of partitions is always the same as the number of
processes (which is normally equal to the number of processors).
<p>We only give a brief summary of the various ParMETIS methods here; for
more details see the ParMETIS documentation. The methods fall into three
categories:
<ol>
<li>
Part* - Perform graph partitioning without consideration of the initial
distribution.</li>

<li>
Repart* - Incremental algorithms with small migration cost.</li>

<li>
Refine* - Refines a given partitioning (balance).&nbsp; Can be applied
multiple times to reduce the communication cost (cut weight) if desired.</li>
</ol>
As a rule of thumb, use one of the Part* methods if you have a poor initial
balance and you are willing to spend some time doing migration. One such
case is static load balancing, that is, you only need to balance once.
Use the Repart* methods when you have a reasonably good load balance that
you wish to update incrementally. These methods are well suited&nbsp; for
dynamic load balancing (for example,&nbsp; adaptive mesh refinement). A
reasonable strategy is to call PartKway once to obtain a good initial balance
and&nbsp; later update this balance using one of the Repart* methods.
<p>This interface is currently compatible with ParMETIS version 2.0.&nbsp;
There is no guarantee that Zoltan will work correctly if you have a different
version of ParMETIS on your computer. Source and documentation for ParMETIS
can be obtained from the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS
home page</a>. As a courtesy service,&nbsp; a compatible version of the
ParMETIS&nbsp; source code will be distributed with Zoltan. However, ParMETIS
is a completely separate library. If you do not wish to install ParMETIS,
it is possible to compile Zoltan without any references to ParMETIS&nbsp;
(when you 'make' Zoltan, comment out the PARMETIS_LIBPATH variable in the
lower-level makefile <i><a href="ug_usage.html#Building the Library">Makefiles/Makefile.&lt;platform></a></i>).
<p>The current version of Zoltan ignores the imbalance tolerance parameter,
IMBALANCE_TOL, when ParMETIS is used. The reason is that the corresponding
imbalance parameter is fixed at 1.05 in ParMETIS 2.0. We expect that future
versions of ParMETIS will allow the user to select the tolerance for load
imbalance. When this feature becomes available in ParMETIS, it will also
be supported through IMBALANCE_TOL in Zoltan.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Method String:</b></td>

<td><b>PARMETIS</b></td>
</tr>

<tr>
<td><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; PARMETIS_METHOD</i></td>

<td>The ParMETIS method to be used.; currently eight are available.&nbsp;
<br><i>PartKway</i> - multilevel Kernighan-Lin partitioning&nbsp;
<br><i>PartGeom</i> - space filling curves (coordinate based)&nbsp;
<br><i>PartGeomKway</i> - hybrid method based on PartKway and PartGeom
(needs both&nbsp; graph data and coordinates)&nbsp;
<br><i>RepartLDiffusion</i> - diffusion algorithm (local)&nbsp;
<br><i>RepartGDiffusion</i> - diffusion algorithm (global)&nbsp;
<br><i>RepartRemap</i> - multilevel partioning with remap seeking to minimize
migration cost&nbsp;
<br><i>RepartMLRemap</i> - similar to RepartRemap but with additional multilevel
refinement&nbsp;
<br><i>RefineKway</i> - refine the current partitioning (balance)</td>
</tr>

<tr>
<td></td>

<td>The method names are case insensitive.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>PARMETIS_OUTPUT_LEVEL</i></td>

<td>Amount of output the load-balancing algorithm should produce.&nbsp;
<br>0 = no output, 1 = print timing info. Turning on more bits displays
more information (for example, 3=1+2, 5=1+4, 6=2+4).</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_COARSE_ALG</i></td>

<td>Coarse algorithm for PartKway. 1 = serial, 2 = parallel.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_FOLD</i></td>

<td>Folding parameter for PartKway (for expert ParMETIS users only).</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>CHECK_GRAPH</i></td>

<td NOSAVE>Level of error checking for graph input.: 0 = no checking, 1
= on-processor checking, 2 = full checking (this is very slow and should
only be used during debugging).</td>
</tr>

<tr>
<td VALIGN=TOP><b>Default values:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_METHOD</i> = RepartLDiffusion</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_OUTPUT_LEVEL</i> = 0</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_COARSE_ALG </i>= 2</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_FOLD </i>= 150</td>
</tr>

<tr>
<td></td>

<td><i>CHECK_GRAPH</i> = 1</td>
</tr>

<tr>
<td VALIGN=TOP><b>Required Query Functions:</b></td>

<td></td>
</tr>

<tr>
<td>For all submethods:</td>

<td><b><a href="ug_query_lb.html#LB_NUM_OBJ_FN">LB_NUM_OBJ_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_OBJ_LIST_FN">LB_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#LB_FIRST_OBJ_FN">LB_FIRST_OBJ_FN</a></b>/<b><a href="ug_query_lb.html#LB_NEXT_OBJ_FN">LB_NEXT_OBJ_FN</a></b>
pair</td>
</tr>

<tr>
<td>Only PartGeom &amp; PartGeomKway:</td>

<td><b><a href="ug_query_lb.html#LB_NUM_GEOM_FN">LB_NUM_GEOM_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_GEOM_FN">LB_GEOM_FN</a></b></td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>All but PartGeom:</td>

<td NOSAVE><b><a href="ug_query_lb.html#Graph-based Functions">LB_NUM_EDGES_FN</a></b>
<br><b><a href="ug_query_lb.html#Graph-based Functions">LB_EDGE_LIST_FN</a></b></td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_alg_jostle.html">Next:&nbsp;
Jostle</a>&nbsp; |&nbsp; <a href="ug_alg_irb.html">Previous:&nbsp; Inertial
Recursive Bisection (IRB)</a>]
</body>
</html>
