<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <TITLE>Zoltan User's Guide:  Refinement Tree Based Partition</TITLE>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/ug_header.gif" ALT="Zoltan User's Guide" ></H3></DIV>

<H2>
<A NAME="REFTREE"></A>Refinement Tree Based Partition</H2>
The refinement tree based partitioning method is due to William Mitchell
of the National Institute of Standards and Technology
[<A HREF="ug_refs.html#reftree">Mitchell</A>].
It is closely related to the Octree and Space-Filling Curve methods,
except it uses the tree that represents the adaptive refinement process
that created the grid.  This tree is constructed through the tree-based
query functions.

<P>Each node of the refinement tree corresponds to an element that
occurred during the grid refinement process.  The first level of the tree
(the children of the root of the tree) corresponds to the initial coarse
grid, one tree node per initial element.  The children of a node in the
tree correspond to the elements that were created when the corresponding
element was refined.  The children are ordered such that a traversal of
the tree creates a space-filling curve within each initial element.
If the initial elements can be ordered with a contiguous path through them,
then the traversal creates a space-filling curve through all the elements.
Each element has a designated "in" vertex and "out" vertex, with the out
vertex of one element being the same as the in vertex of the next element
in the path.

<P>The user may allow Zoltan to determine the order of the coarse grid
elements, or may specify the order, which might be faster.  If the user
gives the order, the in/out vertices must also be supplied.  Similarly, the
user may specify the order and in/out vertices of the child elements, or
allow Zoltan to determine them.  If the user knows how to provide a good
ordering for the children, this may be significantly faster than the default
general algorithm.  However, accelerated forms of the ordering algorithm
are provided for certain types of refinement schemes and should be used in
those cases.
See <B><A HREF="ug_query_lb.html#LB_CHILD_LIST_FN">LB_CHILD_LIST_FN</A></B>.
If the user always specifies the order, then the vertices and in/out vertices
are not used and do not have to be provided.

<P>Weights are assigned to the nodes of the tree.  These weights need not be
only on the leaves (the elements of the final grid), but can also be on
interior nodes (for example, to represent work on coarse grids of a multigrid
algorithm).  The default weights are 1.0 at the leaves and 0.0 at the
interior nodes, which equidistributes the number elements over the
partitions.  A tree traversal is used to sum the weights, and a second traversal
to cut the space-filling curve into equal sized pieces and assign elements to
partitions.

<P>The Refinement Tree Partitioning code is
still under development.  The following restrictions should be removed in
the future.
<LI>The user must provide the order of the elements in the initial grid.
<LI>The only refinement type for which accelerated ordering of the children
is provided is bisection of triangles.  Some other special cases may be
added in the future.
<LI>For multicomponent weights, only the first component is used.
<LI>Heterogeneous architectures are not supported, in the sense that the
computational load is equally divided over the processors.
<BR>&nbsp;
<BR>&nbsp;
<TABLE WIDTH="100%" NOSAVE >
<TR>
<TD VALIGN=TOP WIDTH="20%"><B>Method String:</B></TD>

<TD><B>REFTREE</B></TD>
</TR>

<TR>
<TD><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>REFTREE_HASH_SIZE</I></TD>

<TD> The size of the hash table to map from LB_GIDs to refinement tree
nodes.  Larger values require more memory but may reduce search time.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><I>REFTREE_HASH_SIZE</I> = 16384</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Required Query Functions:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_NUM_COARSE_OBJ_FN">LB_NUM_COARSE_OBJ_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_COARSE_OBJ_LIST_FN">LB_COARSE_OBJ_LIST_FN</A></B>
or <B><A HREF="ug_query_lb.html#LB_FIRST_COARSE_OBJ_FN">LB_FIRST_COARSE_OBJ_FN</A></B>/<B><A HREF="ug_query_lb.html#LB_NEXT_COARSE_OBJ_FN">LB_NEXT_COARSE_OBJ_FN</A></B>
pair</TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_NUM_CHILD_FN">LB_NUM_CHILD_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_CHILD_LIST_FN">LB_CHILD_LIST_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#LB_CHILD_WEIGHT_FN">LB_CHILD_WEIGHT_FN</A></B></TD>
</TR>

</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">[<A HREF="ug.html">Table of Contents</A>&nbsp; |&nbsp;
<A HREF="ug_examples.html">Next:&nbsp; Examples of Library Usage</A>&nbsp;
|&nbsp; <A HREF="ug_alg_oct.html">Previous:&nbsp;&nbsp; Octree/Space-Filling
Curve (SFC) Partitioning</A>]
</BODY>
</HTML>
