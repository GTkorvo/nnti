<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <TITLE>Zoltan User's Guide:  Refinement Tree Based Partition</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<div ALIGN=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp; |&nbsp; <a href="ug_alg_parmetis.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_hsfc.html">Previous</a></i></b></div>


<H2>
<A NAME="REFTREE"></A>Refinement Tree Partitioning (REFTREE)</H2>
The refinement tree based partitioning method is due to William Mitchell
of the National Institute of Standards and Technology
[<A HREF="ug_refs.html#reftree">Mitchell</A>].
It is closely related to the Octree and Space-Filling Curve methods,
except it uses the tree that represents the adaptive refinement process
that created the grid.  This tree is constructed through the tree-based
query functions.

<P>Each node of the refinement tree corresponds to an element that
occurred during the grid refinement process.  The first level of the tree
(the children of the root of the tree) corresponds to the initial coarse
grid, one tree node per initial element.  The children of a node in the
tree correspond to the elements that were created when the corresponding
element was refined.  The children are ordered such that a traversal of
the tree creates a space-filling curve within each initial element.
If the initial elements can be ordered with a contiguous path through them,
then the traversal creates a space-filling curve through all the elements.
Each element has a designated "in" vertex and "out" vertex, with the out
vertex of one element being the same as the in vertex of the next element
in the path.

<P>The user may allow Zoltan to determine the order of the coarse grid
elements, or may specify the order, which might be faster.  In the latter case,
the in/out vertices must also be supplied.  Similarly, the
user may specify the order and in/out vertices of the child elements, or
allow Zoltan to determine them.  If the user knows how to provide a good
ordering for the children, this may be significantly faster than the default
general algorithm.  However, accelerated forms of the ordering algorithm
are provided for certain types of refinement schemes and should be used in
those cases.
See <B><A HREF="ug_query_lb.html#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</A></B>.
If the user always specifies the order, then the vertices and in/out vertices
are not used and do not have to be provided.

<P>Weights are assigned to the nodes of the tree.  These weights need not be
only on the leaves (the elements of the final grid), but can also be on
interior nodes (for example, to represent work on coarse grids of a multigrid
algorithm).  The default weights are 1.0 at the leaves and 0.0 at the
interior nodes, which equidistributes the number elements over the
partitions.  An initial tree traversal is used to sum the weights, and a second traversal
to cut the space-filling curve into appropriately-sized pieces and assign
elements to partitions.  The number of partitions is not necessarily equal
to the number of processors.

<P>The Refinement Tree Partitioning code is
still under development.  The following restrictions should be removed in
the future.
<LI>The user must provide the order of the elements in the initial grid.
<LI>The only refinement types for which accelerated ordering of the children
is provided are bisection of triangles and quadrasection of quadrilaterals.
Some other special cases may be added in the future.
<LI>For multicomponent weights, only the first component is used.
<LI>Heterogeneous architectures are not supported, in the sense that the
computational load is equally divided over the processors.  A vector of
relative partition sizes is used to determine the weight assigned to each
partition, but they are currently all equal.  In the future they should
be input to reflect heterogeneity.
<BR>&nbsp;
<BR>&nbsp;
<TABLE WIDTH="100%" NOSAVE >
<TR>
<TD VALIGN=TOP><B>Method String:</B></TD>

<TD><B>REFTREE</B></TD>
</TR>

<TR>
<TD><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>REFTREE_HASH_SIZE</I></TD>

<TD> The size of the hash table to map from global IDs to refinement tree
nodes.  Larger values require more memory but may reduce search time.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Default:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><I>REFTREE_HASH_SIZE</I> = 16384</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Required Query Functions:</B></TD>

<TD></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#ZOLTAN_NUM_COARSE_OBJ_FN">ZOLTAN_NUM_COARSE_OBJ_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#ZOLTAN_COARSE_OBJ_LIST_FN">ZOLTAN_COARSE_OBJ_LIST_FN</A></B>
or <B><A HREF="ug_query_lb.html#ZOLTAN_FIRST_COARSE_OBJ_FN">ZOLTAN_FIRST_COARSE_OBJ_FN</A></B>/<B><A HREF="ug_query_lb.html#ZOLTAN_NEXT_COARSE_OBJ_FN">ZOLTAN_NEXT_COARSE_OBJ_FN</A></B>
pair</TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#ZOLTAN_NUM_CHILD_FN">ZOLTAN_NUM_CHILD_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</A></B></TD>
</TR>

<TR>
<TD></TD>

<TD><B><A HREF="ug_query_lb.html#ZOLTAN_CHILD_WEIGHT_FN">ZOLTAN_CHILD_WEIGHT_FN</A></B></TD>
</TR>

</TABLE>
&nbsp;

<P>
<HR WIDTH="100%">[<A HREF="ug.html">Table of Contents</A>&nbsp; |&nbsp;
<A HREF="ug_alg_parmetis.html">Next:&nbsp; ParMETIS</A>&nbsp;
|&nbsp; <A HREF="ug_alg_hsfc.html">Previous:&nbsp;&nbsp; Hilbert Space-Filling
Curve Partitioning</A>]
</BODY>
</HTML>
