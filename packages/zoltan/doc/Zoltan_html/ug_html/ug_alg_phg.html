<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2smp i686) [Netscape]">
  <meta name="sandia.approved" content="SAND99-1377">
  <meta name="author" content="karen devine, kddevin@sandia.gov">
  <title>Zoltan User's Guide: Hypergraph Partitioning</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
--><!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->
</head>
<body bgcolor="#ffffff">
<div align="right"><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_alg_oct.html">Next</a>&nbsp; |&nbsp; <a
 href="ug_alg_jostle.html">Previous</a></i></b></div>
<h2>
<a name="Hypergraph Partitioning"></a>Hypergraph Partitioning</h2>
Hypergraph partitioning is a useful partitioning and
load balancing method when connectivity data is available. It can be
viewed as a more sophisticated alternative to
the traditional graph partitioning.
<p>A hypergraph consists of vertices and hyperedges. A hyperedge
connects
one or more vertices. A graph is a special case of a hypergraph where
each edge has size two (two vertices). The hypergraph model is well
suited to parallel computing, where vertices correspond to data objects
and hyperedges represent the communication requirements. The basic partitioning 
problem is to partition the vertices into <i>k</i> approximately equal 
sets such that the number of cut hyperedges is minimized. 
Most partitioners (including Zoltan-PHG) allows a more general
model where both vertices and hyperedges can be assigned weights.
It has been
shown that the hypergraph model gives a more accurate representation
of communication cost (volume) than the graph model. In particular,
for sparse matrix-vector multiplication, the hypergraph model
<strong>exactly</strong> represents communication volume. 
Sparse matrices can be partitioned either along rows or columns;
in the row-net model the columns are vertices and each row corresponds 
to an hyperedge, while in the column-net model the roles of vertices 
and hyperedges are reversed.  </p>

<p>Zoltan contains a native parallel hypergraph partitioner, called PHG
(Parallel HyperGraph partitioner). In addition, Zoltan provides
access to <a href="http://bmi.osu.edu/%7Eumit/software.htm">PaToH</a>,
a serial hypergraph partitioner.
Note that PaToH is not part of Zoltan and should be obtained
separately from the <a href="http://bmi.osu.edu/%7Eumit/software.htm">
PaToH web site</a>.
Zoltan-PHG is a fully parallel multilevel hypergraph partitioner. For
further technical description, see <a href="ug_refs.html#hypergraph-ipdps06">[Devine et al, 2006]</a>.<br>
<p>
Planned features currently not supported:<br>
</p>
<ul>
  <li>Adaptive (diffusive) repartitioning</li>
  <li>Multiconstraint partitioning </li>
  <li>2-dimensional (sparse matrix) partitioning </li>
</ul>
&nbsp;
<table nosave="" width="100%">
  <tbody>
    <tr>
      <td valign="top"><b>Method String:</b></td>
      <td><b>HYPERGRAPH</b></td>
    </tr>
    <tr>
      <td><b>Parameters:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">HYPERGRAPH_PACKAGE</span><br>
      </td>
      <td style="vertical-align: top;">PHG (parallel) or PaToH (serial)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
PHG_OUTPUT_LEVEL</span><br>
      </td>
      <td style="vertical-align: top;">Level of verbosity; 0 is silent.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_FINAL_OUTPUT</span><br>
      </td>
      <td style="vertical-align: top;">Print stats about final
partitioning? (0/1)<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><i>&nbsp;&nbsp;&nbsp; PHG_REDUCTION_METHOD</i></td>
      <td>The method to use in matching/coarsening; currently these are
available.&nbsp; <br>
      <span style="font-style: italic;">ipm</span> - inner product
matching (a.k.a. heavy connectivity matching) <br>
      <span style="font-style: italic;">c-ipm</span> -&nbsp; column
ipm;&nbsp; faster method based on ipm within processor columns <br>
      <span style="font-style: italic;">a-ipm </span>- alternate
between c-ipm and ipm <br>
      <i>h-ipm - </i>hybrid ipm that&nbsp; uses partial c-ipm followed
by ipm on each level <br>
      <span style="font-style: italic;">l-ipm </span>-&nbsp; local ipm
on each processor. Fastest option&nbsp; but often gives poor quality. <br>
      <i><br>
      </i></td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">PHG_REDUCTION_LIMIT</span><br>
      </td>
      <td>Number of vertices at which to stop coarsening.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_VERTEX_VISIT_ORDER</span><br>
      </td>
      <td style="vertical-align: top;">Ordering of vertices in greedy
matching scheme:<br>
0 - natural order (as given by the query functions)<br>
1 - random<br>
2 - increasing vertex weights<br>
3 - increasing vertex degree<br>
4 - increasing vertex degree, weighted by pins<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_EDGE_SCALING</span><br>
      </td>
      <td style="vertical-align: top;">Scale edge weights by some
function of size of the hyperedges:<br>
0 - no scaling<br>
1 - scale by 1/(size-1)&nbsp;&nbsp;&nbsp;&nbsp; [absorption scaling]<br>
2 - scale by 2/((size*size-1)) [clique scaling]<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_VERTEX_SCALING</span><br>
      </td>
      <td style="vertical-align: top;">Variations in "inner product"
similarity metric (for matching):<br>
0 - Euclidean inner product: &lt;x,y&gt;<br>
1 - cosine similarity: &lt;x,y&gt;/(|x|*|y|)<br>
2 - &lt;x,y&gt;/(|x|^2 * |y|^2)<br>
3 - scale by vertex weights<br>
      </td>
    </tr>
    <tr>
      <td valign="top">&nbsp;&nbsp;&nbsp; <i>PHG_COARSE_PARTITIONING</i></td>
      <td>Method to partition the coarsest (smallest) hypergraph;
typically done in serial:<br>
      <span style="font-style: italic;">ran</span> - random<br>
      <span style="font-style: italic;">lin</span> - linear<br>
      <span style="font-style: italic;">gr0</span> - greedy method
based on minimizing cuts<br>
      <span style="font-style: italic;">gr1</span> - another greedy
method<br>
      <span style="font-style: italic;">gr2</span> - another greedy
method<br>
      <span style="font-style: italic;">gr3 </span>- another greedy
method<br>
      <span style="font-style: italic;">gr4</span> - another greedy
method<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp; <i>PHG_COARSE_ITERATIONS</i></td>
      <td>Number of times to do coarse partitioning on each processor.
The best is selected.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_REFINEMENT</span><br>
      </td>
      <td style="vertical-align: top;">Refinement algorithm:<br>
      <span style="font-style: italic;">FM2</span> - two-way FM
(approximate)<br>
      <span style="font-style: italic;">None</span> - no refinement<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp; <i>PHG_FM_LOOP_LIMIT</i></td>
      <td>Loop limit in FM refinement. Higher number means more
refinement. <br>
      </td>
    </tr>
    <tr nosave="" valign="top">
      <td>&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">PHG_FM_MAX_NEG_MOVE</span><br>
      </td>
      <td nosave="">Maximum number of negative moves allowed in FM.<br>
      </td>
    </tr>
    <tr nosave="" valign="top">
      <td>&nbsp;&nbsp; <span style="font-style: italic;">PHG_PROC_SPLIT</span><br>
      </td>
      <td nosave="">Split both hypergraph and processors at each level
of
bisection (0/1).<br>
      </td>
    </tr>
    <tr nosave="" valign="top">
      <td>&nbsp;&nbsp; <span style="font-style: italic;">PHG_BAL_TOL_ADJUSTMENT</span><br>
      </td>
      <td nosave="">Controls how the balance tolerance is adjusted at each level of bisection.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp; <span
 style="font-style: italic;">PHG_RANDOMIZE_INPUT</span><br>
      </td>
      <td style="vertical-align: top;">Randomize layout of vertices and
hyperedges in internal parallel 2D layout? (0/1)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp; <a NAME="PHG_EDGE_WEIGHT_OPERATION"></a><span
 style="font-style: italic;">PHG_EDGE_WEIGHT_OPERATION</span>
      </td>
      <td style="vertical-align: top;">Operation to be applied to edge weights supplied by different processes for the same hyperedge:<br>
<i>add</i> - the hyperedge weight will be the sum of the supplied weights<br>
<i>max</i> - the hyperedge weight will be the maximum of the supplied weights<br>
<i>error</i> - if the hyperedge weights are not equal, Zoltan will flag an error, otherwise the hyperedge weight will be the value returned by the processes<br>
      </td>
    </tr>
    <tr nosave="" valign="top">
      <td>&nbsp;&nbsp; <span style="font-style: italic;">EDGE_SIZE_THRESHOLD</span><br>
      </td>
      <td nosave="">Ignore hyperedges greater than this fraction times
number of vertices.<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b>Default values:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><i>HYPERGRAPH_PACKAGE = PHG<br>
      </i></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_OUTPUT_LEVEL=0</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_FINAL_OUTPUT=1</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><i>PHG_REDUCTION_METHOD=ipm</i></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_REDUCTION_LIMIT=100</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_VERTEX_VISIT_ORDER=1</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_EDGE_SCALING=0</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_VERTEX_SCALING=0</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><i>PHG_COARSE_PARTITIONING=gr0</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><i>PHG_COARSE_ITERATIONS=10</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_REFINEMENT=fm2</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><i>PHG_FM_LOOP_LIMIT=10</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_FM_MAX_NEG_MOVE=100</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_PROC_SPLIT=1</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_BAL_TOL_ADJUSTMENT=0.7</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_RANDOMIZE_INPUT=0</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_EDGE_WEIGHT_OPERATION=max</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">EDGE_SIZE_THRESHOLD=0.25</span></td>
    </tr>
    <tr>
      <td valign="top"><b>Required Query Functions:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a
 href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
pair</td>
    </tr>
    <tr nosave="" valign="top">
      <td><br>
      </td>
      <td nosave=""> 
  <b><a href="ug_query_lb.html#ZOLTAN_HG_SIZE_CS_FN">ZOLTAN_HG_SIZE_CS_FN</a></b>
      <br>
  <b><a href="ug_query_lb.html#ZOLTAN_HG_CS_FN">ZOLTAN_HG_CS_FN</a></b>
      </td>
    </tr>
    <tr>
      <td valign="top"><b>Optional Query Functions:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_HG_SIZE_EDGE_WEIGHTS_FN">ZOLTAN_HG_SIZE_EDGE_WEIGHTS_FN</a></b></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_HG_EDGE_WEIGHTS_FN">ZOLTAN_HG_EDGE_WEIGHTS_FN</a></b></td>
    </tr>
</table>
<p>
</p>
<hr width="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a
 href="ug_alg_jostle.html">Next:&nbsp;
Jostle</a>&nbsp; |&nbsp; <a href="ug_alg_reftree.html">Previous:&nbsp;
Refinement Tree Partitioning</a>]
</body>
</html>
