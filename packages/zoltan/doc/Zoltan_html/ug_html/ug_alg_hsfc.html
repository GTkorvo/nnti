<!-----------------------------------------------------------------------------
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  HSFC</title>
</head>
<body bgcolor="#FFFFFF">

<div ALIGN=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp; |&nbsp; <a href="ug_alg_reftree.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_jostle.html">Previous</a></i></b></div>


<h2>
<a NAME="HSFC"></a>Hilbert Space Filling Curve (HSFC)</h2>
This partitioning algorithm is based on the 2D & 3D Inverse Hilbert
Space-Filling Curve code developed by H. Carter Edwards and on the BSFC
partitioning implementation by Andrew C. Bauer, Department of Engineering, Buffalo, as his summer project 2001.
<p>
The smallest coordinate-aligned bounding box is created enclosing the
computational domain.  The computational domain is then mapped to the unit
square (2D) or unit cube (3D).  Carter's algorithm calculates the Inverse
Hilbert coordinate (scaled to the unit interval) for each computational object,
"dot".  Each dot has a weight (default is unity if unassigned).  The HSFC
partitioning algorithm divides [0,1] into N intervals containing approximately
equal weights where N is the number of processors.  (The code is designed to
allow user-specified unequal weights per interval for future use.)
<p>
The main loop is executed nominally log(total number of dots) times.  For each
loop, [0,1] is divided into K(N-1)+1 intervals, called the grand partition.  K
is a small positive integer (currently 8).  The first loop begins with an
equally spaced grand partition.  The weight of each dot is locally summed into
the appropriate interval of the grand partition using a binary search on its
Inverse Hilbert coordinate.  The global weight contained in each interval of
the grand partition is computed and distributed to each processor.  A new N
piece partition is created by summing the weights of contiguous intervals of
the grand partition until the weight contained in the new interval is
as large as possible without exceeding the target weight.  The resulting
partition is then refined into a new grand partition.  The refinement takes
each interval (from the previous grand partition) that would have caused
overfilling and divides this interval into K-1 new pieces.
<p>
After the final loop, a slightly different greedy algorithm is used to create
the final partition from the last grand partition.  This algorithm similarly
sums the weights assigned to contiguous intervals of the grand algorithm.
However, it determines if the tolerance is best met by underfilling or
overfilling each interval of the final partition.  The target weights for the
remaining intervals are adjusted to compensate for the actual weight assigned
upto and including this current interval.
<p>
The Zoltan implementation of HSFC has one parameter that can be modified
by the <b><a href="ug_interface_lb.html#LB_Set_Param">LB_Set_Param</a></b>
function.
<br>&nbsp;
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP><b>Method String:</b></td>

<td><b>HSFC</b></td>
</tr>

<tr>
<td><b>Parameters:</b></td>

<td></td>
</tr>



<tr>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;<i> KEEP_CUTS</i></td>

<td>Information about cuts is necessary
if application wants to add more objects to the decomposition via calls
to <b><a href="ug_interface_augment.html#LB_Point_Assign">LB_Point_Assign</a></b>
or to <b><a href="ug_interface_augment.html#LB_Box_Assign">LB_Box_Assign</a></b>.&nbsp;
<br>0 = don't keep cuts; 1 = keep cuts.</td>
</tr>


<tr>
<td VALIGN=TOP><b>Default:</b></td>

<td></td>
</tr>


<tr>
<td></td>

<td><i>KEEP_CUTS</i> = 0</td>
</tr>


<tr>
<td VALIGN=TOP><b>Required Query Functions:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_NUM_OBJ_FN">LB_NUM_OBJ_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_OBJ_LIST_FN">LB_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#LB_FIRST_OBJ_FN">LB_FIRST_OBJ_FN</a></b>/<b><a href="ug_query_lb.html#LB_NEXT_OBJ_FN">LB_NEXT_OBJ_FN</a></b>
pair</td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_NUM_GEOM_FN">LB_NUM_GEOM_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#LB_GEOM_FN">LB_GEOM_FN</a></b></td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | 
<a href="ug_alg_reftree.html">Next:&nbsp; Refinement Tree Based Partitioning</a>
|&nbsp; <a href="ug_alg_jostle.html">Previous:&nbsp; Jostle</a>]
</body>
</html>
