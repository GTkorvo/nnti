<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  HSFC</title>
</head>
<body bgcolor="#FFFFFF">

<div ALIGN=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp; |&nbsp; <a href="ug_alg_reftree.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_rib.html">Previous</a></i></b></div>


<h2>
<a NAME="HSFC"></a>Hilbert Space Filling Curve (HSFC)</h2>
This partitioning algorithm is based on the 2D & 3D Inverse Hilbert
Space-Filling Curve code developed by H. Carter Edwards and on the BSFC
partitioning implementation by Andrew C. Bauer, Department of Engineering, State University
of New York at Buffalo, as his summer project at SNL in 2001.
<p>
The Inverse Hilbert Space-Filling Curve routines by H. Carter Edwards map a point in
two or three dimensions into the interval [0,infinity).  This implementation further
scales the Inverse Hilbert coordinate to a double precision floating point
number in the unit interval [0,1].  This algorithm is designed to work for one,
two, or three
dimensional problems.  (The one-dimensional inverse Hilbert curve is defined here
as the identity function, f(x)=x for all x).
<p>
The algorithm seeks to divide [0,1] into P intervals each containing
the same weight of objects associated to these intervals by their inverse Hilbert
coordinates. N bins are created (where N > P) to partition [0,1].  The weights in
each bin are summed across all processors.
A greedy algorithm sums the bins (from left to right) placing a cut when the desired weight
for current partition interval is achieved.
This process is repeated as needed to improve partitioning tolerance by
a technique that maintains the same total number of bins but refines the bins previously
containing a cut.
<p>
This code returns an error if the final imbalance exceeds the user specified tolerance.
<p>
This code implements both the point assign and box assign functionality.  The point
assign determines an appropriate partition interval (associated with a specific processor)
for a new point.   The box assign determines the list of processors
whose associated subdomains intersect the given box.  In order to
use either of these routines, the user parameter KEEP_CUTS must be turned on.
NOTE: At this time neither point assign nor box assign can be used to add points beyond
the original bounding box. An error is returned when this is attempted.
<p>
The Zoltan implementation of HSFC has one parameter that can be modified
by the <b><a href="ug_interface_lb.html#Zoltan_Set_Param">Zoltan_Set_Param</a></b>
function.
<br>&nbsp;
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP><b>Method String:</b></td>

<td><b>HSFC</b></td>
</tr>

<tr>
<td><b>Parameters:</b></td>

<td></td>
</tr>



<tr>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;<i> KEEP_CUTS</i></td>

<td>Information about cuts is necessary
if the application wants to add more objects to the decomposition via calls
to <b><a href="ug_interface_augment.html#Zoltan_LB_Point_Assign">Zoltan_LB_Point_Assign</a></b>
or to <b><a href="ug_interface_augment.html#Zoltan_LB_Box_Assign">Zoltan_LB_Box_Assign</a></b>.&nbsp;
<br>0 = don't keep cuts; 1 = keep cuts.</td>
</tr>


<tr>
<td VALIGN=TOP><b>Default:</b></td>

<td></td>
</tr>


<tr>
<td></td>

<td><i>KEEP_CUTS</i> = 0</td>
</tr>


<tr>
<td VALIGN=TOP><b>Required Query Functions:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
pair</td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_GEOM_FN">ZOLTAN_NUM_GEOM_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_GEOM_FN">ZOLTAN_GEOM_FN</a></b></td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | 
<a href="ug_alg_reftree.html">Next:&nbsp; Refinement Tree Partitioning</a>
|&nbsp; <a href="ug_alg_rib.html">Previous:&nbsp; Recursive Inertial Bisection</a>]
</body>
</html>
