<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  Initialization Interface</title>
<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>
</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_interface_lb.html">Next</a>&nbsp; |&nbsp; <a href="ug_interface.html">Previous</a></i></b></div>

<h2>
<a NAME="Initialization Functions"></a>Initialization Functions</h2>
Functions used to initialize the library and load-balancing data structures
are described below:
<ul><a href="#LB_Initialize">LB_Initialize</a>
<br><a href="#LB_Create">LB_Create</a>
<br><a href="#LB_Set_Fn">LB_Set_Fn</a>
<br><a href="#LB_Set_Specific_Fn">LB_Set_&lt;<i>lb_fn_type</i>>_Fn</a></ul>

<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td><a NAME="LB_Initialize"></a>int <b>LB_Initialize</b>
(int&nbsp;<i>argc</i>,
char&nbsp;**<i>argv</i>,
float&nbsp;*<i>ver</i>);</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>LB_Initialize</b>( <i>argc</i>, <i>argv</i>,
<i>ver</i>)&nbsp;
<br>INTEGER(LB_INT) :: LB_Initialize&nbsp;
<br>INTEGER(LB_INT), INTENT(IN), OPTIONAL :: argc&nbsp;
<br>CHARACTER(LEN=*), DIMENSION(*), INTENT(IN), OPTIONAL :: argv&nbsp;
<br>REAL(LB_FLOAT), INTENT(OUT) :: ver&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">The <b>LB_Initialize</b> function initializes values needed
in the load-balancing tools. If the application uses MPI, this function
should be called after calling <b>MPI_Init</b>. If the application does
not use MPI, this function calls <b>MPI_Init</b> for use by the load balancer.
This function is called with the <i>argc</i> and <i>argv</i> command-line
arguments from the main program, which are used if <b>LB_Initialize</b>
calls <b>MPI_Init</b>. From C,&nbsp; if <b>MPI_Init</b> has already been
called, the <i>argc</i> and <i>argv</i> arguments may have any value because
their values will be ignored.&nbsp; From Fortran, if one of <i>argc</i>
or <i>argv</i> is omitted, they must both be omitted. If they are omitted,
<i>ver</i>
does NOT have to be passed as a keyword argument.
<p><b>LB_Initialize</b> returns the version of the dynamic load-balancing
library so that users can verify which version of the library their application
is linked to.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td WIDTH="20%"><b>Parameters:</b></td>

<td>&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; argc</i></td>

<td>The number of command-line arguments to the application.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; argv</i></td>

<td>An array of strings containing the command-line arguments to the application.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ver</i></td>

<td>The version number of the library.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td VALIGN=TOP><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>
</table>

<p>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td><a NAME="LB_Create"></a>struct <b>LB_Struct</b> *<b>LB_Create</b>
(MPI_Comm&nbsp;<i>communicator</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>LB_Create</b>(<i>communicator</i>)&nbsp;
<br>TYPE(LB_Struct), pointer :: LB_Create&nbsp;
<br>INTEGER, INTENT(IN) :: communicator&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">The <b>LB_Create</b> function allocates memory for storage
of load-balancing information to be used by the load-balancing library
and sets the default values for the load- balancing information. The pointer
returned by this function is passed to many subsequent load-balancing functions.
An application may allocate more than one <b>LB_Struct</b> data structure
if, say, it uses different decompositions with different load-balancing
techniques.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; communicator</i></td>

<td>The MPI communicator to be used for this load-balancing structure.
Only those processors included in the communicator participate in load
balancing. If all processors currently used by the application are to participate
in load balancing, communicator should be <b>MPI_COMM_WORLD</b> .</td>
</tr>

<tr>
<td><b>Returned Value:&nbsp;</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; struct <b>LB_Struct</b> *</td>

<td>Pointer to memory for storage of load-balancing information. If an
error occurs, NULL will be returned in C, or the result will be a nullified
pointer in Fortran. Any error that occurs in this function is assumed to
be fatal.</td>
</tr>
</table>

<p>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td><a NAME="LB_Set_Fn"></a>int <b>LB_Set_Fn</b>
(struct&nbsp;<b>LB_Struct&nbsp;*</b><i>lb</i>,
<b>LB_FN_TYPE&nbsp;</b><i>fn_type</i>,
void&nbsp;(*<i>fn_ptr</i>)(),
void&nbsp;*<i>data</i>);</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>LB_Set_Fn</b>(<i>lb, fn_type, fn_ptr, data</i>)&nbsp;
<br>INTEGER(LB_INT) :: LB_Set_Fn&nbsp;
<br>TYPE(LB_Struct), INTENT(IN) :: lb&nbsp;
<br>TYPE(LB_Fn_Type), INTENT(IN) :: fn_type&nbsp;
<br>EXTERNAL :: fn_ptr&nbsp;
<br>&lt;<i>type-data</i>>, OPTIONAL :: data&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>LB_Set_Fn</b> registers an application-supplied query
function in the load-balancing structure. Both load-balancing and migration
functions can be registered through calls to <b>LB_Set_Fn</b>.&nbsp; To
register functions while maintaining strict type-checking of the <i>fn_ptr</i>
argument, see <b><a href="#LB_Set_Specific_Fn">LB_Set_&lt;<i>lb_fn_type</i>>_Fn</a></b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; lb</i></td>

<td>Pointer to the load-balancing structure created by
<b><a href="#LB_Create">LB_Create</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; fn_type</i></td>

<td>The type of function being registered; see <a href="ug_query.html#Application-Registered Query Functions">Application-Registered
Query Functions</a> for possible function types.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; fn_ptr</i></td>

<td>A pointer to the application-supplied query function being registered.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>A pointer to user defined data that will be passed, as an argument,
to the function pointed to by <i>fn_ptr</i>. In C it may be NULL. In Fortran
it may be omitted.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>
</table>

<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td><a NAME="LB_Set_Specific_Fn"></a>int <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>
(struct&nbsp;<b>LB_Struct&nbsp;</b>*<i>lb</i>,
&lt;<b><i><a href="ug_query.html">lb_fn_type</a></i></b>>&nbsp;(*<i>fn_ptr</i>)(), 
void&nbsp;*<i>data</i>);</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>(<i>lb, fn_ptr, data</i>)&nbsp;
<br>INTEGER(LB_INT) :: LB_Set_&lt;<i><a href="ug_query.html">lb_fn_type</a></i>>_Fn&nbsp;
<br>TYPE(LB_Struct), INTENT(IN) :: lb&nbsp;
<br>EXTERNAL :: fn_ptr&nbsp;
<br>&lt;<i>type-data</i>>, OPTIONAL :: data&nbsp;
<p> An interface block for <i>fn_ptr</i> is included in the FUNCTION definition 
so that strict type-checking of the registered query function can be done.
<p>&lt;<i>type-data</i>> can be any of INTEGER(LB_INT), DIMENSION(*) or
REAL(LB_FLOAT), DIMENSION(*) or REAL(LB_DOUBLE), DIMENSION(*) or TYPE(LB_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">The interface functions <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>,
where <b>&lt;<i><a href="ug_query.html">lb_fn_type</a></i>></b> is one
of the query function types, register specific types of <a href="ug_query.html">application-supplied
query functions</a> in the load-balancing structure. One interface function
exists for each type of query function.&nbsp; For example, <b>LB_Set_Num_Geom_Fn</b>
registers a query function of type <b><a href="ug_query_lb.html#LB_NUM_GEOM_FN">LB_NUM_GEOM_FN</a></b>.&nbsp;
Each load-balancing and migration query function has an associated <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>.&nbsp;
A complete list of these functions is included in <i>lb/lbi_const.h.</i>
<p>Query functions can be registered using either <b><a href="#LB_Set_Fn">LB_Set_Fn</a></b>
or <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>.
<br><b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn </b>provides strict type checking
of the <i>fn_ptr</i> argument; the argument's type is specified for each
<b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>.&nbsp;
<b><a href="#LB_Set_Fn">LB_Set_Fn</a></b> does not provide this strict
type checking, as the pointer to the registered function is cast to a void
pointer.
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; lb</i></td>

<td>Pointer to the load-balancing structure created by
<b><a href="#LB_Create">LB_Create</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; fn_ptr</i></td>

<td>A pointer to the application-supplied query function being registered.&nbsp;
The type of the pointer matches &lt;<b><i><a href="ug_query.html">lb_fn_type</a></i></b>>
in the name <b>LB_Set_&lt;<i>lb_fn_type</i>>_Fn</b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>A pointer to user defined data that will be passed, as an argument,
to the function pointed to by fn_ptr. In C it may be NULL. In Fortran it
may be omitted.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>

<tr>
<td><b>Example:</b></td>

<td></td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE></td>

<td VALIGN=TOP NOSAVE>The interface function
<br>&nbsp;&nbsp;&nbsp; int <b>LB_Set_Geom_Fn</b>(struct <b>LB_Struct</b>
*lb, <b><a href="ug_query_lb.html#LB_GEOM_FN">LB_GEOM_FN</a></b> (*fn_ptr)(),
void *data);
<br>registers an <b><a href="ug_query_lb.html#LB_GEOM_FN">LB_GEOM_FN</a></b>
query function.</td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_interface_lb.html">Next:&nbsp;
Load-Balancing Functions</a>&nbsp; |&nbsp; <a href="ug_interface.html">Previous:&nbsp;
Zoltan Interface Functions</a>]
</body>
</html>
