%!
%%Title: Sandia National Laboratories - Zoltan User's Guide
%%Creator: html2ps version 1.0 beta1
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 470 F div D
/IL 620 F div D
/PS 791 D
/EF [0 1 2 2 2 2 2 2 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [11 9 19 16 16 14 14 12 11 11 11 11 11 11 11 11 11 11 11 11 11 11 8 8] D
/Ey [0 0 2 2 3 2 3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [3 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{Ti}{h}][{h}{Au}][{()}{()}]] D
/ZZ [[{()}1][{()}0][{(- ) Pn join( -)join}2]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf f D
/Fe f D
/TI 1 Ts mul D
/FE {newpath -14 14 M CP BB 484 14 L 484 -634 L CP BB -14 -634 L closepath} D
/LA {TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {71 706 translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M TF not Tc or
 {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if Df{Sd}if}if} D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf t D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb f D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.2 D
/DX (DRAFT) D
/Di 0 D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /hL 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW 1 setlinejoin
 FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D /cf CF D /CF 0 D
 /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add get D Fz Fs FS ZZ
 Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie
 IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh 0 IL neg YO sub M
 ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div IL neg YO sub M Sh
 Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie
 YY Fc /FN EF Hf get D Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh
 0 YO M YY 0 GP exec Sh YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh
 /FN Fn D /AT At D t Pb XO SZ SL get neg R /PF pf D grestore /CF 0 D cs cf FS}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{/Symbol}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {HI 0 gt{(h) HI ST cvs join cvx exec dup 1 get E
 Nf{0 get E join}{pop}ie}{()}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /hL HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if Ts 2 div lt or
 NL /LF E D SI BL} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /AF t D /C1 C1 ( Cp ) join D
 Lc{Cl Sc}if} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Ti () D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{NP}if}D
/Ep {Xp PN 2 mod 0 eq and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL}
 {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL}
 {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()Sm BX} D
/BX {/Bt E D Bt 2 lt{CS 0.8 mul}{11 mul}ie W XO sub MR sub 2 copy gt{E}if pop
 /HZ E D WB Bt 2 eq{HZ ST cvs ( ) join}{()}ie
 Bt ST cvs join ( Bx ) join HM{( ) Pd}if
 L1 HZ add XO add MR add W gt{NL}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) WB Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{/Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D} D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\253\240)(\232)(\234)(\233)(\253)(\273)][(\253\240)(\231)(')(`)(\253)(\273)]] D
/QC [[(\240\273)(\233)(\234)(\234)(\273)(\253)][(\240\273)(`)(')(')(\273)(\253)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/hL 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 3 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta1) /Author () /Keywords (Zoltan, dynamic, load, balancing, parallel, computing) /Subject (Zoltan User)
 /Title (Sandia National Laboratories - Zoltan User's Guide) /DOCINFO pdfmark
/ND 22 D
/HN [1 1 176{pop (??)}for] D
/h1 [(0.0.1\240\240)(Zoltan User's Guide )] D
/h2 [(0.1\240\240)(Introduction)] D
/h3 [(0.2\240\240)(Load-Balancing Tools)] D
/h4 [(0.3\240\240)(Migration-Help Tools)] D
/h5 [(0.3.1\240\240)(Zoltan User's Guide )] D
/h6 [(0.4\240\240)(Using the Library)] D
/h7 [(0.4.1\240\240)(Application Data Types)] D
/h8 [(0.4.2\240\240)(Building the Library)] D
/h9 [(0.4.3\240\240)(Building Applications)] D
/h10 [(0.4.4\240\240)(Zoltan User's Guide )] D
/h11 [(0.5\240\240)(Zoltan Interface Functions)] D
/h12 [(0.6\240\240)(Error Codes)] D
/h13 [(0.6.1\240\240)(Zoltan User's Guide )] D
/h14 [(0.7\240\240)(Initialization Functions)] D
/h15 [(0.7.1\240\240)(Zoltan User's Guide )] D
/h16 [(0.8\240\240)(Load-Balancing Functions)] D
/h17 [(0.8.1\240\240)(Zoltan User's Guide )] D
/h18 [(0.9\240\240)(Functions for Augmenting a Decomposition)] D
/h19 [(0.9.1\240\240)(Zoltan User's Guide )] D
/h20 [(0.10\240\240)(Migration-Help Functions)] D
/h21 [(0.10.1\240\240)(Zoltan User's Guide )] D
/h22 [(0.11\240\240)(Application-Registered Query Functions)] D
/h23 [(0.11.1\240\240)(Zoltan User's Guide )] D
/h24 [(0.12\240\240)(Load-Balancing Query Functions)] D
/h25 [(0.13\240\240)(General Functions)] D
/h26 [(0.14\240\240)(Geometry-based Functions)] D
/h27 [(0.15\240\240)(Graph-based Functions)] D
/h28 [(0.15.1\240\240)(Zoltan User's Guide )] D
/h29 [(0.16\240\240)(Migration-Help Query Functions)] D
/h30 [(0.16.1\240\240)(Zoltan User's Guide )] D
/h31 [(0.17\240\240)(Algorithms)] D
/h32 [(0.17.1\240\240)(Zoltan User's Guide )] D
/h33 [(0.18\240\240)(Recursive Coordinate Bisection \201RCB\202)] D
/h34 [(0.18.1\240\240)(Zoltan User's Guide )] D
/h35 [(0.19\240\240)(ParMETIS)] D
/h36 [(0.19.1\240\240)(Zoltan User's Guide )] D
/h37 [(0.20\240\240)(Octree/Space-Filling Curve \201SFC\202 Partitioning)] D
/h38 [(0.20.1\240\240)(Zoltan User's Guide )] D
/h39 [(0.21\240\240)(Examples of Library Usage)] D
/h40 [(0.21.1\240\240)(Zoltan User's Guide )] D
/h41 [(0.22\240\240)(Initialization Example)] D
/h42 [(0.22.1\240\240)(Zoltan User's Guide )] D
/h43 [(0.23\240\240)(Load-Balancing Example)] D
/h44 [(0.23.1\240\240)(Zoltan User's Guide )] D
/h45 [(0.24\240\240)(Migration Examples)] D
/h46 [(0.25\240\240)(Auto-Migration Example)] D
/h47 [(0.26\240\240)(User-Guided Migration Example)] D
/h48 [(0.26.1\240\240)(Zoltan User's Guide )] D
/h49 [(0.27\240\240)(Query-Function Examples)] D
/h50 [(0.27.1\240\240)(Load-Balancing Query Function Examples)] D
/h51 [(0.27.1.1\240\240)(Basic Example)] D
/h52 [(0.27.1.2\240\240)(User-Defined Local Identifiers Example)] D
/h53 [(0.27.1.3\240\240)(User-Defined Data Pointer Example)] D
/h54 [(0.27.2\240\240)(Migration-Help Examples)] D
/h55 [(0.27.2.1\240\240)(Packing and Unpacking Data)] D
/h56 [(0.27.3\240\240)(Zoltan User's Guide )] D
/h57 [(0.28\240\240)(Future Work)] D
/h58 [(0.28.1\240\240)(Zoltan User's Guide )] D
/h59 [(0.29\240\240)(References)] D
/Hr [-44 -44 44 45 46 47 -53 -53 53 54 55 56 57 -64 -64 64 65 66 -70 -70
70 71 -83 -83 83 84 -87 -87 87 88 -98 -98 98 99 -101 -101 101 102 -109 -109
109 110 111 112 113 -115 -115 115 116 -119 -119 119 120 -122 -122 122 123
-125 -125 125 126 -134 -134 134 135 -136 -136 136 137 -139 -139 139 140
-142 -142 142 143 -147 -147 147 148 149 150 -159 -159 159 160 161 162 163
164 165 166 -168 -168 168 169 -174 -174 174 175]D
/HV [1 2 3 2 2 2 1 2 3 2 3 3 3 1 2 3 2 2 1 2 3 2 1 2 3 2 1 2 3 2 1 2 3
2 1 2 3 2 1 2 3 2 2 2 2 1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2
1 2 3 2 1 2 3 2 1 2 3 2 2 2 1 2 3 2 3 4 4 4 3 4 1 2 3 2 1 2 3 2]D
/Cn [4 1 0 0 0 0 2 1 0 3 0 0 0 3 1 0 0 0 2 1 0 0 2 1 0 0 2 1 0 0 2 1 0
0 2 1 0 0 5 1 0 0 0 0 0 2 1 0 0 2 1 0 0 2 1 0 0 2 1 0 0 2 1 0 0 2 1 0 0
2 1 0 0 2 1 0 0 4 1 0 0 0 0 2 1 0 2 3 0 0 0 1 0 2 1 0 0 2 1 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec dup 1 get
 E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie /Title E /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (http://www.sandia.gov/Main.html) D
/R2 (http://www.sandia.gov/About.htm) D
/R3 (http://www.sandia.gov/Solution.htm) D
/R4 (http://www.sandia.gov/Working.htm) D
/R5 (http://www.sandia.gov/Contacting.htm) D
/R6 (http://www.sandia.gov/News.htm) D
/R7 (http://www.sandia.gov/search.html) D
/R8 (http://www.cs.sandia.gov/~kddevin) D
/R9 (http://www.cs.sandia.gov/~bahendr) D
/R10 (http://www-users.cs.umn.edu/~karypis/metis/parmetis/) D
/R11 (http://sherpa.sandia.gov/9231home/alegra/alegra-frame.html) D
/R12 (http://www.cs.sandia.gov/CRF/MPSalsa/) D
/R13 (http://www.gre.ac.uk/~c.walshaw/jostle/) D
/TS {
 tables E get /table E D
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D pop pop
 /w W D /eps 0.1 D /OU f D /PL 1 D
 /FN EF 21 get D EZ 21 get Ey 21 get FS
 0 1 1{
  /pass E D
  0 1 nrow{
   /irow E D
   /cells rdesc irow get 6 get D
   0 1 ncol{
    /icol E D
    /cell cells icol get D
    cell 0 ne{
     cell aload pop /CB E D pop pop pop
     /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
     /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
     /cmin E D /proc E D
     rspan 0 eq{/rspan nrow irow sub 1 add D}if
     cspan 0 eq{/cspan ncol icol sub 1 add D}if
     pass 0 eq cspan 1 eq and pass 1 eq cspan 1 gt and or{
      /W 1e5 D /LL W D /PH 1 D
      ctype 1 eq{() BD}if
      RC align NA
      AT 4 eq{/CD t D /DC dp D /LN 0 D /M1 0 D /M2 0 D}{/CD f D}ie
      0 0 M /LM 0 D proc exec BN
      AT 4 eq{
       LN array astore cell 15 3 -1 roll put
       cdesc icol get dup dup 5 get M1 lt{5 M1 put}{5 get /M1 E D}ie
       dup 6 get M2 lt{6 M2 put}{6 get /M2 E D}ie
       /LM M1 M2 add D
      }if
      /CD f D
      /thiswid LM left add right add eps add D
      /oldmin 0 D /oldmax 0 D
      0 1 cspan 1 sub{
       icol add cdesc E get dup 2 get /oldmax E oldmax add D
       1 get /oldmin E oldmin add D
      }for
      thiswid oldmax ge{
       0 1 cspan 1 sub{
        icol add cdesc E get dup 2 E 2 get oldmax 0 eq
         {pop thiswid cspan div}{thiswid mul oldmax div}ie
        put
       }for
      }if
      nowrap 1 eq{
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }{
       /W 0 D /LL W D /PH 2 D
       ctype 1 eq{() ES () BD}if
       0 0 M /LM 0 D RC proc exec BN
       /thiswid LM left add right add eps add D
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }ie
      ctype 1 eq{() ES}if
     }if
    }if
   }for
  }for
 }for
 /tmin 0 D /tmax 0 D
 0 1 ncol{
  cdesc E get dup 1 get E 2 get 2 copy gt{pop dup}if
  tmax add /tmax E D tmin add /tmin E D
 }for
 twid 0 lt{twid neg IW gt{IW neg}{twid}ie /twid E D}if
 tdesc 0 twid neg tmin 2 copy lt{E}if pop put
 tdesc 1 twid neg tmax 2 copy lt{E}if pop put
 /W w D /LL W D /OU t D /PH 0 D /PL 0 D
} D
/PT {
 /PL PL 1 add D
 tables E get /table E D Tm 21 get Ts mul BE
 PL 2 ge{save}if
 /SL SL 1 add D /FN EF 21 get D EZ 21 get Ey 21 get FS
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D /tmax E D /tmin E D
 /w W D /xo XO D /mr MR D /ll LL D /lg LG D /ai AI D /bc BC D /nr NR D /ar AR D
 /tr TR D /ui UI D /ph PH D /a0 A0 D /pf PF D /at AT D /av AV D /al AL D
 /Le LE D /la La D
 talign 0 lt{/talign AL 0 gt{AV AL get}{A0 2 le{A0}{0}ie}ie D}if
 ph 1 eq ph 2 eq or{
  NL ph 1 eq{tmax}{tmin}ie dup XO add LM gt{/LM E XO add D}{pop}ie LM E
 }{
  /PH 3 D /LE 1e5 D RC %ZF
  border 0 gt{/border 1 D}if
  /twidth 0 D /avail W xo sub D
  twid 0 eq{0 1 ncol{cdesc E get dup 2 get E 3 get dup 0 gt{div neg dup twid lt
   {/twid E D}{pop}ie}{pop pop}ie}for}if
  /twid twid dup 0 lt{neg avail 2 copy gt{E}if pop}{avail mul}ie D
  /OK t D 0 1 ncol{cdesc E get dup 1 get E 3 get twid mul gt{/OK f D}if}for
  0 1 ncol{
   cdesc E get dup 1 get /colmin E D dup 3 get /cwid E twid mul D dup
   tmax avail le{2 get}if
   tmin avail le tmax avail gt and{
    dup 2 get E 1 get dup 3 1 roll sub avail tmin sub mul tmax tmin sub div add
   }if
   tmin avail gt{1 get}if
   0 E colmin cwid lt OK and{pop cwid}if dup /twidth E twidth add D put
  }for
  /OU f D CP
  tmin twid le{
   0 1 ncol{cdesc E get dup 0 get twidth div twid mul 0 E put}for
   /twidth twid D
  }if
  CP printcap CP E pop sub /caphig E D pop
  0 1 1{
   /pass E D
   0 1 nrow{
    /irow E D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      cell aload pop /CB E D pop pop pop
      /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
      /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
      /cmin E D /proc E D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /W 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /W E W add D}for
      pass 0 eq rspan 1 eq and pass 1 eq rspan 1 gt and or{
       ctype 1 eq{() BD}if
       /W W left sub right sub D /XO 0 D /EO 0 D SI
       /A0 align D RC align NA
       AT 4 eq{
        /DC dp D /DO 0 D /ID 1 D
        0 1 DV length 1 sub{DV E get dup DO gt{/DO E D}{pop}ie}for
        /Lo DO DV 0 get sub D /L1 Lo D
       }if
       0 0 M /BP t D /Fl t D /MF 0 D /FB 0 D
       proc exec T not{/CI 0 D}if BN 0 FB neg R MF 0 eq{/MF CS D}if
       CP /thishig E neg bot add top add CI add D pop
       cell 16 MF put cell 17 Ya put cell 18 thishig put
       valign 4 eq{
        /below thishig Ya sub D
        rdesc irow get dup dup 4 get Ya lt
         {4 Ya put}{4 get /Ya E D}ie
        dup 5 get below lt{5 below put}{5 get /below E D}ie
        /thishig Ya below add D
       }if
       ctype 1 eq{()ES}if
       /oldhig 0 D
       0 1 rspan 1 sub{
        irow add rdesc E get 0 get /oldhig E oldhig add D
       }for
       thishig oldhig ge{
        0 1 rspan 1 sub{
         irow add rdesc E get dup 0 E 0 get oldhig 0 eq
          {pop thishig rspan div}{thishig mul oldhig div}ie
         put
        }for
       }if
      }if
     }if
    }for
   }for
  }for M RC %ZF
  /thight 0 D /racc 0 D /maxh 0 D /brk 0 D /rbeg nhead nfoot add D
  rbeg 1 nrow{
   rdesc E get dup 0 get dup /thight E thight add D
   brk 0 eq{/racc E D}{/racc E racc add D}ie
   racc maxh gt{/maxh racc D}if 2 get /brk E D
  }for
  ph 3 ge{thight caphig add E}if
  ph 0 eq ph 4 eq or{
   /PH 4 D /LE Le D /OU Ou D /yoff 0 D /headsz 0 D
   0 1 nhead 1 sub{rdesc E get 0 get headsz add /headsz E D}for
   /footsz 0 D
   0 1 nfoot 1 sub{rdesc E nhead add get 0 get footsz add /footsz E D}for
   /ahig LE BO add MI add D /maxh maxh headsz add footsz add D
   /thight thight headsz add footsz add D
   tmin avail gt maxh ahig gt or
    {/Sf avail tmin div dup ahig maxh div gt{pop ahig maxh div}if D /SA t D}
    {/Sf 1 D}ie
   tclass 1 eq thight LE 15 sub gt and
    {/SA t D LE 15 sub thight div dup Sf lt{/Sf E D}{pop}ie}if
   SA{Sf Sf scale /ll ll Sf div D /xo xo Sf div D /LE LE Sf div D
    /mr mr Sf div D /BO BO Sf div D /ahig ahig Sf div D}if
   nhead nfoot add getwid
   LE CP E pop add capalg 0 eq{caphig sub}if dup headsz sub footsz sub rwid lt
   E thight lt thight ahig lt and or{NP}if
   capalg 0 eq{printcap -8 SP}if
   CP /ycur E D pop
   printhead
   rbeg 1 nrow{/row E D row
    getwid
    ycur yoff add rwid sub footsz sub LE add 0 lt
    {nfoot 0 gt{printfoot}if Tf NP /rbeg irow1 D
     Ba{MI /MI MI SA{Sf div}if D MI SP /MI E D}if
     CP /ycur E D pop /yoff 0 D printhead}if
    irow1 printrow
   }for
   printfoot /row row 1 add D Tf
   0 ycur yoff add M
   capalg 1 eq{/EO 0 D SI -3 SP printcap}if
   Sf 1 lt{1 Sf div dup scale /ll ll Sf mul D /xo xo Sf mul D /LE LE Sf mul D
    /mr mr Sf mul D /BO BO Sf mul D /SA f D}if
   /EO 0 D
  }if
 }ie
 /W w D /XO xo D /MR mr D /LL ll D /LG lg D /AI ai D /BC bc D /NR nr D /AR ar D
 /TR tr D /UI ui D /PH ph D /A0 a0 D /PF pf D /AT at D /AV av D /AL al D
 /La la D
 /SL SL 1 sub NN D /CF 0 D /FN 0 D SZ SL get FR SL get FS Wf not{()F2}if
 PL 2 ge{Ms E restore Ms or /Ms E D PH 1 eq PH 2 eq or
  {/LM E D}if PH 3 ge{/CI 0 D NL 0 E neg R}if
 }if
 /PL PL 1 sub D /CI 0 D /BP f D /PO f D () Bm 21 get Ts mul BE BL %CF CS SF
} D
/printcap{
 capalg 0 ge{
  SA{/W w Sf div D}
   {talign 1 eq{/XO xo ll twidth sub 2 div add D}if
    talign 2 eq{/XO xo ll twidth sub add D}if
    /W XO twidth add D
   }ie /XO xo D /LL W XO sub MR sub D
  /PA f D /Fl capalg 0 eq D
  1 NA BL caption exec BN OA /PA t D
 }if
} D
/getwid{
 /irow1 E D
 /irow2 irow1 D
 /rwid 0 D
 {rdesc irow2 get dup 0 get rwid add /rwid E D 2 get 0 eq
  {exit}{/irow2 irow2 1 add D}ie
 }loop
} D
/printrow{
 /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
 /xleft xoff xo add D
 /irow E D
 /cells rdesc irow get 6 get D
 0 1 ncol{
  /icol E D
  /cell cells icol get D
  cell 0 ne{
   cell aload pop /CB E D /cvsize E D /above E D /fontsz E D
   /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
   /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
   /cmin E D /proc E D
   rspan 0 eq{/rspan nrow irow sub 1 add D}if
   cspan 0 eq{/cspan ncol icol sub 1 add D}if
   /width 0 D
   0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
   /rhight rdesc irow get 0 get D
   /hight rhight D
   1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
   /W xo xoff add width add right sub D
   /EO xo xoff add left add D SI
   Cf{
    gsave CB VC xo xoff add ycur yoff add M
    0 hight neg RL width 0 RL 0 hight RL width neg 0 RL fill
    grestore
   }if
   ctype 1 eq{() BD}if
   /A0 align D RC
   AT 4 eq{
    /DC dp D /ID 1 D /DO cdesc icol get 5 get D /Lo DO DV 0 get sub D /L1 Lo D
   }if
   valign 3 le{0 ycur yoff add top sub
    hight cvsize sub valign 1 sub mul 2 div sub M}
   {0 ycur yoff add top sub above add rdesc irow get 4 get sub M}ie
   /PA f D /BP t D /Fl t D
   BL proc exec BN
   /PA t D
   ctype 1 eq{() ES}if
  }if
  /xoff xoff cdesc icol get 0 get add D
 }for
 /yoff yoff rhight sub D
} D
/printhead {0 1 nhead 1 sub{printrow}for} D
/printfoot {nhead 1 nhead nfoot add 1 sub{printrow}for} D
/Tf {
 OU{rules 2 ge{/yoff 0 D
   gsave 0 Sg
   [0 1 nhead 1 sub{}for rbeg 1 row 1 sub{}for nhead 1 nhead nfoot add 1 sub{}for]{
    /irow E D
    /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      /rspan cell 6 get D
      /cspan cell 5 get D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /width 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
      /rhight rdesc irow get 0 get D
      /hight rhight D
      1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
      xo xoff add width add ycur yoff add M
      0 hight neg icol cspan add 1 sub ncol lt
       {cdesc icol 1 add get 4 get dup rules 3 le{1 eq}{pop t}ie
        {1 eq{0.8}{0.3}ie
        LW RL CP stroke M}{pop R}ie}{R}ie
      irow nhead nfoot add 1 sub ne nfoot 0 eq or
       {irow rspan add 1 sub nrow lt
       {rdesc irow rspan add get 3 get}{nfoot 0 eq{0}{1}ie}ie
       dup rules 2 mod 0 eq{1 eq}{pop t}ie
       {1 eq irow rspan add nhead eq or irow rspan add row eq nfoot 0 gt and or
        {0.8}{0.3}ie LW width neg 0 RL CP stroke M}{pop}ie}if
     }if
     /xoff xoff cdesc icol get 0 get add D
    }for
    /yoff yoff rhight sub D
   }forall
   grestore
   /Ms t D
  }if
  frame 1 gt{
   gsave
   1 LW 0 Sg
   xleft ycur M CP BB
   0 yoff frame 5 eq frame 7 ge or{RL}{R}ie
   twidth 0 frame 3 eq frame 4 eq or frame 8 ge or{RL}{R}ie CP BB
   0 yoff neg frame 6 ge{RL}{R}ie
   twidth neg 0 frame 2 eq frame 4 eq or frame 8 ge or{RL}{R}ie
   closepath stroke
   grestore
   /Ms t D
  }if
 }if
} D
/tables [[[0 0 0 0 0 -1 0 -130 0 0 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(

)R1 2 A([Sandia National Laboratories] )WB()EA(
)BR(
)R2 2 A([About Sandia] )WB()EA()BR()R3 2 A([Unique Solutions] )WB()EA()BR()R4 2 A([Working With Us] )WB()EA()BR()R5 2 A([Contacting Us] )WB()EA()BR()R6 2 A([News Center] )WB()EA()BR()R7 2 A([Search] )WB()EA()BR()R1 2 A([Home] )WB()EA()BR(
[navigation panel] )WB()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 Db ]
[{()3 Sl()WB()WB IA WB( )WB(
)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 Db ]
]]
]]
[[0 0 0 0 0 -1 0 -140 0 0 0 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(

)BD()5 FZ(Zoltan: )BR(A Dynamic Load-Balancing Library for Parallel Applications)BR()BR(User's Guide)Ef()Ea()ES()0 P(






)2 0.6 1 HR()0 4 -1 H()BD()R8 2 A(Karen Devine)BR()EA()R9 2 A(Bruce Hendrickson)BR()EA(Matthew St. John)BR(Erik Boman)BR(Courtenay Vaughan)ES()EH(
)BD(Sandia National Laboratories)ES(
)BR()BD(P.O. Box 5800)ES(
)BR()BD(Albuquerque, NM\240 87185-1111)ES(
)BR()2 0.6 1 HR(
)3 Al()BR(
)0 4 -1 H(Zoltan User's Guide )WB()EH()Ea()BR(

)0 4 -1 H()0 2 1 A(Introduction)2 0 TN TL()Ec /AF f D()EH(

)BQ()0 3 1 A(Load-Balancing
Tools)3 0 TN TL()Ec /AF f D(
)BR()0 4 1 A(Migration-Help Tools)4 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 5 1 A(Using the Library)5 0 TN TL()Ec /AF f D()EH(

)BQ()0 6 1 A(Application
Data Types)6 0 TN TL()Ec /AF f D(
)BR()0 7 1 A(Building the Library)7 0 TN TL()Ec /AF f D(
)BR()0 7 1 A(Building Applications)7 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 8 1 A(Zoltan Interface Functions)8 0 TN TL()Ec /AF f D()EH(

)BQ()0 9 1 A(Error Codes)9 0 TN TL()Ec /AF f D(
)BR()0 10 1 A(Initialization Functions)10 0 TN TL()Ec /AF f D(
)BR()0 11 1 A(Load-Balancing Functions)11 0 TN TL()Ec /AF f D(
)BR()0 12 1 A(Functions for Adding Items to a Decomposition)12 0 TN TL()Ec /AF f D(
)BR()0 13 1 A(Migration-Help Functions)13 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 14 1 A(Application-Registered Query Functions)14 0 TN TL()Ec /AF f D()EH(

)BQ()0 15 1 A(Load-Balancing Query Functions)15 0 TN TL()Ec /AF f D()QB(

)4 OL()4 OL()0 16 1 A(General Functions)16 0 TN TL()Ec /AF f D(
)BR()0 17 1 A(Geometry-based
Functions)17 0 TN TL()Ec /AF f D(
)BR()0 18 1 A(Graph-based Functions)18 0 TN TL()Ec /AF f D()LO()LO(

)BQ()0 19 1 A(Migration-Help Query Functions)19 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 20 1 A(Algorithms)20 0 TN TL()Ec /AF f D()EH(

)BQ()0 21 1 A(Recursive Coordinate Bisection
\201RCB\202)21 0 TN TL()Ec /AF f D(
)BR()0 22 1 A(ParMETIS)22 0 TN TL()Ec /AF f D(
)BR()0 23 1 A(Octree/Space-Filling Curve \201SFC\202 Partitioning)23 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 24 1 A(Examples of Library Usage)24 0 TN TL()Ec /AF f D()EH(

)BQ()0 25 1 A(Initialization)25 0 TN TL()Ec /AF f D(
)BR()0 26 1 A(Load-Balancing)26 0 TN TL()Ec /AF f D(
)BR()0 27 1 A(Migration)27 0 TN TL()Ec /AF f D(
)BR()0 28 1 A(Query Functions)28 0 TN TL()Ec /AF f D()QB(

)0 4 -1 H()0 29 1 A(Future Work)29 0 TN TL()Ec /AF f D()EH(

)0 4 -1 H()0 30 1 A(References)30 0 TN TL()Ec /AF f D()EH(

)2 0.6 1 HR([)0 2 A(Zoltan Home Page)EA(\240 |\240
)0 2 1 A(Next:\240 Introduction)2 0 TN TL()Ec /AF f D(]

)0 P()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 Db ]
]]
]]
[[0 0 0 0 0 -1 0 -0 0 0 0 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(
)0 PT(

)BR(

)1 PT(

)2 0.6 1 HR(

)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 Db ]
]]
]]
[[0 0 0 0 0 -1 0 0.8 2 0 0 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(.)TT(..)ES(\240
)BR()TT(/* )I(Register method and application query functions)ES( */)ES(\240
)BR()TT(lb = LB_Create_Object\201\202;)ES(\240
)BR()TT(LB_Set_Method\201lb, "RCB"\202;)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_GEOM_FN_TYPE,user_return_coords_fn,NULL\202;)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_NUM_OBJ_FN_TYPE,user_return_num_elems_fn,NULL\202;)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_OBJ_LIST_FN_TYPE,user_return_elem_list_fn,NULL\202;)ES(\240
)BR()TT(...)ES(\240
)BR()TT(/* )I(Call the load balancer)ES( */)ES(\240
)BR()TT(LB_Balance\201lb,&new,&num_imp,&imp_glob_ids,&imp_loc_ids,&imp_procs,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240 &num_exp,&exp_glob_ids,&exp_loc_ids,&exp_procs\202;)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.8 2 0 0 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()TT(...)ES(\240
)BR()TT(/* )I(call registered functions to build LB data structures)ES(
*/)ES(\240
)BR()TT(num_objs = lb->Get_Num_Obj\201lb->Get_Num_Obj_Data, &ierr\202;\240)ES(\240

)0 P()TT(/* )I(allocate memory for object global and local IDs )ES(*/)ES(\240
)BR()TT(lb->Get_Obj_List\201lb->Get_Obj_List_Data, global_ids,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
local_ids, &ierr\202;\240)ES(\240
)BR()TT(for \201i = 0; i < num_objs; i++\202 {)ES(\240
)BR()TT(\240\240 lb->Data[i].Global_Tag = global_ids[i];)ES(\240
)BR()TT(\240\240 lb->Data[i].Local_Tag = local_ids[i];)ES(\240
)BR()TT(\240\240 lb->Get_Geom\201lb->Get_Geom_Data, global_ids[i],\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
local_ids[i], lb->Data[i].Coords, &ierr\202;)ES(\240
)BR()TT(})ES(\240
)BR()TT(/* )I(perform balancing on lb->Data)ES( */)ES(\240
)BR()TT(...)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 2 0 0 0 1 1 {()I(Example of interaction between the application
and the load balancer.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 32 Sn()EA(Application\240
)3 PT(
\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()2 Al()WB IA WB( )WB()Ea()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()3 Al()BR(Dynamic Load Balancer)Ea()BR(

)3 Al()BR()4 PT()Ea()BR(
\240\240

)I(Example of interaction between the application
and the load balancer.)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.8 2 0 0 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()TT(...)ES(\240
)BR()TT(/* )I(Register packing and unpacking functions)ES( */)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_OBJ_SIZE_FN_TYPE,user_elem_size_fn,NULL\202;)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_PACK_OBJ_FN_TYPE,user_pack_one_elem_fn,NULL\202;)ES(\240
)BR()TT(LB_Set_Fn\201lb,LB_UNPACK_OBJ_FN_TYPE,user_unpack_one_elem_fn,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240 NULL\202;)ES(\240
)BR()TT(...)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.8 2 0 0 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()TT(...)ES(\240
)BR()TT(size = lb->Get_Obj_Size\201lb->Get_Obj_Size_Data, &ierr\202;)ES(\240
)BR()TT(/* )I(pack all objects for export)ES( */)ES(\240
)BR()TT(for each object i being exported)ES(\240
)BR()TT(\240\240\240 lb->Pack_Obj\201lb->Pack_Obj_Data, exp_global_id[i],)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
exp_local_id[i], exp_procs[i], size,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
export_buf[i], &ierr\202;\240)ES(\240

)0 P()TT(/* )I(perform communication using map)ES( */)ES(\240
)BR()TT(communicate\201lb->Comm_Map, export_buf, &import_buf\202;)ES(\240

)0 P()TT(/* )I(unpack all imported objects)ES( */)ES(\240
)BR()TT(for each object i received)ES(\240
)BR()TT(\240\240\240 lb->Unpack_Obj\201lb->Unpack_Obj_Data, imp_global_id[i],)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
size, import_buf[i], &ierr\202;)ES(\240
)BR()TT(...)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 2 0 0 0 1 1 {()I(Example of interaction between the application
and the migration-help tools.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 33 Sn()EA(Application\240
)6 PT(
\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()2 Al()WB IA WB( )WB()Ea()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()3 Al()BR(Migration-Help Tools)Ea()BR(

)3 Al()BR()7 PT()Ea()BR(
\240\240

)I(Example of interaction between the application
and the migration-help tools.)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 -0 1 10 1 0 0 9 5 {()I(Data type and macro definitions that must be provided
to the load-balancing library by the application in lb/lb_user_const.h.)ES()} 1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 49 Sn()EA(Definition)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Description)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_GID)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The data type of the unique global IDs used by the application.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_LID)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The data type of the local IDs used by the application query functions.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_SET_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Assigns the global ID value in )I(b)ES( to )I(a)ES( \201i.e., )I(a = b)ES(
\202.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_SET_LID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Assigns the local ID value in )I(b)ES( to )I(a)ES( \201i.e., )I(a = b)ES(
\202.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_EQ_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global IDs )I(a)ES( and )I(b)ES( are equal; returns
FALSE otherwise.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_NE_GID\201)I( a, b\202)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global IDs )I(a)ES( and )I(b)ES( are not equal; returns
FALSE otherwise.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_LT_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global ID )I(a)ES( is less than global ID )I(b)ES(
; returns FALSE otherwise.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_LE_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global ID )I(a)ES( is less than or equal to global
ID )I(b)ES( ; returns FALSE otherise.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_GT_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global ID )I(a)ES( is greater than global ID )I(b)ES(
; returns FALSE otherwise.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(LB_GE_GID\201)I( a, b)ES( \202)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Returns TRUE if global ID )I(a)ES( is greater than or equal to global
ID )I(b)ES( ; returns FALSE otherwise.

)I(Data type and macro definitions that must be provided
to the load-balancing library by the application in lb/lb_user_const.h.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Options to gmake:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 NO_PARMETIS=1)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Do not compile and link with )0 52 1 A(ParMETIS)52 0 TN TL()Ec /AF f D(
in the Zoltan library.\240 If this option is specified, no )0 52 1 A(ParMETIS)52 0 TN TL()Ec /AF f D(libraries
are needed when the application is linking.\240 Otherwise, a )0 52 1 A(ParMETIS)52 0 TN TL()Ec /AF f D(
library path must be specified to )0 7 1 A(build
the application)7 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 1 3 1 0 0 9 5 {()WB 59 Sn()EA()I(Return codes defined
in lb/lbi_const.h.)ES()} 1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()I(LB_OK)ES()} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Function returned without warnings or errors.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(LB_WARN\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Function returned with warnings. The application will probably be able
to continue to run.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(LB_FATAL\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A fatal error occured within the LB library.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(LB_MEMERR)ES()} 0 0 0 0 1 1 0 (.) 1 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An error occurred while allocating memory. When this error occurs,
the library frees any allocated memory and returns control to the application.
If the application then wants to try to use another, less memory-intensive,
algorithm, it can do so.

)WB 59 Sn()EA()I(Return codes defined
in lb/lbi_const.h.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 68 Sn()EA(int )BD(LB_Initialize)ES(\201int )I(argc)ES(,
char **)I( argv)ES(, float *)I( ver)ES(\202;
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(INTEGER\201LB_INT\202 FUNCTION )BD(LB_Initialize)ES(\201 )I(argc)ES(, )I(argv)ES(,
)I(ver)ES(\202\240
)BR(INTEGER\201LB_INT\202, INTENT\201IN\202, OPTIONAL :: argc\240
)BR(CHARACTER\201LEN=*\202, DIMENSION\201*\202, INTENT\201IN\202, OPTIONAL :: argv\240
)BR(REAL\201LB_FLOAT\202, INTENT\201OUT\202 :: ver\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 5 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 argc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of command-line arguments to the application.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 argv)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of strings containing the command-line arguments to the application.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ver)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The version number of the library.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 40 Sn()EA(struct )BD(LB_Struct)ES( *)BD(LB_Create_Object)ES(\201MPI_Comm
)I(communicator)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Create_Object)ES(\201)I(communicator)ES(\202\240
)BR(TYPE\201LB_Struct\202, pointer :: LB_Create_Object\240
)BR(INTEGER, INTENT\201IN\202 :: communicator\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 3 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 communicator)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The MPI communicator to be used for this load-balancing object. Only
those processors included in the communicator participate in load balancing.
If all processors currently used by the application are to participate
in load balancing, communicator should be )BD(MPI_COMM_WORLD)ES( .)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:\240)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 struct )BD(LB_Struct)ES( *)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to memory for storage of load-balancing information. If an
error occurs, NULL will be returned in C, or the result will be a nullified
pointer in Fortran. Any error that occurs in this function is assumed to
be fatal.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 42 Sn()EA(int )BD(LB_Set_Fn)ES( \201struct )BD(LB_Struct )ES(*
)I(lb, )ES()BD(LB_FN_TYPE)ES( )I(fn_type)ES(, void * )I(fn_ptr)ES(\201\202, void
*)I(data)ES(\202;
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Set_Fn)ES(\201)I(lb, fn_type, fn_ptr, data)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Set_Fn\240
)BR(TYPE\201LB_Struct\202, INTENT\201IN\202 :: lb\240
)BR(TYPE\201LB_Fn_Type\202, INTENT\201IN\202 :: fn_type\240
)BR(EXTERNAL :: fn_ptr\240
)BR(<)I(type-data)ES(>, OPTIONAL :: data\240

)0 P(<)I(type-data)ES(> can be any of INTEGER\201LB_INT\202, DIMENSION\201*\202 or
REAL\201LB_FLOAT\202, DIMENSION\201*\202 or REAL\201LB_DOUBLE\202, DIMENSION\201*\202 or TYPE\201LB_User_Data_)I(x)ES(\202
where )I(x)ES( is 1, 2, 3 or 4. See the section on Fortran for an explanation.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 6 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object created by)BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 fn_type)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The type of function being registered; see )0 69 1 A(Application-Registered
Query Functions)69 0 TN TL()Ec /AF f D( for possible function types.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 fn_ptr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A pointer to the application-supplied query function being registered.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A pointer to user defined data that will be passed, as an argument,
to the function pointed to by fn_ptr . In C it may be NULL. In Fortran
it may be omitted.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 41 Sn()EA(int )BD(LB_Set_Method)ES(\201struct )BD(LB_Struct)ES(
*)I( lb)ES(, char * )I(string)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Set_Method)ES(\201)I(lb)ES(, )I(string)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Set_Method\240
)BR(TYPE\201LB_Struct\202, INTENT\201IN\202 :: lb\240
)BR(CHARACTER\201LEN=*\202, INTENT\201IN\202 :: string\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 6 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF]]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 string)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A string containing the name of the desired load-balancing technique.
Valid values of string are\240
)BQ("RCB" \201for )0 21 1 A(recursive-coordinate
bisection)21 0 TN TL()Ec /AF f D(\202,\240
)BR("PARMETIS" \201for any of the methods in the )0 52 1 A(ParMETIS)52 0 TN TL()Ec /AF f D(
library\202,\240
)BR("OCTPART" \201for )0 23 1 A(octree partitioning)23 0 TN TL()Ec /AF f D(\202,
and\240
)BR("NONE" \201for no load-balancing\202.)QB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )BD(LB_Set_Method)ES( is not called, )0 21 1 A(RCB)21 0 TN TL()Ec /AF f D(
is used.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 73 Sn()EA(int )BD(LB_Set_Param)ES(\201struct )BD(LB_Struct)ES(
*)I( lb)ES(, char * )I(param_name)ES(, char * )I(new_val)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 7 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF]]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 param_name)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A string containing the name of the parameter to be altered.\240
Note that the string is case-insensitive.\240 Also, different load-balancing
objects can have different parameter values.\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 new_val)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A string containing the new value for the parameter.\240 Possible
stings include "3.154", "True", "7" or anything appropriate for the parameter
being set. As above, the string is case-insensitive.\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 43 Sn()EA(int )BD(LB_Balance)ES(\201struct )BD(LB_Struct)ES(
* )I(lb)ES(, int * )I(changes)ES(, int * )I(num_import)ES(, )BD(LB_GID)ES(
** )I(import_global_ids)ES(, )BD(LB_LID)ES( ** )I(import_local_ids)ES(,
int ** )I(import_procs)ES(, int * )I(num_export)ES(, )BD(LB_GID )ES(**)I(export_global_ids)ES(, )BD(LB_LID)ES( ** )I(export_local_ids)ES(, int **
)I(export_procs)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Balance)ES(\201)I(lb, changes, num_import, import_global_ids,
import_local_ids, import_procs, num_export, export_global_ids, export_local_ids,
export_procs)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Balance\240
)BR(TYPE\201LB_Struct\202,INTENT\201IN\202 :: lb\240
)BR(INTEGER\201LB_INT\202, INTENT\201OUT\202 :: changes\240
)BR(INTEGER\201LB_INT\202, INTENT\201OUT\202 :: num_import, num_export\240
)BR(<)I(type-gid)ES(>, POINTER, DIMENSION\201:\202 :: import_global_ids, export_global_ids\240
)BR(<)I(type-lid)ES(>, POINTER, DIMENSION\201:\202 :: import_local_ids, export_local_ids\240
)BR(INTEGER\201LB_INT\202, POINTER, DIMENSION\201:\202 :: import_procs, export_procs\240

)0 P(<)I(type-gid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_GID\202\240
)BR(<)I(type-lid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_LID\202\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 12 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object, created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
to be used in this invocation of the load-balancing routine.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 changes)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Set to 1 if the decomposition was changed by the load-balancing method;
0 otherwise.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_import\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the number of objects that are now assigned to this processor
that were assigned to other processors in the old decomposition \201i.e.,
the number of objects to be imported to this processor\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_import)ES( listing the global
IDs of objects to be imported to this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_import)ES( listing the local IDs
of objects to be imported to this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_import)ES( listing the processor
IDs of the processors that owned the imported objects in the previous decomposition
\201i.e., the source processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_export)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the number of objects that were assigned to this processor
in the previous decomposition that are now assigned to other processors
\201i.e., the number of objects that must be exported from this processor
to other processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_export)ES( listing the global
IDs of objects to be exported from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_export)ES( listing the local IDs
of objects to be exported from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_export )ES(listing the processor
IDs of processors that will own the exported objects in the new decomposition
\201i.e., the destination processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 74 Sn()EA(void )BD(LB_Eval)ES(\201struct )BD(LB_struct *)ES()I(lb)ES(,
int )I(print_stats)ES(, int )I(vwgt_dim)ES(, int )I(ewgt_dim)ES(, int *)I(nobj)ES(,
float *o)I(bj_wgt)ES(, int *)I(cut_wgt)ES(, int *)I(nboundary)ES(, int
*)I(nadj)ES(, int *)I(ierr)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 15 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 print_stats)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )I(print_stats)ES(>0, print a summary \201maximum and sum\202 of the quality
metrics to )I(stdout.)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 vwgt_dim)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Object \201vertex\202 weight dimension: compute statistics for the )I(vwgt_dim)ES(first weights)I(. )ES(\2010 if no weights\202)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ewgt_dim)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Edge weight dimension: compute statistics for the )I(ewgt_dim )ES(first
weights)I(. )ES(\201must be 0 or 1 in this version\202)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 nobj)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the number of objects on this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 obj_wgt)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array containing the sum of object weights on this
processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(cut_wgt)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the cut size \201weight\202 for this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nboundary)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return,\240 the number of boundary objects on this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nadj)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return,\240 the number of adjacent processors as defined by
the communication graph.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(ierr)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an )0 9 1 A(error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(None.\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Query functions:)ES(\240
)BR(\240\240\240\240 Required:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240
)BR()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D(
)BR()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D( or )0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D(/)0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240\240 Optional:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 81 1 A(LB_NUM_EDGES_FN)81 0 TN TL()Ec /AF f D(\240
)BR()0 82 1 A(LB_EDGE_LIST_FN)82 0 TN TL()Ec /AF f D()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 75 Sn()EA(int )BD(LB_Free_Data)ES(\201)BD(LB_GID)ES( **
)I(import_global_ids)ES(, )BD(LB_LID)ES( ** )I(import_local_ids)ES(, int
** )I(import_procs)ES(, )BD(LB_GID )ES(** )I(export_global_ids)ES(, )BD(LB_LID)ES(
** )I(export_local_ids)ES(, int ** )I(export_procs)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Free_Data)ES(\201)I(import_global_ids, import_local_ids,
import_procs, export_global_ids, export_local_ids, export_procs)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Free_Data\240
)BR(<)I(type-gid)ES(>, POINTER, DIMENSION\201:\202 :: import_global_ids, export_global_ids\240
)BR(<)I(type-lid)ES(>, POINTER, DIMENSION\201:\202 :: import_local_ids, export_local_ids\240
)BR(INTEGER\201LB_INT\202, POINTER, DIMENSION\201:\202 :: import_procs, export_procs\240

)0 P(<)I(type-gid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_GID\202\240
)BR(<)I(type-lid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_LID\202\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 8 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the global IDs of objects imported to this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the local IDs of objects imported to this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the processor IDs of the processors that owned
the imported objects in the previous decomposition \201i.e., the source processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the global IDs of objects exported from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the local IDs of objects exported from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The array containing the processor IDs of processors that own the exported
objects in the new decomposition \201i.e., the destination processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 76 Sn()EA(int )BD(LB_Destroy_Object)ES( \201struct
)BD(LB_Struct)ES( ** )I(lb)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(A pointer to the address of the load-balancing object, created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
to be destroyed.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 85 Sn()EA(int )BD(LB_Point_Assign)ES( \201struct )BD(LB_Struct)ES(
* )I(lb)ES(, double * )I(coords)ES(, int * )I(proc)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 5 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF]]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 coords)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The )I(\201x,y\202)ES( of )I(\201x,y,z\202)ES( coordinates of the point being assigned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the ID of the processor the point should belong to.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 86 Sn()EA(int )BD(LB_Box_Assign)ES( \201struct )BD(LB_Struct)ES(
*)I( lb)ES(, double )I(xmin)ES(, double )I(ymin)ES(, double )I(zmin)ES(,
double )I(xmax)ES(, double )I(ymax)ES(, double )I(zmax)ES(, int * )I(procs)ES(,
int * )I(numprocs)ES(\202;\240\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 7 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()} 0 0 0 0 1 1 0 (.) 0 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF]]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 xmin, ymin, zmin)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The coordinates of the lower extent of the bounding box around the
object.\240 If your geometry is only 2- dimensional then the z value
will be ignored.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 xmax, ymax, zmax)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The coordinates of the upper extent of the bounding box around the
object.\240 If your geometry is only 2- dimensional then the z value
will be ignored.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The list of processors intersecting the box are returned starting at
this address. Note that it is the responsibility of the calling routine
to ensure that there is sufficient space for the return list.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240 numprocs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, this value contains the number of processors which intersect
the box \201i.e. the number of entries placed in the )I(procs)ES( list\202.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 90 Sn()EA(int )BD(LB_Compute_Destinations)ES(\201struct
)BD(LB_Struct)ES( * )I(lb)ES(, int )I(num_import)ES(,)BD( LB_GID )ES(* )I(import_global_ids)ES(,
)BD(LB_LID)ES( * )I(import_local_ids)ES(,\240 int * )I(import_procs)ES(,
int * )I(num_export)ES(, )BD(LB_GID)ES( ** )I(export_global_ids)ES(, )BD(LB_LID)ES(
** )I(export_local_ids)ES(, int ** )I(export_procs)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Compute_Destinations)ES(\201)I(lb, num_import, import_global_ids,
import_local_ids, import_procs, num_export, export_global_ids, export_local_ids,
export_procs)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Compute_Destinations\240
)BR(TYPE\201LB_Struct\202,INTENT\201IN\202 :: lb\240
)BR(INTEGER\201LB_INT\202, INTENT\201IN\202 :: num_import\240
)BR(INTEGER\201LB_INT\202, INTENT\201OUT\202 :: num_export\240
)BR(<)I(type-gid)ES(>, POINTER, DIMENSION\201:\202 :: import_global_ids, export_global_ids\240
)BR(<)I(type-lid)ES(>, POINTER, DIMENSION\201:\202 :: import_local_ids, export_local_ids\240
)BR(INTEGER\201LB_INT\202, POINTER, DIMENSION\201:\202 :: import_procs, export_procs\240

)0 P(<)I(type-gid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_GID\202\240
)BR(<)I(type-lid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_LID\202\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 11 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object, created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
to be used in this invocation of the migration-help routine.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_import\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that are needed by this processor that are stored
on other processors in the old decomposition \201i.e., the number of objects
to be imported to this processor\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the global IDs of objects
needed by this processor that are stored on other processors in the old
decomposition.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the local IDs of objects
needed by this processor that are stored on other processors in the old
decomposition.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import )ES(listing the processor IDs of the
processors that own objects needed by this processor \201i.e., the source
processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_export)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, the number of objects that were stored on this processor
in the previous decomposition that are needed by other processors \201i.e.,
the number of objects that must be sent from this processor to other processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_export )ES(listing the global
IDs of objects to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(\240Upon return, an array of size )I(num_export )ES(listing the local
IDs of objects to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of size )I(num_export)ES( listing the processor
IDs of processors that need the sent objects \201i.e., the destination processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 1 1 0 0 1 1 {()} -1]
 [[0 0 0 0.15 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB(C:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()WB 91 Sn()EA(int )BD(LB_Help_Migrate)ES(\201struct )BD(LB_Struct)ES(
* )I(lb)ES(, int )I(num_import)ES(, )BD(LB_GID)ES( * )I(import_global_ids)ES(,
)BD(LB_LID)ES( * )I(import_local_ids)ES(, int * )I(import_procs)ES(, int
)I(num_export)ES(, )BD(LB_GID)ES( * )I(export_global_ids)ES(, )BD(LB_LID)ES(
* )I(export_local_ids)ES(,\240 int * )I(export_procs)ES(\202;\240
)BR(\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(FORTRAN:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(FUNCTION )BD(LB_Help_Migrate)ES(\201)I(lb, num_import, import_global_ids,
import_local_ids, import_procs, num_export, export_global_ids, export_local_ids,
export_procs)ES(\202\240
)BR(INTEGER\201LB_INT\202 :: LB_Help_Migrate\240
)BR(TYPE\201LB_Struct\202,INTENT\201IN\202 :: lb\240
)BR(INTEGER\201LB_INT\202, INTENT\201IN\202 :: num_import, num_export\240
)BR(<)I(type-gid)ES(>, POINTER, DIMENSION\201:\202 :: import_global_ids, export_global_ids\240
)BR(<)I(type-lid)ES(>, POINTER, DIMENSION\201:\202 :: import_local_ids, export_local_ids\240
)BR(INTEGER\201LB_INT\202, POINTER, DIMENSION\201:\202 :: import_procs, export_procs\240

)0 P(<)I(type-gid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_GID\202\240
)BR(<)I(type-lid)ES(> can be either INTEGER\201LB_INT\202 or TYPE\201LB_LID\202\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 11 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 lb)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The load-balancing object, created by )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
to be used in this invocation of the migration-help routine.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_import\240)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that are needed by this processor that are stored
on other processors in the old decomposition \201i.e., the number of objects
to be imported to this processor\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the global IDs of objects
needed by this processor that are stored on other processors in the old
decomposition.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the local IDs of objects
needed by this processor that are stored on other processors in the old
decomposition.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import )ES(listing the processor IDs of the
processors that own objects needed by this processor \201i.e., the source
processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_export)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that were stored on this processor in the previous
decomposition that are needed by other processors \201i.e., the number of
objects that must be sent from this processor to other processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export )ES(listing the global IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export )ES(listing the local IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the processor IDs of processors
that need the sent objects \201i.e., the destination processors\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()0 9 1 A(Error code)9 0 TN TL()Ec /AF f D(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 5 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NUM_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects to be balanced that are assigned to the processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 7 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_OBJ_LIST_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of unique global IDs for all objects assigned to the processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of local IDs, the meaning of which can be determined by the
application, for all objects assigned to the processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(obj_wgts)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of object weights. Weight )I(i )ES(is stored in o)I(bj_wgts[\201i-1\202*wgt_dim:i*wgt_dim-1])ES(.\240
If )I(wgt_dim)ES(=0, the return value of )I(obj_wgts)ES( is undefined and
may be NULL.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 10 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_FIRST_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 first_global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the global ID for the first object; the value
is ignored if there are no objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 first_local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the local ID for the first object; the value
is ignored if there are no objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(first_obj_wgt)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Object weight, an array of length )I(wgt_dim. )ES(Undefined if )I(wgt_dim=0.)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 1)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )I(first_global_id)ES( and )I(first_local_id)ES( contain valid IDs
of the first object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 0)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If no objects are available.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 12 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NEXT_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the previous object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the previous object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 next_global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the global ID for the next object; the value
is ignored if there are no more objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 next_local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the local ID for the next object; the value is
ignored if there are no more objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(next_obj_wgt)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Object weight, an array of length )I(wgt_dim. )ES(Undefined if )I(wgt_dim=0.)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 1)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )I(next_global_id)ES( and )I(next_local_id)ES( contain valid IDs
of the next object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 0)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If no more objects are available.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 6 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NUM_BORDER_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 nbor_proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The processor ID of the processor for which the number of border objects
should be returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects sharing a processor subdomain border with processor
)I(nbor_proc)ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 8 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_BORDER_OBJ_LIST_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nbor_proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The processor ID of the processor for which border objects should be
returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of unique global IDs for all objects assigned to the processor
that share a subdomain border with )I(nbor_proc)ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of local IDs, the meaning of which can be determined by the
application, for all objects assigned to the processor that share a subdomain
border with )I(nbor_proc)ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(obj_wgts)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of object weights. Weight )I(i )ES(is stored in )I(obj_wgts[\201i-1\202*wgt_dim:i*wgt_dim-1])ES(.\240
If )I(wgt_dim=0,)ES( )I(obj_wgts)ES( is undefined and may be NULL.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 11 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_FIRST_BORDER_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nbor_proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The processor ID of the processor for which border objects should be
returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 first_global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the global ID for the first object; the value
is ignored if there are no objects along the border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 first_local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the local ID for the first object; the value
is ignored if there are no objects along the border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(first_obj_wgt)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(First object weight. Undefined if\240 )I(wgt_dim=)ES(0.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 1)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )I(first_global_id)ES( and )I(first_local_id)ES( contain valid IDs
of the first object along the processor border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 0)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If no objects are available along this processor border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 13 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NEXT_BORDER_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the previous object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the previous object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nbor_proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The processor ID of the processor for which border objects should be
returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 next_global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the global ID for the next object; the value
is ignored if there are no more objects along the border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 next_local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The returned value of the local ID for the next object; the value is
ignored if there are no more objects along the border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the weights \201typically 1\202, or 0 if\240 weights are not
requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(next_obj_wgt)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Weight of the next object. Undefined if )I(wgt_dim)ES(=0.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 1)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If )I(next_global_id)ES( and )I(next_local_id)ES( contain valid IDs
of the next object along the processor border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 0)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If no more objects are available along this processor border.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 5 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NUM_GEOM_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of values needed to express the geometry of an object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 6 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_GEOM_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the object whose geometry values should be returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the object whose geometry values should be returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(geom_vec)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array in which the geometry values should be stored.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 7 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_NUM_EDGES_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(global_id)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the object for which the number of edges should be
returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(local_id)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the object for which the number of edges should be
returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of edges for the object identified by )I(global_id)ES( and
)I(local_id)ES(.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 9 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_EDGE_LIST_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the object for which edge lists should be returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the object for which edge lists should be returned.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nbor_global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of global IDs of objects sharing edges with the
given object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(nbor_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of processor IDs that identifies where the neighboring
objects reside.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(wgt_dim)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of the edge weights \201typically 1\202, or 0 if edge weights are
not requested.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(ewgts)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Upon return, an array of edge weights, where )I(ewgts[i*wgt_dim: \201i+1\202*wgt_dim-1])ES(
)BR(corresponds to the )I(i)ES(th edge weight. If )I(wgt_dim=0 )ES(the
return value of )I(ewgts )ES(is undefined and may be NULL.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 5 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_OBJ_SIZE_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Returned Value:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 int)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The size \201in bytes\202 of the required data buffer.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 13 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_PRE_MIGRATE_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_import)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that will be received by this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the global IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the local IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the processor IDs of the
source processors. This array may be NULL, as the processor does not necessarily
need to know from which processors it will be receiving objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_export)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that will be sent from this processor to other
processors.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the global IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the local IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the processor IDs of the
destination processors.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(No pre-processing is done if an )BD(LB_PRE_MIGRATE_FN)ES( is not registered.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 13 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_POST_MIGRATE_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_import)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that will be received by this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the global IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the local IDs of objects
to be received by this processor. This array may be NULL, as the processor
does not necessarily need to know which objects it will receive.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 import_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_import)ES( listing the processor IDs of the
source processors. This array may be NULL, as the processor does not necessarily
need to know from which processors it will be receiving objects.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 num_export)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The number of objects that will be sent from this processor to other
processors.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_global_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the global IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_local_ids)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the local IDs of objects
to be sent from this processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 export_procs)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(An array of size )I(num_export)ES( listing the processor IDs of the
destination processors.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(No post-processing is done if an )BD(LB_POST_MIGRATE_FN)ES( is not registered.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 8 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_PACK_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the object for which data should be copied into the
communication buffer.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 local_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The local ID of the object for which data should be copied into the
communication buffer.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 dest_proc)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The destination processor ID \201i.e., the processor to which the object
is being sent\202)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 size)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The size \201in bytes\202 of the communication buffer for the specified object
\201as returned by the )BD()0 95 1 A(LB_OBJ_SIZE_FN)95 0 TN TL()Ec /AF f D()ES(
query function\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 buf)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The starting address of the communication buffer into which the object's
data should be packed.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 6 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Function Type:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(LB_UNPACK_OBJ_FN_TYPE)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 data)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Pointer to user-defined data.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 global_id)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The global ID of the object whose data has been received in the communication
buffer.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 size)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The size \201in bytes\202 of the object's data in the communication buffer.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 buf)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The starting address of the communication buffer for this object.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 ierr)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Error code to be set by function.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 7 1 0 0 1 1 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 92 Sn()EA()BD(General Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(IMBALANCE_TOL)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The amount of load imbalance the partitioning algorithm should deem
acceptable. The load on each processor is computed as the sum of the weights
of objects it is assigned. The imbalance is then computed as the maximum
load divided by the average load. An value for IMBALANCE_TOL of .2 indicates
that 20% imbalance is OK; that is, the max over the average shouldn't exceed
1.2.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(AUTO_MIGRATE)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(If this value is set to TRUE \201nonzero\202 then Zoltan will automatically
perform the data migration during calls to )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(.
A full discussion of automatic migration can be found in the description
of the )0 13 1 A(migration interface functions)13 0 TN TL()Ec /AF f D(.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(KEEP_CUTS)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The recursive geometric partitioning algorithms have the nice property
that each processor owns a portion of the global geometric space. With
this geometric decomposition, it is possible to determine which processor
a new object should be assigned to via the )BD()0 85 1 A(LB_Point_Assign)85 0 TN TL()Ec /AF f D()ES(
or )BD()0 86 1 A(LB_Box_Assign)86 0 TN TL()Ec /AF f D()ES(
functions. If you intend to use these functions, then information about
the geometric partitioning must be retained by setting KEEP_CUTS to 1.\240)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(IMBALANCE_TOL)ES( = .1)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(AUTO_MIGRATE)ES( = FALSE)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(KEEP_CUTS)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 19 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Method String:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(RCB)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(RCB_OVERALLOC)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The amount by which to over-allocate temporary storage arrays for objects
within the RCB algorithm when additional storage is due to changes in processor
assignments.\240
)BR(1.0 = no extra storage allocated; 1.5 = 50% extra storage; etc.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 RCB_REUSE)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Flag to indicate whether to use previous cuts as initial guesses for
the current RCB invocation.\240
)BR(0 = don't use previous cuts; 1 = use previous cuts.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240)I( RCB_WGTFLAG)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Flag to indicate whether to use object weights in the RCB computation.\240
)BR(0 = don't use object weights; 1 = use object weights.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240)I( RCB_CHECK)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Flag controlling the invocation of input and outpur error checking.\240
)BR(0 = don't do checking; 1 = do checking.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240)I( RCB_STATS)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Flag controlling the amount of timing and diagnostic output the routine
produces.\240
)BR(0 = no output; 1 = print summary; 2 = print data for each processor.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240)I( KEEP_CUTS)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Should information about the cuts determining the RCB decomposition be
retained?  It costs a bit of time to do so, but this information is necessary
if application wants to add more objects to the decomposition via calls
to )BD()0 85 1 A(LB_Point_Assign)85 0 TN TL()Ec /AF f D()ES(
or to )BD()0 86 1 A(LB_Box_Assign)86 0 TN TL()Ec /AF f D()ES(.
)BR(0 = don't keep cuts; 1 = keep cuts.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(RCB_OVERALLOC)ES( = 1.0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(RCB_REUSE)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(RCB_WGTFLAG)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(RCB_CHECK)ES( = 1)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(RCB_STATS)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(KEEP_CUTS)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Required Query Functions:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
or )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(/)BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
pair)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 108 1 A(LB_NUM_GEOM_FN)108 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 20 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Method String:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(PARMETIS)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 PARMETIS_METHOD)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The ParMETIS method to be used.; currently eight are available.\240
)BR()I(PartKway)ES( - multilevel Kernighan-Lin partitioning\240
)BR()I(PartGeom)ES( - space filling curves \201coordinate based\202\240
)BR()I(PartGeomKway)ES( - hybrid method based on PartKway and PartGeom
\201needs both\240 graph data and coordinates\202\240
)BR()I(RepartLDiffusion)ES( - diffusion algorithm \201local\202\240
)BR()I(RepartGDiffusion)ES( - diffusion algorithm \201global\202\240
)BR()I(RepartRemap)ES( - multilevel partioning with remap seeking to minimize
migration cost\240
)BR()I(RepartMLRemap)ES( - similar to RepartRemap but with additional multilevel
refinement\240
)BR()I(RefineKway)ES( - refine the current partitioning \201balance\202)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(PARMETIS_OUTPUT_LEVEL)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Amount of output the load-balancing algorithm should produce.\240
)BR(0 = no output, 1 = print timing info. Turning on more bits displays
more information \201for example, 3=1+2, 5=1+4, 6=2+4\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(PARMETIS_VWGT_DIM)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of vertex \201that is, object\202 weights to use .\240
)BR(0 = don't use object weights; 1 = use scalar object weights, n>1 =
use multidimensional weights \201not yet supported by ParMetis\202)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(PARMETIS_EWGT_DIM)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Dimension of\240 edge weights to use .\240
)BR(0 = don't use edge weights; 1 = use scalar edge weights, n>1 = use
multidimensional weights \201not yet supported by ParMetis\202)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(PARMETIS_COARSE_ALG)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Coarse algorithm for PartKway. 1 = serial, 2 = parallel.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(PARMETIS_FOLD)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Folding parameter for PartKway \201for expert ParMETIS users only\202.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default values:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_METHOD)ES( = PartKway)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_OUTPUT_LEVEL)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_VWGT_DIM)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_EWGT_DIM)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_COARSE_ALG )ES(= 2)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(PARMETIS_FOLD )ES(= 150)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Required Query Functions:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(For all submethods:)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
or )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(/)BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
pair)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(Only PartGeom & PartGeomKway:)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 108 1 A(LB_NUM_GEOM_FN)108 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(All but PartGeom:)} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 18 1 A(LB_NUM_EDGES_FN)18 0 TN TL()Ec /AF f D()ES(\240
)BR()BD()0 18 1 A(LB_EDGE_LIST_FN)18 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 1 0 17 1 0 0 1 1 {()} -1]
 [[0 0 0 0.2 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Method String:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD(OCTPART)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Parameters:)ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(OCT_DIM)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Specifies whether the 2D or 3D Octree algorithms should be used. The
3D algorithms can be used for 2D problems, but much memory will be wasted
to allow for a non-existent third dimension. Similarly, a 2D algorithm
can be used for 3D surface meshes provided that the surface can be projected
to the )I(xy)ES(-plane without overlapping points.\240
)BR(2 = use 2D algorithm; 3 = use 3D algorithm.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()I(\240\240\240 OCT_METHOD)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The SFC to be used.\240
)BR(0 = Morton Indexing; 1 = Grey Code; 2 = Hilbert.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(OCT_GRANULARITY)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(The maximum number of objects to allow in a leaf octant of the octree.
These objects will be assigned as a group to a processor, so this parameter
defines the granularity of the load-balancing problem.Values greater than
or equal to one are allowable.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240\240 )I(OCT_OUTPUT_LEVEL)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Amount of output the load-balancing algorithm should produce.\240
)BR(0 = no statistics; 1 = statistics summary; 2 = debugging information.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB(\240\240 )I(OCT_WGTFLAG)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB(Flag to indicate whether to use object weights in the OCTPART computation.\240
)BR(0 = don't use object weights; 1 = use object weights.)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Default:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(OCT_DIM)ES( = 3)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(OCT_METHOD)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(OCT_GRANULARITY)ES( = 1)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(OCT_OUTPUT_LEVEL)ES( = 1)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()I(OCT_WGTFLAG)ES( = 0)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()BD(Required Query Functions:)ES()} 0 0 0 0 1 1 0 (.) 1 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
or )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(/)BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
pair)} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 108 1 A(LB_NUM_GEOM_FN)108 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
[0 0 0 0 0 0 [[{()3 Sl()WB()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
[{()3 Sl()WB()BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES()} 0 0 0 0 1 1 0 (.) 2 0 8 8 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Typical calling sequence for initialization of
the Zoltan library.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 138 Sn()EA()TT(/* Initialize the LB library
*/)ES(\240
)BR()TT(struct LB_Struct *lb;)ES(\240
)BR()TT(float version;)ES(\240
)BR()TT(...)ES(\240
)BR()TT()0 68 1 A(LB_Initialize)68 0 TN TL()Ec /AF f D(\201argc,
argv, &version\202;)ES(\240\240
)BR()TT(lb = )0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D(\201MPI_COMM_WORLD\202;)ES(

)I(Typical calling sequence for initialization of
the Zoltan library.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Typical calling sequence for performing load balancing
with the Zoltan library.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 141 Sn()EA()TT(char *lb_method;)ES(\240
)BR()TT(int new, num_imp, num_exp, *imp_procs, *exp_procs;)ES(\240
)BR()TT()0 49 1 A(LB_GID)49 0 TN TL()Ec /AF f D( *imp_global_ids,
*exp_global_ids;)ES(\240
)BR()TT()0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D( *imp_local_ids, *exp_local_ids;)ES(\240

)0 P()TT(/* )I(Set load-balancing method.)ES( */)ES(\240
)BR()TT(read_load_balancing_info_from_input_file\201&lb_method\202;)ES(\240
)BR()TT()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D(\201lb,
lb_method, &\201lb_params[0]\202\202;)ES(\240

)0 P()TT(/* )I(Register load-balancing query functions.)ES( */)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 108 1 A(LB_NUM_GEOM_FN_TYPE)108 0 TN TL()Ec /AF f D(,
user_return_dimension, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 100 1 A(LB_GEOM_FN_TYPE)100 0 TN TL()Ec /AF f D(,
user_return_coords, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 77 1 A(LB_NUM_OBJ_FN_TYPE)77 0 TN TL()Ec /AF f D(,
user_return_num_node, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 78 1 A(LB_OBJ_LIST_FN_TYPE)78 0 TN TL()Ec /AF f D(,
user_return_owned_nodes, NULL\202;)ES(\240

)0 P()TT(/* )I(Reset some load-balancing parameters.)ES( */)ES(\240
)BR()TT()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D(\201lb, 
"imbalance_tol", "0.1"\202;)ES(
)BR()TT()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D(\201lb, 
"RCB_Reuse", "TRUE"\202;)ES(

)0 P()TT(/* )I(Perform computations)ES( */)ES(\240
)BR()TT(...)ES(\240
)BR()TT(/* )I(Perform load balancing)ES( */)ES(\240
)BR()TT()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D(\201lb,&new,&num_imp,&imp_global_ids,&imp_local_ids,&imp_procs,)ES(\240
)BR()TT(\240\240\240 &num_exp,&exp_global_ids,&exp_local_ids,&exp_procs\202;\240)ES(\240
)BR()TT(if \201new\202)ES(\240
)BR()TT(\240 perform_data_migration\201...\202;)ES(\240

)0 P()TT(/* )I(Free memory allocated for load-balancing results by LB library)ES(
*/)ES(\240
)BR()TT()0 75 1 A(LB_Free_Data)75 0 TN TL()Ec /AF f D(\201&imp_global_ids,
&imp_local_ids, &imp_procs,\240)ES(\240
)BR()TT(\240\240\240\240\240 &exp_global_ids, &exp_local_ids,
&exp_procs\202;\240)ES(\240
)BR()TT(...)ES(
)BR()TT()0 76 1 A(LB_Destroy_Object)76 0 TN TL()Ec /AF f D(
\201&lb\202;

)BR()TT(...)ES(


)I(Typical calling sequence for performing load balancing
with the Zoltan library.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Typical calling sequence for using the migration-help
tools' auto-migration capability with the dynamic load-balancing tools.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 145 Sn()EA()TT(/* )I(Register load-balancing
query functions.)ES( */)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 108 1 A(LB_NUM_GEOM_FN_TYPE)108 0 TN TL()Ec /AF f D(,
user_return_dimension, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 100 1 A(LB_GEOM_FN_TYPE)100 0 TN TL()Ec /AF f D(,
user_return_coords, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 77 1 A(LB_NUM_OBJ_FN_TYPE)77 0 TN TL()Ec /AF f D(,
user_return_num_particles, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 78 1 A(LB_OBJ_LIST_FN_TYPE)78 0 TN TL()Ec /AF f D(,
user_return_particle_list, NULL\202;)ES(\240

)0 P()TT(/* )I(Tell library to automatically migrate data for the application.)ES(
*/)ES(\240
)BR()TT()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D(\201lb, "AUTO_MIGRATE",
"TRUE"\202;)ES(\240

)0 P()TT(/* )I(Register additional functions for packing and unpacking data)ES(
*/)ES(\240
)BR()TT(/* )I(by migration-help tools. )ES(*/)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 95 1 A(LB_OBJ_SIZE_FN_TYPE)95 0 TN TL()Ec /AF f D(,
user_return_particle_data_size, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 96 1 A(LB_PACK_OBJ_FN_TYPE)96 0 TN TL()Ec /AF f D(,
user_pack_particle_data, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 97 1 A(LB_UNPACK_OBJ_FN_TYPE)97 0 TN TL()Ec /AF f D(,
user_unpack_particle_data, NULL\202;)ES(\240
)BR()TT(...)ES(\240
)BR()TT(/* )I(Perform computations)ES( */)ES(\240
)BR()TT(...)ES(\240
)BR()TT(/* )I(Perform load balancing AND automatic data migration!)ES(
*/)ES(\240
)BR()TT()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D(\201lb,&new,&num_imp,&imp_global_ids,&imp_local_ids,&imp_procs,\240)ES(\240
)BR()TT(\240\240\240 &num_exp,&exp_global_ids,&exp_local_ids,&exp_procs\202;\240)ES(\240

)0 P()TT(/* )I(Free memory allocated for load-balancing results by LB library)ES(
*/)ES(\240
)BR()TT()0 75 1 A(LB_Free_Data)75 0 TN TL()Ec /AF f D(\201&imp_global_ids,
&imp_local_ids, &imp_procs,\240)ES(\240
)BR()TT(\240\240\240\240\240 &exp_global_ids, &exp_local_ids,
&exp_procs\202;\240)ES(\240
)BR()TT(...)ES(

)I(Typical calling sequence for using the migration-help
tools' auto-migration capability with the dynamic load-balancing tools.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Typical calling sequence for user-guided use of
the migration-help tools in Zoltan)ES(.)} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 146 Sn()EA()TT(/* )I(Assume
the load-balancing library returns a decomposition of the)ES( */)ES(\240
)BR()TT(/* )I(nodes of a finite element mesh.)ES( */)ES(\240
)BR()TT()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D(\201lb,&new,&num_imp,&imp_global_ids,&imp_local_ids,&imp_procs,\240)ES(\240
)BR()TT(\240\240\240 &num_exp,&exp_global_ids,&exp_local_ids,&exp_procs\202;\240)ES(\240

)0 P()TT(/* )I(Migrate the nodes as directed by the results of LB_Balance.)ES(
*/)ES(\240
)BR()TT(/* )I(While unpacking nodes, build list of requests for elements
needed)ES( */)ES(\240
)BR()TT(/* )I(to support the imported nodes.)ES(*/)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 95 1 A(LB_OBJ_SIZE_FN_TYPE)95 0 TN TL()Ec /AF f D(,
migrate_node_size, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 96 1 A(LB_PACK_OBJ_FN_TYPE)96 0 TN TL()Ec /AF f D(,
migrate_pack_node, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 97 1 A(LB_UNPACK_OBJ_FN_TYPE)97 0 TN TL()Ec /AF f D(,
migrate_unpack_node, NULL\202;)ES(\240
)BR()TT()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D(\201lb,num_import,imp_global_ids,imp_local_ids,imp_procs,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240 num_export,exp_global_ids,exp_local_ids,exp_procs\202;\240)ES(\240

)0 P()TT(/* )I(Prepare for migration of requested elements.)ES( */)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 96 1 A(LB_PACK_OBJ_FN_TYPE)96 0 TN TL()Ec /AF f D(,
migrate_pack_element, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 97 1 A(LB_UNPACK_OBJ_FN_TYPE)97 0 TN TL()Ec /AF f D(,
migrate_unpack_element, NULL\202;)ES(\240
)BR()TT()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb, )0 95 1 A(LB_OBJ_SIZE_FN_TYPE)95 0 TN TL()Ec /AF f D(,
migrate_element_size, NULL\202;)ES(\240

)0 P()TT(/* )I(From the request lists, a processor knows which elements it
needs)ES( */)ES(\240
)BR()TT(/* )I(to support the imported nodes; it must compute which elements
to)ES( */)ES(\240
)BR()TT(/* )I(send to other processors. )ES(*/)ES(\240
)BR()TT()0 90 1 A(LB_Compute_Destinations)90 0 TN TL()Ec /AF f D(\201lb,
Num_Elt_Requests, Elt_Requests_Global_IDs,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240 Elt_Requests_Local_IDs,
Elt_Requests_Procs,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240 &num_tmp_exp,
&tmp_exp_global_ids,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240 &tmp_exp_local_ids,
&tmp_exp_procs\202;\240)ES(\240

)0 P()TT(/* )I(Processor now knows which elements to send to other processors.)ES(
*/)ES(\240
)BR()TT(/* )I(Send the requested elements. While unpacking elements, build)ES(*/)ES(\240
)BR()TT(/* )I(request lists for "ghost" nodes needed by the imported elements.)ES(
*/)ES(\240
)BR()TT()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D(\201lb,
Num_Elt_Requests, Elt_Requests_Global_IDs,\240)ES(\240
)BR()TT(\240\240\240\240\240\240 Elt_Requests_Local_IDs, Elt_Requests_Procs,\240)ES(\240
)BR()TT(\240\240\240\240\240\240 num_tmp_exp_objs, tmp_exp_global_ids,\240)ES(\240
)BR()TT(\240\240\240\240\240\240 tmp_exp_local_ids, tmp_exp_procs\202;)ES(\240

)0 P()TT(/* )I(Repeat process for "ghost" nodes.)ES( */)ES(\240
)BR()TT(...)ES(

)I(Typical calling sequence for user-guided use of
the migration-help tools in Zoltan)ES(.)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Data types for the query-function examples.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 152 Sn()EA()TT(/*)I( Node data structure.)ES(
*/)ES(\240
)BR()TT(/* )I(A node consists of its 3D coordinates and)ES( */)ES(\240
)BR()TT(/* )I(an ID number that is unique across all processors.)ES( */)ES(\240
)BR()TT(struct Node_Type {\240)ES(\240
)BR()TT(\240 double Coordinates[3];\240)ES(\240
)BR()TT(\240 int Global_ID_Num;\240)ES(\240
)BR()TT(};\240)ES(\240

)0 P()TT(/*)I( Mesh data structure.)ES( */\240)ES(\240
)BR()TT(/* )I(Mesh consists of an array of nodes and)ES( */)ES(\240
)BR()TT(/* )I(the number of nodes owned by the processor.)ES( */)ES(\240
)BR()TT(struct Mesh_Type {)ES(\240
)BR()TT(\240 struct Node_Type Nodes[MAX_NODES];\240)ES(\240
)BR()TT(\240 int Number_Owned;\240)ES(\240
)BR()TT(};)ES(\240

)I(Data types for the query-function examples.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Example of load-balancing query functions \201simplest
implementation\202.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 152 Sn()EA()TT(/* )I(included in file lb/lb_user_const.h)ES(
*/)ES(\240
)BR()TT(/* )I(Both global and local identifiers are integers */)ES()ES(\240
)BR()TT(#define )0 49 1 A(LB_GID)49 0 TN TL()Ec /AF f D( int)ES(\240
)BR()TT(#define )0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D( int)ES(\240

)0 P()2 0.6 1 HR()TT(/* )I(in application's program file)ES( */\240)ES(\240
)BR()TT(#include "lb/lbi_const.h")ES(\240
)BR()TT(#include "lb/lb_user_const.h"\240)ES(\240

)0 P()TT(/* )I(Declare a global Mesh data structure.)ES( */)ES(\240
)BR()TT(struct Mesh_Type Mesh;)ES(\240

)0 P()TT(main\201\202\240)ES(\240
)BR()TT({\240)ES(\240
)BR()TT(...\240)ES(\240
)BR()TT(\240\240\240 /* )I(Register load-balancing query functions.)ES(
*/)ES(\240
)BR()TT(\240\240\240 /* )I(Do not register a data pointer with the
functions;)ES( */)ES(\240
)BR()TT(\240\240\240 /* )I(the global Mesh data structure will be
used.)ES( */)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 100 1 A(LB_GEOM_FN_TYPE)100 0 TN TL()Ec /AF f D(,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_coords, NULL\202;\240\240)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 78 1 A(LB_OBJ_LIST_FN_TYPE)78 0 TN TL()Ec /AF f D(,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_owned_nodes, NULL\202;\240\240)ES(\240
)BR()TT(...\240)ES(\240
)BR()TT(}\240)ES(\240

)0 P()TT(void user_return_owned_nodes\201void *data,\240\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID *global_ids, LB_LID *local_ids,
int *ierr\202\240)ES(\240
)BR()TT({\240)ES(\240
)BR()TT(int i;\240)ES(\240
)BR()TT(\240\240\240 /* )I(return global node numbers as global_ids.)ES(
*/\240)ES(\240
)BR()TT(\240\240\240 /* )I(return index into Nodes array for local_ids.)ES(
*/\240)ES(\240
)BR()TT(\240\240\240 for \201i = 0; i < Mesh.Number_Owned; i++\202{\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240 global_ids[i] = Mesh.Nodes[i].Global_ID_Num;\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240 local_ids[i] = i;\240)ES(\240
)BR()TT(\240\240\240 }\240)ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;\240)ES(\240
)BR()TT(}\240)ES(\240

)0 P()TT(void user_return_coords\201void *data,\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID global_id, LB_LID local_id,\240)ES(\240
)BR()TT(\240\240\240\240 double *geom_vec, int *ierr\202\240)ES(\240
)BR()TT({\240)ES(\240
)BR()TT(\240\240\240 /* )I(use local_id to index into the Nodes array.)ES(
*/\240)ES(\240
)BR()TT(\240\240\240 geom_vec[0] = Mesh.Nodes[local_id].Coordinates[0];\240)ES(\240
)BR()TT(\240\240\240 geom_vec[1] = Mesh.Nodes[local_id].Coordinates[1];\240)ES(\240
)BR()TT(\240\240\240 geom_vec[2] = Mesh.Nodes[local_id].Coordinates[2];\240)ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;\240)ES(\240
)BR()TT(})ES(

)I(Example of load-balancing query functions \201simplest
implementation\202.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Example of load-balancing query functions using
addresses as local identifiers.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 152 Sn()EA()TT(/* )I(included in file lb/lb_user_const.h)ES(
*/)ES(\240
)BR()TT(/* )I(Global identifiers are integers. )ES(*/)ES(\240
)BR()TT(/* )I(Local identifiers are pointers.)ES( */)ES(\240
)BR()TT(#define )0 49 1 A(LB_GID)49 0 TN TL()Ec /AF f D( int)ES(\240
)BR()TT(#define )0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D( )WB [16#FF 16#00 16#00] Sc()3 FZ(void
*)Ef()Ec()ES(\240

)0 P()2 0.6 1 HR()TT(/* )I(in application's program file)ES( */\240)ES(\240
)BR()TT(#include "lb/lbi_const.h")ES(\240
)BR()TT(#include "lb/lb_user_const.h")ES(\240

)0 P()TT(/* )I(Declare a global Mesh data structure.)ES( */)ES(\240
)BR()TT(struct Mesh_Type Mesh;)ES(\240

)0 P()TT(main\201\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(...)ES(\240
)BR()TT(\240\240\240 /* )I(Register load-balancing query functions.)ES(
*/\240)ES(\240
)BR()TT(\240\240\240 /* )I(Do not register a data pointer with the
functions;)ES( */)ES(\240
)BR()TT(\240\240\240 /* )I(the global Mesh data structure will be
used.)ES( */)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 100 1 A(LB_GEOM_FN_TYPE)100 0 TN TL()Ec /AF f D(,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_coords, NULL\202;\240)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 78 1 A(LB_OBJ_LIST_FN_TYPE)78 0 TN TL()Ec /AF f D(,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_owned_nodes, NULL\202;\240)ES(\240
)BR()TT(...)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_return_owned_nodes\201void *data,\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID *global_ids, LB_LID *local_ids,
int *ierr\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(int i;)ES(\240
)BR()TT(\240\240\240 /* )I(return global node numbers as global_ids.)ES(
*/)ES(\240
)BR()TT(\240\240\240 /* )I()WB [16#FF 16#00 16#00] Sc()3 FZ(return address of
Nodes array entries for local_ids.)Ef()Ec()ES( */)ES(\240
)BR()TT(\240\240\240 for \201i = 0; i < Mesh.Number_Owned; i++\202{)ES(\240
)BR()TT(\240\240\240\240\240\240\240 global_ids[i] = Mesh.Nodes[i].Global_ID_Num;)ES(\240
)BR()TT(\240\240\240\240\240\240\240 local_ids[i] = )WB [16#FF 16#00 16#00] Sc()3 FZ(\201void
*\202 &\201Mesh.Nodes[i]\202)Ef()Ec(;)ES(\240
)BR()TT(\240\240\240 })ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_return_coords\201void *data,\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID global_id, LB_LID local_id,\240)ES(\240
)BR()TT(\240\240\240\240 double *geom_vec, int *ierr\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(\240\240\240 /* )I(use local_id to )WB [16#FF 16#00 16#00] Sc()3 FZ(address)Ef()Ec(
the requested node.)ES( */)ES(\240
)BR()TT(\240\240\240 geom_vec[0] = \201\201struct Node_Type *\202 local_id\202->Coordinates[0];)ES(\240
)BR()TT(\240\240\240 geom_vec[1] = \201\201struct Node_Type *\202 local_id\202->Coordinates[1];)ES(\240
)BR()TT(\240\240\240 geom_vec[2] = \201\201struct Node_Type *\202 local_id\202->Coordinates[2];)ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(})ES(

)I(Example of load-balancing query functions using
addresses as local identifiers.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Example of load-balancing query functions using
the application-defined data pointer.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 152 Sn()EA()TT(/* )I(included in file lb/lb_user_const.h)ES(
*/)ES(\240
)BR()TT(/* )I(Both global and local identifiers are integers */)ES()ES(\240
)BR()TT(#define )0 49 1 A(LB_GID)49 0 TN TL()Ec /AF f D( int)ES(\240
)BR()TT(#define )0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D( int)ES(\240

)0 P()2 0.6 1 HR()TT(/* )I(in application's program file)ES( */)ES(\240
)BR()TT(#include "lb/lbi_const.h")ES(\240
)BR()TT(#include "lb/lb_user_const.h")ES(\240

)0 P()TT(main\201\202)ES(\240
)BR()TT({)ES(\240
)BR()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(/* )I(declare a local mesh data structure.)ES(
*/)Ef()Ec()ES(\240
)BR()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(struct Mesh_Type mesh;)Ef()Ec()ES(\240
)BR()TT(...)ES(\240
)BR()TT(\240\240\240 /* )I(Register load-balancing query functions.)ES(
*/)ES(\240
)BR()TT(\240\240\240 /* )I()WB [16#FF 16#00 16#00] Sc()3 FZ(Register the address
of mesh as the data pointer.)Ef()Ec()ES( */)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 100 1 A(LB_GEOM_FN_TYPE)100 0 TN TL()Ec /AF f D(,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_coords, )WB [16#FF 16#00 16#00] Sc()3 FZ(&mesh)Ef()Ec(\202;\240)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 78 1 A(LB_OBJ_LIST_FN_TYPE)78 0 TN TL()Ec /AF f D(,)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240
user_return_owned_nodes, )WB [16#FF 16#00 16#00] Sc()3 FZ(&mesh)Ef()Ec(\202;\240)ES(\240
)BR()TT(...)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_return_owned_nodes\201void *data,\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID *global_ids, LB_LID *local_ids,
int *ierr\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(int i;\240)ES(\240
)BR()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(/* )I(cast data pointer to type Mesh_Type.)ES(
*/)Ef()Ec()ES(\240
)BR()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(struct Mesh_Type *mesh_ptr = \201struct Mesh_Type
*\202 data;)Ef()Ec()ES(\240

)0 P()TT(\240\240\240 /* )I(return global node numbers as global_ids.)ES(
*/)ES(\240)TT(\240)ES(\240
)BR()TT(\240\240\240 /* )I(return index into Nodes array for local_ids.)ES(
*/)ES(\240
)BR()TT(\240\240\240 for \201i = 0; i < mesh_ptr->Number_Owned; i++\202
{)ES(\240
)BR()TT(\240\240\240\240\240\240\240 global_ids[i] = )WB [16#FF 16#00 16#00] Sc()3 FZ(mesh_ptr->Nodes[i].Global_ID_Num)Ef()Ec(;)ES(\240
)BR()TT(\240\240\240\240\240\240\240 local_ids[i] = i;)ES(\240
)BR()TT(\240\240\240 })ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_return_coords\201void *data,\240)ES(\240
)BR()TT(\240\240\240\240 LB_GID global_id, LB_LID local_id,\240)ES(\240
)BR()TT(\240\240\240\240 double *geom_vec, int *ierr\202)ES(\240
)BR()TT({)ES(\240

)0 P()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(/* )I(cast data pointer to type Mesh_Type.)ES(
*/)Ef()Ec()ES(\240
)BR()TT()WB [16#FF 16#00 16#00] Sc()3 FZ(struct Mesh_Type *mesh_ptr = \201struct Mesh_Type
*\202 data;)Ef()Ec()ES(\240

)0 P()TT(\240\240\240 /* )I(use local_id to address the requested node.)ES(
*/)ES(\240
)BR()TT(\240\240\240 geom_vec[0] = )WB [16#FF 16#00 16#00] Sc()3 FZ(mesh_ptr->Nodes[local_id].Coordinates[0])Ef()Ec(;)ES(\240
)BR()TT(\240\240\240 geom_vec[1] = )WB [16#FF 16#00 16#00] Sc()3 FZ(mesh_ptr->Nodes[local_id].Coordinates[1])Ef()Ec(;)ES(\240
)BR()TT(\240\240\240 geom_vec[2] = )WB [16#FF 16#00 16#00] Sc()3 FZ(mesh_ptr->Nodes[local_id].Coordinates[2])Ef()Ec(;)ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(})ES(

)I(Example of load-balancing query functions using
the application-defined data pointer.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
[[0 0 0 0 0 -1 0 0.9 2 0 0 0 0 9 5 {()I(Example of migration-help query functions for
the )0 154 1 A(Basic Example)154 0 TN TL()Ec /AF f D(.)ES()} 1]
 [[0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()3 Sl()WB()WB 152 Sn()EA()TT(main\201\202\240)ES(\240
)BR()TT({\240)ES(\240
)BR()TT(...\240)ES(\240
)BR()TT(\240\240\240 /* )I(Register migration-help query functions.)ES(
*/)ES(\240
)BR()TT(\240\240\240 /* )I(Do not register a data pointer with the
functions;)ES( */)ES(\240
)BR()TT(\240\240\240 /* )I(the global Mesh data structure will be
used.)ES( */)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 95 1 A(LB_OBJ_SIZE_FN_TYPE)95 0 TN TL()Ec /AF f D(, user_size_node,
NULL\202;\240\240)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 96 1 A(LB_PACK_OBJ_FN_TYPE)96 0 TN TL()Ec /AF f D(, user_pack_node,
NULL\202;\240)ES(\240
)BR()TT(\240\240\240 )0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D(\201lb,
)0 97 1 A(LB_UNPACK_OBJ_FN_TYPE)97 0 TN TL()Ec /AF f D(,
user_unpack_node, NULL\202;\240\240)ES(\240
)BR()TT(...\240)ES(\240
)BR()TT(}\240)ES(\240

)0 P()TT(int user_size_node\201void *data, int *ierr\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(/* )I(Return the size of data associated with one node.)ES( */)ES(\240
)BR()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(\240\240\240 return\201sizeof\201struct Node_Type\202\202;)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_pack_node\201void *data, LB_GID global_id, LB_LID local_id,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240
int dest_proc, int size, char *buf, int *ierr\202\240)ES(\240
)BR()TT({)ES(\240
)BR()TT(/* Copy)I( the specified node's data into buffer buf.)ES( */)ES(\240
)BR()TT(struct Node_Type *node_buf = \201struct Node_Type *\202 buf;)ES(\240

)0 P()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(\240\240\240 node_buf->Coordinates[0] = Mesh.Nodes[local_id].Coordinates[0];)ES(\240
)BR()TT(\240\240\240 node_buf->Coordinates[1] = Mesh.Nodes[local_id].Coordinates[1];)ES(\240
)BR()TT(\240\240\240 node_buf->Coordinates[2] = Mesh.Nodes[local_id].Coordinates[2];)ES(\240
)BR()TT(\240\240\240 node_buf->Global_ID_Num = Mesh.Nodes[local_id].Global_ID_Num;)ES(\240
)BR()TT(})ES(\240

)0 P()TT(void user_unpack_node\201void *data, LB_GID global_id, int size,\240)ES(\240
)BR()TT(\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240\240
char *buf, int *ierr\202)ES(\240
)BR()TT({)ES(\240
)BR()TT(/* )I(Copy the node data in buf into the Mesh data structure. )ES(*/)ES(\240
)BR()TT(int i;)ES(\240
)BR()TT(struct Node_Type *node_buf = \201struct Node_Type *\202 buf;)ES(\240

)0 P()TT(\240\240\240 *ierr = LB_OK;)ES(\240
)BR()TT(\240\240\240 i = Mesh.Number_Owned;)ES(\240
)BR()TT(\240\240\240 Mesh.Number_Owned = Mesh.Number_Owned + 1;)ES(\240
)BR()TT(\240\240\240 Mesh.Nodes[i].Coordinates[0] = node_buf->Coordinates[0];)ES(\240
)BR()TT(\240\240\240 Mesh.Nodes[i].Coordinates[1] = node_buf->Coordinates[1];)ES(\240
)BR()TT(\240\240\240 Mesh.Nodes[i].Coordinates[2] = node_buf->Coordinates[2];)ES(\240
)BR()TT(\240\240\240 Mesh.Nodes[i].Global_ID_Num = node_buf->Global_ID_Num;)ES(\240
)BR()TT(})ES(\240

)I(Example of migration-help query functions for
the )0 154 1 A(Basic Example)154 0 TN TL()Ec /AF f D(.)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 [16#FF 16#FF 16#FF] ]
]]
]]
] D
0 1 67{TS}for RC ZF

/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (ug.html) D
/Ti (Sandia National Laboratories - Zoltan User's Guide) D
/Au () D
/Df f D


NP RC ZF
()3 Sl()WB 0 Sn(





)WB 1 Sn()EA(


)2 PT(













)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_intro.html) D
/Ti (Zoltan User's Guide: Introduction) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 2 Sn(

)3 Al()BR(
)0 3 0 H(Zoltan)WB 44 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 1 H()WB 45 Sn()WB 31 Sn()EA(Introduction)EH(
Over the past decade, the use of parallel computing to solve large-scale
scientific problems has grown immensely. Many traditional numerical methods,
such as finite difference and finite element methods, have been shown to
be effective and efficient in parallel computing environments; see [)0 34 1 A(Attaway
et al.)34 0 TN TL()Ec /AF f D(] and [)0 35 1 A(Devine et al.)35 0 TN TL()Ec /AF f D(]
for two examples. They have typically been implemented in an MIMD fashion,
with portions of the problem domain being assigned uniquely to individual
processors. This static decomposition of the domain is done as a pre-processing
step to the actual computation either by the application itself or by some
static partitioning tool such as )0 36 1 A(Chaco)36 0 TN TL()Ec /AF f D(,
)0 37 1 A(Metis)37 0 TN TL()Ec /AF f D(, or )0 38 1 A(Jostle)38 0 TN TL()Ec /AF f D(.

)0 P(As the desire for simulations with greater complexity and resolution
arises, new numerical schemes have been developed, such as adaptive numerical
methods, multiphysics simulations, and adaptive physics models. In these
applications, the amount of work per processor can vary over time. For
example, in adaptive finite element methods, the number of degrees of freedom
within a processor can increase or decrease as the method requires greater
or lower accuracy in a region of the problem domain. The changing processor
work-loads make a static decomposition of the domain insufficient; a dynamic
load-balancing strategy is needed to readjust work- loads as the computation
proceeds.

)0 P(Several important differences exist between static and dynamic load-balancing
strategies. Dynamic strategies are complicated by the fact that they must
be implemented in parallel without interfering with the scalability of
the application. Thus, they must use little memory and execute quickly.
Also because they run side-by-side with an application, dynamic strategies
must use a subroutine interface, rather than the file-based interface used
by most static partitioners. Additionally, dynamic load-balancing algorithms
should be "incremental"; that is, small changes in the processor work loads
should produce only small changes in the decomposition so that little data
movement is required to establish the new decomposition. Most static decomposition
strategies do not explicitly enforce this incremental property; good dynamic
strategies must either implicitly or explicitly enforce it.

)0 P(In the past, most dynamic load-balancing strategies have been implemented
on a case-by-case basis within application programs. Typically, a single
strategy was implemented in an application, relying heavily upon the data
structures of the particular application. This approach has two disadvantages.
First, because its implementation relies heavily upon a single application,
the load-balancing algorithm is not easily re-used by other applications.
Second, because the application developer is usually interested more in
the physics of the simulation than in the performance of dynamic load-balancing
algorithms, only one algorithm is implemented and comparisons to other
load-balancing methods are not performed to find, perhaps, a more effective
strategy.\240 See [)0 39 1 A(Hendrickson
and Devine)39 0 TN TL()Ec /AF f D(] for a more thorough discussion of these issues.

)0 P(The goal of the Zoltan Dynamic Load-Balancing Library project is to
provide application developers a general-purpose dynamic load-balancing
tool that can be easily used by a variety of applications. The library
consists of several different dynamic load-balancing algorithms and is
designed so that new algorithms can easily be added to the library. An
object-oriented library interface separates the data structures of the
load-balancing routines from those of the application. The library's routines
gather information \201such as lists of objects to be balanced, their weights,
and their coordinates\202 from the application through a series of query functions.
These simple query functions must be provided by the application and "registered"
with the library. In this manner, the library never directly accesses the
application's data structures. Use of the library in a different application
requires only that the new application supply its own set of query functions
to the load-balancing library. Once the appropriate query functions are
registered with the load-balancing library, the application can easily
select from a number of load-balancing algorithms and invoke load balancing
at the appropriate places in its computation. While some extra memory and
function-call overhead is required by this call-back protocol, the generality
and ease of use of the library obtained by it is well justified.

)0 P(The Zoltan library consists of two parts: dynamic load-balancing tools
that compute new decompositions based on current processor work loads,
and migration-help tools that perform the communication needed to move
data to establish a new decomposition. Each set of tools is described below.

)0 P(Also included with the library package is a test driver, )I(zdrive)ES(,
which allows developers to test changes to the library without having to
compile the library into and run a large simulation code. For information
on how to build and use )I(zdrive)ES(, see the )0 2 A(Test
Driver)EA( section of the )0 2 A(Zoltan Developer's
Guide)EA(.
)0 2 2 H()WB 46 Sn()WB 3 Sn()EA(Load-Balancing Tools)EH(
Within the Zoltan library, many algorithms for dynamically determining
new processor decompositions can be implemented. Information needed by
the algorithms is obtained through queries to the application's data structures
using application defined and registered query routines. Query routines
provided include both geometric queries \201supplying information such as
coordinates for objects\202 and graph-based queries \201supplying such information
as edge lists for objects in the communication graph of the computation\202.
Capability for tree-based algorithms, using, say, the refinement tree of
an adaptive mesh-refinement application, will be added in the future.

)0 P(A typical interaction between an application and the dynamic load-balancing
tools is shown in the )0 32 1 A(figure)32 0 TN TL()Ec /AF f D( below. Through
a call to )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
the application creates a load-balancing object, which is storage space
to hold pointers to registered functions and load-balancing data. This
object is passed to a number of load-balancing functions. The application
then selects a load-balancing method to be used \201Recursive Coordination
Bisection, "RCB," in the example\202 through a call to )BD()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D()ES(.
Several query functions needed by the RCB algorithm are registered through
calls to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(.
These query functions include application-defined functions to return the
number of objects on the processor \201)I(user_return_num_elems_fn)ES(\202, a
list of the objects \201)I(user_return_elem_list_fn)ES(\202, and the coordinates
for a given object \201)I(user_return_coords_fn)ES(\202. After some computation,
the application calls )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
to compute a new decomposition on the processors.

)0 P(The load-balancing library then follows pointers to the registered query
functions to build the data structures needed for the RCB algorithm. An
array of data is built, with one entry for each object owned by the processor.
The number of objects is determined by following the )I(Get_Num_Obj)ES(
pointer to the )I(user_return_num_elems_fn)ES(. Storage is allocated for
the objects, and lists of the objects' identification numbers are obtained
by following the )I(Get_Obj_List)ES( function pointer to the )I(user_return_elem_list_fn)ES(.
Then, for each object, the object's coordinates are obtained through calls
through the )I(Get_Geom)ES( function pointer to the registered function
)I(user_return_coords_fn)ES(. Once the data structures are built, the load-balancing
library can perform the RCB decomposition and return arrays of information
describing the new decomposition to the application.
)BR(\240
)BR(\240
)5 PT(
\240
)0 2 3 H()WB 47 Sn()WB 4 Sn()EA(Migration-Help Tools)EH(
Data migration is, unfortunately, an extremely application-dependent part
of establishing new decompositions. It involves gathering objects from
the data structures on one processor, sending those objects to a new processor,
inserting the objects into the new processor's data structures, and removing
the objects from the original processor. In addition, auxiliary data may
have to be sent to the new processor to support the objects migrated there.
For example, in a finite element application, the "objects" used in load
balancing may be elements. But when elements are migrated to new processors,
the nodes associated with those elements must also be sent to the new processors,
increasing the dependence of data migration on the application.

)0 P(A general-purpose load-balancing library can not perform all the operations
required for data migration in all applications. However, it can assist
an application with the communication required for data migration. As a
result of the load-balancing algorithm, the library knows where data must
be sent to establish the new decomposition and can perform all needed communication
using communication tools within the library. The application, then, must
specify how to gather data associated with migrating objects and how to
insert that data into the new processor's data structures. Following the
registered query-function design of the dynamic load-balancing tools, migration-help
tools can then be provided to the application. An example of the interaction
between the application and the migration-help tools is shown in the )0 33 1 A(figure)33 0 TN TL()Ec /AF f D(
below. The application registers three additional query functions: a function
that returns the size \201in bytes\202 of the data buffer needed to gather all
of one object's data \201)I(user_elem_size_fn)ES(\202, a function that packs
one object's data into a buffer \201)I(user_pack_one_elem_fn)ES(\202, and a function
that unpacks one object's data and inserts it into the new processor's
data structure \201)I(user_unpack_one_elem_fn)ES(\202.

)0 P(The migration-help tools then use these registered functions with the
results of the load-balancing algorithm to move data between processors.
The migration-help tools follow the )I(Get_Obj_Data_Size)ES( function pointer
to )I(user_elem_size_fn)ES( to obtain the size of the data buffer needed
for an object's data. They allocate appropriately sized import and export
buffers. Through repeated calls to the )I(Pack_Object)ES( function \201)I(user_pack_one_elem_fn)ES(\202,
the migration-help tools fill the export buffer with data for each object
to be exported. The migration-help tools then send the export buffer data
to other processors and receive import data from other processors. Then,
for each object imported, the migration help tools call the registered
)I(Unpack_Object)ES( function \201)I(user_unpack_one_elem_fn)ES(\202 to unpack
the data from the import buffer and insert it in the processor's data structure.
Under this model, the application developer does not have to implement
addition communication routines to perform data migration; the migration-help
tools handle all communication required for data movement.
)BR(\240
)8 PT(
\240
)BR(The migration-help tools are separate modules from the dynamic load-balancing
tools. Thus, an application does not have to use the migration-help tools
even though it uses the dynamic load-balancing tools to compute a new decomposition.
If the application has its own migration routines, it can use them in conjunction
with the load-balancing routines in the load-balancing library.
)BR(\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 5 1 A(Next:\240 Using the Library)5 0 TN TL()Ec /AF f D(\240 |\240
)0 0 1 A(Previous:\240 Table of Contents)0 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_usage.html) D
/Ti (Zoltan User's Guide: Library Usage) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 5 Sn(

)3 Al()BR(
)0 3 4 H(Zoltan)WB 53 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 5 H()WB 54 Sn()WB 48 Sn()EA(Using the Library)EH(

)0 3 6 H()WB 55 Sn()WB 6 Sn()EA(Application Data Types)EH(
Application query functions and application callable library functions
use global and local identifiers \201IDs\202 for objects. All objects to be used
in load balancing must have unique global IDs. Different applications may
use different data types to represent these IDs. One finite element application,
for example, may use integers as global identifiers \201e.g., see [)0 50 1 A(MPSalsa)50 0 TN TL()Ec /AF f D(]\202;
another may use a structure of information including local element counts
and processor numbers \201e.g., see [)0 51 1 A(ALEGRA)51 0 TN TL()Ec /AF f D(]\202.
Since the Zoltan library is designed to work with a number of applications,
it must allow applications to specify data types for global and local IDs.The
local IDs passed to the load-balancing library are not used by the library;
they are provided for the convenience of the application and can contain
any information desired by the application. For instance, pointers to objects
may be passed as local IDs, enabling direct access to object data in the
query function routines. See the )0 14 1 A(application-registered
query functions)14 0 TN TL()Ec /AF f D( for more details.To provide data type information to
the load- balancing library, application developers must define their global
and local ID data types in the file "lb/lb_user_const.h" in the Zoltan
library source code distribution. In addition, they must define macros
to copy global and local IDs and to compare global IDs. The data and macro
definitions that must be included are described in the )0 49 1 A(table)49 0 TN TL()Ec /AF f D(
below.\240 The source code distribution contains an example in which
global IDs are integers and local IDs are pointers to objects.
)BR(\240
)9 PT(

)0 3 7 H()WB 56 Sn()WB 7 Sn()EA(Building the Library)EH(
The Zoltan library is implemented in ANSI C and can be compiled with any
ANSI C compiler.\240 Example Makefiles are included with the source code.
The top-level Makefile includes targets for several architectures, including
Sandia's ASCI Red computer and Intel Paragon. Dependency and object files
and the resulting load-balancing library file are placed in subdirectories
for each architecture. Thus, to build the library for Sandia's ASCI Red
computer, a user types
)BQ(gmake [options] tflop)QB(
where the options that may be specified are listed below.
)10 PT(
The resulting library is stored in Obj_tflop/libzoltan.a. Paths within
the top-level Makefile and the Makefiles in the Obj_* subdirectories may
have to be changed for the user's computing environment.
)0 3 8 H()WB 57 Sn()WB 7 Sn()EA(Building Applications)EH(
The library interface is described in the C include file "lbi_const.h";
this file should be included in all application source files that call
Zoltan library routines. The application should then be linked with the
Zoltan library by including -lzoltan in the linking command for the application.
Communication within the library is performed through MPI, so appropriate
MPI libraries must be linked with the application. If the )I(NO_PARMETIS=1)ES(parameter was not specified when Zoltan was compiled, )0 52 1 A(ParMETIS)52 0 TN TL()Ec /AF f D(
libraries -lparmetis and -lmetis must also be included in the application's
linking command.
)BR(\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 8 1 A(Next:\240 Zoltan Interface Functions)8 0 TN TL()Ec /AF f D(\240
|\240 )0 2 1 A(Previous: Introduction)2 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_interface.html) D
/Ti (Zoltan User's Guide: Interface) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 8 Sn(

)3 Al()BR(
)0 3 9 H(Zoltan)WB 64 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 10 H()WB 65 Sn()WB 58 Sn()EA(Zoltan Interface Functions)EH(
An application calls a series of dynamic load-balancing library functions
to initialize the load balancer, perform load balancing and migrate data.
This section details the syntax of each type of interface function:
)BQ()0 10 1 A(Initialization Interface Functions)10 0 TN TL()Ec /AF f D(
)BR()0 11 1 A(Load-Balancing Interface Functions)11 0 TN TL()Ec /AF f D(
)BR()0 12 1 A(Functions for Augmenting a Decomposition)12 0 TN TL()Ec /AF f D(
)BR()0 13 1 A(Migration-Help Interface Functions)13 0 TN TL()Ec /AF f D()QB(
Examples of the calling sequences for initialization, load-balancing, and
data migration are included in the )0 60 1 A(Initialization)60 0 TN TL()Ec /AF f D(,
)0 61 1 A(Load-Balancing)61 0 TN TL()Ec /AF f D(,
and )0 62 1 A(Migration)62 0 TN TL()Ec /AF f D( sections,
respectively, of the )0 63 1 A(Examples
of Library Usage)63 0 TN TL()Ec /AF f D(.
)0 2 11 H()WB 66 Sn()WB 9 Sn()EA(Error Codes)EH(
All interface functions, with the exception of )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(,
return an error code to the application. The possible return codes are
defined in lbi_const.h, and are listed in the )0 59 1 A(table)59 0 TN TL()Ec /AF f D(
below.
)2 Al()11 PT()Ea(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D( |\240 )0 10 1 A(Next:\240
Initialization Functions)10 0 TN TL()Ec /AF f D(\240 |\240 )0 5 1 A(Previous:\240
Using the Library)5 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_interface_init.html) D
/Ti (Zoltan User's Guide: Interface) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 10 Sn(

)3 Al()BR(
)0 3 12 H(Zoltan)WB 70 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 13 H()WB 71 Sn()WB 67 Sn()EA(Initialization Functions)EH(
Functions used to initialize the library and load-balancing objects are
described below:
)UL()0 68 1 A(LB_Initialize)68 0 TN TL()Ec /AF f D(
)BR()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D(
)BR()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()LU(

)2 0.6 1 HR()12 PT(

)2 0.6 1 HR(The )BD(LB_Initialize)ES( function initializes values needed
in the load-balancing tools. This function must be called with the )I(argc)ES(
and )I(argv)ES( command-line arguments from the main program. If the application
uses MPI, this function should be called after calling )BD(MPI_Init)ES(.
If the application does not use MPI, this function calls )BD(MPI_Init)ES(
for use by the load balancer. It also returns the version of the dynamic
load-balancing library so that users can verify which version of the library
their application is linked to.
)BR(From Fortran, if one of )I(argc)ES( or )I(argv)ES( is omitted, they
must both be omitted. If they are omitted, )I(ver)ES( does NOT have to
be passed as a keyword argument.
)BR(\240
)13 PT(
\240

)0 P()2 0.6 1 HR()14 PT(

)2 0.6 1 HR(The )BD(LB_Create_Object)ES( function allocates memory
for storage of load-balancing information to be used by the load-balancing
library and sets the default values for the load- balancing information.
The pointer returned by this function is passed to many subsequent load-balancing
functions. An application may allocate more than one )BD(LB_Struct)ES( object
if, say, it uses different decompositions with different load-balancing
techniques.
)BR(\240
)15 PT(
\240
)BR()2 0.6 1 HR()16 PT(

)2 0.6 1 HR()BD(LB_Set_Fn)ES( registers an application-supplied query
function in the load-balancing library. Both load-balancing and migration-help
functions are registered through calls to )BD(LB_Set_Fn)ES( .
)BR(\240
)17 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 11 1 A(Next:\240 Load-Balancing Functions)11 0 TN TL()Ec /AF f D(\240
|\240 )0 8 1 A(Previous:\240 Zoltan Interface Functions)8 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_interface_lb.html) D
/Ti (Zoltan User's Guide: Interface) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 11 Sn(

)3 Al()BR(
)0 3 14 H(Zoltan)WB 83 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 15 H()WB 84 Sn()WB 72 Sn()EA(Load-Balancing Functions)EH(
The following functions are the load-balancing interface functions in the
Zoltan library; their descriptions are included below.
)BQ()BD()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 74 1 A(LB_Eval)74 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 75 1 A(LB_Free_Data)75 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 76 1 A(LB_Destroy_Object)76 0 TN TL()Ec /AF f D()ES()QB(

)2 0.6 1 HR()18 PT(

)2 0.6 1 HR()BD(LB_Set_Method)ES( is used to specify which load-balancing
technique should be used by the application.
)BR(\240
)19 PT(
\240
)2 0.6 1 HR()20 PT(

)2 0.6 1 HR()BD(LB_Set_Param)ES( is used to alter the value of one
of the parameters used by Zoltan.\240 All Zoltan parameter have reasonable
default values, but this routine allows a user to provide alternative values
if desired.
)BR(\240
)21 PT(

)2 0.6 1 HR()22 PT(

)2 0.6 1 HR()BD(LB_Balance)ES( invokes the load-balancing routine specified
by )BD()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D()ES(.
)BR(\240
)23 PT(
\240

)0 P()2 0.6 1 HR()24 PT(

)2 0.6 1 HR()BD(LB_Eval )ES(evaluates the quality of the load balance
in the load-balance object pointed to by )I(lb)ES(. Some quality metrics
are only available if the graph query functions have been registered. )BD(LB_Eval)ES(may either print a summary of the results to )I(stdout)ES( or return
the results in the output parameters.
)BR(\240
)25 PT(
An output parameter is returned only if the input value of that parameter
was not NULL. \201An exception is that the error code is always returned.\202
The rationale for this feature is that if one wishes just to print the
evaluation results, one can simply set all \201or some of\202 the output parameters
to NULL in the function call.

)0 P()2 0.6 1 HR()26 PT(

)2 0.6 1 HR()BD(LB_Free_Data)ES( frees the memory allocated by the
load-balancing routines to return the results of )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(.
Memory pointed to by the arguments is freed and the arguments are set to
NULL in C or nullified in Fortran. Note that this does not destroy the
load balancing object itself. That requires a call to )BD()0 76 1 A(LB_Destroy_Object)76 0 TN TL()Ec /AF f D()ES(.
)BR(\240
)27 PT(

)2 0.6 1 HR()28 PT(

)2 0.6 1 HR()BD(LB_Destroy_Object)ES( frees the memory associated with
a load balancing object and sets the object to NULL. Note that )BD(LB_Destroy_Object)ES(
does not deallocate the import and export arrays returned from )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(.
This requires a separate call to )BD()0 75 1 A(LB_Free_Data)75 0 TN TL()Ec /AF f D()ES(.
)BR(\240
)29 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 12 1 A(Next:\240 Functions for Augmenting
a Decomposition)12 0 TN TL()Ec /AF f D(\240 |\240 )0 10 1 A(Previous:\240
Initialization Functions)10 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_interface_augment.html) D
/Ti (Zoltan User's Guide: Interface) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 12 Sn(

)3 Al()BR(
)0 3 16 H(Zoltan)WB 87 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 17 H(Functions)WB 88 Sn( for Augmenting a Decomposition)EH(
The following functions support the addition of new items to an existing
decomposition. Given a decomposition, they determine which processor\201s\202
a new item should be assigned to. Currently, they work in conjunction with
only the\240 )0 21 1 A(RCB)21 0 TN TL()Ec /AF f D( algorithm.
)BQ()BD()0 85 1 A(LB_Point_Assign)85 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 86 1 A(LB_Box_Assign)86 0 TN TL()Ec /AF f D()ES()QB(

)2 0.6 1 HR()30 PT(

)2 0.6 1 HR()BD(LB_Point_Assign)ES( is used to determine which processor
a new point should be assigned to. It is only applicable to geometrically
generated decompositions \201currently only RCB\202. If the parameter )BD(KEEP_CUTS)ES(
is set to TRUE, then the recursive sequence of cuts which define an RCB
decomposition is saved. Given a new geometric point, the processor which
owns it can be determined.
)BR(\240
)31 PT(
\240
)2 0.6 1 HR()32 PT(

)2 0.6 1 HR(In many settings, it is useful to know which processors
might need to know about an extended geometric object. )BD(LB_Box_Assign)ES(
addresses this problem. Given a geometric decomposition of space \201currently
only RCB is supported\202, and given an axis-aligned box around the geometric
object, )BD(LB_Box_Assign)ES( determines which processors own geometry that
intersects the box. To use this routine, the parameter )BD(KEEP_CUTS)ES(
must be set to TRUE when the RCB decomposition is generated. This parameter
will cause the recursive sequence of geometric cuts to be saved, which
is necessary for )BD(LB_Box_Assign)ES( to do its job.
)BR(\240

)0 P(\240
)33 PT(

)2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 13 1 A(Next:\240 Migration-Help Functions)13 0 TN TL()Ec /AF f D(\240
|\240 )0 11 1 A(Previous:\240 Load-Balancing Functions)11 0 TN TL()Ec /AF f D(]\240
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_interface_mig.html) D
/Ti (Zoltan User's Guide: Interface) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 13 Sn(

)3 Al()BR(
)0 3 18 H(Zoltan)WB 98 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 19 H()WB 99 Sn()WB 89 Sn()EA(Migration-Help Functions)EH(
If requested, Zoltan can automatically transfer an application's data between
processors to realize the new decomposition. This functionality will be
performed as part of the call to )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
if the )BD()0 92 1 A(AUTO_MIGRATE)92 0 TN TL()Ec /AF f D()ES(
parameter is set to TRUE \201nonzero\202 via a call to )BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES(.
Alternatively, the application can leave )BD()0 92 1 A(AUTO_MIGRATE)92 0 TN TL()Ec /AF f D()ES(
FALSE and call )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES( itself.
In either case, )0 93 1 A(routines
to pack and unpack object data)93 0 TN TL()Ec /AF f D( must be provided by the application.
See )0 62 1 A(Migration Examples)62 0 TN TL()Ec /AF f D(
for examples with and without auto-migration.

)0 P(The following functions are the migration-help interface functions.
Their detailed descriptions can be found below.
)BQ()BD()0 90 1 A(LB_Compute_Destinations)90 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES()QB(

)2 0.6 1 HR()34 PT(

)2 0.6 1 HR()BD(LB_Compute_Destinations)ES( computes the inverse communication
map needed to export data. That is, given, for each processor, a list of
non-local objects assigned to the processor, )BD(LB_Compute_Destinations)ES(
computes the list of objects each processor needs to export to other processors
to satisfy their assignments of non-local objects.
)BR(\240
)35 PT(
\240

)0 P()2 0.6 1 HR()36 PT(

)2 0.6 1 HR()BD(LB_Help_Migrate)ES( takes lists of objects to be sent
to other processors, along with the destinations of those objects, and
performs the operations necessary to send the data associated with those
objects to their destinations. If a migration pre-processing routine \201)BD()0 94 1 A(LB_PRE_MIGRATE_FN_TYPE)94 0 TN TL()Ec /AF f D()ES(\202
is specified, )BD(LB_Help_Migrate)ES( first calls that function. It then
calls an application-registered function \201)BD()0 95 1 A(LB_OBJ_SIZE_FN_TYPE)95 0 TN TL()Ec /AF f D()ES(\202
to obtain the size of a migrating object's data. For each object, it calls
an application-registered packing routine \201)BD()0 96 1 A(LB_PACK_OBJ_FN_TYPE)96 0 TN TL()Ec /AF f D()ES(\202
to load communication buffers. It communicates the buffers to the destination
processors. Finally, for each object received, it calls an application-registered
unpacking routine \201)BD()0 97 1 A(LB_UNPACK_OBJ_FN_TYPE)97 0 TN TL()Ec /AF f D()ES(\202
to move the data from the received communication buffer into the new processor's
data structures.
)BR(\240
)37 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 14 1 A(Next:\240 Application-Registered Query Functions)14 0 TN TL()Ec /AF f D(\240
|\240 )0 12 1 A(Previous:\240 Functions for
Augmenting a Decomposition)12 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_query.html) D
/Ti (Zoltan User's Guide: Query Functions) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 14 Sn(

)3 Al()BR(
)0 3 20 H(Zoltan)WB 101 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 21 H()WB 102 Sn()WB 69 Sn()EA(Application-Registered
Query Functions)EH(
The load-balancing library gets information about a processor's objects
and work load through calls to load-balancing query functions. These functions
must be provided by the application. They are "registered" with the load-balancing
library; that is, a pointer to the function is passed to the load-balancing
library, which can then call that function when its information is needed.\240
Two categories of query functions are used by the library:
)BQ()0 15 1 A(Load-Balancing Query Functions)15 0 TN TL()Ec /AF f D(
)BR()0 19 1 A(Migration-Help Query Functions)19 0 TN TL()Ec /AF f D()QB(
A variety of query functions can be registered by the user. The query functions
have a function type, describing their purpose to the load-balancing library.
When a function is registered with the load-balancing library through a
call to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(,
its function type is passed to the load-balancing library in the )I(fn_type)ES(
argument. Each function description below will include both its function
type and function prototype.

)0 P(Some algorithms in the load-balancing library require that certain query
functions be registered by the application; for example, geometric partitioning
algorithms such as Recursive Coordinate Bisection \201RCB\202 require that an
)BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES( be registered.
When a default value is specified below, the query function type is optional;
if a function of that type is not registered, the default values are used.
Details of which query functions are required by particular algorithms
are included in the )0 20 1 A(Algorithms)20 0 TN TL()Ec /AF f D( section.

)0 P(Many of the functions have both global and local object identifiers
\201IDs\202 in their argument lists. The global IDs provided by the application
must be unique across all processors; they are used for identification
within the load-balancing library. The local IDs are not used by the load-balancing
library; they are provided for the convenience of the application and can
be anything the application desires. The local IDs can be used by application
query routines to enable direct access to application data. For example,
the object with global ID "3295" may be stored by the application in location
"15" of an array in the processor's local memory. Both global ID "3295"
and local ID "15" can be used by the application to describe the object.
Then, rather than searching the array for global ID "3295," the application
query routines can subsequently use the local ID to index directly into
the local storage array. See )0 6 1 A(Application
Data Types)6 0 TN TL()Ec /AF f D( for a description of global and local IDs.All of the functions
have, as their first argument, a pointer to data that is passed to the
load-balancing library through )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(.
This data is not used by the load-balancing library. A different set of
data can be supplied for each registered function. For example, if the
local ID is an index into an array of data structures, then the data pointer
might point to the head of the data structure array.

)0 P(As their last argument, all functions have an error code that should
be set and returned by the registered function. Currently, only two error
codes are recognized. If the function exits without an error, the error
code should be set to 0. If there is a problem, the error code should be
set to some non-zero value.
)BR(\240
)BR(\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 15 1 A(Next:\240 Load-Balancing Query Functions)15 0 TN TL()Ec /AF f D(\240
|\240 )0 13 1 A(Previous:\240 Migration-Help
Functions)13 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_query_lb.html) D
/Ti (Zoltan User's Guide: Query Functions) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 15 Sn(

)3 Al()BR(
)0 3 22 H(Zoltan)WB 109 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 23 H()WB 110 Sn()WB 103 Sn()EA(Load-Balancing Query Functions)EH(
The following registered functions are provided for use by various load-balancing
algorithms in the Zoltan library:
)BQ()0 16 1 A(General Functions)16 0 TN TL()Ec /AF f D(
)BQ()BD()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 104 1 A(LB_NUM_BORDER_OBJ_FN)104 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 105 1 A(LB_BORDER_OBJ_LIST_FN)105 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 106 1 A(LB_FIRST_BORDER_OBJ_FN)106 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 107 1 A(LB_NEXT_BORDER_OBJ_FN)107 0 TN TL()Ec /AF f D()ES()QB(
)0 17 1 A(Geometry-Based Functions)17 0 TN TL()Ec /AF f D(
)BQ()BD()0 108 1 A(LB_NUM_GEOM_FN)108 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES()QB(
)0 18 1 A(Graph-Based Functions)18 0 TN TL()Ec /AF f D(
)BQ()BD()0 81 1 A(LB_NUM_EDGES_FN)81 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 82 1 A(LB_EDGE_LIST_FN)82 0 TN TL()Ec /AF f D()ES()QB()QB(
\240
)0 2 24 H()WB 111 Sn()WB 16 Sn()EA(General Functions)EH(

)2 0.6 1 HR()WB 77 Sn()EA(typedef int )BD(LB_NUM_OBJ_FN)ES(\201void
*)I( data)ES(,)I( )ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NUM_OBJ_FN)ES( query function returns the number
of objects to be balanced that are currently assigned to the processor.
)BR(\240
)38 PT(
\240

)0 P()2 0.6 1 HR()WB 78 Sn()EA(typedef void)BD( LB_OBJ_LIST_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( *)I( global_ids)ES(, )BD(LB_LID)ES( *)I( local_ids)ES(,
int )I(wgt_dim)ES(, float * )I(obj_wgts,)ES( int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_OBJ_LIST_FN)ES( query function fills two \201three
if weights are used\202 arrays with information about the objects currently
assigned to the processor. Both arrays are allocated \201and subsequently
freed\202 by the load-balancing library using a query to an )BD()0 77 1 A(LB_NUM_OBJ_FN)77 0 TN TL()Ec /AF f D()ES(
query function to get the array size. For many algorithms, either an )BD(LB_OBJ_LIST_FN)ES(
query function or an )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(/)BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)39 PT(
\240

)0 P()2 0.6 1 HR()WB 79 Sn()EA(typedef int )BD(LB_FIRST_OBJ_FN)ES(\201void
*)I( data, )ES()BD(LB_GID )ES(*)I( first_global_id)ES(, )BD(LB_LID)ES( *)I(first_local_id)ES(, int )I(wgt_dim,)ES( float * )I(first_obj_wgt)ES(,\240)I()ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_FIRST_OBJ_FN)ES( query function initializes an
iteration over objects assigned to the processor. It returns the global
and local IDs of the first object on the processor. Subsequent calls to
an )BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES( query function iterate
over and return other objects assigned to the processor. This query-function
pair frees the application from having to build an array of objects \201as
in )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(\202 and allows the
load-balancing routines to obtain only as much information about objects
as they need. For many algorithms, either an )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
query function or an )BD(LB_FIRST_OBJ_FN)ES()I(/)ES()BD()0 80 1 A(LB_NEXT_OBJ_FN)80 0 TN TL()Ec /AF f D()ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)40 PT(
\240

)0 P()2 0.6 1 HR()WB 80 Sn()EA(typedef int )BD(LB_NEXT_OBJ_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, )BD(LB_LID )ES()I(local_id)ES(,
)BD(LB_GID )ES(*)I( next_global_id)ES(, )BD(LB_LID)ES( *)I( next_local_id)ES(,
int )I(wgt_dim,)ES( float * )I(next_obj_wgt)ES(, int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NEXT_OBJ_FN)ES( query function is an iterator
function which, when given an object assigned to the processor, returns
the next object assigned to the processor. The first object of the iteration
is provided by an )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(
query function. This query-function pair frees the application from having
to build an array of objects \201as in )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(\202
and allows the load-balancing routines to obtain only as much information
about objects as they need. For many algorithms, either an )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
query function or an )BD()0 79 1 A(LB_FIRST_OBJ_FN)79 0 TN TL()Ec /AF f D()ES(/)BD(LB_NEXT_OBJ_FN)ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)41 PT(
\240

)0 P()2 0.6 1 HR()WB 104 Sn()EA(typedef int )BD(LB_NUM_BORDER_OBJ_FN)ES(\201void
*)I( data)ES(, int )I(nbor_proc)ES(, int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NUM_BORDER_OBJ_FN)ES( query function returns
the number of objects sharing a processor subdomain border \201in the communication
graph of the application\202 with a given processor.
)BR(\240
)42 PT(
\240

)0 P()2 0.6 1 HR()WB 105 Sn()EA(typedef void )BD(LB_BORDER_OBJ_LIST_FN)ES(\201void
*)I( data)ES(, int )I(nbor_proc)ES(, )BD(LB_GID )ES(*)I( global_ids)ES(,
)BD(LB_LID)ES( *)I( local_ids)ES(,)I( )ES(int )I(wgt_dim)ES(, float * )I(obj_wgts,)ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_BORDER_OBJ_LIST_FN)ES( query function fills two
arrays with information about the objects currently assigned to the processor
that share a processor subdomain border \201in the communication graph of
the application\202 with a given processor. Both arrays are allocated \201and
subsequently freed\202 by the load-balancing library using a query to an )BD()0 104 1 A(LB_NUM_BORDER_OBJ_FN)104 0 TN TL()Ec /AF f D()ES(
query function to get the array size. For certain load-balancing algorithms,
either an )BD(LB_BORDER_OBJ_LIST_FN)ES( query function or an )BD()0 106 1 A(LB_FIRST_BORDER_OBJ_FN)106 0 TN TL()Ec /AF f D()ES(/)BD()0 107 1 A(LB_NEXT_BORDER_OBJ_FN)107 0 TN TL()Ec /AF f D()ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)43 PT(
\240

)0 P()2 0.6 1 HR()WB 106 Sn()EA(typedef int )BD(LB_FIRST_BORDER_OBJ_FN)ES(\201void
*)I( data)ES(, int )I(nbor_proc)ES(, )BD(LB_GID)ES( *)I( first_global_id)ES(,
)BD(LB_LID )ES(*)I( first_local_id)ES(,)I( )ES(int)I( wgt_dim, )ES(float)I(* first_obj_wgt, )ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_FIRST_BORDER_OBJ_FN)ES( query function initializes
an iteration over objects assigned to the processor that share a processor
subdomain border with a given processor. It returns the global and local
IDs of the first object on the processor along the specified subdomain
border. Subsequent calls to an )BD()0 107 1 A(LB_NEXT_BORDER_OBJ_FN)107 0 TN TL()Ec /AF f D()ES(
query function iterate over and return other objects along the requested
subdomain border. This query-function pair frees the application from having
to build an array of objects \201as in )BD()0 105 1 A(LB_BORDER_OBJ_LIST_FN)105 0 TN TL()Ec /AF f D()ES(\202
and allows the load-balancing routines to obtain only as much information
about objects as they need. For some load-balancing algorithms, either
an )BD()0 105 1 A(LB_BORDER_OBJ_LIST_FN)105 0 TN TL()Ec /AF f D()ES( query
function or an )BD(LB_FIRST_BORDER_OBJ_FN)ES(/)BD()0 107 1 A(LB_NEXT_BORDER_OBJ_FN)107 0 TN TL()Ec /AF f D()ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)44 PT(
\240

)0 P()2 0.6 1 HR()WB 107 Sn()EA(typedef int )BD(LB_NEXT_BORDER_OBJ_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, )BD(LB_LID)ES( )I(local_id)ES(,
int )I(nbor_proc)ES(, )BD(LB_GID)ES( *)I( next_global_id)ES(, )BD(LB_LID)ES(
*)I( next_local_id)ES(,)I( )ES(int )I(wgt_dim, )ES(float )I(*next_obj_wgt,,)ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NEXT_BORDER_OBJ_FN)ES( query function is an iterator
function which, when given an object assigned to the processor and a neighboring
processor ID, returns the next object assigned to the processor that shares
a subdomain border with the neighboring processor. The first object of
the iteration is provided by an )BD()0 106 1 A(LB_FIRST_BORDER_OBJ_FN)106 0 TN TL()Ec /AF f D()ES(
query function. This query-function pair frees the application from having
to build an array of objects \201as in )BD()0 105 1 A(LB_BORDER_OBJ_LIST_FN)105 0 TN TL()Ec /AF f D()ES(\202
and allows the load-balancing routines to obtain only as much information
about objects as they need. For some load-balancing algorithms, either
an )BD()0 105 1 A(LB_BORDER_OBJ_LIST_FN)105 0 TN TL()Ec /AF f D()ES( query
function or an )BD()0 106 1 A(LB_FIRST_BORDER_OBJ_FN)106 0 TN TL()Ec /AF f D()ES(/)BD(LB_NEXT_BORDER_OBJ_FN)ES(
query-function pair must be registered to allow the load-balancing library
to obtain needed object information; however, both query options need not
be provided.
)BR(\240
)45 PT(
\240
)0 2 25 H()WB 112 Sn()WB 17 Sn()EA(Geometry-based Functions)EH(

)2 0.6 1 HR()WB 108 Sn()EA(typedef int )BD(LB_NUM_GEOM_FN)ES(\201void
*)I( data)ES(, int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NUM_GEOM_FN)ES( query function returns the number
of values needed to express the geometry of an object. For example, for
a two-dimensional mesh-based application, \201)I(x)ES(,)I(y)ES(\202 coordinates
are needed to describe an object's geometry; thus the )BD(LB_NUM_GEOM_FN)ES(
query function should return the value of two. For a similar three-dimensional
application, the return value should be three.
)BR(\240
)46 PT(
\240

)0 P()2 0.6 1 HR()WB 100 Sn()EA(typedef void )BD(LB_GEOM_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, )BD(LB_LID)ES( )I(local_id)ES(,
double *)I( geom_vec)ES(, int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_GEOM_FN)ES( query function returns a vector of
geometry values for a given object. The geometry vector is allocated by
the load-balancing library to be of the size returned by an )BD()0 108 1 A(LB_NUM_GEOM_FN)108 0 TN TL()Ec /AF f D()ES(
query function.
)BR(\240
)47 PT(
\240
)BR(\240
)0 2 26 H()WB 113 Sn()WB 18 Sn()EA(Graph-based Functions)EH(

)2 0.6 1 HR()WB 81 Sn()EA(typedef int )BD(LB_NUM_EDGES_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID )ES()I(global_id)ES(, )BD(LB_LID)ES( )I(local_id)ES(,
int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_NUM_EDGES_FN)ES( query function returns the number
of edges for a given object in the communication graph of the application
\201i.e., the number of objects with which the given object must share information\202.
)BR(\240
)48 PT(
\240

)0 P()2 0.6 1 HR()WB 82 Sn()EA(typedef void )BD(LB_EDGE_LIST_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, )BD(LB_LID )ES()I(local_id)ES(,
)BD(LB_GID)ES( *)I( nbor_global_id)ES(, int * )I(nbor_procs)ES(, int )I(wgt_dim)ES(,
int * )I(ewgts,)ES( int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_EDGE_LIST_FN)ES( query function returns lists
of global IDs, local IDs, and optionally edge weights for objects sharing
an edge with a given object \201i.e., objects that must share information
with the given object\202. The arrays for the returned neighbor lists are
allocated by the load-balancing library; their size is determined by a
call to an )BD()0 81 1 A(LB_NUM_EDGES_FN)81 0 TN TL()Ec /AF f D()ES( query function.
)BR(\240
)49 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 19 1 A(Next:\240 Migration-Help Query Functions)19 0 TN TL()Ec /AF f D(\240
|\240 )0 14 1 A(Previous:\240 Application-Registered
Query Functions)14 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_query_mig.html) D
/Ti (Zoltan User's Guide: Query Functions) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 19 Sn(

)3 Al()BR(
)0 3 27 H(Zoltan)WB 115 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 28 H()WB 116 Sn()WB 93 Sn()EA(Migration-Help Query Functions)EH(
The following query functions must be registered to use any of the migration-help
tools described in )0 13 1 A(Migration-Help Functions)13 0 TN TL()Ec /AF f D(:
)BQ()BD()0 95 1 A(LB_OBJ_SIZE_FN)95 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 96 1 A(LB_PACK_OBJ_FN)96 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 97 1 A(LB_UNPACK_OBJ_FN)97 0 TN TL()Ec /AF f D()ES()QB(
Optional, additional query functions for migration-help may also be registered:
)BQ()BD()0 94 1 A(LB_PRE_MIGRATE_FN)94 0 TN TL()Ec /AF f D()ES(
)BR()BD()0 114 1 A(LB_POST_MIGRATE_FN)114 0 TN TL()Ec /AF f D()ES()QB(

)2 0.6 1 HR()WB 95 Sn()EA(typedef int )BD(LB_OBJ_SIZE_FN)ES(\201void
*)I( data)ES(,)I( )ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_OBJ_SIZE_FN)ES( query function returns the size
\201in bytes\202 of the data buffer that is needed to pack all of a single object's
data. It is assumed that all objects to be packed in a single )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
call are of the same size. When this assumption is not true, the maximum
size of the objects to be packed should be returned by )BD(LB_OBJ_SIZE_FN)ES(.
This assumption may be relaxed in future releases of the library.
)BR(\240
)BR(\240
)50 PT(
\240

)0 P()2 0.6 1 HR()WB 94 Sn()EA(typedef void )BD(LB_PRE_MIGRATE_FN)ES(\201void
*)I( data)ES(, int )I(num_import)ES(, )BD(LB_GID )ES(*)I( import_global_ids)ES(,
)BD(LB_LID)ES( *)I( import_local_ids)ES(, int *)I( import_procs)ES(, int
)I(num_export)ES(, )BD(LB_GID )ES(*)I( export_global_ids)ES(, )BD(LB_LID)ES(*)I( export_local_ids)ES(, int *)I( export_procs)ES(,)I( )ES(int)I(*ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_PRE_MIGRATE_FN)ES( query function performs any
pre-processing desired by the application. If it is registered, it is called
at the beginning of the )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
routine. The arguments passed to )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
are made available for use in the pre-processing routine.
)BR(\240
)51 PT(
\240
)BR()2 0.6 1 HR()WB 114 Sn()EA(typedef void )BD(LB_POST_MIGRATE_FN)ES(\201void
*)I( data)ES(, int )I(num_import)ES(, )BD(LB_GID )ES(*)I( import_global_ids)ES(,
)BD(LB_LID)ES( *)I( import_local_ids)ES(, int *)I( import_procs)ES(, int
)I(num_export)ES(, )BD(LB_GID )ES(*)I( export_global_ids)ES(, )BD(LB_LID)ES(*)I( export_local_ids)ES(, int *)I( export_procs)ES(,)I( )ES(int)I(*ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_POST_MIGRATE_FN)ES( query function performs any
post-processing desired by the application. If it is registered, it is
called at the end of the )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
routine. The arguments passed to )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
are made available for use in the post-processing routine.
)BR(\240
)52 PT(
\240
)BR()2 0.6 1 HR()WB 96 Sn()EA(typedef void )BD(LB_PACK_OBJ_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, )BD(LB_LID)ES()I(local_id)ES(,
int )I(dest_proc)ES(, int )I(size)ES(, char *)I( buf)ES(,)I( )ES(int)I(*ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_PACK_OBJ_FN)ES( query function allows the application
to tell the load-balancing library how to copy all needed data for a given
object into a communication buffer. The object's data can then be sent
to another processor as part of data migration. It may also perform other
computation, such as removing the object from the processor's data structure.
This routine is called by )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
for each object to be sent to another processor.
)BR(\240
)53 PT(
\240

)0 P()2 0.6 1 HR()WB 97 Sn()EA(typedef void )BD(LB_UNPACK_OBJ_FN)ES(\201void
*)I( data)ES(, )BD(LB_GID)ES( )I(global_id)ES(, int )I(size)ES(, char *)I(buf)ES(,)I( )ES(int)I( *ierr)ES(\202;\240
)2 0.6 1 HR(An )BD(LB_UNPACK_OBJ_FN)ES( query function allows the application
to tell the load-balancing library how to copy all needed data for a given
object from a communication buffer into the application's data structure.
This operation is needed as the final step of importing objects during
data migration. The query function may also perform other computation,
such as building request lists for related data. This routine is called
by )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
for each object to be received by the processor. \201Note: a local ID for
the object is not included in this function, as the local ID is local to
the exporting, not the importing, processor.\202
)BR(\240
)54 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 20 1 A(Next:\240 Algorithms)20 0 TN TL()Ec /AF f D(\240 |\240 )0 15 1 A(Previous:\240
Load-Balancing Query Functions)15 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_alg.html) D
/Ti (Zoltan User's Guide: Algorithms) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 20 Sn(

)3 Al()BR(
)0 3 29 H(Zoltan)WB 119 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 30 H()WB 120 Sn()WB 117 Sn()EA(Algorithms)EH(
The following dynamic load-balancing algorithms are currently included
in the Zoltan library:
)BQ()0 21 1 A(Recursive Coordinate Bisection
\201RCB\202)21 0 TN TL()Ec /AF f D(
)BR()0 52 1 A(ParMETIS \201PARMETIS\202)52 0 TN TL()Ec /AF f D(
)BR()0 23 1 A(Octree Partitioning \201OCTPART\202)23 0 TN TL()Ec /AF f D()QB(
The parenthetical string is the input argument for )BD()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D()ES(
to enable the corresponding method. For further analysis and discussion
of the algorithms, see [)0 39 1 A(Hendrickson
and Devine)39 0 TN TL()Ec /AF f D(].

)0 P(The behavior of each method is controlled by several parameters which
can be set by calls to )BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES(.
Although many of the parameters are specific to individual partitioning
algorithms, several have meaning across multiple algorithms. These more
general parameters include the following.
)BR(\240
)55 PT(

)2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 118 1 A(Next:\240 Recursive Coordinate Bisection \201RCB\202)118 0 TN TL()Ec /AF f D(\240
|\240 )0 19 1 A(Previous:\240 Migration-Help Query
Functions)19 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_alg_rcb.html) D
/Ti (Zoltan User's Guide: RCB) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 118 Sn(

)3 Al()BR(
)0 3 31 H(Zoltan)WB 122 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 32 H()WB 123 Sn()WB 21 Sn()EA(Recursive Coordinate Bisection \201RCB\202)EH(
An implementation of Recursive Coordinate Bisection \201RCB\202 due to Steve
Plimpton of Sandia National Laboratories is included in the dynamic load-balancing
library. RCB was first proposed as a static load-balancing algorithm by
)0 121 1 A(Berger and Bokhari)121 0 TN TL()Ec /AF f D(, but is attractive
as a dynamic load-balancing algorithm because it implicitly produces incremental
partitions. In RCB, the computational domain is first divided into two
regions by a cutting plane orthogonal to one of the coordinate axes so
that half the work load is in each of the sub-regions. The splitting direction
is determined by computing in which coordinate direction the set of objects
is most elongated, based upon the geometric locations of the objects. The
sub-regions are then further divided by recursive application of the same
splitting algorithm until the number of sub-regions equals the number of
processors. Although this algorithm was first devised to cut into a number
of sets which is a power of two, the set sizes in a particular cut needn't
be equal. By adjusting the partition sizes appropriately, any number of
equally-sized sets can be created.  If the parallel machine has processors
with different speeds, unequally-sized sets can also be easily generated.
The Zoltan implementation of RCB has several parameters which can be
modified by the
)BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES( function.
)BR(\240
)BR(\240
)56 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 52 1 A(Next:\240 ParMETIS)52 0 TN TL()Ec /AF f D( |\240 )0 20 1 A(Previous:\240
Algorithms)20 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_alg_parmetis.html) D
/Ti (Zoltan User's Guide: SFC) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 52 Sn(

)3 Al()BR(
)0 3 33 H(Zoltan)WB 125 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 34 H()WB 126 Sn()WB 22 Sn()EA(ParMETIS)EH(
ParMETIS is a parallel library for graph partitioning\240 \201and repartitioning\202
developed at the University of Minnesota by Karypis, Schloegel and\240
Kumar. ParMETIS is therefore strictly speaking not a method but rather
a collection of methods. In the Zoltan context, ParMETIS is a method with
many sub-methods. Zoltan provides an interface to all the ParMETIS \201sub-\202methods.\240
The user selects which ParMETIS method to use through the parameter PARMETIS_METHOD.
Most of the ParMETIS methods are based on either multilevel Kernighan-Lin
partitioning or some diffusion algorithm. The names of the ParMETIS methods
used by Zoltan are identical to those in the ParMETIS library. For further
information about the various ParMETIS methods and parameters, please consult
the ParMETIS User's Guide.

)0 P(This interface is currently compatible with ParMETIS version 2.0.\240
There is no guarantee that Zoltan will work correctly if you have a different
version of ParMETIS on your computer. Source and documentation for ParMETIS
can be obtained from the )R10 2 A(ParMETIS
home page)EA(. As a courtesy service,\240 a compatible version of the
ParMETIS\240 source code will be distributed with Zoltan. However, ParMETIS
is a completely separate library. If you do not wish to install ParMETIS,
it is possible to compile Zoltan without any references to ParMETIS\240
\201set the NO_PARMETIS flag when you 'make' Zoltan\202.

)0 P(We only give a brief summary of the various ParMETIS methods here; for
more details see the ParMETIS documentation. The methods fall into three
categories:
)4 OL()-1 LI(Part* - Perform graph partitioning without consideration
of the initial distribution.

)-1 LI(Repart* - Incremental algorithms with small migration cost.

)-1 LI(Refine* - Refines a given partitioning \201balance\202.\240 Can be applied
multiple times to reduce the communication cost \201cut weight\202 if desired.)LO(
As a rule of thumb, use one of the Part* methods if you have a poor initial
balance and you are willing to spend some time doing migration. Use the
Repart* methods when you have a reasonably good load balance that you wish
to update incrementally \201for example, in adaptive mesh refinement\202.
)BR(\240
)BR(The current version of Zoltan ignores the imbalance tolerance parameter,
IMBALANCE_TOL, when ParMETIS is used. The reason is that
the corresponding imbalance parameter is fixed at 0.05 in ParMETIS 2.0. 
We expect that
future versions of ParMETIS will allow the user to select the tolerance
for load imbalance. When this feature becomes available in
ParMETIS, it will also be supported through IMBALANCE_TOL in Zoltan.
)BR(\240
)57 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 124 1 A(Next:\240 Octree/Space-Filling Curve \201SFC\202
Partitioning)124 0 TN TL()Ec /AF f D(\240 |\240 )0 118 1 A(Previous:\240
Recursive Coordinate Bisection \201RCB\202)118 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_alg_oct.html) D
/Ti (Zoltan User's Guide: SFC) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 124 Sn(

)3 Al()BR(
)0 3 35 H(Zoltan)WB 134 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 36 H()WB 135 Sn()WB 23 Sn()EA(Octree/Space-Filling Curve \201SFC\202 Partitioning)EH(
The Octree Partitioning algorithm is based upon work in load balancing
for parallel mesh generation at Rensselaer Polytechnic Institute [)0 127 1 A(Flaherty,
Loy et al.)127 0 TN TL()Ec /AF f D(]. It was implemented in the library by Luis Gervasio, Department
of Computer Science, Rensselaer Polytechnic Institute, as his summer project
in 1998 [)0 128 1 A(Gervasio)128 0 TN TL()Ec /AF f D(].An octree is a spatial
decomposition of the computational domain in which the root of the tree,
representing the entire domain, is recursively divided by two in each coordinate
direction \201producing eight or four "child" octants in 3D or 2D, respectively\202
until each subregion holds at most an application-specified number of objects.
These subregions are represented by the leaves of the octree. The octree
data structure is widely used in mesh generation and adaptive mesh refinement
[)UN()0 129 1 A(Baehmann et al.)129 0 TN TL()Ec /AF f D()NU(, )UN()0 130 1 A(Shephard
and Georges)130 0 TN TL()Ec /AF f D()NU(].The octree resulting from such a spatial decomposition
of the domain can be used to partition an application's work [)0 131 1 A(Edwards)131 0 TN TL()Ec /AF f D(,
)0 132 1 A(Pilkington and Baden)132 0 TN TL()Ec /AF f D(, )0 133 1 A(Warren
and Salmon)133 0 TN TL()Ec /AF f D(]. To partition an octree, a traversal of the tree is used
to define a global ordering on the leaves of the octree. This global ordering
is often referred to as a Space-Filling Curve \201SFC\202. The leaves of the
octree can be easily assigned to processors in a manner which equally distributes
work by assigning slices of the ordered list to processors. Different tree-traversal
algorithms produce different global orderings or SFCs, with some SFCs having
better connectivity and partition quality properties than others. Currently,
Morton Indexing \201i.e., Z-curve\202, Grey Code, and Hilbert SFCs are supported.
Morton Indexing and Grey Code SFCs are the simplest \201and currently, the
fastest\202 of the SFC algorithms, but they produce lower-quality partitions
than the Hilbert SFC. Further work will be performed to improve the performance
of the Hilbert SFC algorithm implemented in the library.
)BR(\240
)58 PT(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 24 1 A(Next:\240 Examples of Library Usage)24 0 TN TL()Ec /AF f D(\240
|\240 )0 52 1 A(Previous:\240\240 ParMETIS)52 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_examples.html) D
/Ti (Zoltan User's Guide: Examples) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 24 Sn(

)3 Al()BR(
)0 3 37 H(Zoltan)WB 136 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 38 H()WB 137 Sn()WB 63 Sn()EA(Examples of Library Usage)EH(
Examples for each part of the Zoltan load-balancing library are provided:
)BQ()0 25 1 A(Initialization of the library)25 0 TN TL()Ec /AF f D(
)BR()0 26 1 A(Load-balancing calling sequence)26 0 TN TL()Ec /AF f D(
)BR()0 27 1 A(Data migration calling sequences)27 0 TN TL()Ec /AF f D(
)BR()0 28 1 A(Query functions for a simple application)28 0 TN TL()Ec /AF f D()QB(

)2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 25 1 A(Next:\240 Initialization Example)25 0 TN TL()Ec /AF f D(\240
|\240 )0 124 1 A(Previous:\240 Octree/Space-Filling
Curve \201SFC\202 Partitioning)124 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_examples_init.html) D
/Ti (Zoltan User's Guide: Examples) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 25 Sn(

)3 Al()BR(
)0 3 39 H(Zoltan)WB 139 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 40 H()WB 140 Sn()WB 60 Sn()EA(Initialization Example)EH(
Before computing new decompositions using Zoltan, an application must initialize
the load-balancing library. This initialization is accomplished through
calls to )BD()0 68 1 A(LB_Initialize)68 0 TN TL()Ec /AF f D()ES(
and )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.
In the )0 138 1 A(figure)138 0 TN TL()Ec /AF f D( below, an example of the
initialization calling sequence is shown. In this example, )BD()0 68 1 A(LB_Initialize)68 0 TN TL()Ec /AF f D()ES(
is called using the )I(argc)ES( and )I(argv)ES( arguments to the main program.
Then a load-balancing object is returned by the call to )BD()0 40 1 A(LB_Create_Object)40 0 TN TL()Ec /AF f D()ES(.
In this example, all processors will be involved in load balancing, as
)BD(MPI_COMM_WORLD)ES( is passed as the communicator to be used by the load-balancing
routines.
)BR(\240
)2 Al()59 PT()Ea(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 26 1 A(Next:\240 Load-Balancing Example)26 0 TN TL()Ec /AF f D(\240
|\240 )0 24 1 A(Previous:\240 Examples of Library
Usage)24 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_examples_lb.html) D
/Ti (Zoltan User's Guide: Examples) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 26 Sn(

)3 Al()BR(
)0 3 41 H(Zoltan)WB 142 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 42 H()WB 143 Sn()WB 61 Sn()EA(Load-Balancing Example)EH(
An example of the typical calling sequence for load balancing using Zoltan
in a finite element application is shown in the )0 141 1 A(figure)141 0 TN TL()Ec /AF f D(
below. An application first selects a load-balancing algorithm through a
call to )BD()0 41 1 A(LB_Set_Method)41 0 TN TL()Ec /AF f D()ES(.
Appropriate query functions are then registered with the load-balancing
library through a series of calls to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(.
In the example, a geometric algorithm, such as RCB, is assumed. Application
query functions returning lists and coordinates of nodes of the finite
element mesh are registered. Next, some parameter values are set by calls
to )BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES(.
After some computation, load balancing is
invoked by calling )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(.
The results of the load balancing include the number of nodes to be imported
and exported to the processor, lists of global and local IDs of the imported
and exported nodes, and source and destination processors of the imported
and exported nodes. The return value of )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
is tested to see whether the new decomposition differs from the old one.
If the decompositions differ, some sort of data migration is needed to
establish the new decomposition; the details of migration are not shown
in this )0 141 1 A(figure)141 0 TN TL()Ec /AF f D( but will be addressed in the
)0 27 1 A(migration examples)27 0 TN TL()Ec /AF f D(. After the data migration
is completed, the arrays of information about imported and exported nodes
returned by )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
are freed by a call to )BD()0 75 1 A(LB_Free_Data)75 0 TN TL()Ec /AF f D()ES(.
Finally, when the application is all finished with the load balancing operations,
it calls )BD()0 76 1 A(LB_Destroy_Object)76 0 TN TL()Ec /AF f D()ES(.
)BR(\240
)BR(\240
)2 Al()60 PT()Ea(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 27 1 A(Next:\240 Migration Examples)27 0 TN TL()Ec /AF f D(\240
|\240 )0 25 1 A(Previous:\240 Initialization
Example)25 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_examples_mig.html) D
/Ti (Zoltan User's Guide: Examples) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 27 Sn(

)3 Al()BR(
)0 3 43 H(Zoltan)WB 147 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 44 H()WB 148 Sn()WB 62 Sn()EA(Migration Examples)EH(
Data migration using Zoltan's migration-help tools can be accomplished
in two different ways:
)BQ()0 144 1 A(auto-migration)144 0 TN TL()Ec /AF f D(, or
)BR()0 146 1 A(user-guided migration)146 0 TN TL()Ec /AF f D(.)QB(
The choice of migration method depends upon the complexity of the application's
data. For some applications, only the objects used in balancing must be
migrated; no auxiliary data structures must be moved. Particle simulations
are examples of such applications; load balancing is based on the number
of particles per processor, and only the particles and their data must
be moved to establish the new decomposition. For such applications, Zoltan's
auto-migration tools can be used. Other applications, such as finite element
methods, perform load balancing on, say, the nodes of the finite element
mesh, but nodes that are moved to new processors also need to have their
connected elements moved to the new processors, and migrated elements may
also need "ghost" nodes \201i.e., copies of nodes assigned to other processors\202
to satisfy their connectivity requirements on the new processor. This complex
data migration requires a more user-controlled approach to data migration
than the auto-migration capabilities of Zoltan can provide.
)BR(\240
)0 2 45 H()WB 149 Sn()WB 144 Sn()EA(Auto-Migration Example)EH(
In the )0 145 1 A(figure)145 0 TN TL()Ec /AF f D( below, an example
of the load-balancing calling sequence for a particle simulation using
Zoltan's auto-migration tools is shown. The application registers the geometric
query functions that will be used by the load-balancing algorithm. It also
requests auto-migration by turning on the )BD(AUTO_MIGRATE)ES( option
through a call to )BD()0 73 1 A(LB_Set_Param)73 0 TN TL()Ec /AF f D()ES(
and registers functions to pack and unpack a particle's data. During the
call to )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(,
the load-balancing library computes the new decomposition and, using calls
to the packing and unpacking query functions, automatically migrates particles
to their new processors. The application then frees the arrays returned
by )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES( and
can continue computation without having to perform any additional operations
for data migration.
)BR(\240
)BR(\240
)2 Al()61 PT()Ea(
\240
)0 2 46 H()WB 150 Sn()WB 146 Sn()EA(User-Guided Migration Example)EH(
In the following )0 146 1 A(figure)146 0 TN TL()Ec /AF f D(,
an example of user-guided migration using Zoltan's migration-help tools
for a finite element application is shown. Several migration steps are
needed to completely rebuild the application's data structures for the
new decomposition. On each processor, newly imported nodes need copies
of elements containing those nodes. Newly imported elements, then, need
copies of "ghost" nodes, nodes that are in the element but are assigned
to other processors. Each of these entities \201nodes, elements, and ghost
nodes\202 can be migrated in separate migration steps using the functions
provided in the migration-help tools.First, the assignment of nodes to
processors returned by )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(
is established. Query functions that pack and unpack nodes are registered
and )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
is called using the nodal decomposition returned from )BD()0 43 1 A(LB_Balance)43 0 TN TL()Ec /AF f D()ES(.
)BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
packs the nodes to be exported, sends them to other processors, and unpacks
nodes received by a processor. The packing routine )I(migrate_node_pack)ES(
includes with each node a list of the element IDs for elements containing
that node. The unpacking routine )I(migrate_node_unpack)ES( examines the
list of element IDs and builds a list of requests for elements the processor
needs but does not already store. At the end of the nodal migration, each
processor has a list of element IDs for elements that it needs to support
imported nodes but does not already store. Through a call to )BD()0 90 1 A(LB_Compute_Destinations)90 0 TN TL()Ec /AF f D()ES(,
each processor computes the list of elements it has to send to other processors
to satisfy their element requests. Packing and unpacking routines for elements
are registered, and )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(
is again used to move element data to new processors. Requests for ghost
nodes can be built within the element packing and unpacking routines, and
calls to )BD()0 90 1 A(LB_Compute_Destinations)90 0 TN TL()Ec /AF f D()ES(
and )BD()0 91 1 A(LB_Help_Migrate)91 0 TN TL()Ec /AF f D()ES(,
with node packing and unpacking, satisfy requests for ghost nodes. In all
three phases of migration, the migration-help tools handle communication;
the application is responsible only for packing and unpacking data and
for building the appropriate request lists.
)BR(\240
)BR(\240
)2 Al()62 PT()Ea(
\240
)BR()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 28 1 A(Next:\240 Query-Function Examples)28 0 TN TL()Ec /AF f D(\240
|\240 )0 26 1 A(Previous:\240 Load-Balancing Example)26 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_examples_query.html) D
/Ti (Zoltan User's Guide: Examples) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 28 Sn(

)3 Al()BR(
)0 3 47 H(Zoltan)WB 159 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 48 H()WB 160 Sn()WB 151 Sn()EA(Query-Function Examples)EH(
Examples of query functions provided by a simple application are included
below.\240 The load-balancing examples include a simple implementation
of )BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D( )ES(and )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
query functions and variants of the simple implementation that exploit
local identifiers and data pointers.\240 Migration-help examples for
packing and unpacking objects are also included.\240\240 Robust error
checking is not included in the routines; application developers should
include more explicit error checking in their query functions.
)UL()0 153 1 A(Load-Balancing Examples)153 0 TN TL()Ec /AF f D(
)UL()0 154 1 A(Basic example)154 0 TN TL()Ec /AF f D(
)BR()0 155 1 A(User-defined local identifiers \201LB_LID\202)155 0 TN TL()Ec /AF f D(
)BR()0 156 1 A(User-defined data pointer)156 0 TN TL()Ec /AF f D()LU(
)0 157 1 A(Migration-Help Examples)157 0 TN TL()Ec /AF f D(
)UL()0 158 1 A(Packing and unpacking functions)158 0 TN TL()Ec /AF f D()LU()LU(
All the examples use a mesh data structure consisting of nodes in the mesh.\240
Load balancing is performed on the nodes.\240 A node is described by
its 3D coordinates and a global ID number that is unique across all processors.\240\240
The type definitions for the mesh and node data structures used in the
examples are included )0 152 1 A(below)152 0 TN TL()Ec /AF f D(.
)BR(\240
)2 Al()63 PT()Ea(
\240
)0 3 49 H()WB 161 Sn()WB 153 Sn()EA(Load-Balancing Query Function Examples)EH(
In the following examples, )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
and )BD()0 100 1 A(LB_GEOM_FN )100 0 TN TL()Ec /AF f D()ES(query functions
are implemented for an application using the mesh and node data structures
described )0 152 1 A(above)152 0 TN TL()Ec /AF f D(.\240 Dynamic
load-balancing is performed on the nodes of the mesh.

)0 P(Through a call to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(,
the function )I(user_return_owned_nodes)ES( is registered as the )BD()0 78 1 A(LB_OBJ_LIST_FN)78 0 TN TL()Ec /AF f D()ES(
query function.\240 It returns\240 global and local identifiers for
each node owned by a processor.

)0 P(The function )I(user_return_coords)ES( is registered as an\240 )BD()0 100 1 A(LB_GEOM_FN)100 0 TN TL()Ec /AF f D()ES(
query function.\240 Given the global and local identifiers for a node,
this function returns the node's coordinates.\240 All the examples exploit
the local identifier to quickly locate nodal data.\240 If such an identifier
is not available in an application, a search using the global identifier
can be performed.

)0 P(The )0 154 1 A(Basic Example)154 0 TN TL()Ec /AF f D( includes the simplest
implementation of the query routines.\240 In the query routines, it uses
global application data structures and a local numbering scheme for the
local identifiers.\240 The )0 155 1 A(User-Defined
Local Identifier Example)155 0 TN TL()Ec /AF f D( defines local identifiers as pointers to nodes;
this model is useful for applications that use dynamic data structures
or don't have a local ordering.\240 The )0 156 1 A(User-Defined
Data Pointer Example)156 0 TN TL()Ec /AF f D( uses only local application data structures; this
model is useful if the application does not have global data structures
or if load-balancing is to be performed on more than one data structure.\240
Differences between the latter two examples and the Basic Example are shown
in )WB [16#FF 16#00 16#00] Sc()3 FZ(red)Ef()Ec(.
)0 4 50 H()WB 162 Sn()WB 154 Sn()EA(Basic Example)EH(
In the simplest example, the query functions access the application data
through a global data structure \201)I(Mesh)ES(\202 representing the mesh.\240
In the calls to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(,
no pointers to application data are registered with the query function
\201i.e., the )I(data)ES( pointer is not used\202.\240\240 A node's local
identifier is an integer representing the index in the )I(Mesh.Nodes)ES(
array of the node.\240 In )I(lb/lb_user_const.h)ES(, )0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D(
is defined as an integer.\240 The local identifier is set to the index's
value in)I( user_return_owned_nodes)ES(.\240 It is used to access the
global )I(Mesh.Nodes)ES( array in )I(user_return_coords)ES(.
)BR(\240
)2 Al()64 PT()Ea(
\240
)0 4 51 H()WB 163 Sn()WB 155 Sn()EA(User-Defined Local Identifiers Example)EH(
In this example, a node's local identifier is defined as a pointer to the
node's data in the global )I(Mesh.Nodes)ES( array.\240 Thus, an index
into the array is not needed.\240 In )I(lb/lb_user_const.h)ES(, )0 49 1 A(LB_LID)49 0 TN TL()Ec /AF f D(
is defined as a pointer.\240 In )I(user_return_owned_nodes)ES(, the address
of a node's data is returned as the local identifier.\240 This address
is then used in )I(user_return_coords)ES( to access the nodal coordinates.
)BR(\240
)BR(This model is useful when a local numbering scheme \201such as the array
index\202 is not available because the application uses dynamic data structures.\240
Differences between this example and the )0 154 1 A(Basic
Example)154 0 TN TL()Ec /AF f D( are shown in )WB [16#FF 16#00 16#00] Sc()3 FZ(red)Ef()Ec(.
)BR(\240
)2 Al()65 PT()Ea(

)0 4 52 H()WB 164 Sn()WB 156 Sn()EA(User-Defined Data Pointer Example)EH(
In this example, the address of a local mesh data structure is registered
with the query functions for use by those functions.\240 This change
eliminates the need for a global mesh data structure in the application.\240
The address of the local data structure is included as an argument in calls
to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(.\240
This address is then used in )I(user_return_owned_nodes)ES( and )I(user_return_coords)ES(
to provide data for these routines.\240 It is cast to the )I()0 152 1 A(Mesh_Type)152 0 TN TL()Ec /AF f D()ES(
data type and accessed with local identifiers as in the )0 154 1 A(Basic
Example)154 0 TN TL()Ec /AF f D(.\240 Differences between this example and the )0 154 1 A(Basic
Example)154 0 TN TL()Ec /AF f D( are shown in )WB [16#FF 16#00 16#00] Sc()3 FZ(red)Ef()Ec(.

)0 P(This model is useful when the application does not have a global data
structure that can be accessed by the query functions.\240 It can also
be used for load balancing on different data objects.\240 For example,
if an application had more than one mesh, load balancing could be performed
separately on each mesh without having different query routines for each
mesh.\240 Calls to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(
would define which mesh should be balanced, and the query routines would
access the mesh currently designated by the )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(
calls.
)BR(\240
)2 Al()66 PT()Ea(
\240
)0 3 53 H()WB 165 Sn()WB 157 Sn()EA(Migration-Help Examples)EH(

)0 4 54 H()WB 166 Sn()WB 158 Sn()EA(Packing and Unpacking Data)EH(
Simple migration-help query functions for the )0 154 1 A(Basic
Example)154 0 TN TL()Ec /AF f D( are included)0 152 1 A( below)152 0 TN TL()Ec /AF f D(.\240
These functions are used by the migration-help tools to move nodes among
the processors.\240 The functions )I(user_size_node)ES(, )I(user_pack_node)ES(,
and )I(user_unpack_node)ES( are registered through calls to )BD()0 42 1 A(LB_Set_Fn)42 0 TN TL()Ec /AF f D()ES(.\240
Query function )I(user_size_node)ES( returns the size \201in bytes\202 of data
representing a single node.\240 Query function )I(user_pack_node)ES(
copies a given node's data into the communication buffer)I( buf)ES(.\240
Query function )I(user_unpack_node)ES( copies a data for one node from
the communication buffer )I(buf)ES( into the )I(Mesh.Nodes)ES( array on
its new processor.

)0 P(These query routines are simple because the application does not dynamically
allocate memory for each node.\240 Such dynamic allocation would have
to be accounted for in the )0 95 1 A(LB_OBJ_SIZE_FN)95 0 TN TL()Ec /AF f D(,
)0 96 1 A(LB_PACK_OBJ_FN)96 0 TN TL()Ec /AF f D(, and )0 97 1 A(LB_UNPACK_OBJ_FN)97 0 TN TL()Ec /AF f D(
routines.\240 The )0 95 1 A(LB_OBJ_SIZE_FN)95 0 TN TL()Ec /AF f D(
should return the size of the largest object to be migrated among all processors,
as all migrating objects must have the same size.
)BR(\240
)2 Al()67 PT()Ea(

)2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 29 1 A(Next:\240 Future Work)29 0 TN TL()Ec /AF f D(\240 |\240 )0 27 1 A(Previous:\240
Migration Examples)27 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_future.html) D
/Ti (Zoltan User's Guide: Future Work) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 29 Sn(

)3 Al()BR(
)0 3 55 H(Zoltan)WB 168 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 56 H()WB 169 Sn()WB 167 Sn()EA(Future Work)EH(
Future efforts will focus on testing the interface in a variety of applications
and developing new algorithms for the load- balancing library. Preliminary
tests of the interface in an unstructured finite element method have been
successful. The load-balancing query functions can be implemented with
a small amount of C code \201less than 200 lines\202, and data migration can
be accomplished without additional communication code in the application
using a calling sequence similar to that in the )0 146 1 A(user-guided
migration example)146 0 TN TL()Ec /AF f D(.

)0 P(Algorithmic development will focus first on the development of a model
for heterogeneous computing systems. Processor speeds, processor memory
sizes, and interconnection network speeds will be included in the model.
The model will be tested first in the simple )0 20 1 A(algorithms)20 0 TN TL()Ec /AF f D(
already implemented. New algorithmic development will be required to use
the heterogeneous system model.

)0 P(After heterogeneous computing model is developed, new algorithms will
be implemented. These algorithms will include local diffusion algorithms
that test the graph-based interface to the load-balancing library and tree-based
algorithms that can take advantage of information available in tree-based
applications such as finite element methods with adaptive mesh refinement.
The tree-based algorithms will require additions to the load-balancing
interface, but the existing interface routines should remain unchanged.
)BR(\240
)BR(\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 30 1 A(Next:\240 References)30 0 TN TL()Ec /AF f D(\240 |\240 )0 28 1 A(Previous:\240
Query-Function Examples)28 0 TN TL()Ec /AF f D(]
)WB NL
/Cb [16#FF 16#FF 16#FF] D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc
DS
/Ba f D /BO 0 D Bs
/UR (ug_refs.html) D
/Ti (Zoltan User's Guide: References) D
/Au () D
/Df f D


0 BO R
()3 Sl()WB 30 Sn(

)3 Al()BR(
)0 3 57 H(Zoltan)WB 174 Sn( User's Guide )WB()EH()Ea()BR(

)0 2 58 H()WB 175 Sn()WB 170 Sn()EA(References)EH(

)4 OL()-1 LI()WB 51 Sn()EA("ALEGRA -- A Framework for Large Strain Rate Physics."
)R11 2 A(http://sherpa.sandia.gov/9231home/alegra/alegra-frame.html)EA(

)-1 LI()WB 34 Sn()EA(S. Attaway, T. Barragy, K. Brown, D. Gardner, B.
Hendrickson, S. Plimpton and C. Vaughan. "Transient Solid Dynamics Simulations
on the Sandia/Intel Teraflop Computer." )I(Proceedings of SC'97)ES(, San
Jose, CA, November, 1997. \201Finalist for the Gordon Bell Prize.\202

)-1 LI()WB 129 Sn()EA(P. Baehmann, S. Wittchen, M. Shephard, K. Grice,
and M. Yerry. "Robust geometrically based automatic two-dimensional mesh
generation." )I(Intl. J. Numer. Meths. Engrg)ES(., )I(24)ES( \2011987\202 1043-1078.

)-1 LI()WB 121 Sn()EA(M. Berger and S. Bokhari. "A partitioning strategy
for nonuniform problems on multiprocessors." )I(IEEE Trans. Computers)ES(,
C-36 \2011987\202 570-580.

)-1 LI()WB 35 Sn()EA(K. Devine, G. Hennigan, S. Hutchinson,
A. Salinger, J. Shadid, and R. Tuminaro. "High Performance MP Unstructured
Finite Element Simulation of Chemically Reacting Flows." )I(Proceedings
of SC'97)ES(, San Jose, CA, November, 1997. \201Finalist for the Gordon Bell
Prize.\202

)-1 LI()WB 131 Sn()EA(H.C. Edwards. )I(A parallel infrastructure for scalable
adaptive finite element methods and its application to least squares\240
C^\201inf\202)ES( collocation.\240 Ph.D. Dissertation, Univ. of Texas at Austin,
May, 1997.

)-1 LI()WB 127 Sn()EA(J. Flaherty, R. Loy, M. Shephard, B. Szymanski,
J. Teresco and L. Ziantz. "Adaptive local refinement with octree load-balancing
for the parallel solution of three-dimensional conservation laws." )I(J.
Parallel Distrib. Comput.)ES(, )I(47)ES( \2011998\202 139-152.

)-1 LI()WB 128 Sn()EA(L. Gervasio. "Final Report." Summer project report,
Internal Memo, Department 9103, Sandia National Laboratories, August, 1998.

)-1 LI()WB 39 Sn()EA(B. Hendrickson and K. Devine. "Dynamic
load balancing in computational mechanics." To appear in )I(Comp. Meth.
Appl. Mech. Engrg.)ES(, 1999.

)-1 LI()WB 36 Sn()EA(B. Hendrickson and R. Leland. "The Chaco user's guide,
version 2.0." Tech. Rep. SAND 94-2692, Sandia National Laboratories, Albuquerque,
NM, October, 1994.

)-1 LI()WB 37 Sn()EA(G. Karypis and V. Kumar. "Parmetis: Parallel graph
partitioning and sparse matrix ordering library." Tech. Rep. 97-060, Department
of Computer Science, Univ. of Minnesota, 1997. )R10 2 A(http://www-users.cs.umn.edu/~karypis/metis/parmetis/)EA(

)-1 LI()WB 171 Sn()EA(R. Loy. )I(Adaptive local refinement with octree load-balancing
for the parallel solution of three-dimensional conservation laws)ES(. Ph.
D. Dissertation, Dept. of Computer Science, Rensselaer Polytechnic Institute,
May 1998.

)-1 LI()WB 172 Sn()EA(S. Mitchell and S. Vavasis. "Quality mesh generation
in three dimensions." )I(Proc. 8th ACM Symposium on Computational Geometry)ES(,
ACM \2011992\202 212-221.

)-1 LI()WB 50 Sn()EA("MPSalsa: Massively Parallel Numerical Methods for
Advanced Simulation of Chemically Reacting Flows." )R12 2 A(http://www.cs.sandia.gov/CRF/MPSalsa/)EA(

)-1 LI()WB 173 Sn()EA(A. Patra and J. T. Oden. "Problem decomposition for
adaptive hp-finite element methods." )I(J. Computing Systems in Engrg.)ES(,
6 \2011995\202.

)-1 LI()WB 132 Sn()EA(J. Pilkington and S. Baden. "Partitioning with
space-filling curves." Tech. Rep. CS94-349, Dept. of Computer Science and
Engineering, Univ. of California, San Diego, CA, 1994.

)-1 LI()WB 130 Sn()EA(M. Shephard and M. Georges. "Automatic three-dimensional
mesh generation by the finite octree technique." )I(Intl. J. Numer. Meths.
Engrg.)ES(, 32 \2011991\202 709-749.

)-1 LI()WB 38 Sn()EA(C. Walshaw. "JOSTLE mesh partitioning software, Version
2.0." )R13 2 A(http://www.gre.ac.uk/~c.walshaw/jostle/)EA(

)-1 LI()WB 133 Sn()EA(M. Warren and J. Salmon. "A parallel hashed octree
n-body algorithm." )I(Proc. Supercomputing `93)ES(, Portland, OR, November
1993.)LO(
\240

)0 P()2 0.6 1 HR([)0 0 1 A(Table of Contents)0 0 TN TL()Ec /AF f D(\240 |\240
)0 29 1 A(Previous:\240 Future Work)29 0 TN TL()Ec /AF f D( |\240 )0 2 A(Zoltan
Home Page)EA(]
)WB NL /BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
()0 1 -1 H(Sandia National Laboratories - Zoltan User's Guide)EH(
              )0 2 -1 H(Table of Contents)EH()WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(Sandia National Laboratories - Zoltan User's Guide)ES()0 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 2()0 C()BD(Zoltan User's Guide: Introduction)ES()2 1 TN()EA()BN}if
3 NH le{44(0.0.1\240\240)3 C(Zoltan User's Guide )WB()44 1 TN()EA()BN}if
2 NH le{45(0.1\240\240)2 C()WB 31 Sn(Introduction)45 1 TN()EA()BN}if
2 NH le{46(0.2\240\240)2 C()WB 3 Sn(Load-Balancing Tools)46 1 TN()EA()BN}if
2 NH le{47(0.3\240\240)2 C()WB 4 Sn(Migration-Help Tools)47 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 5()0 C()BD(Zoltan User's Guide: Library Usage)ES()5 1 TN()EA()BN}if
3 NH le{53(0.3.1\240\240)3 C(Zoltan User's Guide )WB()53 1 TN()EA()BN}if
2 NH le{54(0.4\240\240)2 C()WB 48 Sn(Using the Library)54 1 TN()EA()BN}if
3 NH le{55(0.4.1\240\240)3 C()WB 6 Sn(Application Data Types)55 1 TN()EA()BN}if
3 NH le{56(0.4.2\240\240)3 C()WB 7 Sn(Building the Library)56 1 TN()EA()BN}if
3 NH le{57(0.4.3\240\240)3 C()WB 7 Sn(Building Applications)57 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 8()0 C()BD(Zoltan User's Guide: Interface)ES()8 1 TN()EA()BN}if
3 NH le{64(0.4.4\240\240)3 C(Zoltan User's Guide )WB()64 1 TN()EA()BN}if
2 NH le{65(0.5\240\240)2 C()WB 58 Sn(Zoltan Interface Functions)65 1 TN()EA()BN}if
2 NH le{66(0.6\240\240)2 C()WB 9 Sn(Error Codes)66 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 10()0 C()BD(Zoltan User's Guide: Interface)ES()10 1 TN()EA()BN}if
3 NH le{70(0.6.1\240\240)3 C(Zoltan User's Guide )WB()70 1 TN()EA()BN}if
2 NH le{71(0.7\240\240)2 C()WB 67 Sn(Initialization Functions)71 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 11()0 C()BD(Zoltan User's Guide: Interface)ES()11 1 TN()EA()BN}if
3 NH le{83(0.7.1\240\240)3 C(Zoltan User's Guide )WB()83 1 TN()EA()BN}if
2 NH le{84(0.8\240\240)2 C()WB 72 Sn(Load-Balancing Functions)84 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 12()0 C()BD(Zoltan User's Guide: Interface)ES()12 1 TN()EA()BN}if
3 NH le{87(0.8.1\240\240)3 C(Zoltan User's Guide )WB()87 1 TN()EA()BN}if
2 NH le{88(0.9\240\240)2 C(Functions for Augmenting a Decomposition)88 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 13()0 C()BD(Zoltan User's Guide: Interface)ES()13 1 TN()EA()BN}if
3 NH le{98(0.9.1\240\240)3 C(Zoltan User's Guide )WB()98 1 TN()EA()BN}if
2 NH le{99(0.10\240\240)2 C()WB 89 Sn(Migration-Help Functions)99 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 14()0 C()BD(Zoltan User's Guide: Query Functions)ES()14 1 TN()EA()BN}if
3 NH le{101(0.10.1\240\240)3 C(Zoltan User's Guide )WB()101 1 TN()EA()BN}if
2 NH le{102(0.11\240\240)2 C()WB 69 Sn(Application-Registered
Query Functions)102 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 15()0 C()BD(Zoltan User's Guide: Query Functions)ES()15 1 TN()EA()BN}if
3 NH le{109(0.11.1\240\240)3 C(Zoltan User's Guide )WB()109 1 TN()EA()BN}if
2 NH le{110(0.12\240\240)2 C()WB 103 Sn(Load-Balancing Query Functions)110 1 TN()EA()BN}if
2 NH le{111(0.13\240\240)2 C()WB 16 Sn(General Functions)111 1 TN()EA()BN}if
2 NH le{112(0.14\240\240)2 C()WB 17 Sn(Geometry-based Functions)112 1 TN()EA()BN}if
2 NH le{113(0.15\240\240)2 C()WB 18 Sn(Graph-based Functions)113 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 19()0 C()BD(Zoltan User's Guide: Query Functions)ES()19 1 TN()EA()BN}if
3 NH le{115(0.15.1\240\240)3 C(Zoltan User's Guide )WB()115 1 TN()EA()BN}if
2 NH le{116(0.16\240\240)2 C()WB 93 Sn(Migration-Help Query Functions)116 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 20()0 C()BD(Zoltan User's Guide: Algorithms)ES()20 1 TN()EA()BN}if
3 NH le{119(0.16.1\240\240)3 C(Zoltan User's Guide )WB()119 1 TN()EA()BN}if
2 NH le{120(0.17\240\240)2 C()WB 117 Sn(Algorithms)120 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 118()0 C()BD(Zoltan User's Guide: RCB)ES()118 1 TN()EA()BN}if
3 NH le{122(0.17.1\240\240)3 C(Zoltan User's Guide )WB()122 1 TN()EA()BN}if
2 NH le{123(0.18\240\240)2 C()WB 21 Sn(Recursive Coordinate Bisection \201RCB\202)123 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 52()0 C()BD(Zoltan User's Guide: SFC)ES()52 1 TN()EA()BN}if
3 NH le{125(0.18.1\240\240)3 C(Zoltan User's Guide )WB()125 1 TN()EA()BN}if
2 NH le{126(0.19\240\240)2 C()WB 22 Sn(ParMETIS)126 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 124()0 C()BD(Zoltan User's Guide: SFC)ES()124 1 TN()EA()BN}if
3 NH le{134(0.19.1\240\240)3 C(Zoltan User's Guide )WB()134 1 TN()EA()BN}if
2 NH le{135(0.20\240\240)2 C()WB 23 Sn(Octree/Space-Filling Curve \201SFC\202 Partitioning)135 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 24()0 C()BD(Zoltan User's Guide: Examples)ES()24 1 TN()EA()BN}if
3 NH le{136(0.20.1\240\240)3 C(Zoltan User's Guide )WB()136 1 TN()EA()BN}if
2 NH le{137(0.21\240\240)2 C()WB 63 Sn(Examples of Library Usage)137 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 25()0 C()BD(Zoltan User's Guide: Examples)ES()25 1 TN()EA()BN}if
3 NH le{139(0.21.1\240\240)3 C(Zoltan User's Guide )WB()139 1 TN()EA()BN}if
2 NH le{140(0.22\240\240)2 C()WB 60 Sn(Initialization Example)140 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 26()0 C()BD(Zoltan User's Guide: Examples)ES()26 1 TN()EA()BN}if
3 NH le{142(0.22.1\240\240)3 C(Zoltan User's Guide )WB()142 1 TN()EA()BN}if
2 NH le{143(0.23\240\240)2 C()WB 61 Sn(Load-Balancing Example)143 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 27()0 C()BD(Zoltan User's Guide: Examples)ES()27 1 TN()EA()BN}if
3 NH le{147(0.23.1\240\240)3 C(Zoltan User's Guide )WB()147 1 TN()EA()BN}if
2 NH le{148(0.24\240\240)2 C()WB 62 Sn(Migration Examples)148 1 TN()EA()BN}if
2 NH le{149(0.25\240\240)2 C()WB 144 Sn(Auto-Migration Example)149 1 TN()EA()BN}if
2 NH le{150(0.26\240\240)2 C()WB 146 Sn(User-Guided Migration Example)150 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 28()0 C()BD(Zoltan User's Guide: Examples)ES()28 1 TN()EA()BN}if
3 NH le{159(0.26.1\240\240)3 C(Zoltan User's Guide )WB()159 1 TN()EA()BN}if
2 NH le{160(0.27\240\240)2 C()WB 151 Sn(Query-Function Examples)160 1 TN()EA()BN}if
3 NH le{161(0.27.1\240\240)3 C()WB 153 Sn(Load-Balancing Query Function Examples)161 1 TN()EA()BN}if
4 NH le{162(0.27.1.1\240\240)4 C()WB 154 Sn(Basic Example)162 1 TN()EA()BN}if
4 NH le{163(0.27.1.2\240\240)4 C()WB 155 Sn(User-Defined Local Identifiers Example)163 1 TN()EA()BN}if
4 NH le{164(0.27.1.3\240\240)4 C()WB 156 Sn(User-Defined Data Pointer Example)164 1 TN()EA()BN}if
3 NH le{165(0.27.2\240\240)3 C()WB 157 Sn(Migration-Help Examples)165 1 TN()EA()BN}if
4 NH le{166(0.27.2.1\240\240)4 C()WB 158 Sn(Packing and Unpacking Data)166 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 29()0 C()BD(Zoltan User's Guide: Future Work)ES()29 1 TN()EA()BN}if
3 NH le{168(0.27.3\240\240)3 C(Zoltan User's Guide )WB()168 1 TN()EA()BN}if
2 NH le{169(0.28\240\240)2 C()WB 167 Sn(Future Work)169 1 TN()EA()BN}if
ND 1 gt{Ts 3 mul Np 30()0 C()BD(Zoltan User's Guide: References)ES()30 1 TN()EA()BN}if
3 NH le{174(0.28.1\240\240)3 C(Zoltan User's Guide )WB()174 1 TN()EA()BN}if
2 NH le{175(0.29\240\240)2 C()WB 170 Sn(References)175 1 TN()EA()BN}if

/TE t D NP TU PM 0 eq and{/Pn () D showpage}if end restore
