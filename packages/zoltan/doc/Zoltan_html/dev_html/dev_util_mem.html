<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! Zoltan is distributed under the GNU Lesser General Public License 2.1.     !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1376">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title> Zoltan Developer's Guide:  Memory Utilities</title>
</head>
<body bgcolor="#FFFFFF">

<div ALIGN=right>
<h3>
<img SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></h3></div>

<h2>
<a NAME="Memory"></a>Memory Management Utilities</h2>
Several memory allocation and deallocation routines are provided in the
load-balancing library. They are defined in the file <i>all/all_allo.c</i>;
their prototypes for inclusion in other files are in <i>all/all_allo_const.h</i>.
The use of these routines is not mandatory in algorithm development (except
<b><a href="#LB_Special_Malloc">LB_Special_Malloc</a></b> and <b><a href="#LB_Special_Free">LB_Special_Free</a></b>),
but the routines provide helpful error-checking and <a href="#Debug_Memory">debugging
capabilities</a>, and the use of them is strongly suggested.
<p>The routines included in the utility are listed below.
<blockquote><b><a href="#LB_Array_Alloc">LB_Array_Alloc</a></b>:&nbsp;
Allocates arrays of dimension <i>n</i>, <i>n</i>=0,1,...,4
<br><b><a href="#LB_Malloc">LB_Malloc</a></b>:&nbsp; Wrapper for system
malloc.
<br><b><a href="#LB_Realloc">LB_Realloc</a></b>:&nbsp; Wrapper for system
realloc.
<br><b><a href="#LB_Free">LB_Free</a></b>:&nbsp; Frees memory and sets
the pointer to NULL.
<br><b><a href="#LB_Special_Malloc">LB_Special_Malloc</a></b>:&nbsp; Allocate
memory for import and export result arrays.
<br><b><a href="#LB_Special_Free">LB_Special_Free</a></b>:&nbsp; Frees
memory allocated by LB_Special_Malloc.</blockquote>

<hr><a NAME="LB_Array_Alloc"></a>double *<b>LB_Array_Alloc</b>(char *<i>
file</i>, int <i>line</i>, int <i>n</i>, int <i>d1</i>, int <i>d2</i>,
..., int <i>dn</i>, int <i>size</i>);&nbsp;
<hr>
<p>The <b>LB_Array_Alloc</b> routine dynamically allocates an array of
dimension <i>n</i>, <i>n </i>= 0, 1, ..., 4 with size (<i>d1</i> x <i>d2</i>
x ... x <i>dn</i>). It is intended to be used for 2, 3 and 4 dimensional
arrays - <b>LB_Malloc</b> should be used for the simpler cases. The memory
allocated by <b>LB_Array_Alloc</b> is contiguous, and can be freed by a
single call to <b>LB_Free</b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; file</i></td>

<td>A string containing the name of the file calling the function. The
<i>__FILE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; line</i></td>

<td>The line number within <i>file</i> of the call to the function. The
<i>__LINE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; n</i></td>

<td>The number of dimensions in the array to be allocated. Valid values
are 0, 1, 2, 3, or 4.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>d1</i>, <i>d2</i>, ..., <i>dn</i></td>

<td>The size of each dimension to be allocated. One argument is included
for each dimension.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>size</i></td>

<td>The size (in bytes) of the data objects to be stored in the array.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; double *</td>

<td>A pointer to the starting address of the <i>n</i>-dimensional array,
or NULL if the allocation fails.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>int **<i> x</i> = (int **) <b>LB_Array_Alloc</b> (<i> __FILE__</i>
, <i>__LINE__</i> , 2, 5, 6, <i>sizeof</i> (int));</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Allocates a two-dimensional, 5x6-element array of integers.</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Malloc"></a>double *<b>LB_Malloc</b>(int <i>n</i>, char
*<i> file</i> , int <i>line</i>);&nbsp;
<hr>
<p>The <b>LB_Malloc</b> function is a wrapper around the standard C malloc
routine. It allocates a block of memory of size <i>n</i> bytes. The principle
advantage of using the wrapper is that it allows you to track memory leaks
via the DEBUG_MEMORY parameter.
<p>A macro <b>LB_MALLOC</b> is defined in <i>all/all_allo_const.h</i>.
It takes the argument <i>n</i>, and adds the <i>__FILE__</i> and <i>__LINE__</i>
macros to the argument list of the <b>LB_Malloc</b> call:
<blockquote>#define&nbsp;&nbsp;&nbsp; <b>LB_MALLOC</b>(<i>n</i>)&nbsp;&nbsp;&nbsp;

<b>LB_Malloc</b>((<i>n</i>), <i>__FILE__</i>, <i>__LINE__</i>)</blockquote>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp;<i> n</i></td>

<td>The size (in bytes) of the memory-allocation request.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; file</i></td>

<td>A string containing the name of the file calling the function. The
<i>__FILE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; line</i></td>

<td>The line number within <i>file</i> of the call to the function. The
<i>__LINE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; double *</td>

<td>A pointer to the starting address of memory allocated.&nbsp; NULL is
returned if <i>n</i> = 0 or the routine is unsuccessful.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>struct <b>LB_Struct</b> *<i>b</i> = (struct <b>LB_Struct</b> *) <b>LB_MALLOC</b>(<i>sizeof</i>(struct
<b>LB_Struct</b>));</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Allocates memory for one <b>LB_Struct</b> data structure.&nbsp;</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Realloc"></a>double *<b>LB_Realloc</b>(void *<i>ptr</i>,
int <i>n</i>, char *<i>file</i>, int <i>line</i>);&nbsp;
<hr>
<p>The <b>LB_Realloc</b> function is a "safe" version of realloc. It changes
the size of the object pointed to by <i>ptr</i> to <i>n</i> bytes. The
contents of <i>ptr</i> are unchanged up to a minimum of the old and new
sizes. Error tests ensuring that <i>n</i> is a positive number and that
space is available to be allocated are performed.
<p>A macro <b>LB_REALLOC</b> is defined in <i>all/all_allo_const.h</i>.
It takes the arguments <i>ptr</i> and <i>n</i>, and adds the <i>__FILE__</i>
and <i>__LINE__</i> macros to the argument list of the <b>LB_Realloc</b>
call:
<blockquote>#define&nbsp;&nbsp;&nbsp; <b>LB_REALLOC</b>(<i>ptr</i>, <i>n</i>)&nbsp;&nbsp;

<b>LB_Realloc</b>((<i>ptr</i>), (<i>n</i>), <i>__FILE__</i>, <i>__LINE__</i>)</blockquote>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ptr</i></td>

<td>Pointer to allocated memory to be re-sized.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp;<i> n</i></td>

<td>The size (in bytes) of the memory-allocation request.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; file</i></td>

<td>A string containing the name of the file calling the function. The
<i>__FILE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; line</i></td>

<td>The line number within <i>file</i> of the call to the function. The
<i>__LINE__</i>
macro can be passed as this argument. This argument is useful for debugging
memory allocation problems.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; double *</td>

<td>A pointer to the starting address of memory allocated.&nbsp; If the
routine is unsuccessful, NULL is returned and *<i>ptr</i> is unchanged.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td><i>int</i> *<i>b</i> = (<i>int </i>*) <b><a href="#LB_Malloc">LB_MALLOC</a></b>
(<i>sizeof</i> (struct <b>LB_Struct</b>));&nbsp;
<br><i>b</i> = (<i>int </i>*) <b>LB_REALLOC</b> (<i>b</i>, 2*<i>n</i>);</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Reallocates memory for <i>b</i> from length <i>n</i> to length 2*<i>n</i>.&nbsp;</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Free"></a>void <b>LB_Free</b>(void **<i>ptr</i>, char *<i>
file</i> , int <i>line</i>);&nbsp;
<hr>
<p>The <b>LB_Free</b> function calls the system's "free" function for the
memory pointed to by <i>*ptr</i>. Note that the argument to this routine
has an extra level of indirection when compared to the standard C "free"
call. This allows the pointer being freed to be set to NULL, which can
help find errors in which a pointer is used after it is deallocated. Error
checking is performed to prevent attempts to free NULL pointers. When <b>LB_Free</b>
is used with the DEBUG_MEMORY options, it can help identify memory leaks.
<p>A macro <b>LB_FREE</b> is defined in <i>all/all_allo_const.h</i>. It
takes the argument <i>ptr</i>, and adds the <i>__FILE__</i> and <i>__LINE__</i>
macros to the argument list of the <b>LB_Free</b> call:
<blockquote>#define&nbsp;&nbsp;&nbsp; <b>LB_FREE</b>(<i>ptr</i>)&nbsp;&nbsp;&nbsp;

<b>LB_Free</b>((void **)(<i>ptr</i>), <i>__FILE__</i>, <i>__LINE__</i>)</blockquote>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ptr</i></td>

<td>Address of a pointer to the memory to be freed. Upon return, <i>ptr</i>
is set to NULL.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td><b>LB_FREE</b>(&amp;<i> x</i>);</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Frees memory associated with the variable <i>x</i>; upon return, <i>x</i>
is NULL.</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Special_Malloc"></a>int <b>LB_Special_Malloc</b>(struct
<b><a href="dev_lb_structs.html#LB_Struct">LB_Struct</a></b> *<i>lb</i>,
void **<i>array</i>, int <i>size</i>, <b>LB_SPECIAL_MALLOC_TYPE</b> <i>type</i>);&nbsp;
<hr>
<p>The <b>LB_Special_Malloc</b> routine allocates memory for result arrays
like <i>import_global_ids</i>, <i>import_local_ids</i>, <i>import_procs</i>,
<i>export_global_ids</i>,
<i>export_local_ids</i> and <i>export_procs</i>. Since these arrays are
returned to the application, they must be allocated by <b>LB_Special_Malloc</b>
to insure they are allocated by the same language as the application. Memory
allocated by <b>LB_Special_Malloc</b> must be deallocated by <b>LB_Special_Free</b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; lb</i></td>

<td>The load balancing structure currently in use.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; array</i></td>

<td>Usually of type int**, <b><a href="../ug_html/ug_usage.html#Macro defs">LB_GID</a></b>**,
or <b><a href="../ug_html/ug_usage.html#Macro defs">LB_LID</a></b>**. Returned
as a pointer to the allocated space.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; size</i></td>

<td>The number of elements (not bytes) to be allocated.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>type</i></td>

<td>The type of array to allocate. Must be one of <b>LB_SPECIAL_MALLOC_INT</b>,
<b>LB_SPECIAL_MALLOC_GID</b> or <b>LB_SPECIAL_MALLOC_LID</b>.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; int</td>

<td>1 if the allocation succeeded; 0 if it failed.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>ierr = <b>LB_Special_Malloc</b>(<i>lb</i>, (void **)<i>import_gid</i>,
<i>num_import</i>,
<b>LB_SPECIAL_MALLOC_GID</b>);</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Allocates an array with <i>num_import</i> <a href="../ug_html/ug_usage.html#Macro defs"><b>LB_GID</b>s</a>.</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Special_Free"></a>int <b>LB_Special_Free</b>(struct <b><a href="dev_lb_structs.html#LB_Struct">LB_Struct</a></b>
*<i>lb</i>, void **<i>array</i>,<b> LB_SPECIAL_MALLOC_TYPE</b> <i>type</i>);&nbsp;
<hr>
<p><b>LB_Special_Free</b> frees memory allocated by <b>LB_Special_Malloc</b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; lb</i></td>

<td>The load balancing structure currently in use.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; array</i></td>

<td>The array to be freed.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>type</i></td>

<td>The type of the array. Must be one of <b>LB_SPECIAL_MALLOC_INT</b>,
<b>LB_SPECIAL_MALLOC_GID</b> or <b>LB_SPECIAL_MALLOC_LID</b>.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; int</td>

<td>1 if the deallocation succeeded; 0 if it failed.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Example:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>ierr = <b>LB_Special_Free</b>(<i>lb</i>, (void **)<i>import_gid</i>,
<b>LB_SPECIAL_MALLOC_GID</b>);</td>
</tr>

<tr>
<td VALIGN=TOP></td>

<td>Frees the <b><a href="../ug_html/ug_usage.html#Macro defs">LB_GID</a></b>
array <i>import_gid</i>.</td>
</tr>
</table>

<p>
<hr><a NAME="Debug_Memory"></a>
<h3>
<b>Debugging Memory Errors</b></h3>
The principle reason that Zoltan has wrappers around the system memory
routines is to facilitate debugging of memory problems. These capabilities
are supported by the <b>DEBUG_MEMORY</b> parameter whose value can be altered
via the <a href="../ug_html/ug_interface_lb.html#LB_Set_Param">LB_Set_Param</a>
routine. Valid values for this integer parameter range from 0 through 3.
A value of 0 turns off all debugging. With a value of 1 (the default),
the number of calls to <b>LB_Malloc</b> and the number of calls to <b>LB_Free</b>
are tallied, and can be printed by a call to <b>LB_Memory_Stats</b> (type
void, no arguments). If <b>DEBUG_MEMORY</b> is 2, Zoltan keeps a list of
all calls to <b>LB_Malloc</b> which have not yet been freed. This list
is printed by a call to <b>LB_Memory_Stats</b>. This is a useful tool for
detecting memory leaks. Also, any calls to <b>LB_Free</b> with addresses
not in this list trigger warning messages. (Note that allocations which
occurred prior to setting <b>DEBUG_MEMORY</b> to 2 will not be in this
list and so can generate spurious warnings.) If additional information
is needed, a value for <b>DEBUG_MEMORY</b> of 3 also prints information
about each allocation as it happens. We have found values of 1 and 2 to
be very helpful in our development efforts.&nbsp;
<hr WIDTH="100%">
<br>[<a href="dev.html">Table of Contents</a>&nbsp; |&nbsp; <a href="dev_util_params.html">Next:&nbsp;
Parameter Setting Routines</a>&nbsp; |&nbsp; <a href="dev_util.html">Previous:&nbsp;
Utilities</a>]
</body>
</html>
