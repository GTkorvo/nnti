<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 4.1.3_U1 sun4m) [Netscape]">
   <TITLE> Zoltan Developer's Guide:  Utilities</TITLE>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></H3></DIV>

<H2>
<A NAME="Memory"></A>Memory Management Utilities</H2>
Several memory allocation and deallocation routines are provided in the
load-balancing library. They are defined in the file <I>all/all_allo.c</I>;
their prototypes for inclusion in other files are in <I>all/all_allo_const.h</I>.
The use of these routines is not mandatory in algorithm development
(except LB_Special_Malloc and LB_Special_Free), but
the routines provide helpful error-checking and <A HREF="#Debug_Memory">debugging
capabilities</A>, and the use of them is strongly suggested.

<P>The routines included in the utility are listed below.
<BLOCKQUOTE><B><A HREF="#LB_Array_Alloc">LB_Array_Alloc</A></B>:&nbsp;
Allocates arrays of dimension <I>n</I>, <I>n</I>=0,1,...,4
<BR><B><A HREF="#LB_Malloc">LB_Malloc</A></B>:&nbsp; Wrapper for system
malloc.
<BR><B><A HREF="#LB_Realloc">LB_Realloc</A></B>:&nbsp; Wrapper for system
realloc.
<BR><B><A HREF="#LB_Free">LB_Free</A></B>:&nbsp; Frees memory and sets
the pointer to NULL.
<BR><B><A HREF="#LB_Special_Malloc">LB_Special_Malloc</A></B>:&nbsp; Allocate
memory for import and export result arrays.
<BR><B><A HREF="#LB_Special_Free">LB_Special_Free</A></B>:&nbsp; Frees memory
allocated by LB_Special_Malloc.
</BLOCKQUOTE>

<HR><A NAME="LB_Array_Alloc"></A>double *<B>LB_Array_Alloc</B>(char *<I>
file</I>, int <I>line</I>, int <I>n</I>, int <I>d1</I>, int <I>d2</I>,
..., int <I>dn</I>, int <I>size</I>);&nbsp;
<HR>

<P>The <B>LB_Array_Alloc</B> routine dynamically allocates an array of
dimension <I>n</I>, <I>n </I>= 0, 1, ..., 4 with size (<I>d1</I> x <I>d2</I>
x ... x <I>dn</I>). It is intended to be used for 2, 3 and 4 dimensional
arrays - <B>LB_Malloc</B> should be used for the simpler cases. The memory
allocated by <B>LB_Array_Alloc</B> is contiguous, and can be freed by a
single call to <B>LB_Free</B>.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; file</I></TD>

<TD>A string containing the name of the file calling the function. The
<I>__FILE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; line</I></TD>

<TD>The line number within <I>file</I> of the call to the function. The
<I>__LINE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; n</I></TD>

<TD>The number of dimensions in the array to be allocated. Valid values
are 0, 1, 2, 3, or 4.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>d1</I>, <I>d2</I>, ..., <I>dn</I></TD>

<TD>The size of each dimension to be allocated. One argument is included
for each dimension.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>size</I></TD>

<TD>The size (in bytes) of the data objects to be stored in the array.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; double *</TD>

<TD>A pointer to the starting address of the <I>n</I>-dimensional array,
or NULL if the allocation fails.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>int **<I> x</I> = (int **) <B>LB_Array_Alloc</B> (<I> __FILE__</I>
, <I>__LINE__</I> , 2, 5, 6, <I>sizeof</I> (int));</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Allocates a two-dimensional, 5x6-element array of integers.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Malloc"></A>double *<B>LB_Malloc</B>(int <I>n</I>, char
*<I> file</I> , int <I>line</I>);&nbsp;
<HR>

<P>The <B>LB_Malloc</B> function is a wrapper around the standard C malloc
routine. It allocates a block of memory of size <I>n</I> bytes. The principle
advantage of using the wrapper is that it allows you to track memory leaks
via the DEBUG_MEMORY parameter.

<P>A macro <B>LB_MALLOC</B> is defined in <I>all/all_allo_const.h</I>.
It takes the argument <I>n</I>, and adds the <I>__FILE__</I> and <I>__LINE__</I>
macros to the argument list of the <B>LB_Malloc</B> call:
<BLOCKQUOTE>#define&nbsp;&nbsp;&nbsp; <B>LB_MALLOC</B>(<I>n</I>)&nbsp;&nbsp;&nbsp;&nbsp;
<B>LB_Malloc</B>((<I>n</I>), <I>__FILE__</I>, <I>__LINE__</I>)</BLOCKQUOTE>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp;<I> n</I></TD>

<TD>The size (in bytes) of the memory-allocation request.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; file</I></TD>

<TD>A string containing the name of the file calling the function. The
<I>__FILE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; line</I></TD>

<TD>The line number within <I>file</I> of the call to the function. The
<I>__LINE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; double *</TD>

<TD>A pointer to the starting address of memory allocated.&nbsp; NULL is
returned if <I>n</I> = 0 or the routine is unsuccessful.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>struct <B>LB_Struct</B> *<I>b</I> = (struct <B>LB_Struct</B> *) <B>LB_MALLOC</B>(<I>sizeof</I>(struct
<B>LB_Struct</B>));</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Allocates memory for one <B>LB_Struct</B> data structure.&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Realloc"></A>double *<B>LB_Realloc</B>(void *<I>ptr</I>,
int <I>n</I>, char *<I>file</I>, int <I>line</I>);&nbsp;
<HR>

<P>The <B>LB_Realloc</B> function is a "safe" version of realloc. It changes
the size of the object pointed to by <I>ptr</I> to <I>n</I> bytes. The
contents of <I>ptr</I> are unchanged up to a minimum of the old and new
sizes. Error tests ensuring that <I>n</I> is a positive number and that
space is available to be allocated are performed.

<P>A macro <B>LB_REALLOC</B> is defined in <I>all/all_allo_const.h</I>.
It takes the arguments <I>ptr</I> and <I>n</I>, and adds the <I>__FILE__</I>
and <I>__LINE__</I> macros to the argument list of the <B>LB_Realloc</B>
call:
<BLOCKQUOTE>#define&nbsp;&nbsp;&nbsp; <B>LB_REALLOC</B>(<I>ptr</I>, <I>n</I>)&nbsp;&nbsp;&nbsp;
<B>LB_Realloc</B>((<I>ptr</I>), (<I>n</I>), <I>__FILE__</I>, <I>__LINE__</I>)</BLOCKQUOTE>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>ptr</I></TD>

<TD>Pointer to allocated memory to be re-sized.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp;<I> n</I></TD>

<TD>The size (in bytes) of the memory-allocation request.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; file</I></TD>

<TD>A string containing the name of the file calling the function. The
<I>__FILE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; line</I></TD>

<TD>The line number within <I>file</I> of the call to the function. The
<I>__LINE__</I> macro can be passed as this argument. This argument is
useful for debugging memory allocation problems.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; double *</TD>

<TD>A pointer to the starting address of memory allocated.&nbsp; If the
routine is unsuccessful, NULL is returned and *<I>ptr</I> is unchanged.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD><I>int</I> *<I>b</I> = (<I>int </I>*) <B><A HREF="#LB_Malloc">LB_MALLOC</A></B>
(<I>sizeof</I> (struct <B>LB_Struct</B>));&nbsp;
<BR><I>b</I> = (<I>int </I>*) <B>LB_REALLOC</B> (<I>b</I>, 2*<I>n</I>);</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Reallocates memory for <I>b</I> from length <I>n</I> to length 2*<I>n</I>.&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Free"></A>void <B>LB_Free</B>(void **<I>ptr</I>, char *<I>
file</I> , int <I>line</I>);&nbsp;
<HR>

<P>The <B>LB_Free</B> function calls the system's "free" function for the
memory pointed to by <I>*ptr</I>. Note that the argument to this routine
has an extra level of indirection when compared to the standard C "free"
call. This allows the pointer being freed to be set to NULL, which can
help find errors in which a pointer is used after it is deallocated. Error
checking is performed to prevent attempts to free NULL pointers. When <B>LB_Free</B>
is used with the DEBUG_MEMORY options, it can help identify memory leaks.

<P>A macro <B>LB_FREE</B> is defined in <I>all/all_allo_const.h</I>. It
takes the argument <I>ptr</I>, and adds the <I>__FILE__</I> and <I>__LINE__</I>
macros to the argument list of the <B>LB_Free</B> call:
<BLOCKQUOTE>#define&nbsp;&nbsp;&nbsp; <B>LB_FREE</B>(<I>ptr</I>)&nbsp;&nbsp;&nbsp;&nbsp;
<B>LB_Free</B>((void **)(<I>ptr</I>), <I>__FILE__</I>, <I>__LINE__</I>)</BLOCKQUOTE>
Using this macro, the developer gains the file and line debugging information
without having to type file and line information in each memory allocation
call.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>ptr</I></TD>

<TD>Address of a pointer to the memory to be freed. Upon return, <I>ptr</I>
is set to NULL.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD><B>LB_FREE</B>(&amp;<I> x</I>);</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Frees memory associated with the variable <I>x</I>; upon return, <I>x</I>
is NULL.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Special_Malloc"></A>int <B>LB_Special_Malloc</B>(struct
LB_Struct *<I>lb</I>, void **<I>array</I>, int <I>size</I>,
LB_SPECIAL_MALLOC_TYPE <I>type</I>);&nbsp;
<HR>

<P>The <B>LB_Special_Malloc</B> routine allocates memory for result arrays
like <I>import_global_ids</I>, <I>import_local_ids</I>, <I>import_procs</I>,
<I>export_global_ids</I>, <I>export_local_ids</I> and <I>export_procs</I>.
Since these arrays are returned to the application, they must be allocated
by <B>LB_Special_Malloc</B> to insure they are allocated by the same
language as the application.  Memory allocated by <B>LB_Special_Malloc</B>
must be deallocated by <B>LB_Special_Free</B>.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; lb</I></TD>

<TD>The load balancing object currently in use.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; array</I></TD>

<TD>Usually of type int**, LB_GID**, or LB_LID**.  Returned as a pointer
to the allocated space.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; size</I></TD>

<TD>The number of elements (not bytes) to be allocated.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>type</I></TD>

<TD>The type of array to allocate.  Must be one of LB_SPECIAL_MALLOC_INT,
LB_SPECIAL_MALLOC_GID or LB_SPECIAL_MALLOC_LID.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; int</TD>

<TD>1 if the allocation succeeded; 0 if it failed.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>ierr = <B>LB_Special_Malloc</B>(<I>lb</I>, (void **)<I>import_gid</I>,
<I>num_import</I>, LB_SPECIAL_MALLOC_GID);</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Allocates an array with <I>num_import</I> LB_GIDs.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Special_Free"></A>int <B>LB_Special_Free</B>(struct
LB_Struct *<I>lb</I>, void **<I>array</I>,
LB_SPECIAL_MALLOC_TYPE <I>type</I>);&nbsp;
<HR>

<P><B>LB_Special_Free</B> frees memory allocated by <B>LB_Special_Malloc</B>.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; lb</I></TD>

<TD>The load balancing object currently in use.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; array</I></TD>

<TD>The array to be freed.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>type</I></TD>

<TD>The type of the array.  Must be one of LB_SPECIAL_MALLOC_INT,
LB_SPECIAL_MALLOC_GID or LB_SPECIAL_MALLOC_LID.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; int</TD>

<TD>1 if the deallocation succeeded; 0 if it failed.</TD>
</TR>

<TR>
<TD VALIGN=TOP><B>Example:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>ierr = <B>LB_Special_Free</B>(<I>lb</I>, (void **)<I>import_gid</I>,
LB_SPECIAL_MALLOC_GID);</TD>
</TR>

<TR>
<TD VALIGN=TOP></TD>

<TD>Frees the LB_GID array <I>import_gid</I>.
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="Debug_Memory"></A>
<H3>
<B>Debugging Memory Errors</B></H3>
The principle reason that Zoltan has wrappers around the system memory
routines is to facilitate debugging of memory problems. These capabilities
are supported by the <B>DEBUG_MEMORY</B> parameter whose value can be altered
via the <A HREF="dev_util_params.html#Set_Param">LB_Set_Param</A> routine.
Valid values for this integer parameter range from 0 through 3. A value
of 0 turns off all debugging. With a value of 1 (the default), the number
of calls to <B>LB_Malloc</B> and the number of calls to <B>LB_Free</B>
are tallied, and can be printed by call to <B>LB_Memory_Stats</B> (type
void, no arguments). If <B>DEBUG_MEMORY</B> is 2, then Zoltan keeps a list
of all calls to <B>LB_Malloc</B> which have not yet been freed. This list
is outputed by a call to <B>LB_Memory_Stats</B>. This is a useful tool
for detecting memory leaks. Also, any calls to <B>LB_Free</B> with addresses
not in this list trigger warning messages. (Note that allocations which
occurred prior to setting <B>DEBUG_MEMORY</B> to 2 will not be in this
list and so can generate spurious warnings.) If additional information
is needed, then a value for <B>DEBUG_MEMORY</B> of 3 also prints information
about each allocation as it happens. We have found values of 1 and 2 to
be very helpful in our development efforts.&nbsp;
<HR WIDTH="100%">
<BR>[<A HREF="dev.html">Table of Contents</A>&nbsp; |&nbsp; <A HREF="dev_util_params.html">Next:&nbsp;
Parameter Setting Routines</A>&nbsp; |&nbsp; <A HREF="dev_util.html">Previous:&nbsp;
Utilities</A>]
</BODY>
</HTML>
