<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1376">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title> Zoltan Developer's Guide:  Communication Utilities</title>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>
</head>
<body bgcolor="#FFFFFF">

<div ALIGN=right>
<h3>
<img SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></h3></div>

<h2>
<a NAME="irreg_comm"></a>Irregular Communication Library</h2>
For much of its communication, the Zoltan library uses the irregular communication
package developed by Bruce Hendrickson and Steve Plimpton.&nbsp; The package
consists of a few simple functions which create communication maps, perform
communication, and destroy communication maps upon completion.
<br>The functions are listed below.
<blockquote><b><a href="#LB_Comm_Create">LB_Comm_Create</a>:&nbsp; </b>computes
a communication plan for sending objects to destination processors.
<br><b><a href="#LB_Comm_Do">LB_Comm_Do</a>:&nbsp; </b>uses a communication
plan to send objects to destination processors.
<br><b><a href="#LB_Comm_Destroy">LB_Comm_Destroy</a>:</b>&nbsp; free memory
associated with a communication plan.</blockquote>
The Zoltan library uses the irregular communication package in its migration-help
tools and in some of the load-balancing algorithms. For example, in <b><a href="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</a></b>,
<b><a href="#LB_Comm_Create">LB_Comm_Create</a></b>
is used to develop a communication map for sending objects to be exported
to their new destination processors. The data for the objects is packed
into a communication buffer and sent to the other processors through a
call to <b><a href="#LB_Comm_Do">LB_Comm_Do</a></b>. Simultaneously, each
processor receives a communication buffer with data for objects it is importing.
After the imported objects are unpacked, the communication plan is no longer
needed; it is deallocated by a call to
<b><a href="#LB_Comm_Destroy">LB_Comm_Destroy</a></b>.
Developers should use the package whenever possible, as improvements made
to the package to support heterogeneous architectures can then automatically
propagate to the algorithms.
<p>The order that messages are processed in the communication package is,
by default, deterministic.&nbsp; Messages are processed in order of their
sending processors' ID&nbsp;numbers.&nbsp; Setting the <a href="../ug_html/ug_alg.html#General_Parameters">general
parameter</a> <b>DETERMINISTIC</b>&nbsp;to FALSE allows the communication
package to process messages in the order they are received by a processor.
This non-deterministic logic provides slightly more efficient execution;
the library reads messages from any processor and sets pointers to the
storage for that processor sequentially in the receiving buffer. However,
imported objects may be processed in different orders, depending on the
order of their sending processors in the communication plan, causing the
results to vary over several executions of the program.
<br>&nbsp;
<p>
<hr><a NAME="LB_Comm_Create"></a>int<b> LB_Comm_Create</b>(struct Comm_Obj&nbsp;
**<i>plan</i>,<b> </b>int <i>nsend</i>, int *<i>proclist</i>, MPI_Comm
<i>comm</i>
, int <i>tag</i>, int *<i>nreturn</i>);&nbsp;
<hr>
<p>The <b>LB_Comm_Create</b> function sets up the communication plan in
the irregular communication package. Its input is a count of objects to
be sent to other processors, a list of the processors to which the objects
should be sent (repetitions are allowed), and an MPI communicator and tag.
It allocates and builds a communication plan that describes to which processors
data will be sent and from which processors data will be received. It also
computes the amount of data to be sent to and received from each processor.
It returns the number of objects to be received by the processor and a
pointer to the communication plan it created. In <b><a href="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</a></b>,
for example, the number of objects to be exported by a processor and a
list of the destination processors for the objects are passed to <b>LB_Comm_Create</b>;
the resulting plan describes the communication patterns needed to export
the objects and to import objects to establish a new decomposition. This
plan is then used by calls to <b><a href="#LB_Comm_Do">LB_Comm_Do</a></b>
to perform the actual communication.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>plan</i></td>

<td>A pointer to the communication plan created by <b>LB_Comm_Create</b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; nsend</i></td>

<td>The number of objects to be sent to other processors.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; proclist</i></td>

<td>An array of size <i>nsend</i> of destination processor numbers for
each of the objects to be sent.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; comm</i></td>

<td>The MPI communicator for the irregular communication.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>tag</i></td>

<td>A tag for MPI communication.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nreturn</i></td>

<td>Upon return, the number of objects to be received by the processor.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp; int</td>

<td>Error code.</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Comm_Do"></a>int<b> LB_Comm_Do</b>(struct Comm_Obj *<i>plan</i>,
int <i>tag</i>, char *<i>sendbuf</i>, int <i>nsize</i>, char *<i>recvbuf</i>);&nbsp;
<hr>
<p>The <b>LB_Comm_Do</b> function performs the communication described
in a communication plan built by <b><a href="#LB_Comm_Create">LB_Comm_Create</a></b>.
Using the plan, it takes a buffer of object data to be sent and the size
(in bytes) of each object's data in that buffer and sends the data to other
processors. In <b><a href="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</a></b>,
for example, the send buffer is filled by <b><a href="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</a></b>
through calls to the <i>lb->Pack_Obj</i> function for all objects to be
exported. The <b>LB_Comm_Do</b> function also receives object data from
other processors and stores it in a receive buffer. In <b><a href="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</a></b>,
the data for objects to be imported is received in <i>recvbuf</i> and can
then be unpacked through calls to the <i>lb->Unpack_Obj</i> function for
each imported object. The receive buffer must be allocated by the code
calling <b>LB_Comm_Do</b> using the number of received objects returned
by <b><a href="#LB_Comm_Create">LB_Comm_Create.</a></b><i> </i>All objects
(both sent and received) are assumed to have the same data size.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; plan</i></td>

<td>A pointer to a communication plan built by <b><a href="#LB_Comm_Create">LB_Comm_Create</a></b>.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>tag</i></td>

<td>An MPI message tag.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; sendbuf</i></td>

<td>A buffer filled with object data to be sent to other processors.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; nsize</i></td>

<td>The size (in bytes) of the data for one object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>recvbuf</i></td>

<td>Upon return, a buffer filled with object data received from other processors.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; int</td>

<td>Error code.</td>
</tr>
</table>

<p>
<hr><a NAME="LB_Comm_Destroy"></a>int <b>LB_Comm_Destroy</b>(struct Comm_Obj
**<i>plan</i>);&nbsp;
<hr>
<p>The <b>LB_Comm_Destroy</b> function frees all memory associated with
a communication plan created by <b><a href="#LB_Comm_Create">LB_Comm_Create</a></b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr VALIGN=TOP>
<td VALIGN=TOP WIDTH="20%"><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; plan</i></td>

<td>A pointer to a communication plan built by <b><a href="#LB_Comm_Create">LB_Comm_Create</a></b>.&nbsp;
Upon return, <i>plan</i> is set to NULL.&nbsp;</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; int</td>

<td>Error code.</td>
</tr>
</table>

<hr WIDTH="100%">
<br>[<a href="dev.html">Table of Contents</a>&nbsp; |&nbsp; <a href="dev_util_parallel.html">Next:&nbsp;
Parallel Computing Utilities</a>&nbsp; |&nbsp; <a href="dev_util_params.html">Previous:&nbsp;
Parameter Setting Utilities</a>]
</body>
</html>
