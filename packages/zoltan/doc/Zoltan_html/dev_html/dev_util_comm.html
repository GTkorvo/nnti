<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <META NAME="sandia.approved" CONTENT="SAND99-1376">
   <META NAME="author" CONTENT="karen devine, kddevin@sandia.gov">
   <TITLE> Zoltan Developer's Guide:  Communication Utilities</TITLE>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></H3></DIV>

<H2>
<A NAME="irreg_comm"></A>Irregular Communication Library</H2>
For much of its communication, the Zoltan library uses the irregular communication
package developed by Bruce Hendrickson and Steve Plimpton.&nbsp; The package
consists of a few simple functions which create communication maps, perform
communication, and destroy communication maps upon completion.
<BR>The functions are listed below.
<BLOCKQUOTE><B><A HREF="#LB_Comm_Create">LB_Comm_Create</A>:&nbsp; </B>computes
a communication plan for sending objects to destination processors.
<BR><B><A HREF="#LB_Comm_Do">LB_Comm_Do</A>:&nbsp; </B>uses a communication
plan to send objects to destination processors.
<BR><B><A HREF="#LB_Comm_Destroy">LB_Comm_Destroy</A>:</B>&nbsp; free memory
associated with a communication plan.</BLOCKQUOTE>
The Zoltan library uses the irregular communication package in its migration-help
tools and in some of the load-balancing algorithms. For example, in <B><A HREF="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>,
<B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B> is used to develop
a communication map for sending objects to be exported to their new destination
processors. The data for the objects is packed into a communication buffer
and sent to the other processors through a call to <B><A HREF="#LB_Comm_Do">LB_Comm_Do</A></B>.
Simultaneously, each processor receives a communication buffer with data
for objects it is importing. After the imported objects are unpacked, the
communication plan is no longer needed; it is deallocated by a call to
<B><A HREF="#LB_Comm_Destroy">LB_Comm_Destroy</A></B>. Developers should
use the package whenever it is appropriate.

<P>The order that messages are processed in the communication package is
non-deterministic; it depends only on the order they are received by a
processor. This non-deterministic logic provides the most efficient execution;
the library reads messages from any processor and sets pointers to the
storage for that processor sequentially in the receiving buffer. Thus,
imported objects may be processed in different orders, depending on the
order of their sending processors in the communication plan. For debugging,
however, it is sometimes useful to impose a deterministic order upon the
message processing. In such cases, the function call to <B>debug_sort2_int_int</B>
in <B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B> should be used.
It sorts the received messages in order of their processor numbers. Thus,
imported objects are processed in order of their sending processors.&nbsp;
Ensuring deterministic results this way will be possible through a parameter
in future versions.
<BR>&nbsp;
<BR>&nbsp;

<P>
<HR><A NAME="LB_Comm_Create"></A>int<B> LB_Comm_Create</B>(struct Comm_Obj&nbsp;
**<I>plan</I>,<B> </B>int <I>nsend</I>, int *<I>proclist</I>, MPI_Comm
<I>comm</I> , int <I>tag</I>, int *<I>nreturn</I>);&nbsp;
<HR>

<P>The <B>LB_Comm_Create</B> function sets up the communication plan in
the irregular communication package. Its input is a count of objects to
be sent to other processors, a list of the processors to which the objects
should be sent (repetitions are allowed), and an MPI communicator. It allocates
and builds a communication plan that describes to which processors data
will be sent and from which processors data will be received. It also computes
the amount of data to be sent to and received from each processor. It returns
the number of objects to be received by the processor and a pointer to
the communication plan it created. In <B><A HREF="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>,
for example, the number of objects to be exported by a processor and a
list of the destination processors for the objects are passed to <B>LB_Comm_Create</B>;
the resulting plan describes the communication patterns needed to export
the objects and to import objects to establish a new decomposition. This
plan is then used by calls to <B><A HREF="#LB_Comm_Do">LB_Comm_Do</A></B>
to perform the actual communication.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD>&nbsp;&nbsp;&nbsp; <I>plan</I></TD>

<TD>A pointer to the communication plan created by <B>LB_Comm_Create</B>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; nsend</I></TD>

<TD>The number of objects to be sent to other processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; proclist</I></TD>

<TD>An array of size <I>n</I> of destination processor numbers for each
of the objects to be sent.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; comm</I></TD>

<TD>The MPI communicator for the irregular communication.</TD>
</TR>

<TR>
<TD>&nbsp;&nbsp;&nbsp; <I>tag</I></TD>

<TD>A tag for MPI communication.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>nreturn</I></TD>

<TD>Upon return, the number of objects to be received by the processor.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; int</TD>

<TD>Error code.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Comm_Do"></A>int<B> LB_Comm_Do</B>(struct Comm_Obj *<I>plan</I>,
int <I>tag</I>, char *<I>sendbuf</I>, int <I>nsize</I>, char *<I>recvbuf</I>);&nbsp;
<HR>

<P>The <B>LB_Comm_Do</B> function performs the communication described
in a communication plan built by <B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B>.
Using the plan, it takes a buffer of object data to be sent and the size
(in bytes) of each object's data in that buffer and sends the data to other
processors. In <B><A HREF="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>,
for example, the send buffer is filled by <B><A HREF="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>
through calls to the <I>lb->Pack_Obj</I> function for all objects to be
exported. The <B>LB_Comm_Do</B> function also receives object data from
other processors and stores it in a receive buffer. In <B><A HREF="../ug_html/ug_interface_mig.html#LB_Help_Migrate">LB_Help_Migrate</A></B>,
the data for objects to be imported is received in <I>recvbuf</I> and can
then be unpacked through calls to the <I>lb->Unpack_Obj</I> function for
each imported object. The receive buffer must be allocated by the code
calling <B>LB_Comm_Do</B> using the number of received objects returned
by <B><A HREF="#LB_Comm_Create">LB_Comm_Create.</A></B><I> </I>All objects
(both sent and received) are assumed to have the same data size.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; plan</I></TD>

<TD>A pointer to a communication plan built by <B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B>.</TD>
</TR>

<TR>
<TD>&nbsp;&nbsp;&nbsp; <I>tag</I></TD>

<TD>An MPI message tag.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; sendbuf</I></TD>

<TD>A buffer filled with object data to be sent to other processors.</TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; nsize</I></TD>

<TD>The size (in bytes) of the data for one object.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;&nbsp; <I>recvbuf</I></TD>

<TD>Upon return, a buffer filled with object data received from other processors.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD>&nbsp;&nbsp;&nbsp; int</TD>

<TD>Error code.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<HR><A NAME="LB_Comm_Destroy"></A>int <B>LB_Comm_Destroy</B>(struct Comm_Obj
**<I>plan</I>);&nbsp;
<HR>

<P>The <B>LB_Comm_Destroy</B> function frees all memory associated with
a communication plan created by <B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B>.
<BR>&nbsp;
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP><I>&nbsp;&nbsp;&nbsp; plan</I></TD>

<TD>A pointer to a communication plan built by <B><A HREF="#LB_Comm_Create">LB_Comm_Create</A></B>.&nbsp;
Upon return, <I>plan</I> is set to NULL.&nbsp;</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD>&nbsp;&nbsp;&nbsp; int</TD>

<TD>Error code.</TD>
</TR>
</TABLE>

<HR WIDTH="100%">
<BR>[<A HREF="dev.html">Table of Contents</A>&nbsp; |&nbsp; <A HREF="dev_util_parallel.html">Next:&nbsp;
Parallel Computing Utilities</A>&nbsp; |&nbsp; <A HREF="dev_util_params.html">Previous:&nbsp;
Parameter Setting Utilities</A>]
</BODY>
</HTML>
