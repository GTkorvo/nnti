<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! Zoltan is distributed under the GNU Lesser General Public License 2.1.     !
 ! For more info, see the README file in the top-level Zoltan directory.      ! 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>
<! CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
>

<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 4.1.3_U1 sun4m) [Netscape]">
   <META NAME="sandia.approved" CONTENT="SAND99-1376">
   <META NAME="author" CONTENT="karen devine, kddevin@sandia.gov">

   <TITLE> Zoltan Developer's Guide:  Testing in MPSalsa</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></H3></DIV>

<H2>
<A NAME="Salsa"></A>Appendix: Testing in MPSalsa</H2>
The Zoltan library was tested in MPSalsa, a 3D unstructured finite element
code for simulating chemically reacting flow [<A HREF="dev_refs.html#MPSalsa">MPSalsa
User's Guide</A>]. Currently, calls to the load-balancing library are included
in the steady-state solver. A test problem is solved using the original
decomposition provided by nem_slice. A new decomposition is then computed
through a call to the load-balancing library (<I>call_load_balancing</I>
function in MPSalsa's <I>rf/rf_dlb.c</I>). The simulation is run again
using the new decomposition and the solution from the previous solve as
the initial guess for the new solve. Thus, in MPSalsa's output, the initial
values for the new solve should correspond with the final values of the
previous solve. This condition can be checked coarsely by comparing the
minimum, maximum and average solution values of the old solve's final solution
with the new solve's initial guess; it can be checked more carefully by
using MPSalsa's debug level of 7 and comparing each solution vector entry
for the old and new solve. Because the initial guess for the new solve
is the steady-state solution, only one (or perhaps, two) Newton steps should
be required in the new solve; any greater number probably indicates a problem
with migration of the solution vector.

<P>After the second solve, the load-balancing library is invoked again
after registering an <B><A HREF="../ug_html/ug_query_lb.html#LB_OBJ_WEIGHT_FN">LB_OBJ_WEIGHT_FN</A></B>
query function. Thus, load-balancing is performed this time using object
weights. In the current implementation, nodal weights are determined arbitrarily
by the nodal coordinates. To see the values to which the weights are set,
one should look at assignments to the <I>Weight</I> field of the <I>Node_Struct</I>
data structure defined in <I>rf/rf_node_const.h</I>. These weights can
be set to any value desired by the user. More intelligent weighting schemes
that, say, take into account nodal fill times or number of non-zeros on
the node's row of the matrix, can (and probably should) be implemented.

<P>The load-balancing query functions and all data migration functions
are implemented in <I>rf/rf_dlb.c</I> and <I>rf/rf_dlb_const.h</I>. Data
types for global and local object IDs are defined in <I>rf/rf_dlb_user_const.h</I>;
this file should be copied to <I>lb/lb_user_const.h</I> before compiling
the load-balancing library. Global IDs are integers representing global
node or element numbers. Local IDs are pointers to nodes or elements. Calls
to load-balancing library functions are currently in <I>rf/rf_salsa.c</I>
(for initialization) and <I>rf/rf_solve.c </I>(to register weight functions).
All load-balancing code is enclosed within "#ifdef DLB / #endif" controls
to prevent interference between load-balancing testing and other project
development.

<P>A working distribution of MPSalsa can be obtained from CVS using the
following command:
<BLOCKQUOTE>cvs checkout MPSalsa</BLOCKQUOTE>
Minor changes to the Makefiles are necessary to enable the DLB flag and
set paths to the load-balancing interface files. In the top-level MPSalsa
Makefile, the standard MPSalsa distribution from CVS has
<BLOCKQUOTE>SUBVPATH=../rf ../el ../md ../ps ../pe ../ds
<BR>SUBINCPATH=-I../rf -I../el -I../md -I../ps -I../pe -I../ds</BLOCKQUOTE>
Assuming the load-balancing library's CVS distribution is in a directory
named <I>DLB</I> in the same directory as MPSalsa's CVS distribution, these
lines should be changed to
<BLOCKQUOTE>SUBVPATH=../rf ../el ../md ../ps ../pe ../ds ../../DLB/lb
<BR>SUBINCPATH=-I../rf -I../el -I../md -I../ps -I../pe -I../ds -I../../DLB/lb</BLOCKQUOTE>
Commented versions of these lines are included in the top-level Makefile.

<P>In lower-level MPSalsa Makefiles, the DLB flags should be activated
by removing the comment character from lines defining DLB_DEF and DLB_LIB.
For example, in MPSalsa's <I>Obj_smos/Makefile</I>, the following lines
should be included:
<BLOCKQUOTE>DLB_DEF = -DDLB
<BR>DLB_LIB =-L../../DLB/Obj_smos -lzoltan -L/Net/mp/mpi/new/lib/paragon/sunmos-nx
-lmpi</BLOCKQUOTE>
An MPSalsa executable is then built using gmake and specifying the target
architecture; e.g.,
<BLOCKQUOTE>gmake smos</BLOCKQUOTE>
builds the MPSalsa executable for the Intel Paragon sipapu.

<P>Unfortunately, the exclusion of the load-balancing code from the standard
compilation of MPSalsa makes testing by other MPSalsa users unlikely; perhaps
a load-balancing developer can occasionally run MPSalsa's parallel software
test suite, comparing the text output files, to ensure that changes to
MPSalsa haven't broken the data migration routines. The more elegant solution
of automatically running a parallel version of MPSalsa with the load-balancing
enabled would require significantly changing MPSalsa's <I>dtest</I> utility,
a most unpleasant task.

<P>The load-balancing method and parameters for the method can be specified
in the MPSalsa input file in the User-Function section. An example user-function
section for RCB load balancing is included in the <A HREF="#salsa input fig">figure</A>
below. The <I>Function Name</I> specification states that the <I>LB_set_up
</I>function receives three <I>FN_DATA</I> data lines. The first data line
contains a string that specifies the name of the load-balancing method
to be used in the call to <B><A HREF="../ug_html/ug_interface_lb.html#LB_Set_Method">LB_Set_Method</A></B>.
The string <I>NONE</I> is a valid option on this line if no balancing is
desired.

<P>The second data line contains the floating-point parameters to be passed
to the load-balancing library in <B><A HREF="../ug_html/ug_interface_lb.html#LB_Set_Method">LB_Set_Method</A></B>.
These parameters must be listed in the order that the load-balancing method
would expect them. If a <I>FLOAT</I> <I>FN_DATA</I> line is not included,
the default load-balancing parameters are used.

<P>The third data line contains two integers. The first integer specifies
the amount of debugging information MPSalsa prints during load balancing
and data migration. Higher values of this integer produce greater amounts
of debugging output. The second integer enables MPSalsa to test the use
of different MPI communicators in the load-balancing library. If the integer
is 0, all processors participate in load balancing. If the integer is 1,
only processors with rank less than or equal to <I>N/2</I> participate,
where <I>N</I> is the number of processors. If the integer is 2, two separate
instances of load balancing occur simultaneously, one among the lower <I>N/2</I>
processors and the other among the remaining processors. If an <I>INT FN_DATA</I>
line is not included, the default debugging level (zero) and MPI communicator
(<I>MPI_COMM_WORLD</I>) are used.
<BR>&nbsp;
<BR>&nbsp;
<CENTER><TABLE BORDER=2 COLS=1 WIDTH="90%" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><A NAME="salsa input fig"></A><TT>------------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Data Specification for User's Functions</TT>
<BR><TT>------------------------------------------------------------</TT>
<BR><TT>Number of functions to pass data to = 1</TT>
<BR><TT>Function Name = LB_set_up&nbsp; 3</TT>
<BR><TT>FN_DATA = STRING RCB</TT>
<BR><TT>FN_DATA = FLOAT&nbsp; 1.0 0.0</TT>
<BR><TT>FN_DATA = INT 0 0</TT></TD>
</TR>

<CAPTION ALIGN=BOTTOM><I>User-function section of the MPSalsa input file
to select RCB&nbsp;load balancing.</I></CAPTION>
</TABLE></CENTER>
&nbsp;

<P>Some example MPSalsa problems that use the load balancing library are
in the directory
<BLOCKQUOTE>/Net/pecos/rf_crew/people/kddevin/ex/lb</BLOCKQUOTE>
MPSalsa input files are typically named <I>in.*</I> or <I>input.*</I>.
Refer to the <A HREF="dev_refs.html#MPSalsa">MPSalsa User's Guide</A> for
more details on running MPSalsa.

<P>To visualize nodal weights or processor assignments, an auxiliary MPSalsa
output file must be created. Such a file can be built using the <I>add_var</I>
utility:
<BLOCKQUOTE>add_var -n 2 -l Weight, Processor -o exo_file-out-aux.exoII
exo_file.exoII</BLOCKQUOTE>
where "exo_file" corresponds to the ExodusII mesh file specified in MPSalsa
input file. (The command "<I> add_var -h"</I> provides help for using <I>add_var</I>.)
An Auxiliary Output Specification must then be added to the MPSalsa input
file; this section must precede the Parallel I/O Section. An example of
the Auxiliary Output Specification for nodal weights and nodal processor
assignments is shown in the <A HREF="#exodus fig">figure</A> below. The
name of the auxiliary output file should be the name of the file created
by the <I>add_var</I> utility. The number of auxiliary nodal variables
is two: the nodal weights and the nodal processor assignments. The functions
<I>f_dlb_weight</I> and <I>f_dlb_processor</I> are MPSalsa functions that
return the nodal weights and processor assignments, respectively. After
MPSalsa's execution, the auxiliary output file can be viewed with <I>AVS</I>,
<I>Mustafa</I>, <I>blot</I>, or any graphics utility that reads ExodusII
files.
<BR>&nbsp;
<BR>&nbsp;
<CENTER><TABLE BORDER=2 COLS=1 WIDTH="90%" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><A NAME="exodus fig"></A><TT>-------------------------------</TT>
<BR><TT>Auxiliary Output Specifications</TT>
<BR><TT>-------------------------------</TT>
<BR><TT>Auxiliary output file = exo_file-out-aux.exoII</TT>
<BR><TT>Number of auxiliary nodal variables = 2</TT>
<BR><TT>Auxiliary nodal variable and function name(s):</TT>
<BR><TT>AUX_OUT = Weight FUNCTION = f_dlb_weight</TT>
<BR><TT>AUX_OUT = Processor FUNCTION = f_dlb_processor</TT></TD>
</TR>

<CAPTION ALIGN=BOTTOM><I>Auxiliary Output section of the MPSalsa input
file to create an auxiliary ExodusII file for nodal weights and nodal processor
assignments.</I></CAPTION>
</TABLE></CENTER>
&nbsp;

<P>Data migration in MPSalsa does not yet work for problems where mesh
refinement is used, as parent and child elemental information is not yet
migrated.

<P>
<HR WIDTH="100%">
<BR>[<A HREF="dev.html">Table of Contents</A>&nbsp; |&nbsp; <A HREF="dev_rcb.html">Next:&nbsp;
Recursive Coordinate Bisection</A>&nbsp; |&nbsp; <A HREF="dev_refs.html">Previous:&nbsp;
References</A>]
</BODY>
</HTML>
