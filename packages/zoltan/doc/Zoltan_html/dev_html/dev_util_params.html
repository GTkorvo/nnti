<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; U; SunOS 4.1.3_U1 sun4m) [Netscape]">
   <META NAME="sandia.approved" CONTENT="SAND99-1376">
   <META NAME="author" CONTENT="karen devine, kddevin@sandia.gov">

   <TITLE> Zoltan Developer's Guide:  Parameter Setting Utilities</TITLE>
<!
  ------------------------
  | CVS File Information |
  ------------------------
  $RCSfile$
  $Author$
  $Date$
  $Revision$
>

</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV ALIGN=right>
<H3>
<IMG SRC="figures/dev_header.gif" ALT="Zoltan Developer's Guide" ></H3></DIV>

<H2>
<A NAME="Memory"></A>Parameter Setting Utilities</H2>
Zoltan allows applications to change a number of parameter settings at
runtime. This facility supports debugging by, for instance, allowing control
over the type and quantity of output. It also allows users to modify some
of the parameters that characterize the partitioning algorithms. The design
of the parameter setting routines was driven by several considerations.
First, we wanted to keep the user interface as simple as possible. Second,
we wanted to allow different load-balancing structures to have different 
parameter settings associated with them. This second consideration precluded the
use of C's static global variables (except in a few special places). The
parameter routines described below allow developers to provide runtime
access to any appropriate variables. In some cases (e.g. <A HREF="dev_util_mem.html#Debug_Memory">MEMORY_DEBUG</A>)
it is appropriate to allow developers to tinker with parameters which will
never be documented for users.

<P>Our solution to parameter setting is to have a single interface routine
<B><A HREF="#LB_Set_Param">LB_Set_Param</A></B>. This function calls a
set of more domain-specific parameter setting routines, each of which is
responsible for a domain-specific set of parameters. Assuming there are
no errors, the parameter name and new value are placed in a linked list
of new parameters which is maintained by the load-balancing structure. When
a partitioning method is invoked on a load-balancing structure, it scans through
this linked list using the <B><A HREF="#LB_Assign_Param_Vals">LB_Assign_Param_Vals</A></B>
function, resetting parameter values which are appropriate to the method.

<P>The routines that control parameter setting are listed below.
<BLOCKQUOTE><B><A HREF="#LB_Set_Param">LB_Set_Param</A></B>:&nbsp; User
interface function which calls a set of method-specific routines.
<BR><B><A HREF="#LB_Check_Param">LB_Check_Param</A></B>:&nbsp; Routine
to check if parameter name and value are OK.
<BR><B><A HREF="#LB_Assign_Param_Vals">LB_Assign_Param_Vals</A></B>:&nbsp;
Scans list of parameter names &amp; values, setting relevant parameters
accordingly.</BLOCKQUOTE>

<HR><A NAME="LB_Set_Param"></A>int <B>LB_Set_Param</B>(struct <B>LB_Struct</B>
* <I>lb</I>, char * <I>param_name</I>, char * <I>new_val</I>);
<BR>
<HR>

<P>The <B>LB_Set_Param</B> function is the user interface for parameter
setting. It's principle purpose is to call a sequence of more domain-specific
routines for setting domain-specific paramters (e.g. <B>LB_Set_RCB_Param</B>).
If you are adding parameters to Zoltan, you must write one of these domain-specific
paramater routines and modify <B>LB_Set_Param</B> to call it. <B>LB_Set_RCB_Param</B>
can serve as a template for this task. The arguments to this routine are
two strings <I>param_name</I> and <I>new_val</I>. The domain-specific routines
return an integer value with the following meaning.
<BLOCKQUOTE>0 - The parameter name was found, and the value passed all
error checks.
<BR>1 - The parameter name was not found among the parameters known by
the domain-specific routine.
<BR>2 - The parameter name was found, but the value failed the error
checking.
<BR>3 - Same as 0, but do not add parameter and value to linked list.
<BR>Other - More serious error, value is an <A HREF="../ug_html/ug_interface.html#Error Codes">error
code</A>.</BLOCKQUOTE>
If one of the domain-specific parameter routines returns with a 0, then
<B>LB_Set_Param</B> adds the parameter and the value (both strings) to
a linked list of such pairs that is pointed to by the <I>Params</I> field
of the <I>lb</I> structure.
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>lb</I></TD>

<TD>The load-balancing structure whose parameter value is being modified.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>param_name</I></TD>

<TD>A string containing the name of the parameter being modified. It is
automatically converted to all capitals.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>new_val</I></TD>

<TD>The new value desired for the parameter, expressed as a string.</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; int</TD>

<TD><A HREF="../ug_html/ug_interface.html#Error Codes">Error code</A>.</TD>
</TR>
</TABLE>

<HR><A NAME="LB_Check_Param"></A>int <B>LB_Check_Param</B>( char * <I>param_name</I>,
char * <I>new_val</I>, struct <B>PARAM_VARS</B> * <I>params</I>, struct
<B>PARAM_UTYPE</B> * <I>result</I>, int * <I>matched_index</I>);
<BR>
<HR>The <B>LB_Check_Param</B> routine simplifies the task of writing your
own domain-specific parameter setting function. <B>LB_Check_Param</B> compares
the <I>param_name</I> string against a list of strings that you provide,
and if a match is found it extracts the new value from the <I>new_val</I>
string. See <B>LB_Set_RCB_Param</B> for an example of how to use this routine.
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>param_name</I></TD>

<TD>A capitalized string containing the name of the parameter being modified.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>new_val</I></TD>

<TD>The new value desired for the parameter, expressed as a string.</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>params</I></TD>

<TD>The data structure describing the domain-specific parameters to be
matched against. The data structure is an array of items, each of which
consists of three fields. The first field is a string which is a capitalized
name of a parameter. The second field is an address which is unused in
<B>LB_Check_Param</B>, but is used in <B><A HREF="#LB_Assign_Param_Vals">LB_Assign_Param_Vals</A></B>.
The third field is another capitalized string which indicates the type
of the parameter from the first field. Currently supported types are "INT",
"INTEGER", "DOUBLE", "LONG", "STRING" and "CHAR". It is easy to add additional
types by simple modifications to <B>LB_Check_Param</B> and <B><A HREF="#LB_Assign_Param_Vals">LB_Assign_Param_Vals</A></B>.
The array is terminated by an item consisting of three NULL fields. See
<B>LB_Set_RCB_Param</B> for an example of how to set up this data structure.&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>result</I></TD>

<TD>If <I>param_name</I> matches any of the parameter names from the first
field of the <I>params</I> data structure, then <B>LB_Check_Param</B> attempts
to decode the value in <I>new_val</I>. The type of the value is determined
by the third field in the <I>params</I> data structure. If the value decodes
properly, then it is returned in <I>result</I>.&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>matched_index</I></TD>

<TD>If <I>param_name</I> matches, then <I>matched_index</I> returns then
index into the <I>params</I> array which corresponds to the matched parameter
name. The <I>matched_index</I> and <I>result</I> values allow the developer
to check that values being assigned to parameters are valid.&nbsp;</TD>
</TR>

<TR>
<TD><B>Returned Value:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; int</TD>

<TD>0 - <I>param_name</I> found in <I>params</I> data structure and <I>new_val</I>
decodes OK.&nbsp;
<BR>1 - <I>param_name</I> not found in <I>params</I> data structure.&nbsp;
<BR>2 - <I>param_name</I> found in <I>params</I> data structure but <I>new_val</I>
doesn't decode properly.&nbsp;</TD>
</TR>
</TABLE>

<HR><A NAME="LB_Assign_Param_Vals"></A>void <B>LB_Assign_Param_Vals</B>(
struct <B>LB_PARAM</B> * <I>change_list</I>, struct <B>PARAM_VARS</B> *
<I>params</I>);
<BR>
<HR>This routine changes parameter values as specified by the list of names
and new values which is associated with a load-balancing structure. To use this
routine, parameter values should first be set to their defaults, and then
<B>LB_Assign_Param_Vals</B> should be called to alter the values as appropriate.
See <B>LB_rcb</B> for a template.
<TABLE WIDTH="100%" >
<TR VALIGN=TOP>
<TD VALIGN=TOP WIDTH="20%"><B>Parameters:</B></TD>

<TD></TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>change_list</I></TD>

<TD>The linked list of parameter names names and new values which is constructed
by <B><A HREF="#LB_Set_Param">LB_Set_Param</A></B> and is a field of the
structure defining a load-balancing structure.&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP>&nbsp;&nbsp; <I>params</I></TD>

<TD>The data structure describing the domain-specific parameters to be
matched against. The data structure is an array of items, each of which
consists of three fields. The first field is a string which is a capitalized
name of a parameter. The second field is an address of the parameter which
should be altered. The third field is another capitalized string which
indicates the type of the parameter being altered. Currently supported
types are "INT", "INTEGER", "DOUBLE", "LONG", "STRING" and "CHAR". It is
easy to add additional types by simple modifications to <B><A HREF="#LB_Check_Param">LB_Check_Param</A></B>
and <B>LB_Assign_Param_Vals</B>. The array is terminated by an item consisting
of three NULL fields.&nbsp;</TD>
</TR>
</TABLE>

<HR WIDTH="100%">
<BR>[<A HREF="dev.html">Table of Contents</A>&nbsp; |&nbsp; <A HREF="dev_util_comm.html">Next:&nbsp;
Irregular Communication Library</A>&nbsp; |&nbsp; <A HREF="dev_util_mem.html">Previous:&nbsp;
Memory Management Utilities</A>]
</BODY>
</HTML>
