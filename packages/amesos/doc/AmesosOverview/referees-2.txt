Dear Dr. Gladwell,

we have modified the paper to take into account all the comments of Referees
1, 2 and 3.  The requests of Referee 4 have mostly been fullfilled, except for
more examples. We have improved the example of Fig.  2, however:

1) The referee would like a real-life example. What is "real-life"? A
   tridiagonal matrix? A penta-diagonal? A matrix read from Harwell/Boeing? We
   can add an function that reads a matrix from file, but the reader will
   just find an obscure name like read_HB_matrix(). Would this be clearer? We
   don't think so.

2) A code snippet in an ACM/TOMS paper has to be brief, concise, simple-to-read. 
   We also want the code of Fig. 2 to be compilable and quickly
   understandable. The Amesos distribution already contains several "real-life"
   examples; they all differ *only* in the matrix generation part, which is
   not the goal of this paper; the linear system solution is exactly the same.

2) The referee says that the MATLAB code corresponding to Fig. 2 is 
   "(x = diag(ones(N,1)) \  rand(N,1))". Frankly, this sentence is unfair: we used
   a diagonal matrix to make the code shorter; we know that diagonal matrices
   don't require direct solvers.

4) The referee confuses the matrix creation and system solver phases. Amesos
   only tackles the latter; matrix creation is a whole different subject, very
   problem dependent and not the subject of the paper. In fact, Interface 3.3
   is just a wrapper to matrix queries (or get() methods), with no
   corresponding set() methods. Another reason why a more advanced example
   would be misleading for the reader.

5) The whole point of Amesos is that, for *any* matrix that satisfies Interface
   3.3, one can use any of the supported direct solvers. So reporting an
   example with a diagonal matrix, or another more complicated matrix, would
   not change the lines related to Amesos: they will always read:
   solver->SymbolicFactorizat(), solver->NumericFactorization(),
   solver->Solve().

6) The referee would like an example that is not based on Epetra, and
   details how to build all the classes Vector, Matrix, LinearProblem, Solver.
   First, this will take a few pages (at least). Second, it would require to
   entirely rewrite Amesos. Third, it would have no connections with the
   numerical results reported in Section 6.

Detailed answers to the associate editor's comments and referees' comments are
reported below.

We are looking forward to hearing from you.

Best regards,
-Marzio Sala, Ken Stanley and Mike Heroux

 
> ================================================================
> COMMENTS FROM ASSOCIATE EDITOR
> 
> Associate Editor: Boisvert, Ronald
> Comments to the Author:
> Two of the referees point out minor problems with the manuscript that should
> be very easy to fix. Please make those changes.

Done.

> One referee still has some fundamental problems. I am concerned about these
> because they strike at the heart of what it means to be a research paper
> focused on design issues. I hope that you can take a serious look at these
> comments and consider how you might respond to them. It seems to me that
> providing some of the suggested examples would greatly improve the paper.

Detailed answers can be found below.  See discussion above for issues
concerning the additional or modified example(s).

> I hope you will craft a revision for us. Please include a cover letter
> explaining how you respond to the major concerns of this last referee.
> 
> By the way, one of the referees questioned which link for Davis' book is most
> appropriate to use. When I asked Tim about this he explained as follows: the
> SIAM web page http://www.siam.org/fa02 is just a link to the web page for the
> book, http://www.cise.ufl.edu/research/sparse/CSparse, which then has a link
> to http://www.cise.ufl.edu/research/sparse/codes . So citing just
> http://www.siam.org/fa02 is enough.

Done.

> ------------------------------------------------------------------------------
> Referee: 1
> Comments to the Author
> 
> Overall, a very nice paper. I have only a few very minor comments/typos to note.
> 
> On page 2, (Q1), typo: should be "Is it portable to all required platforms and
> does it have an acceptable licensing agreement?"

Done.

> On page 2, you state that "For relatively simple problems, Q3 is usually the
> key point, followed by Q4." By "simple" do you mean "small", or do you mean
> "just solve Ax=b, nothing special, but A may be big". For the latter, I would
> agree. For the former, I would say Q1 and Q2 are critical, since Q3 and Q4 are
> so small as to be irrelevant. Can you clarify?

We modified the sentence to take into account the "small" case, which was left
out. The original sentence now refer to "possibly large but relatively
well-conditioned problems". 

> For the citation [Davis 2006], it would be better to cite the book (section
> 8.6) and perhaps also give the url. The book in Section 8.6 states that the
> online version can be found at www.siam.org/fa02. The online version states
> that it can be found at www.cise.ufl.edu/research/sparse/codes; I'm not sure
> why they are different. Perhaps cite both, to be safe. In any case, the url
> you have is incorrect in the references (drop the ".pdf" ending). Be sure to
> double check all the other url's you cite in the references.

We cite www.siam.org/fo02. (Note that we could not access
www.siam.org/fa02 today, 16-Dec-06...)
 
> ------------------------------------------------------------------------------
> Referee: 2
> Comments to the Author
> The authors have answered all the issues raised in the review reports.
> A few (very minor) comments; on page 2, line -2 "even if they truly important"
> an "are" is missing.  page 8, line 5: "compresses row storage" should be
> "compressed" page9, line 5: "data layout can differ" this entails a
> redistribution, which should probably be said explicitly, even if it is sort
> of implicitly acknowleged at page 17 in the first item discussing the model
> limitations.

Done. We have added a short sentence on data redistribution in page 9.

> There are mentions of the Fortran 90 language, specifying that it does not
> provide polymorphism and inheritance (page 4 and 18); the reference should
> probably be made to Fortran 95, which is the standard level most commonly
> implemented today; with fortran 2003 the comment about inheritance and
> polymorphism would be false, but no compiler on the market fully implements
> the standard as of today.

We not refer to Fortran 95 instead of Fortran 90. We added a sentence to
clarify that novel implementations of Fortran 2003 may change the picture.

> Two English sentences (in an otherwise very well written paper) don't sound
> quite right, at page 5 line -4, and page 8 line 1; not being a native speaker
> myself, I'll leave them to the editor.
> 
> ------------------------------------------------------------------------------
> Referee: 3
> Comments to the Author
> There are no comments
> 
> ------------------------------------------------------------------------------
> Referee: 4
> Comments to the Author 
> Referee 4: Comments to the Author
>
> This paper exhibits several improvements, but some issues still remain.  It is
> a good paper, with a noble cause, but its general claims of simplicity and
> flexibility are difficult to justify by the examples and supporting text.  The
> C code  for solving a diagonal system is somewhat trivial and side-steps many
> of the important design issues encountered in practice.    

It is important to understand that the construction of linear objects is not
related to Amesos; one can use Epetra or PETSc, or a custom format; the only
point is that the format must be wrapped by a class based on Interface 3.3.

> Likewise, the
> interface descriptions seem  incomplete. I still don't know, for example, how
> one is supposed to access components of the LinearProblem interface, 3.3; 

Several getXXX() methods have been added to the presented interfaces. 

> the List data structure in Interface 3.5 is unspecified; there is no description
> of what problem parameters this interface allows.   

A note on the List data structure has been added. The parameters are reported
in the manual and are of little interest in this context.

> The use of design patterns
> unnecessary complicates your interface code example.  

Why is this? Indeed, it makes it shorter, as it avoid an if (solver == "...")
... that would be required otherwise.

> There are a few errors > in the code example (Fig. 2) 

which errors?

> but more importantly there is no real discussion
> of how one is supposed to use these interfaces in practice, or why this
> approach is superior to similar approaches or designs.   
>
> In my first review I outlined steps the authors could take to justify their 
> claims.  I proposed an example solving a small linear system that could be 
> specified by hand, or read in from a file, and show the codes for solving this 
> with two different direct solver packages, using an appropriate Matrix and 
> Vector classes that implement the proposed interfaces.  (Something other than 
> the authors' own Epetra classes would be enlightening.) 

It will take a few pages to define all classes without Epetra support. Also,
the resulting code will have no connection with the one used in the numerical
results section.

> Letting the readers see 
> such examples would be very useful and help illustrate the simplicity, 
> generality,  and flexibility of the proposed interface.  As it stands, the 
> problem statement is great, the proposed solution has potential, but the paper 
> needs a more concentrated effort to demonstrate its design strengths. 

We don't believe that solving a 5x5 matrix would help the reader. Indeed, the
code would read EXACTLY as it is know, only the matrix generation part will
change. 

The current Amesos implementation is based on Epetra, so using a non-Epetra
class is currently impossible. This only refers to the virtual classes, not
their implementations. In fact, one can easily wrap *any* vector and
matrix class that satisfy the proposed interfaces using Epetra objects, than
use Amesos. The procedure is not difficult, however:
- it cannot be presented in a short example: Epetra implements 
  Interfaces 3.1, 3.2 and 3.3, but also adds a variety of other methods that
  are not relevant in the current, Amesos-related, discussion; 
- there are several details related to the Epetra implementation that are best
  described in Epetra documents and not in this paper, which focuses on the
  Amesos project
- Trilinos contains several functions that read Harwell/Boeing or MatrixMarket
  matrices; the Amesos examples indeed already contain such a reader.

It is important to note that Interfaces 3.2 and 3.3 describe how to *get*
matrix and vector elements, not how *set* them. Obviously set() methods are
required, though inessential for Amesos.

> I believe this paper has good potential.  The authors have done a nice job of 
> presenting their ideas, and by providing more discussions the "why" rather than 
> just the "what", they would elevate this manuscript from "good" to "excellent". 
>  
> Major points: 
> 
> 1) The authors state that primary design requirement of this interface is 
> "simplicity of usage" (Page 3): "Solving [a] linear system in a language like 
> MATLAB is very easy, i.e. one just writes x = A \ b.  It should not be much 
> different in a  non-MATLAB code."  When I look at the code example in Fig 2, 
> this looks VERY MUCH different than the corresponding MATLAB code (x = 
> diag(ones(N,1)) \  rand(N,1)).  How is this requirement being met? 
 
Frankly, this statement is quite unfair. First, there is no linear system to
be solved with diagonal matrices; here we create a diagonal matrix for
simplicity. The interested reader can access the vast Epetra documentation and
examples to create more interesting ones, or simply download Amesos and "cd
amesos/example; ls *.cpp".

Second, the code of Figure 2 is longer because C++ requires
statements that MATLAB doesn't: the #include, { and } braces, and
allocation/deallocation (we cannot avoid them unless we change language).  We
also have several comments for the reader.  Finally, several lines are
required to build the Epetra objects and are not related to the system
solution phase.

Line containing "string solverType = argv[1];" has been added to support
multiple solvers, as requested by the referee, and has no MATLAB equivalent.

If we consider all of this, MATLAB's backslash is then replaced by:

   solver->symbolicFactorization(); // symbolic factorization 
   solver->numericFactorization(); // numeric factorization 
   solver->solve(); // linear system solution 
   delete solver; 

which are not much more difficult than "A \ B". Note that MATLAB's backslash
does not store the symbolic and numeric factorization, while the code of Fig.
2 does.

> 2) Serial/Parallel:  If there was a serial interface presented in the paper, I 
> completely missed it.  The basic data structures, Vector and Matrix require a 
> Map distribution among processors, which makes little sense in a sequential 
> program.  Granted, having a parallel code that could run in sequential mode for 
> development and testing purposes is convenient, but this does NOT create a 
> realistic interface for sequential applications.  (Hint: if your example has 
> MPI_Init() in it, it is a parallel code.) 
 
The Map class can exist in serial. A note has been added to clarify that
serial Map classes are trivial to define. Most of Trilinos is based on this
concept: define a data layout in both serial and parallel. The overhead is
very small for serial, and it makes the parallelization of the code easy.
Then, all the other interfaces will just work in both serial and parallel.

> 4) Code Example (Fig 2) 
>  
> a) This example is too trivial to adequately evaluate the proposed 
> interface.  Solving a diagonal linear system seems to bypass many important 
> design decisions.  Why not exhibit a more realistic problem?  If the interface 
> is truly "general, flexible, consistent, reusable, and efficient," designed with 
> "simplicity of usage" as its primary requirement, then this should be easy,  no? 
 
It is important to note that Amesos is a set of interfaces between linear
algebra objects and third-party direct solvers. The reader can modify the code
example of Fig. 2 to generate any matrix. Would a tridiagonal matrix be more
realistic? A penta-diagonal? This will just change the definition of the
matrix which, once again, is *not* the goal of this paper. Note that Interface
3.3 does not specify any set() method, thus leaving problem- and
storage-dependent issues to the application.

> b) Use of map.NumMyElements() is inconsistent with Interface 3.1. 

We are using Epetra, which adopts a slightly different convention. A note has
been added to the caption of Fig. 2.

> c) Constructor for Epetra_LinearProblem is not  part of Interface 3.4, as 
> indicated by the comments. 
 
The text says that the "interface will contain the following methods", but
does not prevent other methods. In our opinion, constructors (and then the
destructor) are more low-level details: we are presenting the idea.

> d) Using pointers in Amesos_BaseSolver, rather than references leads to 
> potential memory leaks. 

It is not possible to use references, for they cannot be changed. Using
pointers let the user modify or replace linear algebra objects, especially
vectors. Techniques like reference counting or auto_ptr may force the user to
modify his or her data structures, and were therefore avoided. In fact, there
is no universally accepted memory management system for C++ other than
new/delete...
 
> 5) The notion of a Factory just seems a bit confusing and out-of-place in a 
> solving linear systems.  I could see one using this in an *implementation* of 
> such an interface, but why expose this to the application user?  Yes, it is a 
> design pattern, but why does this make the application easier?  Is there an 
> alternate C design that achieves the same goal without this? 
 
The Factory is a crucial aspect of Amesos. Factories can be seen as "virtual
constructors", and allows a sharp separation between Amesos' classes and the
application. Said that, one is not forced to use the Factory class and could
simply instantiate a concrete class.

> 6)  Section 6.1: Example Applications to Domain Decomposition and Multilevel 
> Preconditioners: please include a sample code for this.  Just saying it 
> "basically looks like the one in Figure 2" seems inadequate.  After all, this is 
> an interface proposal, so the example usage of code IS the work being evaluated. 
> Any further examples would be welcomed. 
 
The actual code, contained in
Trilinos/packages/ml/src/Utils/ml_amesos_wrap.cpp, function ML_Amesos_Gen(),
indeed looks like the example of Fig 2. This is the real strength of Amesos.
The only thing that changes is the matrix construction. 

> Minor points: 
> 
> 7) Title: by this paper's own admission, this interface is specific to MPI-based 
> parallel sparse direct solvers (as opposed to thread-based, or shared-memory 
> parallel solvers).   Perhaps the title should more accurately reflect the 
> paper's subject matter... 
>
> 8) Interface 3.2 (Page 7): likewise, the names "Vector" and "Matrix" for these 
> interfaces seem rather generic, as they are in fact specific parallel 
> distributed objects that are being defined.   

Vector and Matrix classes can be used in both serial and parallel. We have
opted for the simplest and shortest names.
 
> 9) Interface 3.2 (Page 7)  Vector interface: the signature "double * 
> getValues()" uses unconventional semantics in C, as most getXXX() functions do 
> not  modify the underlying object.  In fact, the getXXX() style of interface is 
> a bit antiquated, mainly from C, and should be replaced with clearer const and 
> non-const versions: "double * Values()" and "const double * Values() const".  
 
We already have them, right? Const and non-const versions of getValues() are
included in the interface.

> 10)Interface 3.1 (Page 7)  the Map interface is not very well defined.  Exactly 
> what processor distributions are allowed and how are these defined?  Is being 
> able to query just the global numbers of elements, local number of elements, and 
> the processor ID sufficient to extract a general  mapping?  Is there some 
> restricted class of distributions being implied?  
 
We only require that each global ID is assigned to exactly one processor. This
implies a certain distribution on Vector's and Matrix's.

> 11) Interface 3.3 (Page 8) This interface is not named in the text.  Why not?  
 
We say: "The abstract matrix interface is as follows." In the line below we
describe the interface.
 
> a) "int getNumMyRowEntries(const int ID)" should be declared const. 

Done.
 
> b) "int getMyRow()" should be declared const.  Why does this interface 
> copy the data elements, but the similar getValues() in the Vector interface does 
> not.  

Done. 

We leave the possibility to get the raw vector pointers, so that the
use can do anything he or she wants. Probably not optimal from the OO point,
but essential to obtain performances. For example, one can call getXXX(), then
use BLAS. This is done in most scientific software (e.g. PETSc and Trilinos).

> c) Why is "updateMyGhostNodes()" declared const?  The term "update" 
> implies that relationship between this object and something is being altered...
> 12) Interface 3.4 (Page 9) LinearProblem:   This seems a container of three 
> items (A, x, b) but how are they accessed?  (That is, there are 
> "set___()"functions, but no "get__()" counterparts.) 
 
The method updates the values of ghost nodes in the input vector, and does not
change the matrix. We have added the get__XX() counterparts.

> 13) Interface 3.5 (page 9) Solver:  what is a "List"?  In the text it is 
> described as "any container that can be used to specify parameters.  But what is 
> it, actually?  The C interface requires some kind of type here.  Is it a 
> templated class? An STL list object?   What access methods are assumed for such 
> a class? 

We added a reference to the class used by Amesos.
