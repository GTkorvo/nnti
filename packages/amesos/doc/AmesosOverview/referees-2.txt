Dear Dr. Gladwell,

we have modified the paper to take into account Referees' comments and
suggestions.  Detailed answers to the associate editor's comments and
referees' comments are reported below.

We are looking forward to hearing from you.

Best regards,
-Marzio Sala, Ken Stanley and Mike Heroux

 
> ================================================================
> COMMENTS FROM ASSOCIATE EDITOR
> 
> Associate Editor: Boisvert, Ronald
> Comments to the Author:
> Two of the referees point out minor problems with the manuscript that should
> be very easy to fix. Please make those changes.

Done.

> One referee still has some fundamental problems. I am concerned about these
> because they strike at the heart of what it means to be a research paper
> focused on design issues. I hope that you can take a serious look at these
> comments and consider how you might respond to them. It seems to me that
> providing some of the suggested examples would greatly improve the paper.

A list of detailed answers is reported below. About the examples requested by
Referee 4, we have greatly improved the example of Figure 2. It should be
clear now how to insert a generic (i, j) element of the matrix, so that the
reader can decide to implement his or her "real-life" problem. We believe that
a diagonal matrix is the best compromise in this context. In fact, an example
reading Harwell/Boeing matrices is already contained in the Amesos
distribution, and it differs *only* in the matrix generation part, which is
not the goal of this paper.

The basic idea of Amesos is that, for *any* matrix that satisfies Interface
3.3, one can use any of the supported direct solvers. So reporting an example
with a diagonal matrix, or another more complicated matrix, would not change
the lines related to Amesos: they will always read:
solver->SymbolicFactorizat(), solver->NumericFactorization(), solver->Solve().

Perhaps Referee 4 confuses the matrix creation and system solver phases.
Amesos aims at the latter only; matrix creation is quite a different subject,
very implementation dependent and not the goal of this paper. This is why Interface
3.3 is just a wrapper to matrix queries (or get() methods), with no
corresponding set() methods. 

More detailed answers can be found below.

> I hope you will craft a revision for us. Please include a cover letter
> explaining how you respond to the major concerns of this last referee.
> 
> By the way, one of the referees questioned which link for Davis' book is most
> appropriate to use. When I asked Tim about this he explained as follows: the
> SIAM web page http://www.siam.org/fa02 is just a link to the web page for the
> book, http://www.cise.ufl.edu/research/sparse/CSparse, which then has a link
> to http://www.cise.ufl.edu/research/sparse/codes . So citing just
> http://www.siam.org/fa02 is enough.

Done.  (Note that we could not access www.siam.org/fa02 today, 29-Dec-06,
while web page http://ec-securehost.com/SIAM/FA02.html works.)

> ------------------------------------------------------------------------------
> Referee: 1
> Comments to the Author
> 
> Overall, a very nice paper. I have only a few very minor comments/typos to note.
> 
> On page 2, (Q1), typo: should be "Is it portable to all required platforms and
> does it have an acceptable licensing agreement?"

Done.

> On page 2, you state that "For relatively simple problems, Q3 is usually the
> key point, followed by Q4." By "simple" do you mean "small", or do you mean
> "just solve Ax=b, nothing special, but A may be big". For the latter, I would
> agree. For the former, I would say Q1 and Q2 are critical, since Q3 and Q4 are
> so small as to be irrelevant. Can you clarify?

Done. We modified the sentence to take into account the "small" case, which was left
out. The original sentence now refer to "possibly large but relatively
well-conditioned problems". 

> For the citation [Davis 2006], it would be better to cite the book (section
> 8.6) and perhaps also give the url. The book in Section 8.6 states that the
> online version can be found at www.siam.org/fa02. The online version states
> that it can be found at www.cise.ufl.edu/research/sparse/codes; I'm not sure
> why they are different. Perhaps cite both, to be safe. In any case, the url
> you have is incorrect in the references (drop the ".pdf" ending). Be sure to
> double check all the other url's you cite in the references.

We cite www.siam.org/fo02. (Note that we could not access
www.siam.org/fa02 today, 29-Dec-06...)
 
> ------------------------------------------------------------------------------
> Referee: 2
> Comments to the Author
> The authors have answered all the issues raised in the review reports.
> A few (very minor) comments; on page 2, line -2 "even if they truly important"
> an "are" is missing.  page 8, line 5: "compresses row storage" should be
> "compressed" page9, line 5: "data layout can differ" this entails a
> redistribution, which should probably be said explicitly, even if it is sort
> of implicitly acknowleged at page 17 in the first item discussing the model
> limitations.

Done. We have added a short sentence on data redistribution in page 9.

> There are mentions of the Fortran 90 language, specifying that it does not
> provide polymorphism and inheritance (page 4 and 18); the reference should
> probably be made to Fortran 95, which is the standard level most commonly
> implemented today; with fortran 2003 the comment about inheritance and
> polymorphism would be false, but no compiler on the market fully implements
> the standard as of today.

We now refer to Fortran 95 instead of Fortran 90. We added a sentence to
clarify that novel implementations of Fortran 2003 may change the picture.

> Two English sentences (in an otherwise very well written paper) don't sound
> quite right, at page 5 line -4, and page 8 line 1; not being a native speaker
> myself, I'll leave them to the editor.
> 
> ------------------------------------------------------------------------------
> Referee: 3
> Comments to the Author
> There are no comments
> 
> ------------------------------------------------------------------------------
> Referee: 4
> Comments to the Author 
> Referee 4: Comments to the Author
>
> This paper exhibits several improvements, but some issues still remain.  It is
> a good paper, with a noble cause, but its general claims of simplicity and
> flexibility are difficult to justify by the examples and supporting text.  The
> C code  for solving a diagonal system is somewhat trivial and side-steps many
> of the important design issues encountered in practice.    

It is important to understand that the construction of linear objects is not
related to Amesos; one can use Epetra or PETSc, or a custom format; the only
point is that the format must be wrapped by a class based on Interface 3.3.

> Likewise, the
> interface descriptions seem  incomplete. I still don't know, for example, how
> one is supposed to access components of the LinearProblem interface, 3.3; 

Done. Several getXXX() methods that were missing have been added to the design.

> the List data structure in Interface 3.5 is unspecified; there is no description
> of what problem parameters this interface allows.   

A note on the List data structure has been added. The actual parameters are
reported in the manual and the on-line documentation.

> The use of design patterns
> unnecessary complicates your interface code example.  
>
> There are a few errors > in the code example (Fig. 2) 

The new version of the example should compile smoothly. The matrix creation
phase is now much easier to understand: a generic (i, j) element is inserted
in the matrix, and the discussion specifies that one can insert arbitrary
elements, as long as they refer to locally owned rows. This should allow the
reader to generate more interesting matrices. The code also compiles in serial
(without MPI support) and in parallel (with MPI support).

> but more importantly there is no real discussion
> of how one is supposed to use these interfaces in practice, or why this
> approach is superior to similar approaches or designs.   

To be best of our knowledge, Amesos is the only project that offers a unified
and quite general approach to so many direct solver libraries.

As regards the use in pracice, it is wasy to wrap *any* vector and matrix
class that satisfy the proposed interfaces using Epetra objects, then use
Amesos. How to wrap a matrix using Epetra  is not reported here because the
wrapper classes are relatively lengthy (though easy to write), and they are
already described in the Epetra documentation and the Trilinos tutorial.

> In my first review I outlined steps the authors could take to justify their 
> claims.  I proposed an example solving a small linear system that could be 
> specified by hand, or read in from a file, and show the codes for solving this 
> with two different direct solver packages, using an appropriate Matrix and 
> Vector classes that implement the proposed interfaces.  (Something other than 
> the authors' own Epetra classes would be enlightening.) 

Unfortunately it will take a few pages to define all classes without direct
use of the Epetra package. Also, the resulting code will have no connection
with the one used in the numerical results section, and be quite difficult to
understand to the reader.

The current Amesos implementation is based on Epetra, so using a non-Epetra
class is impossible. This does not mean that the users have to use Epetra,
just wrap their own matrix and vector classes with Epetra objects.

> Letting the readers see 
> such examples would be very useful and help illustrate the simplicity, 
> generality,  and flexibility of the proposed interface.  As it stands, the 
> problem statement is great, the proposed solution has potential, but the paper 
> needs a more concentrated effort to demonstrate its design strengths. 

It is easy to modify the new example to generate a 5x5 matrix. The solution
part will look exactly as it is now.

> I believe this paper has good potential.  The authors have done a nice job of 
> presenting their ideas, and by providing more discussions the "why" rather than 
> just the "what", they would elevate this manuscript from "good" to "excellent". 
>  
> Major points: 
> 
> 1) The authors state that primary design requirement of this interface is 
> "simplicity of usage" (Page 3): "Solving [a] linear system in a language like 
> MATLAB is very easy, i.e. one just writes x = A \ b.  It should not be much 
> different in a  non-MATLAB code."  When I look at the code example in Fig 2, 
> this looks VERY MUCH different than the corresponding MATLAB code (x = 
> diag(ones(N,1)) \  rand(N,1)).  How is this requirement being met? 
 
Frankly, this statement is quite unfair.  The code of Figure 2 is longer
because C++ requires statements that MATLAB doesn't: the #include, { and }
braces, MPI initialization and finalization,  comments, and
allocation/deallocation (we cannot avoid them unless we change language).
Finally, several lines are required to build the Epetra objects and are not
related to the system solution phase.

If we consider all of this, MATLAB's backslash is then replaced by:

   solver->symbolicFactorization(); // symbolic factorization 
   solver->numericFactorization(); // numeric factorization 
   solver->solve(); // linear system solution 
   delete solver; 

which are not much more difficult than "A \ B". Note that MATLAB's backslash
does not store the symbolic and numeric factorization, while the code of Fig.
2 does.

> 2) Serial/Parallel:  If there was a serial interface presented in the paper, I 
> completely missed it.  The basic data structures, Vector and Matrix require a 
> Map distribution among processors, which makes little sense in a sequential 
> program.  Granted, having a parallel code that could run in sequential mode for 
> development and testing purposes is convenient, but this does NOT create a 
> realistic interface for sequential applications.  (Hint: if your example has 
> MPI_Init() in it, it is a parallel code.) 
 
The Map class can exist in serial. A note has been added to clarify that
serial Map classes are trivial to define. Most of Trilinos is based on this
concept: define a data layout in both serial and parallel. The overhead is
very small for serial, and it makes the parallelization of the code easy.
Then, all the other interfaces will just work in both serial and parallel.

> 4) Code Example (Fig 2) 
>  
> a) This example is too trivial to adequately evaluate the proposed 
> interface.  Solving a diagonal linear system seems to bypass many important 
> design decisions.  Why not exhibit a more realistic problem?  If the interface 
> is truly "general, flexible, consistent, reusable, and efficient," designed with 
> "simplicity of usage" as its primary requirement, then this should be easy,  no? 
 
Amesos is a set of interfaces between linear
algebra objects and third-party direct solvers. The reader can modify the code
example of Fig. 2 to generate any matrix. Would a tridiagonal matrix be more
realistic? A penta-diagonal? This will just change the definition of the
matrix which, once again, is *not* the goal of this paper. Note that Interface
3.3 does not specify any set() method, thus leaving problem- and
storage-dependent issues to the application.

> b) Use of map.NumMyElements() is inconsistent with Interface 3.1. 

Epetra adopts a slightly different naming convention. A note has been added to
the caption of Fig. 2.

> c) Constructor for Epetra_LinearProblem is not  part of Interface 3.4, as 
> indicated by the comments. 
 
The text says that the "interface will contain the following methods", but
does not prevent other methods to exist. In our opinion, constructors (and
then the destructor) are more implementation details, that can be found on the
Amesos web page by browsing the Doxygen documentation.

> d) Using pointers in Amesos_BaseSolver, rather than references leads to 
> potential memory leaks. 

It is not possible to use references, for they cannot be changed. Using
pointers lets the user modify or replace linear algebra objects, especially
vectors. Techniques like reference counting or auto_ptr may force the user to
modify his or her data structures, and were therefore avoided. In fact, there
is no universally accepted memory management system for C++ other than
new/delete and this explains our choices.
 
> 5) The notion of a Factory just seems a bit confusing and out-of-place in a 
> solving linear systems.  I could see one using this in an *implementation* of 
> such an interface, but why expose this to the application user?  Yes, it is a 
> design pattern, but why does this make the application easier?  Is there an 
> alternate C design that achieves the same goal without this? 
 
The Factory is a crucial aspect of Amesos. Factories can be seen as "virtual
constructors", and allows a sharp separation between Amesos' classes and the
application. Said that, one is not forced to use the Factory class and could
simply instantiate a concrete class.

> 6)  Section 6.1: Example Applications to Domain Decomposition and Multilevel 
> Preconditioners: please include a sample code for this.  Just saying it 
> "basically looks like the one in Figure 2" seems inadequate.  After all, this is 
> an interface proposal, so the example usage of code IS the work being evaluated. 
> Any further examples would be welcomed. 
 
The actual code, contained in
Trilinos/packages/ml/src/Utils/ml_amesos_wrap.cpp, function ML_Amesos_Gen(),
indeed looks like the example of Fig 2. This is the real strength of Amesos.
The only thing that changes is the matrix construction. 

> Minor points: 
> 
> 7) Title: by this paper's own admission, this interface is specific to MPI-based 
> parallel sparse direct solvers (as opposed to thread-based, or shared-memory 
> parallel solvers).   Perhaps the title should more accurately reflect the 
> paper's subject matter... 
>
> 8) Interface 3.2 (Page 7): likewise, the names "Vector" and "Matrix" for these 
> interfaces seem rather generic, as they are in fact specific parallel 
> distributed objects that are being defined.   

Vector and Matrix classes can be used in both serial and parallel. We have
opted for the simplest and shortest names.
 
> 9) Interface 3.2 (Page 7)  Vector interface: the signature "double * 
> getValues()" uses unconventional semantics in C, as most getXXX() functions do 
> not  modify the underlying object.  In fact, the getXXX() style of interface is 
> a bit antiquated, mainly from C, and should be replaced with clearer const and 
> non-const versions: "double * Values()" and "const double * Values() const".  
 
Const and non-const versions of getValues() are now included in the interface.

> 10)Interface 3.1 (Page 7)  the Map interface is not very well defined.  Exactly 
> what processor distributions are allowed and how are these defined?  Is being 
> able to query just the global numbers of elements, local number of elements, and 
> the processor ID sufficient to extract a general  mapping?  Is there some 
> restricted class of distributions being implied?  
 
We only require that each global ID is assigned to exactly one processor. This
implies a certain distribution on Vector's and Matrix's.

> 11) Interface 3.3 (Page 8) This interface is not named in the text.  Why not?  
 
We say: "The abstract matrix interface is as follows." In the line below we
describe the interface.
 
> a) "int getNumMyRowEntries(const int ID)" should be declared const. 

Done.
 
> b) "int getMyRow()" should be declared const.  Why does this interface 
> copy the data elements, but the similar getValues() in the Vector interface does 
> not.  

Done. 

We leave the possibility to get the raw vector pointers, so that the
use can do anything he or she wants. Probably not optimal from the OO point,
but essential to obtain performances. For example, one can call getXXX(), then
use BLAS. This is done in most scientific software (e.g. PETSc and Trilinos).

> c) Why is "updateMyGhostNodes()" declared const?  The term "update" 
> implies that relationship between this object and something is being altered...
> 12) Interface 3.4 (Page 9) LinearProblem:   This seems a container of three 
> items (A, x, b) but how are they accessed?  (That is, there are 
> "set___()"functions, but no "get__()" counterparts.) 
 
The method updates the values of ghost nodes in the input vector, and does not
change the matrix. We have added the get__XX() counterparts.

> 13) Interface 3.5 (page 9) Solver:  what is a "List"?  In the text it is 
> described as "any container that can be used to specify parameters.  But what is 
> it, actually?  The C interface requires some kind of type here.  Is it a 
> templated class? An STL list object?   What access methods are assumed for such 
> a class? 

We added a reference to the class used by Amesos.
