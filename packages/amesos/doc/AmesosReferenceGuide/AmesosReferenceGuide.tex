%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\documentclass[11pt]{SANDreport}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{amssymb,latexsym}
\usepackage{rotating,tabularx}

\usepackage{times}

\def\choicebox#1#2{\noindent$\hphantom{th}$\parbox[t]{2.10in}{\sf
#1}\parbox[t]{3.35in}{#2}\\[0.8em]}

\setlength\oddsidemargin {-0pt}\setlength\evensidemargin{-0pt}
\setlength{\textwidth}{150mm}\setlength{\textheight}{210mm}
\headheight=12.45pt


\title{Amesos 1.0 Reference Guide}
\SANDnum{SAND2004-2188}
\SANDauthor{
Marzio Sala, Ken Stanley
}

\SANDprintDate{May 2004}
\SANDreleaseType{Unlimited Release}

\newcommand{\Amesos}{Amesos}
\newcommand{\Trilinos}{Trilinos}
\newcommand{\TrilinosTM}{Trilinos \copyright}

\newtheorem{remark}{Remark}

\begin{document}

\maketitle

\begin{center}
Marzio  Sala \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
P.O.~Box 5800 \\
Albuquerque, NM 87185-1110
\\[30pt]
Ken Stanley\\
322 W. College St.\\
Oberlin OH 44074
\end{center}

\vspace{20pt}

\begin{abstract}
  
  This document describes the main functinalities of the Amesos package,
  version 1.0. Amesos, available as part of Trilinos 4.0, provides an
  object-oriented interface to several serial and parallel sparse direct
  solvers libraries, for the solution of the linear systems of equations
  \begin{equation}
    \label{eq:linear_system}
    A X = B
  \end{equation}
  where $A$ is a real sparse, distributed matrix, defined as an
  Epetra\_RowMatrix object, and $X$ and $B$ are defined as
  Epetra\_MultiVector objects.
  
  Amesos provides a common look-and-feel to several direct solvers,
  insulating the user from each package's details, such as matrix and
  vector formats, and data distribution.
\end{abstract}

\clearpage

\clearpage

\section*{Acknowledgments}
The authors would like to acknowledge the support of the ASCI and LDRD programs
that funded development of Amesos.

\smallskip

%Tim Davis is acknowledged for providing KLU and UMFPACK.

\smallskip

%Xiaoye Sherry Li is thanked for providing all the SuperLU libraries, and
%for the suggestions and supports about the Amesos\_Superludist
%interface.

\smallskip

%The MUMPS developers' team is acknowledged for providing MUMPS.

\clearpage

\SANDmain


\tableofcontents

\clearpage

\section{Introduction}

Aim of the Amesos package is to provide an object-oriented interface to
several sparse direct solvers\footnote{Amesos is an interface to other
  packages, mainly developed outside the Trilinos framework. In order to
  use those packages, the user should carefully check copyright and
  licensing of those third-party codes.  Please refer to the web page or
  the documentation of each particular package for details.}. For each
solver, Amesos provides a C++ interface. All the interfaces have the
same look-and-feel, and accept matrices defined as Epetra\_RowMatrix
objects, and vectors defined as Epetra\_MultiVector objects. Amesos
makes easy for users to switch from one direct solver library from
another.

Amesos contains several classes, as reported in table~\ref{tab:classes}.
The classes covered in this guide are:
\begin{itemize}
\item \verb!Amesos_KLU!: Interface to Amesos's internal solver KLU (in
  Section~\ref{sec:klu});
\item \verb!Amesos_Umfpack!: Interface to Tim Davis's
  UMFPACK~\cite{umfpack-home-page}, version 4.3 (in Section~\ref{sec:umfpack});
\item \verb!Amesos_Superludist!: Interface to Xiaoye S.~Li's distributed
  SuperLU~\cite{superlu-home-page} (in Section~\ref{sec:superludist});
\item \verb!Amesos_Mumps!: Interface to MUMPS
  4.3.1~\cite{mumps-home-page} (in Section~\ref{sec:mumps}).
\end{itemize}

All the Amesos classes are derived from a base class mode,
\verb!Amesos_BaseSolver!. This abstract interface provides the basic
functionalities for all Amesos solvers, and allows users to choose
different direct solvers very easily --- by changing an input parameter.
See Section~\ref{sec:amesos_generic} for more details.

Once an Amesos object is defined, the direct solution of the linear
system simply reads, for all interfaces,
\begin{verbatim}
AmesosObject.Solve();
\end{verbatim}
or, more generally, by
\begin{verbatim}
AmesosObject.SymbolicFactorization();
AmesosObject.NumericFactorization();
AmesosObject.Solve();
\end{verbatim}
This sequence of commands applies to serial, as well as distributed
libraries. All necessary data redistribution is automatically managed by
Amesos.

\begin{table}[tbhp]
  \centering
  \begin{tabular}{| l | l l l | }
    \hline
    Class &   &  & Interface to \\
    \hline
    \tt Amesos\_Klu          & serial & general & KLU \\
    \tt Amesos\_Umfpack      & serial & general & UMFPACK 4.3 \\
    \tt Amesos\_Superlu      & serial & general & SuperLU 3.0 \\
    \tt  Amesos\_Superludist  & parallel & general & SuperLU\_DIST 2.0 \\
    \tt Amesos\_Mumps        & parallel & SPD, sym, general & MUMPS 4.3.1 \\
    \tt Amesos\_Scalapack    & parallel & general & ScaLAPACK \\
    \hline
  \end{tabular}
  \caption{Supported interfaces. ``serial'' means that the supported
    direct solver is serial. When solving with 
    more than one processor, the linear problem is exported to process
    0, here solved, then the solution is broadcasted to the distributed
    solution 
    vector. ``parallel'' means that a subset or all the processes in the current
    communicator will be used by the solver. ``general'' means general
    unsymmetric 
    matrix, If ``sym'' (symmetric matrix) or  ``SPD'' (symmetric
    positive definite), the direct solver library can take advantage of
    that particular matrix property.}
  \label{tab:classes}
\end{table}


%%%
%%%
%%%

\section{Configuring and Installation Amesos}
\label{sec:3pl}

Amesos is distributed through the Trilinos project, and can be
downloaded from the web site
\begin{verbatim}
http://software.sandia.gov/trilinos/packages/amesos
\end{verbatim}

\smallskip

Each of the Amesos classes provides an interface to a third-party direct
sparse solver code\footnote{Exception to this rule is KLU, which is
  distributed within Amesos.}. In order to configure and compile a given
interface, the user must first install the underlying direct sparse
solver code. Generally, the BLAS library is required. Some solvers may
need CBLACS, LAPACK, BLACS, ScaLAPACK. Amesos requires Epetra and
Teuchos (both part of Trilinos).

Amesos is configured and built using the GNU autoconf~\cite{Autoconf}
and automake~\cite{Automake} tools. To configure Amesos from the
Trilinos top directory, a possible procedure is as follows.  Let
\verb!$TRILINOS_HOME! be a shell variable representing the location
of the Trilinos source directory, and \verb!%! the shell prompt sign.  In order to configure Trilinos with
Amesos, for instance on a LINUX machine with MPI, one may do the
following:
\begin{verbatim}
% cd $TRILINOS_HOME
% mkdir LINUX_MPI
% cd LINUX_MPI
% ../configure --with-mpi-compilers \
               --prefix=$TRILINOS_HOME/LINUX_MPI \
               --enable-amesos \
               FLAGS \
               AMESOS_FLAGS
% make
% make install
\end{verbatim}
Here, \verb!FLAGS! represents the set of configure options for other
Trilinos packages, and \verb!AMESOS_FLAGS! the configure options
specific to Amesos.  The configure options required to enable a specific
interface are reported in each third-party package's section. A complete
list of them can be obtained by typing
\begin{verbatim}
% $TRILINOS_HOME/packages/amesos/configure --help
\end{verbatim}

\begin{sidewaystable}[tbhp]
  \centering
  \begin{tabular}{| l  l | c | c | c | c | c | }
    \hline
    Architecture & Communicator & KLU & UMFPACK & SuperLU\_DIST 2.0 &
    MUMPS 4.3.1 & ScaLAPACK    \\
    \hline
    LINUX & SERIAL & $\bullet$ & $\bullet$ & -- & -- & -- \\
    LINUX, GNU & LAM/MPI  &$\bullet$  & $\bullet$ & $\bullet$
    & -- & $\bullet$ \\
%    LINUX, GNU & MPICH  & -- & -- & -- & -- \\
    LINUX, Intel & MPICH  &$\bullet$  & $\bullet$ & -- 
    & $\bullet$ & $\bullet$ \\
    SGI 64 & MPI & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & -- \\
    DEC/Alpha & MPI & $\bullet$ & $\bullet$ & -- & -- & -- \\
    MAC OS X/G4 & MPICH & $\bullet$ & -- & -- & -- & -- \\
%    SUN/Solaris & MPI & -- & -- & -- & -- \\
    Sandia Cplant & MPI & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & -- \\
    ASCI Red & MPI & $\bullet$ & $\bullet$ & $\bullet$ & -- & -- \\
    \hline
  \end{tabular}
  \caption{Supported architectures for various interfaces. 
  `$\bullet$' means that the interface has been successfully compiled, 
  `--' means that it has not been tested.}
  \label{tab:arch}
\end{sidewaystable}

%%%
%%%
%%%

\section{Amesos\_BaseSolver: A Generic Interface to Direct Solvers}
\label{sec:amesos_generic}

All Amesos objects are derived from the pure virtual class
Amesos\_BaseSolver, and can be constructed using the function class
\verb!Amesos!.  \verb!Amesos! allows a code to delay the decision about
which concrete class to use to implement the Amesos\_BaseSolver
interface. The main goal of this class is to allow the user to select
any supported (and enabled at configuration time) direct solver, simply
changing an input parameter. Another remarkable advantage of
Amesos\_BaseSolver is that users does not have to include the header
files of the third-party libraries in their code\footnote{Using
  Amesos\_BaseSolver, third-party libraries header files are required in
  the compilation of Amesos only.}.

An example of use of this class is as follows. First, the following
header file must be included:
\begin{verbatim}
  #include "Amesos.h" 
\end{verbatim}
Then, let \verb!A! be an Epetra\_RowMatrix object (for instance, and
Epetra\_CrsMatrix)\footnote{Some solvers can take advantage if the
  matrix is an Epetra\_CrsMatrix or an Epetra\_VbrMatrix; this is
  reported in Table~\ref{tab:matrices}.}.

\begin{table}[tbhp]
  \centering
  \begin{tabular}{| p{4cm} | c | c | c | }
    \hline
    Class &  Epetra\_RowMatrix & Epetra\_CrsMatrix & Epetra\_VrbMatrix \\
    \hline
    Amesos\_Klu          & $\bullet$&  $\bullet$ & -- \\
    Amesos\_Umfpack      & $\bullet$& $\bullet$ & -- \\
    Amesos\_Superlu      & $\bullet$& $\bullet$ & -- \\
    Amesos\_Superludist  & $\bullet$& $\bullet$ & -- \\
    Amesos\_Mumps        & $\bullet$ & $\bullet$ & $\bullet$ \\
    Amesos\_Scalapack    & $\bullet$& $\bullet$ & -- \\
    \hline
  \end{tabular}
  \caption{Supported matrix formats. `$\bullet$' means that the interface
    can take advantage of the given matrix format, `--' means that it doesn't.}
  \label{tab:matrices}
\end{table}


We need to define a linear problem,
\begin{verbatim}
  Epetra_LinearProblem * Amesos_LinearProblem = 
                         new Epetra_LinearProblem;
  Amesos_LinearProblem->SetOperator( A ) ; 
\end{verbatim}
Now, let \verb!Choice! be a char array variable, with one of the
 values reported in the first column of table~\ref{tab:classes}.
We can construct an \verb!Amesos_BaseSolver! object as follows:
\begin{verbatim}
  Amesos_BaseSolver * A_Base;
  Amesos Amesos_Factory;

  A_Base = Amesos_Factory.Create(Choice, *Amesos_LinearProblem);
  assert(A_Base!=0);
\end{verbatim}
If the class requested by \verb!Choice! is not available (because is not
installed, or \verb!Choice! is mispelled), \verb!Create()! returns 0.

Symbolic and numeric factorizations are computed using methods
\begin{verbatim}
  A_Base->SymbolicFactorization();
  A_Base->NumericFactorization();
\end{verbatim}
The numeric factorization phase will check whether a symbolic
factorization exists or not. If not, method
\verb!SymbolicFactorization()! is invoked.  Solution is computed, using
\begin{verbatim}
  A_Base->Solve();
\end{verbatim}
The solution phase will check whether a numeric factorization exists or
not. If not, method \verb!NumericFactorization()! is called.

Users must provide the nonzero structure of the matrix for the symbolic
phase, and the actual nonzero values for the numeric
factorization. Right-hand side and solution vectors must be set before
the solution phase, for instance using
\begin{verbatim}
  Amesos_LinearProblem->SetLHS(x);
  Amesos_LinearProblem->SetRHS(b);
\end{verbatim}

Specific parameters can be set using a Teuchos parameters list, whose
definition requires the input file \verb!Teuchos_ParameterList.hpp!. For
a detailed description, we refer to the Teuchos documentation. We report
the most important methods of this class in Table~\ref{tab:teuchos}.

\begin{table}[htbp]
  \centering
  \begin{tabular}{| p{4cm} | p{10cm} |}
    \hline
    \verb!set(Name,Value)! & Add entry \verb!Name! with value and type
    specified by \verb!Value!. Any C++ type (like int, double, a
    pointer, etc.) is valid. \\
    \verb!get(Name,DefValue)! & Get value (whose type is automatically
    specified by \verb!DefValue!). If not present, return
    \verb!DefValue!. \\
    \verb!subList(Name)! & Get a reference to sublist \verb!List!. If not
    present, create the sublist. \\
    \hline
  \end{tabular}
  \caption{Some methods of Teuchos::ParameterList class.}
  \label{tab:teuchos}
\end{table}


Here, we simply recall that the
parameters list can be created as
\begin{verbatim}
  Teuchos::ParameterList AmesosList;
\end{verbatim}
and parameters can be set as
\begin{verbatim}
  AmesosList.set(ParameterName,ParameterValue);
\end{verbatim}
Here, \verb!ParameterName! is a string containing the parameter name,
and \verb!ParameterValue! is any valid C++ object that specifies the
parameter value (for instance, an integer, a pointer to an array or to
an object).

Amesos parameters can (possibly) affect all the solvers, or being
specific to a given interface. In this latter case, they are defined in
a sublist.

We now list all the parameters that may affect all the Amesos solvers.
To know whether a specific interface supports a given parameter, we
refer to table~\ref{tab:options}.

\vskip .1in \choicebox{\tt UseTranspose}{If {\tt false}, solve linear
  system~(\ref{eq:linear_system}). Otherwise, solve the linear system
  with the transpose matrix $A^T$.}

\vskip .1in \choicebox{\tt MatrixType}{Set it to {\tt SPD} if the matrix
  is symmetric positive definite, to {\tt symmetric} if symmetric, and
  to {\tt general} is the matrix is general unsymmetric. At this stage
  of development, only the MUMPS interface can take advantage of {\tt
    SPD} and {\tt symmetric}. }

\choicebox{\tt Threshold}{In the conversion from Epetra\_RowMatrix to a
  package's format, do not include elements whose absolute value is
  below the specified threshold.}

\choicebox{\tt AddZeroToDiag}{If true, in the conversion from
  Epetra\_RowMatrix to a package's format, a zero element will be added
  to the diagonal if not present.}

\choicebox{\tt PrintTiming}{Print some timing information when the
  Amesos object is destoyed.}

\choicebox{\tt PrintStatus}{Print some information about the linear
  system and the solver when the Amesos object is destoyed.}

\choicebox{\tt ComputeVectorNorms}{After solution, compute the 2-norm of
  each vector in the Epetra\_MultiVector $B$ and $X$. }

\choicebox{\tt ComputeTrueResidual}{After solution, compute the real
  residual $\| B - A X \|_2$ for all vectors in Epetra\_MultiVector. }

\choicebox{\tt MaxProcs}{If positive, the linear system matrix will be
  distributed on the specified number of processes only (or the all the
  processes in the MPI communicator if the specified number is greater).
  If {\tt MaxProcs=-1}, Amesos will estimate using internal heuristics
  the optimal number of processes that can efficiently solve the linear
  system. If {\tt MaxProcs=-2}, Amesos will use the square root of the
  number of processes.  If {\tt MaxProcs=-3}, all processes in the
  communicator will be used. \\ This option may require the conversion
  of a C++ MPI communicator to a FORTRAN MPI communicator. If this is
  not supported, the specified value of {\tt MaxProcs} will be ignored,
  and all the processes in {\tt MPI\_COMM\_WORLD} will be used.}

\choicebox{\tt MaxProcsMatrix}{The linear system matrix will be
  distributed over the specified number of processes. This number must
  be less or equal to {\tt MaxProcs}. See {\tt Maxprocs}. If {\tt MaxProcsMatrix=-4}, then the value of {\tt MaxProcsMatrix} equals that of {\tt MaxProcs}.}

\choicebox{\tt OutpuLevel}{If {\tt 0}, no output is printed on the
  standard output. If {\tt 1}, output is reported as specified by other
  parameters. If {\tt 2}, all output is printed (this is equivalent to
  {\tt PrintTiming == true}, {\tt PrintStatus == true}, {\tt
    ComputeVectorNorms == true}, {\tt ComputeTrueResidual == true}).}

\choicebox{\tt DebugLevel}{If {\tt 1}, some debugging information are
  printed on the standard output.}

\choicebox{\tt Refactorize}{
  ``Refactorization'' of a matrix refers to the use of a prior
  symbolic and numeric factorization (including row and column
  ordering), to factorize a subsequent matrix using the same
  pivot ordering.  This can be signicantly faster, but the
  numerical quality of the factorization may suffer.
  If {\tt true}, then attempt to re-use the existing
  symbolic and numeric factorization, to factorize a new matrix using
  the identical pivot ordering (both row and column ordering) as
  a prior pivot-capable factorization.}

\choicebox{\tt RcondThreshold}{After a refactorization,
    an estimate of the reciprocal of the condition number is computed.
    If this estimate is too small (less than {\tt RcondThreshold}),
    then the pivot-less factorization is aborted, and the matrix
    is factorized again with normal numerical pivoting.}

\choicebox{\tt ScaleMethod}{Most methods can scale the input matrix
prior to factorization.  This typically improves the quality of
the factorization and reduces fill-in as well.  Setting this
parameter to zero turns off scaling.  A value of 1 selects the
method's default scaling method (which may in fact be not to
scale at all).  A value of 2 means to scale the matrix
using the first non-default method the package has, 3
means to use its 2nd alternative method, and so on.}

%\choicebox{\tt Redistribute}{[bool] If true, ..... Default: true.}

\smallskip

\begin{sidewaystable}[tbhp]
  \centering
  \begin{tabular}{| p{5cm} | p{2cm} | p{2cm} | c | c | c
      | c | c |}
    \hline
    option & type & default value & KLU & UMFPACK & SuperLU\_DIST &  MUMPS & ScaLAPACK \\
    \hline
    \tt UseTranspose & \tt bool & \tt false & $\bullet$ & $\bullet$ & -- & $\bullet$
    & $\bullet$ \\
    \tt MatrixType & \tt string & \tt \tt general & -- & -- & -- & $\bullet$
    & -- \\
    \tt Threshold & \tt double & \tt 0.0 & -- & -- & -- & $\bullet$ & --
    \\
    \tt AddZeroToDiag & \tt bool & \tt false & -- & -- & $\bullet$ &
    $\bullet$ & -- \\
    \tt PrintTiming & \tt bool & \tt false & $\bullet$ & $\bullet$ & -- & $\bullet$ &
    $\bullet$ \\
    \tt PrintStatus & \tt bool & \tt false & $\bullet$ & $\bullet$ & $\bullet$  &
    $\bullet$ & $\bullet$ \\
    \tt MaxProcs & \tt int & -1 & -- & -- & $\bullet$  & $\bullet$  &
    $\bullet$  \\
    \tt MaxProcsMatrix & \tt int & -4 & -- & -- & -- & $\bullet$  & --
    \\
    \tt ComputeVectorNorms & \tt bool & \tt false & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$
    & $\bullet$ \\
    \tt ComputeTrueResidual & \tt bool & \tt false & $\bullet$ & $\bullet$ & $\bullet$ &
    $\bullet$ & $\bullet$ \\
    \tt OutputLevel & \tt int & \tt 1 & $\bullet$ & $\bullet$ & $\bullet$ &
    $\bullet$ & $\bullet$ \\
    \tt DebugLevel & \tt int & \tt 0 & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
%---- added by Tim Davis:
    \tt Refactorize    & \tt bool   & \tt false  & $\bullet$ & -- & -- & -- & -- \\
    \tt RcondThreshold & \tt double & $10^{-12}$ & $\bullet$ & -- & -- & -- & -- \\
    \tt ScaleMethod    & \tt int    & 1          & $\bullet$ & -- & -- & -- & -- \\
%----
    \hline
  \end{tabular}
  \caption{Supported options. `$\bullet$' means that the interface
    supports the options, `--' means that it doesn't.}
  \label{tab:options}
\end{sidewaystable}

Solver-specific parameters are reported in each package's subsection.
The general procedure is to create a sublist with a given name (for
instance, the sublist for MUMPS is "mumps"), then set all the
solver's specific parameters in this sublist. An example is as follows:
\begin{verbatim}
  int ictnl[40];
  // defines here the entries of ictnl
  Teuchos::ParameterList & AmesosMumpsList = 
    AmesosList.sublist("mumps");
  AmesosMumpsList.set("ICTNL", ictnl);
\end{verbatim}
Parameters and sublists not recognized are simply ignored. Recall that
spaces are important, and that parameters list is case sensitive!

%%%
%%%
%%%

\section{Amesos Interface to KLU}
\label{sec:klu}

KLU is a serial, unblocked code ideal for getting started. Particular
classes of matrices, such as circuit matrices, may perform well with KLU.

KLU is Tim Davis' implementation of Gilbert-Peierl's left-looking sparse
partial pivoting algorithm, with Eisenstat and Liu's symmetric pruning.
It doesn't exploit dense matrix kernels, but it is the only sparse LU
factorization algorithm known to be asymptotically optimal, in the sense
that it takes time proportional to the number of floating-point
operations. It is the precursor to SuperLU, thus the name ("Clark Kent
LU"). For very sparse matrices that do not suffer much fill-in (such as
most circuit matrices when permuted properly) dense matrix kernels do
not help, and the asymptotic run-time is of practical importance.

\smallskip

In order to use KLU, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-klu
\end{verbatim}
The KLU souces are distributed with the Amesos package.

%%%
%%%
%%%

\section{Amesos Interface to UMFPACK 4.3}
\label{sec:umfpack}

UMFPACK is a C package copyrighted by Timothy A.~Davis. More information
can be obtained at the web page
\begin{verbatim}
  http://www.cise.ufl.edu/research/sparse/umfpack
\end{verbatim}

In order to use UMFPACK, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-umfpack 
--with-amesos-umfpacklib=<UMFPACK library> 
--with-amesos-umfpackincdir=<UMFPACK include files>
--with-amesos-umfpackamdlib=<AMD library>
--with-amesos-umfpackamdincdir=<AMD include files>
\end{verbatim}

UMFPACK is a serial solver. Amesos will take care of moving matrix,
solution and right-hand side to processor 0 (using Epetra\_Import
objects), solve the linear system on processor 0, then broadcast the
solution as required.

%%%
%%%
%%%

%\section{Amesos Interface to DSCPACK}
%\label{sec:dscpack}

%%%
%%%
%%%

\section{Amesos Interface to SuperLU\_DIST 2.0}
\label{sec:superludist}

SuperLU\_DIST, written by Xiaoye S. Li, is a parallel extension to the
serial SuperLU library.  SuperLU\_DIST is written in ANSI C, using MPI
for communication, and it is targeted for the distributed memory
parallel machines. It is copyrighted by The Regents of the University of
California, through Lawrence Berkeley National Laboratory.  We refer to
the web site
\begin{verbatim}
  http://www.nersc.gov/~xiaoye/SuperLU
\end{verbatim}
and to the SuperLU\_DIST manual~\cite{superlu-manual} for more
information.

SuperLU\_DIST includes routines to handle both real and complex matrices
in double precision. However, as Amesos is currently based on the Epetra
package (that does not handle complex matrices), only double precision
matrices can be considered.

Amesos\_Superludist can solve the linear system on a subset of the
processes, as specified in the parameters list. This is done by
creating a new process group derived from the MPI group of the
Epetra\_Comm object, with function \verb!superlu_gridinit()!. 

\medskip

In order to interface with SuperLU\_DIST 2.0, Amesos must be configured with
the options
\begin{verbatim}
--enable-amesos-superludist 
--with-amesos-superludistlib=<SuperLU_DIST library>
--with-amesos-superludistincdir=<SuperLU_DIST include files>
\end{verbatim}

The SuperLU\_DIST constructor will look for a sublist, called
\verb!Superludist!.  The following parameters reflect the behavior of
SuperLU\_DIST options argument, as specified in the SuperLU\_DIST
manual~\cite[pages 55--56]{superlu-manual}. The user is referred to this
manual for a detailed explanation of the reported parameters. Default
values are as reported in the SuperLU\_DIST manual.

\vskip .1in

\choicebox{\tt Fact}{({\tt string}) Specifies whether or not the factored form
  of the matrix $A$ is supplied onentry and, if not, how the matrix will
  be factored. It can be: {\tt DOFACT, SamePattern,
    SamePattern\_SameRowPerm, FACTORED}. Default: {\tt
    SamePattern\_SameRowPerm}.}

\choicebox{\tt Equil}{({\tt bool}) Specifies whether to equilibrate the system of
  not. Default: {\tt true}.}

\choicebox{\tt ColPerm}{({\tt string}) Specifies the column ordering
  strategy.  It can be: {\tt NATURAL, MMD\_AT\_PLUS\_A, MMD\_ATA,
    COLAMD, MY\_PERMC}.  Default: {\tt MMD\_AT\_PLUS\_A}.}

\choicebox{\tt perm\_c}{({\tt int *}) Specifies the ordering to use when {\tt
    ColPerm = MY\_PERMC}.}

\choicebox{\tt RowPerm}{({\tt string}) Specifies the row ordering
  strategy.  It can be: {\tt NATURAL, LargeDiag, MY\_PERMR}.  Default:
  {\tt LargeDiag}.}

\choicebox{\tt perm\_r}{({\tt int *}) Specifies the ordering to use when {\tt
    RowPerm = MY\_PERMR}.}

\choicebox{\tt ReplaceTinyPivot}{({\tt bool}) Specifies whether to replace the
  tiny diagonals with $\varepsilon \| A \|$ during LU
  factorization. Default: {\tt true}.}

\choicebox{\tt IterRefine}{({\tt string}) Specifies how to perform iterative
  refinement. It can be: {\tt NO, DOUBLE, EXTRA}. Default: {\tt
    DOUBLE}.}


%%%
%%%
%%%

\section{Amesos Interface to MUMPS 4.3.1}
\label{sec:mumps}

MUMPS (``MUltifrontal Massively Parallel Solver'') is a parallel direct
solver, written in FORTRAN 90 with C interface, copyrighted by P. R.
Amestoy, I. S.  Duff, J. Koster, J.-Y.  L'Excellent. Up-to-date copies
of the MUMPS package can be obtained from the Web page
\begin{verbatim}
http://www.enseeiht.fr/apo/MUMPS/
\end{verbatim}
Here, for the sake of completeness, we briefly present a broad view of
the MUMPS package, so that the reader can better understand the
Amesos\_Mumps interface. For details about the algorithms and the
implementation, as well as of the input parameters, we refer
to~\cite{mumps-manual}

MUMPS can solve the original system~(\ref{eq:linear_system}), as well as
the transposed system, given an assembled or elemental matrix. Note that
only the assembled format is supported by Amesos\_Mumps. Mumps offers,
among other features, error analysis, iterative refinement, scaling of
the original matrix, Schur complement with respect to a prescribed
subset of rows. Reordering techniques can take advantage of PORD
(distributed within MUMPS), or METIS~\cite{METIS}\footnote{At this time,
  METIS ordering is not supported by Amesos\_Mumps.}. 

Amesos\_Mumps is based on the distributed double-precision version of
MUMPS (which requires MPI, BLAS, BLACS
and ScaLAPACK~\cite{scalapack}).  

\medskip

In order to interface with MUMPS 4.3.1, Amesos must be configured with
the options\footnote{The MUMPS interface can take be used on a subset of
  the processes. To that aim, it must be possible to convert from a C++
  MPI communicator to a FORTRAN MPI communicator. Such a conversion is
  not always possible. In you experience compilation problems with {\tt
    Amesos\_Mumps}, you can try the option {\tt
    --disable-amesos-mumps\_mpi\_c2f}.}
\begin{verbatim}
--enable-amesos-mumps 
--with-amesos-mumpslib=<MUMPS library>
--with-amesos-mumpsincdir=<MUMPS include files>
\end{verbatim}

The MUMPS constructor will look for a sublist, called
\verb!mumps!. 
The user can set all the MUMPS's parameters, by sticking pointers to the
integer array ICNTL and the double array CNTL to the parameters list,
or by using the functions reported at the end of this section.

\vskip .1in
\choicebox{\tt ICTNL}{({\tt int[40])} Pointer to an integer array, containing
  the integer parameters (see~\cite[pages 13--17]{mumps-manual}).}

\choicebox{\tt CTNL}{({\tt double[5])} Pointer to an double array, containing
  the double parameters (see~\cite[page 17]{mumps-manual}).}

\choicebox{\tt PermIn}{({\tt int *)} Use integer vectors of size
  NumGlobalElements (global dimension of the matrix) as given ordering.
  {\tt PermIn} must be defined on the host only, and allocated by the
  user, if the user sets ICNTL(7) = 1.}
  
\choicebox{\tt Maxis}{({\tt int)} Set Maxis value.}

\choicebox{\tt Maxs}{({\tt int}) Set Maxis value.}

\choicebox{\tt ColPrecScaling}{({\tt double *)} Use double precision vectors
  of size NumGlobalElements (global dimension of the matrix) as scaling
  for columns and rows. The double vector must be defined on the host
  only, and allocated by the user, if the user sets ICNTL(8) = -1.}

\choicebox{\tt RowPrecScaling}{({\tt double *)} Use double precision vectors
  of size NumGlobalElements (global dimension of the matrix) as scaling
  for columns and rows. The double vector must be defined on the host
  only, and allocated by the user, if the user sets ICNTL(8) = -1.}


\bigskip

Other functions are avaiable to retrive the output values. The following
Amesos\_Mumps methods are {\sl not} supported by the Amesos\_BaseSolver
class; hence, the user must create an Amesos\_Mumps object in order to
take advantage of them.

\medskip

\begin{verbatim}
double * GetRINFO() 
\end{verbatim}
Gets the pointer to the RINFO array (defined on all processes).

\medskip

\begin{verbatim}
int * GetINFO() 
\end{verbatim}
Gets the pointer to the INFO array (defined on all processes).

\medskip

\begin{verbatim}
double * GetRINFOG() 
\end{verbatim}
Gets the pointer to the RINFOG array (defined on host only).

\medskip

\begin{verbatim}
int * GetINFOG() 
\end{verbatim}
Gets the pointer to the INFOG array (defined on host only).

\bigskip
  
A functionality that is peculiar to MUMPS, is the ability to return
the Schur complement matrix, with respect to a specified set of nodes.

\begin{verbatim}
int ComputeSchurComplement(bool flag,
                           int NumSchurComplementRows, 
                           int * SchurComplementRows);
\end{verbatim}
This method computes (if \verb!flag! is true) the Schur complement with
respect to the set of indices included in the integer array {\tt
  SchurComplementRows} , of size {\tt NumSchurComplementRows}. This is a
{\sl global} Schur complement, and it is formed (as a dense matrix) on
processor 0 only.

\medskip

\begin{verbatim}
Epetra_CrsMatrix * GetCrsSchurComplement();
\end{verbatim}
This method returns the Schur complement in an Epetra\_CrsMatrix, on host
only. No checks are performed to see whether this action is legal or not
(that is, if the call comes after the solver has been invocated).
The returned Epetra\_CrsMatrix must be freed by the user.

\medskip

\begin{verbatim}
Epetra_SerialDenseMatrix * GetDenseSchurComplement();
\end{verbatim}
This method returns the Schur complement as a Epetra\_SerialDenseMatrix
(on host only).

\medskip


As an example, the following frament of code shows how to use MUMPS to
obtain the Schur complement matrix with respect to a given subsets of
nodes.  First, we need to create an parameter list, and an Amesos\_Mumps
object.
\begin{verbatim}
  Teuchos:::ParameterList params;
  Amesos_Mumps * Solver;
  Solver = new Amesos_Mumps(*Problem,params);
\end{verbatim}
Then, we define the set of nodes that will constitute the Schur
complement matrix. This must be defined on processor 0 only. For
instance, one may have:
\begin{verbatim}
  int NumSchurComplementRows = 0;
  int * SchurComplementRows = NULL;
  if( Comm.MyPID() == 0 ) {
    NumSchurComplementRows = 4;
    SchurComplementRows = new int[NumSchurComplementRows];
    SchurComplementRows[0] = 0;
    SchurComplementRows[1] = 1; 
    SchurComplementRows[2] = 2;
    SchurComplementRows[3] = 3;
  }
\end{verbatim}
Now, we can ask for the Schur complement using
\begin{verbatim}  
  Solver->ComputeSchurComplement(true, NumSchurComplementRows,
                                       SchurComplementRows);
\end{verbatim}
The Schur complement matrix can be obtain after the solver phase:  
\begin{verbatim}  
  Solver->Solve();
  Epetra_CrsMatrix * SC;
  SC = Solver->GetCrsSchurComplement();
  Epetra_SerialDenseMatrix * SC_Dense;
  SC_Dense = Solver->GetDenseSchurComplement();
\end{verbatim}

%%%
%%%
%%%

%\section{Amesos Interface to ScaLAPACK}
%\label{sec:scalapack}

%%%
%%%
%%%

\section{Example Code}
\label{sec:comparison}

In this section we report a complete code that can be used to compare
the performances of various direct solvers. The code is based on the
Amesos\_BaseSolver interface described in
Section~\ref{sec:amesos_generic}.

First, we need to include the appropriate headers. The variable
\verb!HAVE_CONFIG_H! must have been defined -- in the file, or at
compilation time. 
\begin{verbatim}
#ifndef HAVE_CONFIG_H
#define HAVE_CONFIG_H
#endif
#include "Epetra_ConfigDefs.h"
#ifdef HAVE_MPI
#include "mpi.h"
#include "Epetra_MpiComm.h"
#else
#include "Epetra_SerialComm.h"
#endif
#include "Epetra_Vector.h"
#include "Epetra_Time.h"
#include "Amesos_ConfigDefs.h"
#include "Teuchos_ParameterList.hpp"
#include "Amesos.h"
#include "Trilinos_Util_CrsMatrixGallery.h"
\end{verbatim}
The code can be run with or without MPI; however, the supported versions
of MUMPS and SuperLU\_DIST requires MPI.
\begin{verbatim}
int main(int argc, char *argv[]) {

#ifdef HAVE_MPI
  MPI_Init(&argc, &argv);
  Epetra_MpiComm Comm(MPI_COMM_WORLD);
#else
  Epetra_SerialComm Comm;
#endif
\end{verbatim}
Here we use the class Trilinos\_Util::CrsMatrixGallery to read and
Harwell/Boeing matrix from file, whose name is hardwired in the code for
simplicity (see~\cite[Chap 5]{Trilinos-tutorial}). The name can be read from the
input line using class Trilinos\_Util\_CommandLineParser (see
\cite{Trilinos-tutorial}), or the Teuchos package.
\begin{verbatim}
  Trilinos_Util::CrsMatrixGallery G("hb", Comm);
  G.Set("matrix_name","662_bus.rsa");
\end{verbatim}
Class Trilinos\_Util::CrsMatrixGallery automatically defines an
Epetra\_LinearProblem, that can be obtained as follows:
\begin{verbatim}  
  Epetra_LinearProblem * Problem = G.GetLinearProblem();
\end{verbatim}
Now, we define a Teuchos parameters list, and set the maximum number of
processes by
\begin{verbatim}  
  Teuchos::ParameterList AmesosList;
  AmesosList.set("MaxProcs",8);
\end{verbatim}
At this point, we can create an Amesos\_BaseSolver object, depending on
the run-time choice (here hardcoded for the sake of simplicity as a
string):
\begin{verbatim}  
  Amesos_BaseSolver * Solver;
  Amesos              Amesos_Factory;
  // change this as required
  char SolutionLib[] = "umfpack";

  Solver = Amesos_Factory.Create(SolutionLib, *Problem, params );
  if( Solver == 0 ) cerr << "library not available" << endl;
\end{verbatim}
We can solve the linear problem:
\begin{verbatim}  
  Epetra_Time Time(Comm);      
  Solver->SymbolicFactorization();
  double TimeForSymbolicFactorization = Time.ElapsedTime();
  
  Time.ResetStartTime();  
  Solver->NumericFactorization();
  double TimeForNumericFactorization = Time.ElapsedTime();
   
  Time.ResetStartTime();
  Solver->Solve();
  double TimeForSolve = Time.ElapsedTime();
\end{verbatim}
and finally delete the Amesos\_BaseSolver object, and exit the code.

\begin{verbatim}  
  delete Solver;
    
#ifdef HAVE_MPI
  MPI_Finalize();
#endif

  return( EXIT_SUCCESS );

}
\end{verbatim}

\bibliographystyle{plain}
\bibliography{AmesosBibliography}

\end{document}
