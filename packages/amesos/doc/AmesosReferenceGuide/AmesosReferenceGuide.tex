%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\documentclass[11pt]{SANDreport}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amsthm}
\usepackage{amssymb,latexsym}
\usepackage{rotating,tabularx}

\usepackage{times}

\def\choicebox#1#2{\noindent$\hphantom{th}$\parbox[t]{2.10in}{\sf
#1}\parbox[t]{3.35in}{#2}\\[0.8em]}

\setlength\oddsidemargin {-0pt}\setlength\evensidemargin{-0pt}
\setlength{\textwidth}{150mm}\setlength{\textheight}{210mm}
\headheight=12.45pt


\title{Amesos 2.0 Reference Guide}
\SANDnum{SAND2004-XXXX}
\SANDauthor{
Marzio Sala
}

\SANDprintDate{October 2004}
\SANDreleaseType{Unlimited Release}

\newcommand{\epetra}{{\sc Epetra}}
\newcommand{\amesos}{{\sc Amesos}}
\newcommand{\teuchos}{{\sc Teuchos}}
\newcommand{\ml}{{\sc ML}}
\newcommand{\ifpack}{{\sc Ifpack}}
\newcommand{\triutils}{{\sc Triutils}}
\newcommand{\trilinos}{{\sc Trilinos}}
\newcommand{\TrilinosTM}{Trilinos \copyright}

\newtheorem{remark}{Remark}

\begin{document}

\maketitle

\begin{center}
Marzio  Sala \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
P.O.~Box 5800 \\
Albuquerque, NM 87185-1110
\end{center}

\vspace{20pt}

\begin{abstract}
  This document describes the main functionalities of the Amesos package,
  version 2.0. Amesos, a Trilinos package, provides an
  object-oriented interface to several serial and parallel sparse direct
  solvers libraries, for the solution of the linear systems of equations
  \begin{equation}
    \label{eq:linear_system}
    A X = B
  \end{equation}
  where $A$ is a real sparse, distributed matrix, defined as an
  Epetra\_RowMatrix object, and $X$ and $B$ are defined as
  Epetra\_MultiVector objects. Supported libraries include:
  LAPACK, KLU, UMFPACK, SuperLU, SuperLU\_DIST, MUMPS, DSCPACK.
  
  Amesos provides a common look-and-feel to several direct solvers,
  insulating the user from each package's details, such as matrix and
  vector formats, and data distribution.
\end{abstract}

\clearpage

\clearpage

%-----------------------------------------------------------------------------
\section*{Acknowledgments}
%-----------------------------------------------------------------------------
The authors would like to acknowledge the support of the ASCI and LDRD programs
that funded development of Amesos.

\clearpage

\SANDmain


\tableofcontents

\clearpage

%-----------------------------------------------------------------------------
\section{Introduction}
\label{sec:intro}
%-----------------------------------------------------------------------------

Aim of the Amesos package is to provide an object-oriented interface to
several sparse direct solvers\footnote{Amesos is an interface to other
  packages, mainly developed outside the Trilinos framework. In order to
  use those packages, the user should carefully check copyright and
  licensing of those third-party codes.  Please refer to the web page or
  the documentation of each particular package for details.}. For each
solver, Amesos provides a C++ interface. All the interfaces have the
same look-and-feel, and accept matrices defined as Epetra\_RowMatrix
objects\footnote{Most interfaces take advantage of linear system matrices 
  that can be casted to {\tt Epetra\_CrsMatrix} or {\tt Epetra\_VbrMatrix}.}, 
  and vectors defined as Epetra\_MultiVector objects. Amesos
makes easy for users to switch from one direct solver library from
another.

Amesos contains several classes, as reported in table~\ref{tab:classes}.
The classes covered in this guide are:
\begin{itemize}
\item \verb!Amesos_LAPACK!: Interface to LAPACK's dense solvers (in
  Section~\ref{sec:lapack}). This class is the only interface to
  dense solver in \amesos;
\item \verb!Amesos_KLU!: Interface to Amesos's internal solver KLU (in
  Section~\ref{sec:klu});
\item \verb!Amesos_Umfpack!: Interface to Tim Davis's
  UMFPACK~\cite{umfpack-home-page}, version 4.3 (in Section~\ref{sec:umfpack});
\item \verb!Amesos_Superlu!: Interface to Xiaoye S.~Li's serial
  SuperLU~\cite{superlu-home-page} (in Section~\ref{sec:superlu});
\item \verb!Amesos_Superludist!: Interface to Xiaoye S.~Li's distributed
  SuperLU~\cite{superlu-home-page} (in Section~\ref{sec:superludist});
\item \verb!Amesos_Mumps!: Interface to MUMPS
  4.3.2~\cite{mumps-home-page} (in Section~\ref{sec:mumps}).
\item \verb!Amesos_Dscpack!: Interface to DSCPACK~\cite{dscpack-manual} 
(in Section~\ref{sec:dscpack}).
\end{itemize}

A simple fragment of code using Amesos can read as follows. First,
  we need to include the header files for Amesos:
\begin{verbatim}
#include "Amesos.h"
#include "Amesos_BaseSolver.h"
\end{verbatim}
Note that these header files will {\sl not} include the header files
for the supported libraries (which are of course needed to compile the
\amesos\ library itself). Now, let define the linear system matrix, the
vector that will contain the solution, and the right-hand side as:
\begin{verbatim}
Epetra_LinearProblem Problem;
Epetra_RowMatrix* A;            // linear system matrix
Epetra_MultiVector* LHS;        // vector that will contain the solution
Epetra_MultiVector* RHS;        // right-hand side
\end{verbatim}

All \amesos\ object (derived from pure virtual class 
\verb!Amesos_BaseSolver!\footnote{A pure virtual class is a class that
defines interfaces only, and no code. Pure virtual classes cannot
be instantiated; however, it is possible to declare and use pointers and
references to a pure virtual class, as normally done with class
{\tt Amesos\_BaseSolver}.})
can be created using the function class \verb!Amesos!\footnote{A function
class is a class that contains methods, but no private data. Function
classes can be used, for example, to create objects.}, as follows:
\begin{verbatim}
Amesos_BaseSolver * Solver;
Amesos Factory;
char* SolverType = "Amesos_Klu";
Solver = Factory.Create(SolverType, *Problem);
\end{verbatim}
The complete list of parameters recognized by \verb!Create()! is reported
in Table~\ref{tab:classes}.

\begin{remark}
It is important to note that all available solvers can be selected
simply by changing an input parameter. Some solvers are serial, other
parallel; generally, each solver has its own matrix format. However, the
user will still have the {\em same} interface to all of them.
\end{remark}

The \verb!Factory! object will create an \verb!Amesos_Klu! object (if \amesos\
has been configure to support this solver). \verb!Factory.Create()! 
returns 0 if the requested solver is not available. Parameter names 
are case-sensitive; misspelled parameters 
will not be recognized. Method
\verb!Factory.Query()! can be used to query the factory about the
availability of a given solver:
\begin{verbatim}
char* SolverType = "Amesos_Klu";
bool IsAvailable = Factory.Query(SolverType);
\end{verbatim}

Parameters for all \amesos\ solvers are specified using a 
Teuchos\footnote{\amesos cannot be compiled without 
  the support for \teuchos.} 
parameters list, whose
definition requires the input file \verb!Teuchos_ParameterList.hpp!. For
a detailed description, we refer to the Teuchos documentation. We report
the most important methods of this class in Table~\ref{tab:teuchos}.
However, in most cases, users can proceed without calling
\verb!SetParameters()!.

\begin{table}[htbp]
  \centering
  \begin{tabular}{| p{4cm} | p{10cm} |}
    \hline
    \verb!set(Name,Value)! & Add entry \verb!Name! with value and type
    specified by \verb!Value!. Any C++ type (like int, double, a
    pointer, etc.) is valid. \\
    \verb!get(Name,DefValue)! & Get value (whose type is automatically
    specified by \verb!DefValue!). If not present, return
    \verb!DefValue!. \\
    \verb!subList(Name)! & Get a reference to sublist \verb!List!. If not
    present, create the sublist. \\
    \hline
  \end{tabular}
  \caption{Some methods of Teuchos::ParameterList class.}
  \label{tab:teuchos}
\end{table}

Here, we simply recall that the parameters list can be created as
\begin{verbatim}
Teuchos::ParameterList List;
\end{verbatim}
and parameters can be set as
\begin{verbatim}
List.set(ParameterName,ParameterValue);
\end{verbatim}
Here, \verb!ParameterName! is a string containing the parameter name,
and \verb!ParameterValue! is any valid C++ object that specifies the
parameter value (for instance, an integer, a pointer to an array or to
an object). The list of parameters that affect all \amesos\ solvers are
reported in Section~\ref{sec:parameters}, while parameters that are specific
to a given solver (if any) are reported in the Section of this document
dedicated to that solver.

\medskip

Note that \verb!Problem! is still empty. After setting the pointer to
the linear system matrix, we can perform the symbolic factorization
of the linear system matrix:
\begin{verbatim}
AMESOS_CHK_ERR(Solver->SymbolicFactorization());
\end{verbatim}
This phase does not require the numerical values of \verb!A!, that can
therefore be changed after the call to \verb!SymbolicFactorization()!.
However,  the nonzero pattern of \verb!A! {\em cannot} be
changed\footnote{The values of {\tt A} must
  be set before calling {\tt SymbolicFactorization()} and not changed
  if the user specify a threshold different from {\tt 0.0}.}.
\verb!AMESOS_CHK_ERR! is a macro (defined in \verb!Amesos_ConfigDefs.h!)
that checks the return code. If this return code is not zero, the
macro prints out an error message, and returns.

The numeric factorization is performed by
\begin{verbatim}
AMESOS_CHK_ERR(Solver->NumericFactorization());
\end{verbatim}

The values of \verb!RHS! must be set before solving the linear system, which
simply reads
\begin{verbatim}
Problem.SetLHS(LHS);
Problem.SetRHS(RHS);
AMESOS_CHK_ERR(Solver->Solve());
\end{verbatim}

Should the user need to re-factorize the matrix, he or she must call
\verb!NumericFactorization()!. If the structure of the matrix is changed,
he or she must call \verb!SymbolicFactorization()!. However, it is supposed
that the linear system matrix and the solution and right-hand side vectors
are still defined with the same \verb!Epetra_Map!.

\begin{table}[tbhp]
  \centering
  \begin{tabular}{| l | l l l | }
    \hline
    Class &   &  & Interface to \\
    \hline
    \tt Amesos\_Klu          & serial   & general & KLU \\
    \tt Amesos\_Umfpack      & serial   & general & UMFPACK 4.3 \\
    \tt Amesos\_Lapack       & serial   & general & LAPACK \\
    \tt Amesos\_Superlu      & serial   & general & SuperLU 3.0 \\
    \tt  Amesos\_Superludist & parallel & general & SuperLU\_DIST 2.0 \\
    \tt Amesos\_Mumps        & parallel & SPD, sym, general & MUMPS 4.3.2 \\
    \tt Amesos\_Dscpack      & parallel & symmetric & DSCPACK 1.0 \\
    \hline
  \end{tabular}
  \caption{Supported interfaces. ``serial'' means that the supported
    direct solver is serial. When solving with 
    more than one processor, the linear problem is exported to process
    0, here solved, then the solution is broadcasted to the distributed
    solution 
    vector. ``parallel'' means that a subset or all the processes in the current
    communicator will be used by the solver. ``general'' means general
    unsymmetric 
    matrix, If ``sym'' (symmetric matrix) or  ``SPD'' (symmetric
    positive definite), the direct solver library can take advantage of
    that particular matrix property.}
  \label{tab:classes}
\end{table}

%-----------------------------------------------------------------------------
\section{Configuring and Installation Amesos}
\label{sec:configuration}
%-----------------------------------------------------------------------------

Amesos is distributed through the Trilinos project, and can be
downloaded from the web site
\begin{verbatim}
http://software.sandia.gov/trilinos/packages/amesos
\end{verbatim}

\smallskip

Each of the \amesos\ classes provides an interface to a third-party direct
sparse solver code\footnote{Exception to this rule is KLU, which is
  distributed within Amesos.}. In order to configure and compile a given
interface, the user must first install the underlying direct sparse
solver code. Generally, the BLAS library is required. Some solvers may
need CBLACS, LAPACK, BLACS, ScaLAPACK. Amesos also requires Epetra and
Teuchos (both part of Trilinos).

Amesos is configured and built using the GNU autoconf~\cite{Autoconf}
and automake~\cite{Automake} tools. To configure Amesos from the
Trilinos top directory, a possible procedure is as follows.  Let
\verb!$TRILINOS_HOME! be a shell variable representing the location
of the Trilinos source directory, and \verb!%! the shell prompt sign.  
Let us suppose that we want to configure \amesos\ on a
LINUX machine with MPI, with support
for KLU and UMFPACK. Header files for UMFPACK are located
in directory \verb!/usr/local/umfpack/include!, while the library,
called \verb!libumfpack.a! is located in \verb!/usr/local/umfpack/lib!.
The configure like will look like:
\begin{verbatim}
% cd $TRILINOS_HOME
% mkdir LINUX_MPI
% cd LINUX_MPI
% ../configure \
  --with-mpi-compilers \
  --prefix=$TRILINOS_HOME/LINUX_MPI \
  --enable-amesos \
  --enable-amesos-klu \
  --enable-amesos-umfpack \
  --with-incdirs="-I/usr/local/umfpack/include" \
  --with-ldflags="-L/usr/local/umfpack/lib" \
  --with-libs="-lumfpack"
% make
% make install
\end{verbatim}
Other flags may be required depending on the location of
 MPI, BLAS and LAPACK. Supported architectures are reported 
 in Table~\ref{tab:arch}.

\begin{sidewaystable}[tbhp]
  \centering
  \begin{tabular}{| l  l | c | c | c | c | c | c| c|}
    \hline
    Architecture & Communicator & LAPACK  & KLU       & UMFPACK   & SuperLU &  SuperLU\_DIST 2.0
                                                                                          & MUMPS 4.3.2 & DSCPACK\\
    \hline
    LINUX           & SERIAL  & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & --        & --        & --        \\
    % --------------------------------------------------------
    LINUX, GNU      & LAM/MPI & $\bullet$ & $\bullet$ & $\bullet$ & --        & $\bullet$ & --        & $\bullet$ \\
    % --------------------------------------------------------
    LINUX, Intel    & MPICH   & $\bullet$ & $\bullet$ & $\bullet$ & --        & --        & $\bullet$ & $\bullet$ \\
    % --------------------------------------------------------
    SGI 64          & MPI     & $\bullet$ & $\bullet$ & $\bullet$ & --        & $\bullet$ & $\bullet$ & --        \\
    % --------------------------------------------------------
    DEC/Alpha       & MPI     & $\bullet$ & $\bullet$ & $\bullet$ & --        & --        & --        & --        \\
    % --------------------------------------------------------
    MAC OS X/G4     & MPICH   & $\bullet$ & $\bullet$   & --      & --        & --        & --        & --        \\
    % --------------------------------------------------------
    Sandia Cplant   & MPI     & $\bullet$ & $\bullet$ & $\bullet$ & --        & $\bullet$ & $\bullet$ & --        \\
    % --------------------------------------------------------
    Sandia ASCI Red & MPI     & $\bullet$ & $\bullet$ & $\bullet$ & --        & $\bullet$ & --        & --        \\
    \hline
  \end{tabular}
  \caption{Supported architectures for various interfaces. 
  `$\bullet$' means that the interface has been successfully compiled, 
  `--' means that it has not been tested.}
  \label{tab:arch}
\end{sidewaystable}

%-----------------------------------------------------------------------------
\section{Supported Matrix Formats}
\label{sec:matrix}
%-----------------------------------------------------------------------------

Table~\ref{tab:matrices} reports the supported matrix types for all the 
\amesos\ classes. In the table, ``Transp'' means that \amesos\ 
can solve both the linear system with the linear system matrix and with 
its transpose.  `$\bullet$' means that the interface can take advantage of the given matrix 
format, `--' means that it doesn't.

\begin{table}[tbhp]
  \centering
  \begin{tabular}{| p{3.5cm} | c | c | c | c | }
    \hline
    Class & Transp & Epetra\_RowMatrix & Epetra\_CrsMatrix & Epetra\_VrbMatrix \\
    \hline
    Amesos\_Lapack       & yes & $\bullet$ & $\bullet$ & -- \\
    Amesos\_Klu          & yes & $\bullet$ & $\bullet$ & -- \\
    Amesos\_Umfpack      & yes & $\bullet$ & $\bullet$ & -- \\
    Amesos\_Superlu      & no  & $\bullet$ & $\bullet$ & -- \\
    Amesos\_Superludist  & no  & $\bullet$ & $\bullet$ & -- \\
    Amesos\_Mumps        & yes & $\bullet$ & $\bullet$ & $\bullet$ \\
    Amesos\_Dscpack      & yes & --        & $\bullet$ & -- \\
    \hline
  \end{tabular}
  \caption{Supported matrix formats. ``Transp'' means that \amesos
    can solve both the linear system with the linear system matrix and with its
transpose.
`$\bullet$' means that the interface
    can take advantage of the given matrix format, `--' means that it doesn't.}
  \label{tab:matrices}
\end{table}

%-----------------------------------------------------------------------------
\section{Parameters for All \amesos\ Solvers}
\label{sec:parameters}
%-----------------------------------------------------------------------------

We now list all the parameters that may affect all the Amesos solvers.
To know whether a specific interface supports a given parameter, we
refer to table~\ref{tab:options}.

\vskip .1in \choicebox{\tt UseTranspose}{If {\tt false}, solve linear
  system~(\ref{eq:linear_system}). Otherwise, solve the linear system
  with the transpose matrix $A^T$.}

\vskip .1in \choicebox{\tt MatrixType}{Set it to {\tt SPD} if the matrix
  is symmetric positive definite, to {\tt symmetric} if symmetric, and
  to {\tt general} is the matrix is general unsymmetric. At this stage
  of development, only the MUMPS interface can take advantage of {\tt
    SPD} and {\tt symmetric}. }

\choicebox{\tt Threshold}{In the conversion from Epetra\_RowMatrix to a
  package's format, do not include elements whose absolute value is
  below the specified threshold.}

\choicebox{\tt AddZeroToDiag}{If true, in the conversion from
  Epetra\_RowMatrix to a package's format, a zero element will be added
  to the diagonal if not present.}

\choicebox{\tt PrintTiming}{Print some timing information when the
  Amesos object is destoyed.}

\choicebox{\tt PrintStatus}{Print some information about the linear
  system and the solver when the Amesos object is destoyed.}

\choicebox{\tt ComputeVectorNorms}{After solution, compute the 2-norm of
  each vector in the Epetra\_MultiVector $B$ and $X$. }

\choicebox{\tt ComputeTrueResidual}{After solution, compute the real
  residual $\| B - A X \|_2$ for all vectors in Epetra\_MultiVector. }

\choicebox{\tt MaxProcs}{If positive, the linear system matrix will be
  distributed on the specified number of processes only (or the all the
  processes in the MPI communicator if the specified number is greater).
  If {\tt MaxProcs=-1}, Amesos will estimate using internal heuristics
  the optimal number of processes that can efficiently solve the linear
  system. If {\tt MaxProcs=-2}, Amesos will use the square root of the
  number of processes.  If {\tt MaxProcs=-3}, all processes in the
  communicator will be used. \\ This option may require the conversion
  of a C++ MPI communicator to a FORTRAN MPI communicator. If this is
  not supported, the specified value of {\tt MaxProcs} will be ignored,
  and all the processes in {\tt MPI\_COMM\_WORLD} will be used.}

\choicebox{\tt MaxProcsMatrix}{The linear system matrix will be
  distributed over the specified number of processes. This number must
  be less or equal to {\tt MaxProcs}. See {\tt Maxprocs}. If {\tt MaxProcsMatrix=-4}, then the value of {\tt MaxProcsMatrix} equals that of {\tt MaxProcs}.}

\choicebox{\tt OutpuLevel}{If {\tt 0}, no output is printed on the
  standard output. If {\tt 1}, output is reported as specified by other
  parameters. If {\tt 2}, all output is printed (this is equivalent to
  {\tt PrintTiming == true}, {\tt PrintStatus == true}, {\tt
    ComputeVectorNorms == true}, {\tt ComputeTrueResidual == true}).}

\choicebox{\tt Refactorize}{
  ``Refactorization'' of a matrix refers to the use of a prior
  symbolic and numeric factorization (including row and column
  ordering), to factorize a subsequent matrix using the same
  pivot ordering.  This can be signicantly faster, but the
  numerical quality of the factorization may suffer.
  If {\tt true}, then attempt to re-use the existing
  symbolic and numeric factorization, to factorize a new matrix using
  the identical pivot ordering (both row and column ordering) as
  a prior pivot-capable factorization.}

\choicebox{\tt RcondThreshold}{After a refactorization,
    an estimate of the reciprocal of the condition number is computed.
    If this estimate is too small (less than {\tt RcondThreshold}),
    then the pivot-less factorization is aborted, and the matrix
    is factorized again with normal numerical pivoting.}

\choicebox{\tt ScaleMethod}{Most methods can scale the input matrix
prior to factorization.  This typically improves the quality of
the factorization and reduces fill-in as well.  Setting this
parameter to zero turns off scaling.  A value of 1 selects the
method's default scaling method (which may in fact be not to
scale at all).  A value of 2 means to scale the matrix
using the first non-default method the package has, 3
means to use its 2nd alternative method, and so on.}

\smallskip

\begin{sidewaystable}[tbhp]
  \centering
  \begin{tabular}{| p{5cm} | p{2cm} | p{2cm} | c | c | c
      | c | c | c |}
    \hline
    option & type & default value & \rotatebox{90}{KLU } &
    \rotatebox{90}{UMFPACK } & \rotatebox{90}{SuperLU\_DIST } &
    \rotatebox{90}{MUMPS } & \rotatebox{90}{LAPACK  }&
    \rotatebox{90}{DSCPACK } \\    
    \hline
     \tt UseTranspose       & \tt bool   & \tt false  & $\bullet$ & $\bullet$ & -- & $\bullet$  & $\bullet$ & -- \\
    % -------------------------------------------------------------------
     \tt MatrixType         & \tt string & \tt general& --        & -- & -- & $\bullet$ & -- & -- \\
    % -------------------------------------------------------------------
     \tt Threshold          & \tt double & \tt 0.0    & --        & -- & -- & $\bullet$ & -- & --  \\
    % -------------------------------------------------------------------
     \tt AddZeroToDiag      & \tt bool   & \tt false  & --        & -- & $\bullet$ & $\bullet$ & -- & -- \\
    % -------------------------------------------------------------------
     \tt PrintTiming        & \tt bool   & \tt false  & $\bullet$ & $\bullet$ & -- & $\bullet$ & $\bullet$ & $\bullet$ \\
    % -------------------------------------------------------------------
    \tt PrintStatus         & \tt bool   & \tt false  & $\bullet$ & $\bullet$ & $\bullet$  & $\bullet$ & $\bullet$ & $\bullet$ \\
    % -------------------------------------------------------------------
    \tt MaxProcs            & \tt int    & -1         & --        & -- & $\bullet$  & $\bullet$  & $\bullet$ & $\bullet$  \\
    % -------------------------------------------------------------------
    \tt MaxProcsMatrix      & \tt int    & -4         & --        & -- & -- & $\bullet$  & -- &   --    \\
    % -------------------------------------------------------------------
    \tt ComputeVectorNorms  & \tt bool   & \tt false  & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
    % -------------------------------------------------------------------
    \tt ComputeTrueResidual & \tt bool   & \tt false  & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$  & $\bullet$\\
    % -------------------------------------------------------------------
    \tt OutputLevel         & \tt int    & \tt 1      & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$  & $\bullet$\\
    % -------------------------------------------------------------------
    \tt DebugLevel          & \tt int    & \tt 0      & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
%---- added by Tim Davis:
    \tt Refactorize         & \tt bool   & \tt false  & $\bullet$ & -- & -- & -- & -- & -- \\
    % -------------------------------------------------------------------
    \tt RcondThreshold      & \tt double & $10^{-12}$ & $\bullet$ & -- & -- & -- & -- &--\\
    % -------------------------------------------------------------------
    \tt ScaleMethod         & \tt int    & 1          & $\bullet$ & -- & -- & -- & -- &--\\
%----
    \hline
  \end{tabular}
  \caption{Supported options. `$\bullet$' means that the interface
    supports the options, `--' means that it doesn't.}
  \label{tab:options}
\end{sidewaystable}

Solver-specific parameters are reported in each package's subsection.
The general procedure is to create a sublist with a given name (for
instance, the sublist for MUMPS is "mumps"), then set all the
solver's specific parameters in this sublist. An example is as follows:
\begin{verbatim}
  int ictnl[40];
  // defines here the entries of ictnl
  Teuchos::ParameterList & AmesosMumpsList = 
    AmesosList.sublist("mumps");
  AmesosMumpsList.set("ICTNL", ictnl);
\end{verbatim}
Parameters and sublists not recognized are simply ignored. Recall that
spaces are important, and that parameters list is case sensitive!

%-----------------------------------------------------------------------------
\section{Amesos Interface to KLU}
\label{sec:klu}
%-----------------------------------------------------------------------------

KLU is a serial, unblocked code ideal for getting started. Particular
classes of matrices, such as circuit matrices, may perform well with KLU.

KLU is Tim Davis' implementation of Gilbert-Peierl's left-looking sparse
partial pivoting algorithm, with Eisenstat and Liu's symmetric pruning.
It doesn't exploit dense matrix kernels, but it is the only sparse LU
factorization algorithm known to be asymptotically optimal, in the sense
that it takes time proportional to the number of floating-point
operations. It is the precursor to SuperLU, thus the name ("Clark Kent
LU"). For very sparse matrices that do not suffer much fill-in (such as
most circuit matrices when permuted properly) dense matrix kernels do
not help, and the asymptotic run-time is of practical importance.

\smallskip

In order to use KLU, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-klu
\end{verbatim}
The KLU sources are distributed with the Amesos package. We strongly encourage
to configure \amesos\ with KLU support. KLU is the only interface that is
turned on by default.

\smallskip

No specific parameters are available for this class.

\smallskip

KLU is a serial solver. Amesos will gather all matrix rows on processor
zero before the symbolic factorization, and all matrix values before the
numeric factorization. A call to \verb!Solve()! requires a gather
or all the right-hand side on process 0, the local solution of the linear
system, and finally a scatter operation, to redistribute as necessary the
solution vector.

%-----------------------------------------------------------------------------
\section{Amesos Interface to UMFPACK 4.3}
\label{sec:umfpack}
%-----------------------------------------------------------------------------

UMFPACK is a C package copyrighted by Timothy A.~Davis. More information
can be obtained at the web page
\begin{verbatim}
  http://www.cise.ufl.edu/research/sparse/umfpack
\end{verbatim}

In order to use UMFPACK, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-umfpack 
\end{verbatim}
Location of the header files should be specified using \verb!--with-incdirs!,
location of the library with \verb!--with-ldflags!, and the library
to be linked by \verb!--with-libs!. See Section~\ref{sec:configuration} for an
example.

\smallskip

No specific parameters are available for this class.

\smallskip

UMFPACK is a serial solver. Amesos will gather all matrix rows on processor
zero before the symbolic factorization, and all matrix values before the
numeric factorization. A call to \verb!Solve()! requires a gather
or all the right-hand side on process 0, the local solution of the linear
system, and finally a scatter operation, to redistribute as necessary the
solution vector.

%-----------------------------------------------------------------------------
\section{Amesos Interface to SuperLU 3.0}
\label{sec:superlu}
%-----------------------------------------------------------------------------

SuperLU, written by Xiaoye S. Li, is a serial solver.
SuperLU is written in ANSI C, using MPI
for communication. It is copyrighted by The Regents of the University of
California, through Lawrence Berkeley National Laboratory.  We refer to
the web site
\begin{verbatim}
http://www.nersc.gov/~xiaoye/SuperLU
\end{verbatim}
and to the SuperLU manual~\cite{superlu-manual} for more
information.

\medskip

In order to interface with SuperLU\_DIST 2.0, Amesos must be configured with
the options
\begin{verbatim}
--enable-amesos-superludist 
\end{verbatim}
Location of the header files should be specified using \verb!--with-incdirs!,
location of the library with \verb!--with-ldflags!, and the library
to be linked by \verb!--with-libs!. See Section~\ref{sec:configuration} for an
example.

\smallskip

No specific parameters are available for this class.

\smallskip

SuperLU 3.0 is a serial solver. Amesos will gather all matrix rows on processor
zero before the symbolic factorization, and all matrix values before the
numeric factorization. A call to \verb!Solve()! requires a gather
or all the right-hand side on process 0, the local solution of the linear
system, and finally a scatter operation, to redistribute as necessary the
solution vector.

%-----------------------------------------------------------------------------
\section{Amesos Interface to SuperLU\_DIST 2.0}
\label{sec:superludist}
%-----------------------------------------------------------------------------

SuperLU\_DIST, written by Xiaoye S. Li, is a parallel extension to the
serial SuperLU library.  SuperLU\_DIST is written in ANSI C, using MPI
for communication, and it is targeted for the distributed memory
parallel machines. It is copyrighted by The Regents of the University of
California, through Lawrence Berkeley National Laboratory.  We refer to
the web site
\begin{verbatim}
http://www.nersc.gov/~xiaoye/SuperLU
\end{verbatim}
and to the SuperLU\_DIST manual~\cite{superlu-manual} for more
information.

SuperLU\_DIST includes routines to handle both real and complex matrices
in double precision. However, as Amesos is currently based on the Epetra
package (that does not handle complex matrices), only double precision
matrices can be considered.

Amesos\_Superludist can solve the linear system on a subset of the
processes, as specified in the parameters list. This is done by
creating a new process group derived from the MPI group of the
Epetra\_Comm object, with function \verb!superlu_gridinit()!. 

\medskip

In order to interface with SuperLU\_DIST 2.0, Amesos must be configured with
the options
\begin{verbatim}
--enable-amesos-superludist 
\end{verbatim}
Location of the header files should be specified using \verb!--with-incdirs!,
location of the library with \verb!--with-ldflags!, and the library
to be linked by \verb!--with-libs!. See Section~\ref{sec:configuration} for an
example.

\medskip

The SuperLU\_DIST constructor will look for a sublist, called
\verb!Superludist!.  The following parameters reflect the behavior of
SuperLU\_DIST options argument, as specified in the SuperLU\_DIST
manual~\cite[pages 55--56]{superlu-manual}. The user is referred to this
manual for a detailed explanation of the reported parameters. Default
values are as reported in the SuperLU\_DIST manual.

\vskip .1in

\choicebox{\tt Fact}{({\tt string}) Specifies whether or not the factored form
  of the matrix $A$ is supplied onentry and, if not, how the matrix will
  be factored. It can be: {\tt DOFACT, SamePattern,
    SamePattern\_SameRowPerm, FACTORED}. Default: {\tt
    SamePattern\_SameRowPerm}.}

\choicebox{\tt Equil}{({\tt bool}) Specifies whether to equilibrate the system of
  not. Default: {\tt true}.}

\choicebox{\tt ColPerm}{({\tt string}) Specifies the column ordering
  strategy.  It can be: {\tt NATURAL, MMD\_AT\_PLUS\_A, MMD\_ATA,
    COLAMD, MY\_PERMC}.  Default: {\tt MMD\_AT\_PLUS\_A}.}

\choicebox{\tt perm\_c}{({\tt int *}) Specifies the ordering to use when {\tt
    ColPerm = MY\_PERMC}.}

\choicebox{\tt RowPerm}{({\tt string}) Specifies the row ordering
  strategy.  It can be: {\tt NATURAL, LargeDiag, MY\_PERMR}.  Default:
  {\tt LargeDiag}.}

\choicebox{\tt perm\_r}{({\tt int *}) Specifies the ordering to use when {\tt
    RowPerm = MY\_PERMR}.}

\choicebox{\tt ReplaceTinyPivot}{({\tt bool}) Specifies whether to replace the
  tiny diagonals with $\varepsilon \| A \|$ during LU
  factorization. Default: {\tt true}.}

\choicebox{\tt IterRefine}{({\tt string}) Specifies how to perform iterative
  refinement. It can be: {\tt NO, DOUBLE, EXTRA}. Default: {\tt
    DOUBLE}.}

%-----------------------------------------------------------------------------
\section{Amesos Interface to MUMPS 4.3.2}
\label{sec:mumps}
%-----------------------------------------------------------------------------

MUMPS (``MUltifrontal Massively Parallel Solver'') is a parallel direct
solver, written in FORTRAN 90 with C interface, copyrighted by P. R.
Amestoy, I. S.  Duff, J. Koster, J.-Y.  L'Excellent. Up-to-date copies
of the MUMPS package can be obtained from the Web page
\begin{verbatim}
http://www.enseeiht.fr/apo/MUMPS/
\end{verbatim}
Here, for the sake of completeness, we briefly present a broad view of
the MUMPS package, so that the reader can better understand the
Amesos\_Mumps interface. For details about the algorithms and the
implementation, as well as of the input parameters, we refer
to~\cite{mumps-manual}

MUMPS can solve the original system~(\ref{eq:linear_system}), as well as
the transposed system, given an assembled or elemental matrix. Note that
only the assembled format is supported by Amesos\_Mumps. Mumps offers,
among other features, error analysis, iterative refinement, scaling of
the original matrix, Schur complement with respect to a prescribed
subset of rows. Reordering techniques can take advantage of PORD
(distributed within MUMPS), or METIS~\cite{METIS}\footnote{At this time,
  METIS ordering is not supported by Amesos\_Mumps.}. 

Amesos\_Mumps is based on the distributed double-precision version of
MUMPS (which requires MPI, BLAS, BLACS
and ScaLAPACK~\cite{scalapack}).  

\medskip

In order to interface with MUMPS 4.3.2, Amesos must be configured with
the options\footnote{The MUMPS interface can take be used on a subset of
  the processes. To that aim, it must be possible to convert from a C++
  MPI communicator to a FORTRAN MPI communicator. Such a conversion is
  not always possible. In you experience compilation problems with {\tt
    Amesos\_Mumps}, you can try the option {\tt
    --disable-amesos-mumps\_mpi\_c2f}.}
\begin{verbatim}
--enable-amesos-mumps 
\end{verbatim}
Location of the header files should be specified using \verb!--with-incdirs!,
location of the library with \verb!--with-ldflags!, and the library
to be linked by \verb!--with-libs!. See Section~\ref{sec:configuration} for an
example.

It is also possible to configure with support for the single precision
version of MUMPS, using option
\begin{verbatim}
--enable-amesos-smumps 
\end{verbatim}
which enables the \amesos\ interface support for the
single-precision version of MUMPS. This is intended to be used when
the precision of the solution is not of primary importance, for example,
is \amesos\ is used to solve the coarse problem in multilevel
preconditioners, like \ml~\cite{ml-guide}. In this case, users may decide
to use single-precision solves of the coarse problem
to save memory and computational time. As
Amesos is based on the Epetra\_LinearProblem class
(defined for double precision only), this interface
still requires double-precision matrix and vectors.
After the solver phase, the single precision vector
is copied into the double-precision solution vector
of the given Epetra\_LinearProblem. If enabled,
disabled double-precision version of MUMPS.

\medskip

The MUMPS constructor will look for a sublist, called
\verb!mumps!. 
The user can set all the MUMPS's parameters, by sticking pointers to the
integer array ICNTL and the double array CNTL to the parameters list,
or by using the functions reported at the end of this section.

\vskip .1in
\choicebox{\tt ICTNL}{({\tt int[40])} Pointer to an integer array, containing
  the integer parameters (see~\cite[pages 13--17]{mumps-manual}).}

\choicebox{\tt CTNL}{({\tt double[5])} Pointer to an double array, containing
  the double parameters (see~\cite[page 17]{mumps-manual}).}

\choicebox{\tt PermIn}{({\tt int *)} Use integer vectors of size
  NumGlobalElements (global dimension of the matrix) as given ordering.
  {\tt PermIn} must be defined on the host only, and allocated by the
  user, if the user sets ICNTL(7) = 1.}
  
\choicebox{\tt Maxis}{({\tt int)} Set Maxis value.}

\choicebox{\tt Maxs}{({\tt int}) Set Maxis value.}

\choicebox{\tt ColPrecScaling}{({\tt double *)} Use double precision vectors
  of size NumGlobalElements (global dimension of the matrix) as scaling
  for columns and rows. The double vector must be defined on the host
  only, and allocated by the user, if the user sets ICNTL(8) = -1.}

\choicebox{\tt RowPrecScaling}{({\tt double *)} Use double precision vectors
  of size NumGlobalElements (global dimension of the matrix) as scaling
  for columns and rows. The double vector must be defined on the host
  only, and allocated by the user, if the user sets ICNTL(8) = -1.}


\bigskip

Other functions are avaiable to retrive the output values. The following
Amesos\_Mumps methods are {\sl not} supported by the Amesos\_BaseSolver
class; hence, the user must create an Amesos\_Mumps object in order to
take advantage of them.

\medskip

\begin{verbatim}
double * GetRINFO() 
\end{verbatim}
Gets the pointer to the RINFO array (defined on all processes).

\medskip

\begin{verbatim}
int * GetINFO() 
\end{verbatim}
Gets the pointer to the INFO array (defined on all processes).

\medskip

\begin{verbatim}
double * GetRINFOG() 
\end{verbatim}
Gets the pointer to the RINFOG array (defined on host only).

\medskip

\begin{verbatim}
int * GetINFOG() 
\end{verbatim}
Gets the pointer to the INFOG array (defined on host only).

\bigskip
  
A functionality that is peculiar to MUMPS, is the ability to return
the Schur complement matrix, with respect to a specified set of nodes.

\begin{verbatim}
int ComputeSchurComplement(bool flag,
                           int NumSchurComplementRows, 
                           int * SchurComplementRows);
\end{verbatim}
This method computes (if \verb!flag! is true) the Schur complement with
respect to the set of indices included in the integer array {\tt
  SchurComplementRows} , of size {\tt NumSchurComplementRows}. This is a
{\sl global} Schur complement, and it is formed (as a dense matrix) on
processor 0 only.

\medskip

\begin{verbatim}
Epetra_CrsMatrix * GetCrsSchurComplement();
\end{verbatim}
This method returns the Schur complement in an Epetra\_CrsMatrix, on host
only. No checks are performed to see whether this action is legal or not
(that is, if the call comes after the solver has been invocated).
The returned Epetra\_CrsMatrix must be freed by the user.

\medskip

\begin{verbatim}
Epetra_SerialDenseMatrix * GetDenseSchurComplement();
\end{verbatim}
This method returns the Schur complement as a Epetra\_SerialDenseMatrix
(on host only).

\medskip


As an example, the following frament of code shows how to use MUMPS to
obtain the Schur complement matrix with respect to a given subsets of
nodes.  First, we need to create an parameter list, and an Amesos\_Mumps
object.
\begin{verbatim}
  Teuchos:::ParameterList params;
  Amesos_Mumps * Solver;
  Solver = new Amesos_Mumps(*Problem,params);
\end{verbatim}
Then, we define the set of nodes that will constitute the Schur
complement matrix. This must be defined on processor 0 only. For
instance, one may have:
\begin{verbatim}
  int NumSchurComplementRows = 0;
  int * SchurComplementRows = NULL;
  if( Comm.MyPID() == 0 ) {
    NumSchurComplementRows = 4;
    SchurComplementRows = new int[NumSchurComplementRows];
    SchurComplementRows[0] = 0;
    SchurComplementRows[1] = 1; 
    SchurComplementRows[2] = 2;
    SchurComplementRows[3] = 3;
  }
\end{verbatim}
Now, we can ask for the Schur complement using
\begin{verbatim}  
  Solver->ComputeSchurComplement(true, NumSchurComplementRows,
                                       SchurComplementRows);
\end{verbatim}
The Schur complement matrix can be obtain after the solver phase:  
\begin{verbatim}  
  Solver->Solve();
  Epetra_CrsMatrix * SC;
  SC = Solver->GetCrsSchurComplement();
  Epetra_SerialDenseMatrix * SC_Dense;
  SC_Dense = Solver->GetDenseSchurComplement();
\end{verbatim}

%-----------------------------------------------------------------------------
\section{Amesos Interface to LAPACK}
\label{sec:lapack}
%-----------------------------------------------------------------------------

In some cases, the linear system matrix can be of relatively small size,
  or it can be quite dense, or both. If this happens, it may be convenient
  to convert the sparse matrix to dense format, then use LAPACK routines.

\smallskip

In order to use LAPACK, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-lapack 
\end{verbatim}
Header files and library is automatically located by {\tt configure}.

\smallskip

LAPACK is a (suite of) serial solver(s). Amesos will gather all matrix rows on processor
zero before the symbolic factorization, and all matrix values before the
numeric factorization. On process 0, the matrix will be converted
to dense storage, using \verb!Epetra_SerialDenseMatrix! objects.
A call to \verb!Solve()! requires a gather
or all the right-hand side on process 0, the local solution of the linear
system, and finally a scatter operation, to redistribute as necessary the
solution vector.

\smallskip

No specific parameters are available for this class.

%-----------------------------------------------------------------------------
\section{Amesos Interface to DSCPACK}
\label{sec:dscpack}
%-----------------------------------------------------------------------------

DSCPACK can be used to solve symmetric sparse linear systems of equations.
DSCPACK provides a variety of sparsity preserving (fill-reducing) ordering and
computes either an $LL^T$ (Cholesky) or $LDL^T$ factorization of the linear
system matrix. This solver is written in C, and it uses MPI for
inter-processor communication, and the BLAS library for improved
chace-performances. The implementation is based on the idea of partitioning
the sparse matrix into domains and separators. 

We refer to the web site
\begin{verbatim}
http://www.cse.psu.edu/~ragavan/dscpack
\end{verbatim}
and to the DSCPACK manual~\cite{dscpack-manual} for more
information.

\smallskip

In order to use DSCPACK, Amesos must be configured with the options
\begin{verbatim}
--enable-amesos-dscpack 
\end{verbatim}
Location of the header files should be specified using \verb!--with-incdirs!,
location of the library with \verb!--with-ldflags!, and the library
to be linked by \verb!--with-libs!. See Section~\ref{sec:configuration} for an
example.

\smallskip

DSCPACK solves the linear system using a number of processors that is a power
of 2. If necessary, we linear system matrix will be automatically
redistributed on the highest number of processors (either all the
processors, or the number specified in \verb!MaxProcs!) that is a power of 2.

\smallskip

No specific parameters are available for this class.

%-----------------------------------------------------------------------------
\section{Preconditioners Based on \amesos}
\label{sec:prec}
%-----------------------------------------------------------------------------

\amesos\ is used in other \trilinos\ packages. In particular, \ifpack\
  can take advantage of \amesos\ to define additive overlapping domain
  decomposition preconditioners (of Schwarz type). We refer to the
  \ifpack\ documentation for more details.

\begin{remark}
\amesos\ is also used by another \trilinos\ package, \ml. \ml takes
advantages of the \amesos\ interfaces to solve the coarse problem
that arises in multilevel preconditioners; see the \ml\ guide for more
details~\cite{ml-guide}.
\end{remark}

%-----------------------------------------------------------------------------
\section{Guide to the Examples}
\label{sec:examples}
%-----------------------------------------------------------------------------

The \amesos\ distribution contains examples in subdirectory
\begin{verbatim}
$TRILINOS_HOME/packages/amesos/example
\end{verbatim}
Most of the example requires \amesos\ to be configured with support for
\triutils. \triutils\ is a Trilinos package, automatically compiled unless
the user specifies
\begin{verbatim}
--disable-triutils
\end{verbatim}
\triutils\ is used to generate the linear system matrix. New users can
start from file
\begin{verbatim}
$TRILINOS_HOME/packages/amesos/example/example_AmesosFactory.cpp
\end{verbatim}
which contains detailed comments about all the \amesos\ commands.
Example
\begin{verbatim}
$TRILINOS_HOME/packages/amesos/example/example_AmesosFactory_HB.cpp
\end{verbatim}
shows how to read a matrix stored in Harwell/Boeing format, redistribute it
to all the processes used in the computation, and use \amesos\ to solve the
corresponding linear system. Finally, example
\begin{verbatim}
$TRILINOS_HOME/packages/amesos/example/example_AmesosFactory_Tridiag.cpp
\end{verbatim}
creates a simple tridiagonal matrix, and solves the corresponding linear
system.

\bibliographystyle{plain}
\bibliography{AmesosBibliography}

\end{document}
