 \documentclass[12pt,relax]{EpetraUserGuide}
\usepackage{array}
\usepackage{fancyvrb}
    \title{\EpetraTM{} User Guide}
\SANDsubtitle{}

    \author{Michael A. Heroux, Robert J. Hoekstra and Alan Williams \\
	\\
	    Sandia National Laboratories\\
	    P.O. Box 5800\\
	    Albuquerque, NM 87185-1110 
	 }

    % There is a "Printed" date on the title page of a SAND report, so
    % the generic \date should generally be empty.
    \date{\today} % Remove ``\today'' in final version


\SANDnum{SAND2003-xxxx}
\SANDprintDate{Printed July 2003}
\SANDauthor{Michael A. Heroux \\
	Computational Mathematics and Algorithms Department \\
	\\
	Robert J. Hoekstra \\
	Computational Sciences Department \\
	\\
	Alan Williams \\
	Alan's Group Name \\
	\\
	 Sandia National Laboratories \\
	P.~O.~Box 5800 \\
	Albuquerque, NM 87185-1110}


\SANDreleaseType{Unlimited Release}


\SANDdistcategory{UC-999}    
% New commands

\newcommand{\comm}{Epetra\_Comm}
\newcommand{\serialcomm}{Epetra\_SerialComm}
\newcommand{\mpicomm}{Epetra\_MpiComm}
\newcommand{\mpismpcomm}{Epetra\_MpiSmpComm}
\newcommand{\lbcomm}{Epetra\_LbComm}
\newcommand{\map}{Epetra\_Map}
\newcommand{\blockmap}{Epetra\_BlockMap}
\renewcommand{\vector}{Epetra\_Vector}
\newcommand{\multivector}{Epetra\_MultiVector}
\newcommand{\crsgraph}{Epetra\_CrsGraph}
\newcommand{\crsmatrix}{Epetra\_CrsMatrix}
\newcommand{\vbrmatrix}{Epetra\_VbrMatrix}
\newcommand{\rowmatrix}{Epetra\_RowMatrix}


\begin{document}
\maketitle

\begin{abstract}

The \TrilinosTM{} Project is an effort to facilitate the design, development,
integration and ongoing support of mathematical software libraries.
One special Trilinos package is \EpetraTM{}.  Epetra provides a collections of
vector, graph and matrix objects that can be used on serial
and parallel computers.  It is designed to make construction, use and redistribution
of these objects as efficient and easy as possible.  Epetra objects are compatible with all
other Trilinos packages, including all linear, nonlinear and eigen solvers and all
preconditioners packages.  It also implements all Trilinos abstract interfaces and 
provides access to the Zoltan~\cite{zoltan-ug} load balancing package, and an object-oriented
interface to the BLAS~\cite{BLAS1,BLAS2,BLAS3} and LAPACK~\cite{lapack}.


This user guide is designed to address two types of users: 
(i) those who
are primarily interested in using already-constructed Epetra objects (such as 
numerical algorithm developers who want to implement algorithms via 
operations on Epetra vector, graph and matrix objects) and 
(ii) those who, in addition to using Epetra
objects, are also constructing Epetra vector, graphs and matrices.  This group
includes application developers who are constructing these objects for the purpose
of solving linear, nonlinear and eigensystems.

\end{abstract}


\section*{Acknowledgement}
The authors would like to acknowledge the support of the ASCI and LDRD 
programs that funded development of Epetra.

\clearpage
\tableofcontents
\listoffigures
\listoftables

\clearpage

\section*{Nomenclature}
\addcontentsline{toc}{section}{Nomenclature}
\begin{itemize}
\item[Trilinos]
The name of the project of which Epetra is one of the packages.  Also a Greek term which,
loosely translated means ``a string of pearls,'' 
meant to evoke an image that each Trilinos package is a pearl in its 
own right, but is even more valuable when combined with other 
packages.
\item[Petra]
A Greek term meaning ``foundation.''  Trilinos has three Petra 
libraries: Epetra, Tpetra and Jpetra that provide basic classes 
for constructing and manipulating matrix, graph and vector
objects.  Epetra is the current production version that is
split into two packages, one core and one extensions.
\item[Comm Object]
An instance of one of the Epetra Comm classes.  Presently we support
an MPI, Serial and SMP/MPI implementation of the base \comm{} interface.
\item[Map Object] 
Object-oriented algebraic preconditioner, compatible with 
Epetra and AztecOO.
\end{itemize}

NOTE: Add section on repeated use of Epetra objects.


\section{Introduction}
\label{Section:Introduction}

Epetra is a collection of C++ classes that support the construction
and use of common numerical linear algebra objects such as vectors,
graphs and matrices.  It is primarily designed for irregular, parallel
distributed memory computations, but can also be used on serial systems
with structured data.  This user guide is intended to (i) introduce a new
user to the basic features of Epetra, (ii) discuss in detail Epetra
object constructors, and (iii) illustrate the use of
Epetra's advance parallel data repartitioning capabilities to
experienced users.  This document is not intended as a reference
manual.  Detailed descriptions of Epetra classes and methods can be
found online at the Trilinos Project home page~\cite{Trilinos-home-page}.


\subsection{Overview of Major Epetra Classes and Feautures}

Epetra contains many classes and provides a wide spectrum of
functionality within these classes.  However, there is a relatively
short list of classes and features that are commonly used.  We discuss
these here.

\subsubsection{Communication Support}
Epetra is written to run on parallel, distributed memory computers.  It accomplishes 
this via its abstract \comm{} class.  \comm{} is a pure virtual class,
specifying the methods that Epetra needs in order to execute on a
distributed memory computer.  However, \comm{} provides no
implementation of these methods.  Instead, Epetra contains
several derived classes that implement the \comm{} interface,
providing the needed functionality.  In this way, Epetra is not
explicitly dependent on any one communication library or interface.
Presently we have three implementations of \comm{}:
\begin{enumerate}
\item {\bf \serialcomm{}: } Implements the \comm{}
methods to run on a serial computer.  In this case, the majority of
the methods have trivial implementations.  However, having the
\serialcomm{} class allows the rest of Epetra classes to be used
independently from the type of parallel computer being used and allows
serial use of Epetra within a parallel application.
\item {\bf \mpicomm{}: } Uses a user-provided MPI
communicator to implement the \comm{} methods.  In fact, many of the
\comm{} methods have a name similar to an existing MPI function.
Since MPI is by far the most common communication interface and
library used with Epetra, this bias to MPI function names is
intentional.
\item {\bf \mpismpcomm{}:} An experimental implementation that
incorporates information about shared memory threads.  This
implementation of \comm{} is intended for situations where threads,
e.g.~pthreads, are created and retained as part of the call to the 
\mpismpcomm{} constructor.  These threads can then be used by any
kernels in Epetra that have been instrumented to run with threads.  At
this point, \mpismpcomm{} is purely for research purposes.
\item {\bf \lbcomm{}: } A new version of \comm{} built using an MPI
communicator and special tuned implementations of basic communication
operations coming from the LB\_Comm library that is part of the Zoltan
load balancing library~\cite{zoltan-ug}.
\end{enumerate}

By using an abstract interface to provide distributed memory support,
Epetra allows for future development of novel parallel communication.
Also, although MPI is by far the most commonly used implementation of
\comm{}, Epetra has no explicit dependence on MPI and therefore MPI is
not required to build Epetra.

\subsubsection{Distributed Data Support}

Coupled with distributed memory communications, Epetra also provides
support for distributed data objects.  Users can constructed,
manipulate and redistribute Epetra objects in a flexible and powerful
way.  The primary classes that are used to describe the layout of
distributed objects are the \blockmap{} and \map{} classes.  Both of
these classes encode information about the distribution of {\it global
IDs (GIDs)}. GIDs are integer labels that can be associated
with elements of  Epetra distributed objects.  For example, the
elements of an \vector{} are the vector values and each
value of an \vector{} object is associated with a GID.
Similarly, each row of an \crsgraph{}, an \crsmatrix{} and an
\multivector{} is an element and is associated with a GID.  Multiple
elements can be associated with the same GID, but each element has a
unique GID.

\subsection{Primary Linear Algebra Classes}
Although there are many classes in Epetra, the core linear algebra classes are the
vector, graph and matrix classes.  All of these classes implement the
\distobject{} interface, and can therefore be redistributed across the
parallel machine in a variety of ways.  However, a simple use of Epetra usually
involves the construction of a single \comm{} object, which is passed
in to the constructor of a single \map{} object and the resulting \map{}
is then used to construct any number of vector and matrix objects,
something we illustrate in Section~\ref{Section:FirstExample}.
The primary Epetra linear algebra classes are as follows:
\begin{enumerate}
\item {\bf \vector{}: } Supports construction and use of distributed
vectors of double-precision numbers.  Once constructed, \vector{}
objects can be used in multiple ways.  Common operations such as
norms, dot products and vector updates are supported by methods in
this class.  Additional functionality is available via several
extension techniques discussed later.
\item{\bf \multivector{}: } An \multivector{} object is a collection
of \vector{} objects (although \vector{} is actually implemented as a
specialization of \multivector{}).  Specifically, an \multivector{}
object is a collection of vectors with the same size and
distribution.  This kind of object is useful for block algorithms and
applications that manage multiple vectors simultaneously.  \vector{}
and \multivector{} objects are understood by all Trilinos packages.
\item{\bf \crsgraph{}:} Supports the construction and use of adjacency
graphs.  These graphs are used to describe the pattern of Epetra
sparse matrix classes and provide pattern-based information to
load-balancing interfaces.  The graphs are also used to implement
overlapping subdomain algorithms and a variety of other parallel
algorithms.
\item{\bf \crsmatrix{}:} Supports construction and use of distributed
sparse matrix objects.  Once constructed, an \crsmatrix{} object can
be used with any Trilinos solvers or preconditioners.  This class also
supports common matrix and matrix-vector operations such as matrix
scaling, matrix norms and matrix-vector multiplication.
\item{\bf \vbrmatrix{}:} Although less frequently used than the
\crsmatrix{} class, this class supports the construction of sparse
matrices whose entries are dense matrices.  This type of matrix is
frequently found in applications where multiple degrees of freedom are
tracked at each mesh point.  When properly used, the \vbrmatrix{}
class can offer substantial machine performance and algorithmic
robustness improvements.

\end{enumerate}

\section{A First Example}
\label{Section:FirstExample}
Before proceeding with additional descriptive information, we
introduce a simple example in this section in order to explicitly
illustrate a straight-forward use of Epetra.  Although this example only
starts to tap the capabilities of Epetra, we hope the reader finds it
useful.

The example code, listed in Figures~\ref{Figure:FirstExample}
and~\{Figure:FirstExamplePowerMethod}, is the main program driver and
a simple implementation of the Power Method~\cite{GoluVanL96} for computing the dominant
eigenvalue and associated eigenvector of a given matrix,
respectively.  In the remainder of this section we proceed with a
description of the code in these figures.
\begin{figure}
\begin{center}
\input{Ex1}
\end{center}
\label{Figure:FirstExample}
\caption{Simple Driver for Power Method Example}
\end{figure}

\begin{figure}
\begin{center}
\input{Ex1a}
\end{center}
\label{Figure:FirstExamplePowerMethod}
\caption{Simple Power Method Routine}
\end{figure}

\subsection{Explanation of Figure~\ref{Figure:FirstExample}}

\subsubsection{Lines 1--2}
Include system header files needed for screen output and system
functions.
\subsubsection{Lines 3--8}
Include the appropriate implementation of the \comm{} class.  If
Epetra was built in MPI mode, the macro ``HAVE\_MPI'' will be defined
and this example will be built with MPI support.  If not, then the
example will be built in serial mode.  Note that these lines of code
 and lines 15--20 are the only difference between a serial and distributed memory
version of the example. 
\subsubsection{Lines 9--11}
Include the other Epetra header files needed to use Epetra classes.
It is a good practice to explicitly include header files for all
Epetra classes you explicitly use and only those header files.
\subsubsection{Lines 12--13}
Declare prototype for power_method function.
\subsubsection{Line 14}
Start of main program.  Note that argv[1] will be used to pass in the
problem size.
\subsubsection{Lines 15--21}
Depending on whether or not Epetra was built in MPI
mode\footnote{Whether or not Trilinos, and Epetra as a Trilinos package, is built
in MPI mode is determined by how the Trilinos (or Epetra) {\tt
configure} script in invoked.  If no MPI-related arguments are passed
to the configure script, then packages are built in serial mode only.
If one or more MPI options are invoked, then packages are built with
MPI support (in addition to serial support).}, MPI will be initialized
and an \mpicomm{} object will be constructed, or an \serialcomm{}
object will be constructed.  Please note that, in principle, the serial
version of this example would work, even if Epetra were built in MPI
mode.  Serial mode is always available.

Line 21 prints the Comm object to cout.  Most Epetra classes have
implemented the ostream << operator so that an instance of an Epetra
object can be viewed.  Sometime the volume of output can be very
large, so some care is needed when using this feature.
\subsubsection{Lines 22--27}
This example accepts a single integer argument
specifying the number of equations that should be used.  These lines
of code capture that number and put it into NumGlobalElements.
\subsubsection{Lines 28--31}
Constructs an \map{} object that has NumGlobalElements elements spread
across the parallel (or serial) machine.  The second argument (a
``0'') indicates that our global indices are zero-based.  Fortran
users would typically pass in a ``1'' here.  The third argument is the
Comm object we just built.
\subsubsection{Line 32}
Once an \map{} object is constructed, we can query it for how many
elements of the map are on the calling process\footnote{For readers
who are not familiar with a single-program, multiple data (SPMD)
programming model, it may be useful to read a bit about it.  Typing
``SPMD tutorial'' into a web search engine should be a sufficient
starting point.}.  In this way, the remainder of our code can operate
independent of how data was distributed.
\subsubsection{Lines 33--34}
Instantiates (creates) an \crsmatrix{}.  The first argument tells the
constructor whether or not data passed in to this object should be
copied (user values and indices will be copied to internal storage) or
viewed (user values and indices will be pointed to by this object and
the user {\it must} guarantee the integrity of that data).  View mode
is available across many Epetra classes.  In general, this is a very
dangerous practice.  However, in certain very important situations, it
is essential to have this mode.  This is especially true when using
Epetra with Fortran, or when accepting matrix data from other parts of
application where it is too expensive to replicate the data storage.

The second argument is the \map{} object we just constructed.  The
third argument is an advisory value telling the constructor
approximately how many nonzero values will be defined for each row of
the matrix\footnote{getting this value wrong does not
affect the correctness of results, but may affect performance and
efficient use of memory}.  We are constructing a diagonal matrix, so the value ``1''
is appropriate.

At this point the matrix is an empty ``bucket'' ready to receive
matrix values and indices.  Also, at this point, most of the methods
in the \crsmatrix{} cannot be called successfully for this object.
\subsubsection{Lines 35--41}
These lines insert values and indices into the matrix we just
instantiated.  Our matrix is very simple--a single diagonal entry per
row--so these lines may be a bit confusing.  The \crsmatrix{} class is
designed to accept matrix entries in a variety of ways.  However,
there is a strong bias in the interface to accept multiple entries in
a specified row.  Any matrix entry can be submitted one or more times,
with subsequent values being added to any existing value.
Section~\ref{Section:ConstructingCrsMatrices} discusses these issues
in detail.

Line 35 defines a simple double variable that will be passed in on
line 40 as an array of length 1.  Line 37 loops over all elements
owned by the calling processor.  Line 38 get the global ID associated
with the current loop index.  This value will be used 


\section{Constructing \crsmatrix{} Objects}
\label{Section:ConstructingCrsMatrices}

\section{ Advanced topics}
\subsection {Using \crsmatrix{} Objects as Column Matrices}

\clearpage
\bibliographystyle{plain}
\bibliography{EpetraUserGuide}
\addcontentsline{toc}{section}{References}

\appendix
\section{Commonly Used CVS Commands}
\label{Section:CVS}
\section{Common Bugzilla Tasks}
\label{Section:Bugzilla}


\end{document}
