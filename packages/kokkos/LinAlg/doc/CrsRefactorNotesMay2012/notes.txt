************************************************************

Questions/Challenges:

* Why does Matrix need a Graph? 
  Ours doesn't, but derivations might, so just add it to the base constructor.
  The reason is that CrsGraphBase and CrsMatrixBase are models for how Tpetra will use local CRS objects
  Also, giving Matrix the Graph gives it the node and ensures they share the node type. 
  - This also requires some agreement between node and matrix/graph; maybe a bad idea? But a template constructor could always ignore the node.

* Also, it seems that we have two options: 
  C1) 1. finalize Graph  in T::G::fillComplete()
     2. finalize Matrix in T::M::fillComplete()
  C2) finalize graph and matrix in T::M::fillComplete()
  Matrix separate from graph is clear. 
  Matrix as a container/interface to hide the structure of values makes some sense, but isn't necessary.

  We could instead do:
  C1) 1. graph alone, filled via LclMatOps::finalizeGraph()
      2. then LclMatOps.setGraphAndMatrix(graph,vals)
  C2) graph and matrix
  Less interface on graph and matrix objects allows more re-use of code.

  For now, let's stick with a minimal matrix object. 
  Graph and matrix are filled (statically) by LocalMatOps and submitted to LocalMatOps.

  Also, graph and matrix objects can have accept a ParameterList-accepting constructor.

************************************************************

  Intimacy between CrsGraph and CrsMatrix

  Note, there is still some strange-looking interplay between CrsMatrix and CrsGraph. This is for two reasons: 
  I.  Stand-alone CrsGraph means that they both have to be able to do the same things. Currently, we just have CrsGraph do stuff on behalf of CrsMatrix.
  II. Certain operations are destructive (like restructuring), and we have to ensure that they are done in lockstep between CrsMatrix and CrsGraph.
  For example, I can't move CrsMatrix data from 1D (non-packed) to 1D (packed) without the rowptrs, so I can't let CrsGraph do its restructuring in such a way that they are
  destroyed before CrsMatrix can use them. There are a couple of ways to handle that:
  a) grab the ArrayRCP to the old rowptrs
  b) let CrsGraph do its restructuring
  c) grab the ArrayRCP to the new rowptrs
  d) have CrsMatrix do its restructuring, then release to old pointers (which are then deallocated)
  There's nothing wrong with this approach; this is how Epetra does it. 
  Because the work is duplicated and dependent on the implementation in CrsGraph, we just put it all there, so that changes are made in one place (technically, two nearby places).

************************************************************

Allocation routines in Kokkos Graph objects

I wasn't sure where the allocation routines supporting thread appropriate allocation (first-touch, pinning) should go: localmatops or kokkos::graph. 
I chose the latter, thinking it would allow allocation strategy to be change for a mat-vec and supporting some minor amount of state. This can be revisited.

************************************************************

Template parameters on classes

While there are necessarily some template parameters in classes, there are not template parameters classes, and therefore no obligation that the classes are template. 
The reason is that we don't want to specify the number and nature of these, so we can't use them, so we should require them.

The local mat ops as specified to graph is stripped of scalar type, in order to allow it to be used with different T::CrsMatrix objects without additional templating. 
Therefore, we pass these around with no Scalar parameter, and then bind the scalar in the CrsMatrix.

We make little requirements on SparseOps objects: they should be able to finalize the type of graphs and matrices that they accept, though these static methods may do more.

Given a sparse object SOBASE, we should enjoy the following:
  SOBASE::bind_scalar<S1>::graph<O,N>::graph_type  
is the same as  
  SOBASE::bind_scalar<S2>::graph<O,N>::graph_type

and also

  SOBASE::bind_scalar<S1>::other_type
is the same as
  SOBASE::bind_scalar<S2>::bind_scalar<S1>::other_type

************************************************************

* Kokkos::Crs{Matrix,Graph}::finalize(bool)
  Before, CrsGraph and CrsMatrix had methods for setting the data, then a separate method called finalize() which accepted an OptimizeStorage boolean. 
  I'm leaving finalize() in there for the moment, as a pure virtual function, to be over-ridden by base classes.
  Another reason is that there may be some value in separating the set-data and the finalization. 
  I removed the OptimizeStorage argument from finalize(), but I replaced it with a ParameterList.
* Kokkos::Crs{Matrix,Graph} and protected data.
  Notice, no protected members. They're a bad idea, ripe for abuse, and an indication of design laziness. 
  In a scenario where we are going to be publishing this interface and pushing it out to external devs, we should make this one bulletproof.
* How to finalize() graph and matrix at the same time? No direct support; that case is covered by a specific LocalMatOps.

************************************************************

What things are for, and why they are the way they are

* Kokkos::Crs{Matrix,Graph}::clear()
  Need a way for the subclass to clear the parent data after it is no longer needed.
  Maybe setStructure(null,null) is the solution instead.
  Nevermind, killed it. We are now pure virtual. Let's see how that works out for now.

* CrsGraph::getNumEntries() is for CrsMatrix::setValues() to check validity.

************************************************************

Graph and Matrix are separate objects to allow multiple matrices for one graph, which reflects Tpetra design.
SparseOps is an object to allow state preservation.

1. Data is submitted to Graph and Matrix, then they are submitted to SparseOps.
2. Graph has a finalize() method so that it can be finalized in the absence of a matrix.

These support the graph first, then matrix/ces paradigm.

Tpetra uses no finalize method on Matrix.

************************************************************

Const correctness and Proper encapsulation

No protected if not necessary; strongly prefer private.
Const correctness to enforce semantics wherever we can. This keeps developers from making bugs.

************************************************************

Generic vs. Inheritence 

If Tpetra uses static typedef to determine local Matrix and Graph types, why bother with virtual?
There is no code re-use.

How about, local mat ops is a factory for objects derived from abstract CrsGraph and CrsMatrix?
:( But then we have a dynamic cast when we fill the sparse mat-vec object. 

Then we go fully generic? 
:( Ugly compile errors.
:) But abstract base class informs what is expected of us; inheriting from that guarantees that we compile.

************************************************************

Finalizing use case:

A)
  1) Tpetra::CrsGraph constructs a lclGraph
  2) Tpetra::CrsMatrix constructs a lclMatrix(lclGraph)
  ...
  3) Tpetra::CrsGraph calls lclGraph->finalize(), which may do something but should keep in mind that a call with a matrix will follow.
  ...
  4) Tpetra::CrsMatrix A calls lclGraph->finalize(A::lclMatrix), which will do whatever needs to be done to A::lclMatrix
  ...
  5) Tpetra::CrsMatrix B calls lclGraph->finalize(B::lclMatrix), which will do whatever needs to be done to B::lclMatrix

B) 
  1) Tpetra::CrsGraph constructs a lclGraph
  2) Tpetra::CrsMatrix constructs a lclMatrix(lclGraph)
  ... 
  3) Tpetra::CrsMatrix calls lclGraph->finalize(lclMatrix), which will do everything

************************************************************

Empty matrices 

This is something that popped up and seemed necessary, probably having to do with zero-row objects and null vectors. 
I can't remember. Maybe I should delete it, see if it asserts it existence again. But I didn't.
But I think the reason is that, even if the matrix has some non-zero number of rows, it may have no entries, with an empty column map.

************************************************************

SpMV and transpose

Add some unrolling of numRHS.

We can optionally do a better job by telling finalize() that the tranpose will be needed, and should be explicitly formed.
Then calling a cscmm in the case that it was. This is a parameter list argument to the Tpetra::CrsMatrix (sublist "Local Fill")

************************************************************

Items that specifically need review:
 * kokkos/LinAlg/Kokkos_DefaultSparseMultiplyKernelOps.hpp

************************************************************

Finalize: something is up here: i need to figure out whether finalize happens only in the graph or in the matrix as well.

okay, matrix has only a const graph, so it can't necessarily call the appropriate finalizer
so, no finalize() on matrix, though it still has a isFinalized()

T::M -> grab either const or non-const K::G, then call either finalizeMatrix or finalizeGraph, as appropriate
     or pass K::M to T::G and let T::G do the right thing.

************************************************************

deprecate T::G and T::M::fillComplete(bool) for PL

************************************************************
