 \documentclass[12pt,relax]{AztecOOUserGuide}
 \usepackage{fancyvrb}
\SANDsubtitle{}
\title{\AztecOOTM{} User Guide}

\author{Michael A. Heroux \\
	\\
	    Sandia National Laboratories\\
	    P.O. Box 5800\\
	    Albuquerque, NM 87185-1110 
	 }

    % There is a "Printed" date on the title page of a SAND report, so
    % the generic \date should generally be empty.
    \date{} % Remove ``\today'' in final version


\SANDnum{SAND2003-xxxx}
\SANDprintDate{Printed September 2003}
\SANDauthor{Michael A. Heroux \\
	Computational Mathematics and Algorithms Department \\
	 Sandia National Laboratories \\
	P.~O.~Box 5800 \\
	Albuquerque, NM 87185-1110}


\SANDreleaseType{Unlimited Release}


% New commands
\newcommand{\Az}  {{\bf Aztec}}
\newcommand\R     {{\rm \bf R}}
\newcommand\I     {{\rm \bf I}}
\newcommand\C     {{\rm \bf C}}

%
% define boxes for describing variables, etc
%

\def\optionbox#1#2{\noindent$\hphantom{hix}${\parbox[t]{2.10in}{\it #1}}{\parbox[t]{3.9in}{#2}} \\[1.1em]}

\def\choicebox#1#2{\noindent$\hphantom{hixthere}$\parbox[t]{2.10in}{\sf #1}\parbox[t]{3.5in}{#2}\\[0.8em]}

\def\structbox#1#2{\noindent$\hphantom{hix}${\parbox[t]{2.10in}{\it #1}}{\parbox[t]{3.9in}{#2}} \\[.02cm]}

\def\in{\hskip .2in \=}
\def\hsp{\hskip .4in \=}
\def\sp{\hskip .18in \=}
\def\sh{\hskip .18in }
\def\bb{\hskip .034in }
\def\lil{\hskip .1in }


\def\protobox#1{\vspace{2em}{\flushleft{\bf Prototype}
\hrulefill}\flushleft{\fbox{\parbox[t]{6in}{\vspace{1em}{\sf #1}\vspace{1em}}}}}

\newcommand{\comm}{Epetra\_Comm}
\newcommand{\serialcomm}{Epetra\_SerialComm}
\newcommand{\mpicomm}{Epetra\_MpiComm}
\newcommand{\mpismpcomm}{Epetra\_MpiSmpComm}
\newcommand{\lbcomm}{Epetra\_LbComm}
\newcommand{\map}{Epetra\_Map}
\newcommand{\blockmap}{Epetra\_BlockMap}
\newcommand{\serialdensevector}{Epetra\_SerialDenseVector}
\newcommand{\intserialdensevector}{Epetra\_IntSerialDenseVector}
\renewcommand{\vector}{Epetra\_Vector}
\newcommand{\multivector}{Epetra\_MultiVector}
\newcommand{\crsgraph}{Epetra\_CrsGraph}
\newcommand{\crsmatrix}{Epetra\_CrsMatrix}
\newcommand{\vbrmatrix}{Epetra\_VbrMatrix}
\newcommand{\rowmatrix}{Epetra\_RowMatrix}
\newcommand{\distobject}{Epetra\_DistObject}
\newcommand{\linearproblem}{Epetra\_LinearProblem}
\newcommand{\operator}{Epetra\_Operator}
\newcommand{\fecrsmatrix}{Epetra\_FECrsMatrix}
\newcommand{\fevbrmatrix}{Epetra\_FEVbrMatrix}
\newcommand{\msrmatrix}{Epetra\_MsrMatrix}
\newcommand{\statustest}{AztecOO\_StatusTest}
\newcommand{\oooperator}{AztecOO\_Operator}


\begin{document}
\maketitle

\begin{abstract}

The \TrilinosTM{} Project is an effort to facilitate the design, development,
integration and ongoing support of mathematical software libraries.
\AztecOOTM{} is a package within Trilinos that enables the use of the Aztec solver 
library~\cite{Aztec2.1} with \EpetraTM{}~\cite{Epetra-Users-Guide} objects.  
AztecOO provides access to Aztec preconditioners and solvers by
implementing the Aztec ``matrix-free'' interface using Epetra.
While Aztec is written in C and procedure-oriented, 
AztecOO is written in C++ and is object-oriented.

In addition to providing access to Aztec capabilities, AztecOO also
provides some signficant new functionality.  In particular it provides
an extensible status testing capability that allows expression of
sophisticated stopping criteria as is needed in production use of
iterative solvers.  AztecOO also provides mechanisms for using 
Ifpack~\cite{Ifpack-Ref-Guide}, ML~\cite{ML-home-page} and AztecOO
itself as preconditioners.
\end{abstract}


\section*{Acknowledgement}
The authors would like to acknowledge the support of the ASCI and LDRD 
programs that funded development of AztecOO and the authors of Aztec
2.1 upon which AztecOO is built: Ray Tuminaro, Mike Heroux, Scott
Hutchinson and John Shadid.  

\clearpage
\tableofcontents
\listoffigures
\listoftables

\clearpage


NOTE: Add section on repeated use of AztecOO objects.


\section{Introduction}
\label{Section:Introduction}

AztecOO is a collection of C++ classes that support the construction
and use of objects for solving linear systems of equations via
preconditioned Krylov methods, as provided in Aztec.

This user guide is intended to (i) introduce a new
user to the basic features of AztecOO, (ii) discuss the details of AztecOO
constructors, and (iii) illustrate the use of
AztecOO's advanced uses.  This document is not intended as a reference
manual.  Detailed descriptions of AztecOO classes and methods can be
found online at the Trilinos Project home page~\cite{Trilinos-home-page}.


\subsection{Overview of Major AztecOO Classes and Features}

AztecOO contains a variety of classes to support the solution of
linear systems of equations of the form $Ax=b$ using preconditioned
iterative methods.  AztecOO also fully contains Aztec, so any application
that is using Aztec can use the AztecOO library in place of Aztec.  

The primary AztecOO class is of the same name, AztecOO.  An AztecOO
class instance acts as a manager of Aztec, accepting user data as
Epetra objects.  If an AztecOO object is instantiated using Epetra
objects, all of Aztec's preconditioners and Krylov methods can be
applied to the Epetra-defined problem.  However, AztecOO provides a
variety of mechanisms to override default Aztec capabilities.  Users
can construct and use preconditioners from Ifpack or ML, or can use
another instance of the AztecOO class as a preconditioner.  Users can
also override the default convergence tests in Aztec and use any
combination of available status tests in \statustest{} classes,
or define their own.

\subsection{Use of Epetra}

AztecOO relies on Epetra for both concrete and abstract classes that
describe matrix, vector and linear operator objects.  
Although  concrete classes are needed to construct matrices, AztecOO
itself uses these matrices via two Epetra abstract classes.  By using
abstract interfaces, we can support any of the predefined classes that
implement the abstract interfaces and allow users to define
new implementations.  This allows AztecOO
to be easily extended.  

\subsubsection{Epetra Abstract Classes}

The two primary abstract Epetra classes used by AztecOO are:
\begin{enumerate}
\item {\bf \rowmatrix{}: } Supports the use of any class that is
conceptually a linear operator with access to coefficient data.
Although row-orientation is assumed, this class works equally well
with column oriented data, since transpose operations are supported.  
This class provides an interface to access matrix data.  In addition,
it extends the \operator{} interface, so any class that implements
\rowmatrix{} also implmenents \operator{}, described next.  There are
four primary classes in Epetra that implement \rowmatrix{}, namely 
the \crsmatrix{}, \vbrmatrix{}, \fecrsmatrix{} and \fevbrmatrix{}
classes.  AztecOO also provides an implementation of \crsmatrix{}
called \msrmatrix{}.  \msrmatrix{} allows users whose application is
already forming Aztec DMSR matrix structs to encapsulate the DMSR
matrix in a class that implements \rowmatrix.  The encapsulation does
not copy the data in the DMSR matrix struct.  This feature is
important for people making a transition from Aztec to AztecOO.
\item {\bf \operator{}: } Supports the use of any class that is
conceptually a linear operator.  There are only a handful of methods
in this class, the most important of which are the Apply() and
ApplyInverse() (ApplyInverse() can be defined as nonexistent).  
A large number of Epetra classes implement the
\operator{} interface, including the \crsmatrix{}, \vbrmatrix{},
\fecrsmatrix{} and \fevbrmatrix{} since these classes implement
\rowmatrix{} and \rowmatrix{} extends \operator{}.  In addition, ML
and IFPACK both implement the \operator{} interface, so they can be
used as preconditioners for AztecOO.  A class called \oooperator{}
also implements the \operator{} interface using an existing AztecOO
class instance.  This allows AztecOO to be used as a preconditioner
for itself.

\end{enumerate}

\subsubsection{Epetra Concrete Classes}

Given the above abstract classes, we need some concrete classes in
order to construct explicit objects.  Specifically,
the following concrete Epetra classes are used:
\begin{enumerate}
\item {\bf \vector{}: } Supports construction and use of distributed
vectors of double-precision numbers.  Once constructed, \vector{}
objects can be used in multiple ways.  Common operations such as
norms, dot products and vector updates are supported by methods in
this class.  Additional functionality is available via several
extension techniques discussed later.
\item{\bf \multivector{}: } An \multivector{} object is a collection
of \vector{} objects (although \vector{} is actually implemented as a
specialization of \multivector{}).  Specifically, an \multivector{}
object is a collection of vectors with the same size and
distribution.  This kind of object is useful for block algorithms and
applications that manage multiple vectors simultaneously.  \vector{}
and \multivector{} objects are understood by all Trilinos packages.
\item{\bf \crsgraph{}:} Supports the construction and use of adjacency
graphs.  These graphs are used to describe the pattern of Epetra
sparse matrix classes and provide pattern-based information to
load-balancing interfaces.  The graphs are also used to implement
overlapping subdomain algorithms and a variety of other parallel
algorithms.
\item{\bf \crsmatrix{}:} Supports construction and use of distributed
sparse matrix objects.  Once constructed, an \crsmatrix{} object can
be used with any Trilinos solvers or preconditioners.  This class also
supports common matrix and matrix-vector operations such as matrix
scaling, matrix norms and matrix-vector multiplication.
\item{\bf \fecrsmatrix{}:} This class inherits from \crsmatrix,
providing an interface to construct the matrix from element stiffness
matrices.  Once constructed, this matrix can be used as an \crsmatrix{}.
\item{\bf \vbrmatrix{}:} Although less frequently used than the
\crsmatrix{} class, this class supports the construction of sparse
matrices whose entries are dense matrices.  This type of matrix is
frequently found in applications where multiple degrees of freedom are
tracked at each mesh point.  When properly used, the \vbrmatrix{}
class can offer substantial machine performance and algorithmic
robustness improvements.
\item{\bf \fevbrmatrix{}:} This class inherits from \vbrmatrix,
providing an interface to construct the block matrix from element stiffness
matrices.  Once constructed, this matrix can be used as an \vbrmatrix{}.
\item{\bf \msrmatrix{}:} Although not part of Epetra, we list this
class here because it is a viable option for existing Aztec users.
An \msrmatrix{} object is constructed by passing in an existing
AZ\_MATRIX struct defining a DMSR matrix as described in the Aztec 2.1
User's Guide~\cite{Aztec2.1}. Given the matrix data in this form, the
\msrmatrix{} class implements the \rowmatrix{} interface using the
DMSR matrix with little extra storage required.  This class is useful
if an existing Aztec user has already constructed a DMSR matrix.
\item{\bf \linearproblem{}:} An \linearproblem{} object is an
aggregate object that encapsulates the problem $Ax=b$.  It contains a
pointer to an \rowmatrix{} or \operator{} representing $A$, and an 
\multivector{} for $x$ and another for $b$.  (NOTE:  Although the
interface supports multiple right-hand-sides and solution vectors,
AztecOO presently supports the solution of only one right-hand-side.)
Although use of the \linearproblem{} is not required for passing $A$,
$x$ and $b$ to AztecOO, it is highly recommended.  Use of
\linearproblem{} guarantees that the matrix, left-hand-side and
right-hand-side are compatible.  Also, the \linearproblem{} class
provides methods for scaling the linear problem using any of a variety
of diagonal scaling methods.
\end{enumerate}




\section{A First Example}
\label{Section:FirstExample}
Before proceeding with additional descriptive information, we
introduce a simple example in this section in order to explicitly
illustrate a straight-forward use of AztecOO.  This specific example
constructs a tridiagonal matrix and a random RHS vector.  Then it
constructs an AztecOO object, sets a few parameters for the solver and
then solves the problem.

The example code is listed in Figure~\ref{Figure:FirstExample}.  
In the remainder of this section we proceed with a
description of the code.
\begin{figure}
\begin{center}
\input{Ex1}
\end{center}
\caption{\label{Figure:FirstExample} Simple AztecOO/Epetra Example}
\end{figure}

\subsection{Explanation of Figure~\ref{Figure:FirstExample}}

\paragraph{Line 1}
Include the AztecOO\_config.h file.  This file contains macros
definitions that were defined during the configuration process.  In
particular, the macro HAVE\_MPI will be defined or undefined in this
file, depending on whether AztecOO was built in MPI mode or not.  We
will use HAVE\_MPI below to determine if our example code should be
compiled with MPI support or not.
\paragraph{Lines 2--7}
Include the appropriate implementation of the \comm{} class.  If
AztecOO was built in MPI mode, the macro ``HAVE\_MPI'' will be defined
and this example will be built with MPI support.  If not, then the
example will be built in serial mode.  Note that these lines of code,
lines 15--20 and lines 60--62 are the only difference between a serial
and distributed memory version of the example. 
\paragraph{Lines 8--11}
Include the other necessary Epetra and AztecOO header files.
It is a good practice to explicitly include header files for all
classes you explicitly use, and only those header files.
\paragraph{Line 13}
Start of main program.
\paragraph{Lines 15--21}
Depending on whether or not AztecOO was built in MPI
mode\footnote{Whether or not Trilinos, and AztecOO as a Trilinos package, is built
in MPI mode is determined by how the Trilinos (or AztecOO) {\tt
configure} script in invoked.  If no MPI-related arguments are passed
to the configure script, then packages are built in serial mode only.
If one or more MPI options are invoked, then packages are built with
MPI support (in addition to serial support).}, MPI will be initialized
and an \mpicomm{} object will be constructed, or an \serialcomm{}
object will be constructed.  Please note that, in principle, the serial
version of this example would work, even if AztecOO were built in MPI
mode.  Serial mode is always available.  Line 21 prints the \comm{} 
object to cout.
\paragraph{Line 23}
Define the local problem dimension.  NumMyElements will be used to
define an \map{} that has 100 elements on each processor.  In turn the
map will be used to construct vectors with 100 entries on each
processor and matrices with 100 rows on each processor.
\paragraph{Lines 24--25}
Constructs an \map{} object that has NumMyElements elements spread
across the parallel (or serial) machine.  The first argument indicates
that we are not specifying the global number of elements, but allowing
the \map{} constructor to compute it as the sum of
NumMyElements defined on each calling processor.  The second argument
is the number of elements assigned to the calling processors.  The
third argument (a
``0'') indicates that our global indices are zero-based.  Fortran
users would typically pass in a ``1'' here.  The fourth argument is the
Comm object we just built.
\paragraph{Line 26}
Once an \map{} object is constructed, we can query it for how many total
elements are in the map\footnote{For readers
who are not familiar with a single-program, multiple data (SPMD)
programming model, it may be useful to read a bit about it.  Typing
``SPMD tutorial'' into a web search engine should be a sufficient
starting point.}.  In this way, the remainder of our code can operate
independent of how data is distributed.
\paragraph{Line 29}
Instantiates (creates) an \crsmatrix{}.  The first argument tells the
constructor whether or not data passed in to this object should be
copied (user values and indices will be copied to internal storage) or
viewed (user values and indices will be pointed to by this object and
the user {\it must} guarantee the integrity of that data).  View mode
is available across many Epetra classes.  In general, this is a very
dangerous practice.  However, in certain very important situations, it
is essential to have this mode.  This is especially true when using
Epetra with Fortran, or when accepting matrix data from other parts of
application where it is too expensive to replicate the data storage.

The second argument is the \map{} object we just constructed.  The
third argument is an advisory value telling the constructor
approximately how many nonzero values will be defined for each row of
the matrix\footnote{getting this value wrong does not
affect the correctness of results, but may affect performance and
efficient use of memory}.  We are constructing a tridiagonal matrix, 
so the value ``3'' is appropriate.

At this point the matrix is an empty ``bucket'' ready to receive
matrix values and indices.  Also, at this point, most of the methods
in the \crsmatrix{} cannot be called successfully for this object.
\paragraph{Lines 31--43}
These lines insert values and indices into the matrix we just
instantiated.  Our matrix is tridiagonal with a value of 2 at each
diagonal and -1 on the immediate off-diagonals.  We do not go into
detail about the methods called here.  The reader should look at the
Epetra User Guide~\cite{Epetra-User-Guide} or the online reference
material at the Trilinos home page~\cite{trilinos-home-page}.
\paragraph{Lines 45--48}
Once the matrix is constructed, we create our vectors b and x using
the same map that determined the layout of the matrix rows.  We also
fill b with random values (line 48).
\paragraph{Lines 50--53}
Now that A, x and b are formed, we can define a linear problem
instance.  This object will in turn be used to define an AztecOO
instance.  Note that it is possible to construct AztecOO objects in
other ways, but we strongly recommend use of the constructor shown in
line 53.  Note that when the AztecOO object is constructed, the
parameter and option values listed in
Section~\ref{sect:OptionsAndParams} will be set to their default
values.  These defaults can be changed by calling the SetAztecOption()
and SetAztecParam() methods.
\paragraph{Lines 55--56}
Once the solver object is instantiated, we change the value of
AZ\_precond to AZ\_Jacobi.  Note that the key/value pairs passed in to
this method can be any valid pair as defined in
Section~\ref{sect:OptionsAndParams}.  Next we call the Iterate()
method, passing in the maximum number of iterations that can be
performed and a tolerance that should be used to test for
convergence.  Depending on the values of the Aztec parameters and
options, this method will attempt to solve the problem using the
prescribed preconditioner (if any) and the specified iterative
method.  It will also print intermediate results if the user has
requested them.  Upon exit from this method, the problem will
hopefully be solved and the solution will be in x which in turn is
part of the linear problem instance.  Also upon exit, a number of
methods can be called to determine the results of the iterations.
\paragraph{Lines 58--59}
Print results from calling the solver.
\paragraph{Lines 60--62}
If our code was compile in MPI mode, we need to call MPI\_Finalize()
for proper clean up.
\paragraph{Line 64} Program exit.

\section{Aztec Options and Parameters}

Because AztecOO is fundamentally a wrapper around Aztec, much of the
control and selection of solver options and parameters is done via two
method calls that set Aztec options and parameters, namely
SetAztecOption() and SetAztecParam().  Most of the
options and parameters are identical to those found in Aztec 2.1.
However, there are a number of new options and parameters.  Below we
list all options and parameters, including the default value and
description of each.

\subsection{Aztec Options\label{optionI}}

\vspace{2em}
{\flushleft{\bf Specifications} \hrulefill}
\nopagebreak \\[0.5em]
%
\optionbox{options[{\sf AZ\_solver}]}{Specifies solution
  algorithm. DEFAULT: \sf AZ\_gmres.}
\choicebox{AZ\_cg}{Conjugate gradient (only
  applicable to symmetric positive definite matrices).}
\choicebox{AZ\_gmres}{Restarted generalized minimal residual.}
\choicebox{AZ\_cgs}{Conjugate gradient squared.}
\choicebox{AZ\_tfqmr}{Transpose-free quasi-minimal residual.}
\choicebox{AZ\_bicgstab}{Bi-conjugate gradient with
  stabilization.}
\choicebox{AZ\_lu}{Sparse direct solver (single processor only).}
%
\optionbox{options[{\sf AZ\_scaling}]}{Specifies scaling algorithm.
  The entire matrix is scaled (overwriting the old
  matrix). Additionally, the right hand side, the initial guess and
  the final computed solution are scaled if necessary. For 
  symmetric scaling, this transforms $ A x = b$ into
  $ S A S y = S b $ as opposed to $ S A x = S b $ when symmetric
  scaling is not used. NOTE: The residual within \Az{} is now 
  given by $ S (b - A x) $. Thus, residual printing and convergence
  checking are effected by scaling.  DEFAULT: \sf
  AZ\_none.}
%
\choicebox{AZ\_none}{No scaling.}
\choicebox{AZ\_Jacobi}{Point Jacobi scaling.}
\choicebox{AZ\_BJacobi}{Block Jacobi scaling where the block
  size corresponds to the VBR blocks.  Point Jacobi scaling is
  performed when using the MSR format.}
\choicebox{AZ\_row\_sum}{Scale each row so the magnitude of its
  elements sum to 1.}
\choicebox{AZ\_sym\_diag}{Symmetric scaling so diagonal elements
  are 1.}
\choicebox{AZ\_sym\_row\_sum}{Symmetric scaling using the matrix
  row sums.}
%
\optionbox{options[{\sf AZ\_precond}]}{Specifies preconditioner.
  DEFAULT: \sf AZ\_none.}
\choicebox{AZ\_none}{No preconditioning.}
\choicebox{AZ\_Jacobi}{$k$ step Jacobi (block Jacobi for DVBR matrices
  where each block corresponds to a VBR block). The number of
  Jacobi steps, $k$, is set via {\it options}[{\sf AZ\_poly\_ord}].}
\choicebox{AZ\_Neumann}{Neumann series polynomial
  where the polynomial order is set via
  {\it options}[{\sf AZ\_poly\_ord}].}
\choicebox{AZ\_ls}{Least-squares polynomial
  where the polynomial order is set via
  {\it options}[{\sf AZ\_poly\_ord}].}
\choicebox{AZ\_sym\_GS}{Non-overlapping domain decomposition
  (additive Schwarz)
  $k$ step symmetric Gauss-Siedel.
  In particular, a symmetric Gauss-Siedel domain decomposition
  procedure is used where each processor independently
  performs one step of
  symmetric Gauss-Siedel on its local matrix, followed by communication
  to update boundary values before the next local symmetric
  Gauss-Siedel step. The number of steps, $k$, is set via
  {\it options}[{\sf AZ\_poly\_ord}].}
\choicebox{AZ\_dom\_decomp}{Domain decomposition preconditioner
  (additive Schwarz). That is, each processor augments
  its submatrix according to {\it options}[{\sf AZ\_overlap}]
  and approximately ``solves'' the resulting subsystem 
  using the solver specified by \\
  $\hphantom{using the solr}$
  {\it options}[{\sf AZ\_subdomain\_solve}].\\
  Note: {\it options}[{\sf AZ\_reorder}] determines whether
  matrix equations are reordered (RCM) before ``solving'' submatrix problem.}
\optionbox{options[{\sf AZ\_subdomain\_solve}]}{Specifies the solver
  to use on each subdomain when {\it options}[{\sf AZ\_precond}] is set
  to {\sf AZ\_dom\_decomp} DEFAULT: \sf AZ\_ilut.}
\choicebox{AZ\_lu}{Approximately solve processor's submatrix via
  a sparse LU factorization in conjunction with a drop tolerance 
  {\it params}[{\sf AZ\_drop}]. The current sparse
  lu factorization is provided by the package y12m~\cite{y12m}.}
\choicebox{AZ\_ilut}{Similar to {\sf AZ\_lu} using
  Saad's {\sf ILUT} instead of LU \cite{ilut}. The drop 
  tolerance is given by {\it params}[{\sf AZ\_drop}]
  while the fill-in is given by {\it params}[{\sf AZ\_ilut\_fill}]. }
\choicebox{AZ\_ilu}{Similar to {\sf AZ\_lu} using
  {\sf ilu(k)} instead of LU with k determined by 
  {\it options}[{\sf AZ\_graph\_fill}]}
\choicebox{AZ\_rilu}{Similar to {\sf AZ\_ilu} using
  {\sf rilu(k,$\omega$)} instead of {\sf ilu(k)}
  with $\omega$ ($0 \ge \omega \ge 1$) given by {\it params}[{\sf AZ\_omega}]
  \cite{milu}.}
\choicebox{AZ\_bilu}{Similar to {\sf AZ\_ilu} using block
  {\sf ilu(k)} instead of {\sf ilu(k)} where each block corresponds
  to a VBR block.}
\choicebox{AZ\_icc}{Similar to {\sf AZ\_ilu} using
  {\sf icc(k)} instead of {\sf ilu(k)} \cite{icc}.}
%
\optionbox{options[{\sf AZ\_conv}]}{Determines the residual expression used
  in convergence checks and printing.  DEFAULT: {\sf AZ\_r0}.
  The iterative solver terminates if the corresponding residual expression
  is less than {\it params}[{\sf AZ\_tol}]:}
\choicebox{AZ\_r0}{$\|r\|_2 / \|r^{(0)}\|_2 $}
\choicebox{AZ\_rhs}{$\|r\|_2 / \|b\|_2 $}
\choicebox{AZ\_Anorm}{$\|r\|_2 / \|A\|_{\infty} $}
\choicebox{AZ\_noscaled}{$\|r\|_2$}
\choicebox{AZ\_sol}{$\|r\|_{\infty}
  /(\|A\|_{\infty} * \|x\|_1 + \|b\|_{\infty}) $}
\choicebox{AZ\_weighted}{$\|r\|_{WRMS} $\\
  where $\| \cdot \|_{WRMS} = \sqrt{(1/n) \sum_{i=1}^n (r_i/w_i)^2}$,
  $n$ is the total number of unknowns, $w$ is a weight
  vector provided by the
  user  via {\it params}[{\sf AZ\_weights}] and
  $r^{(0)}$ is the initial residual.}
%
\optionbox{options[{\sf AZ\_output}]}{Specifies information (residual
  expressions - see {\it options}[{\sf AZ\_conv}]) to be printed.
  DEFAULT: \sf 1.}
\choicebox{AZ\_all}{Print out the matrix and indexing vectors for
  each processor. Print out all intermediate residual expressions.}
\choicebox{AZ\_none}{No intermediate results are printed.}
\choicebox{AZ\_warnings}{Only Aztec warnings are printed.}
\choicebox{AZ\_last}{Print out only the final residual expression.}
\choicebox{$>$ 0}{Print residual expression every {\it
    options[{\sf AZ\_output}]\/} iterations.}
%
\optionbox{options[{\sf AZ\_pre\_calc}]}{Indicates whether to use
  factorization information from previous calls to {\sf AZ\_solve}.
  DEFAULT: {\sf AZ\_calc}.}
\choicebox{AZ\_calc}{Use no information from previous {\sf
    AZ\_solve} calls.}
\choicebox{AZ\_recalc}{Use preprocessing information from a
  previous call but recalculate preconditioning factors. This is
  primarily intended for factorization software which performs a
  symbolic stage.}
\choicebox{AZ\_reuse}{Use preconditioner from a previous
  {\sf AZ\_solve} call, do not recalculate preconditioning factors.
  Also, use scaling factors from previous call to scale the
  right hand side, initial guess and the final solution.}
%
%
\optionbox{options[{\sf AZ\_graph\_fill}]}{The level of graph fill-in (k)
  for incomplete factorizations: ilu(k), icc(k), bilu(k).
  DEFAULT: 0}
%
\optionbox{options[{\sf AZ\_max\_iter}]}{Maximum number of iterations. DEFAULT:
  500.}
%
\optionbox{options[{\sf AZ\_poly\_ord}]}{The polynomial order when using
  polynomial preconditioning.  Also, the number of steps when using Jacobi or
  symmetric Gauss-Seidel preconditioning.  DEFAULT: 3.}
%
\optionbox{options[{\sf AZ\_overlap}]}{Determines the submatrices factored with
  the domain decomposition algorithms (see {\it options}[{\sf AZ\_precond}]).
  DEFAULT: 0.}
%
%\choicebox{AZ\_none}{Factor the local submatrix defined on this processor
%  by discarding column entries that correspond to external elements.}
%
\choicebox{AZ\_diag}{Factor the local submatrix defined on this processor
  augmented by a diagonal (block diagonal for VBR format) matrix. This diagonal
  matrix corresponds to the diagonal entries of the matrix rows (found on other
  processors) associated with external elements.  This can be viewed as taking
  one Jacobi step to update the external elements and then performing domain
  decomposition with {\sf AZ\_none} on the residual equations.}
%
\choicebox{k}{Augment each processor's local submatrix with
  rows from other processors. The new rows are obtained in k 
  steps (k $\ge$ 0). Specifically at each augmentation step,
  rows corresponding to external unknowns are obtained. These
  external unknowns are defined by nonzero columns in the 
  current augmented matrix not containing a corresponding
  row on this processor. After the k steps, all columns 
  associated with external
  unknowns are discarded to obtain a square matrix.
  The resulting procedure is an overlapped additive Schwarz
  procedure.}
%
\optionbox{options[{\sf AZ\_type\_overlap}]}{Determines how overlapping
    subdomain results are combined when different processors
    have computed different values for the same unknown.
    DEFAULT: \sf AZ\_standard.}
\choicebox{AZ\_standard}{The resulting value of an unknown is 
    determined by the processor owning that unknown. Information
    from other processors about that unknown is discarded.}
\choicebox{AZ\_symmetric}{Add together the results obtained from different
    processors corresponding to the same unknown. This keeps the 
    preconditioner symmetric if a symmetric technique was used on
    each subdomain.}
%
\optionbox{options[{\sf AZ\_kspace}]}{Krylov subspace size for
  restarted GMRES.\\
  DEFAULT: 30.}
%
\optionbox{options[{\sf AZ\_reorder}]}{Determines whether RCM reordering
  will be done in conjunction with domain decomposition incomplete 
  factorizations. 1 indicates RCM reordering is used. 0 indicates that
  equations are not reordered.  DEFAULT:~1.}
%
\optionbox{options[{\sf AZ\_keep\_info}]}{Determines whether matrix
  factorization information will be kept after this solve (for example
  to solve the same system with another right hand side, see 
  {\it options}[{\sf AZ\_pre\_calc}]).  1 indicates factorization 
  information is kept.  0 indicates that factorization information is
  discarded.  DEFAULT: 0.}
%
\optionbox{options[{\sf AZ\_orthog}]}{GMRES orthogonalization scheme.\\
  DEFAULT: {\sf AZ\_classic}.}
\choicebox{AZ\_classic}{2 steps of classical Gram-Schmidt orthogonalization.}
\choicebox{AZ\_modified}{Modified Gram-Schmidt orthogonalization.}
%
\optionbox{options[{\sf AZ\_aux\_vec}]}{Determines $\tilde r$ (a required
  vector within some iterative methods). The convergence behavior varies
  slightly depending on how this is set.  DEFAULT: \sf AZ\_resid.}
\choicebox{AZ\_resid}{$\tilde r$ is set to the initial residual vector.}
\choicebox{AZ\_rand}{$\tilde r$ is set to random numbers between -1 and 1.
  NOTE: When using this option, the convergence depends on the number of
  processors (i.e. the iterates obtained with x processors differ from the
  iterates obtained with y processors if x $\ne$ y).}  $\hphantom{h}$
\subsection{\Az{} parameters\label{optionD}}

The double precision array {\it params\/} set by the user and normally of
length {\sf AZ\_PARAMS\_SIZE}. However, when a weight vector is needed for the
convergence check (i.e. {\it options}[{\sf AZ\_conv}] = {\sf AZ\_weighted}), it
is embedded in {\it params\/} whose length must now be {\sf AZ\_PARAMS\_SIZE} +
\# of elements updated on this processor.  In either case, the contents of {\it
  params\/} are used (but not altered) by the function {\sf AZ\_solve} to
control the behavior of the iterative methods.  The array elements are
specified as follows: \vspace{2em}
{\flushleft{\bf Specifications} \hrulefill} \nopagebreak \\[0.5em]
%
\optionbox{params[{\sf AZ\_tol}]}{Specifies tolerance value used in
   conjunction with convergence tests. DEFAULT: $10^{-6}$.}
\optionbox{params[{\sf AZ\_drop}]}{Specifies drop tolerance used in
   conjunction with LU  or ILUT preconditioners (see description
   below for ILUT). \\ DEFAULT: 0.0.}
\optionbox{params[{\sf AZ\_ilut\_fill}]}{ ILUT uses two criteria for
   determining the number of nonzeros in the resulting approximate
   factorizations. For examples, setting {\it params}[{\sf AZ\_ilut\_fill}]
   $ = 1.3 $, requires that the ILUT factors contain no more than
   approximately 1.3 times the number of nonzeros of the original matrix.
   Additionally, ILUT drops all elements in the resulting factors that are
   less than {\it params}[{\sf AZ\_drop}]. Thus, when
   {\it params}[{\sf AZ\_drop}] is set to zero, nothing is dropped and the
   size of the matrix factors is governed only by {\it params}[{\sf AZ\_ilut\_fill}].
   However, positive values of {\it params}[{\sf AZ\_drop}] may result in
   matrix factors containing significantly fewer nonzeros. \cite{ilut} \\
   DEFAULT: 1.}
\optionbox{params[{\sf AZ\_omega}]}{Damping or relaxation parameter used
   for RILU. When {\it params}[{\sf AZ\_omega}] is set to zero, RILU
   corresponds to ILU(k). When it is set to one, RILU corresponds to
   MILU(k) where k is given by {\it options}[{\sf AZ\_graph\_fill}]. 
   \cite{milu}\\ DEFAULT: 1.}
\optionbox{params[{\sf AZ\_weights}]}{
   When {\it options}[{\sf AZ\_conv}] = AZ\_weighted, the {\it i\/}'th local
   component of the weight vector is stored in the location
   {\it params}[{\sf AZ\_weights}+i].}
Figure \ref{init_options} illustrates a sample user function {\sf choose\_solver\_options} that chooses specific solver options 
(by overwriting default values set with {\sf AZ\_defaults}).

\begin{figure}[Htbp]
  \shadowbox{
%    \begin{minipage}{\textwidth}
    \begin{minipage}{6.2in}
      \vspace{0.5em}
      {\large \flushleft{\bf Example}} \hrulefill %
      \vspace{0.5em}
%%%
\begin{verbatim}
void choose_solver_options(int options[AZ_OPTIONS_SIZE],
                  double params[AZ_PARAMS_SIZE])
{
  options[AZ_solver]     = AZ_cgs;
  options[AZ_scaling]    = AZ_none;
  options[AZ_precond]    = AZ_ls;
  options[AZ_output]     = 1;
  options[AZ_max_iter]   = 640;
  options[AZ_poly_ord]   = 7;
  params[AZ_tol]         = 0.0000001;
  params[AZ_drop]        = 0.;
  params[AZ_omega]        = 1.;

}
\end{verbatim}
%%%
      \vspace{0.1em}
    \end{minipage}}
  \caption{Example option initialization routine (\/{\sf
      choose\_solver\_options}).} \label{init_options}
 \end{figure}

\subsection{Return status\label{status}}

The double precision array {\it status} of length {\sf AZ\_STATUS\_SIZE}
returned from {\sf AZ\_solve}\footnote{ All integer information returned from
  {\sf AZ\_solve} is cast into double precision and stored in {\it status}.}.
The contents of {\it status} are described below.  \vspace{2em}
{\flushleft{\bf Specifications} \hrulefill} \nopagebreak \\[0.5em]
%
\optionbox{status[{\sf AZ\_its}]}{Number of iterations taken by the
   iterative method.}
\optionbox{status[{\sf AZ\_why}]}{Reason why {\sf AZ\_solve} terminated.}
      \choicebox{AZ\_normal}{User requested convergence criteria is
                 satisfied.}
      \choicebox{AZ\_param}{User requested option is not available.}
      \choicebox{AZ\_breakdown}{Numerical breakdown occurred.}
      \choicebox{AZ\_loss}{Numerical loss of precision occurred.}
      \choicebox{AZ\_ill\_cond}{The Hessenberg matrix within GMRES is
        ill-conditioned. This could be caused by a number of reasons.
        For example, the preconditioning matrix could be nearly singular
        due to an unstable factorization (note: pivoting is not implemented
        in any of the incomplete factorizations). Ill-conditioned Hessenberg
        matrices could also arise from a singular application
        matrix. In this case, GMRES tries to compute a least-squares solution.}
      \choicebox{AZ\_maxits}{Maximum iterations taken without convergence.}
\optionbox{status[{\sf AZ\_r}]}{The true residual norm corresponding to
   the choice {\it options}[{\sf AZ\_conv}] (this norm is calculated
   using the computed solution).}
\optionbox{status[{\sf AZ\_scaled\_r}]}{The true residual ratio expression
   as defined by  {\it options}[{\sf AZ\_conv}].}
\optionbox{status[{\sf AZ\_rec\_r}]}{Norm corresponding to
   {\it options}[{\sf AZ\_conv}] of final residual or estimated final
   residual (recursively computed by iterative method). Note: When using
   the 2-norm, {\bf tfqmr} computes an estimate of the residual norm
   instead of computing the residual.}
\optionbox{status[{\sf AZ\_solve\_time}]}{Utilization time in Aztec to solve system.}
\optionbox{status[{\sf AZ\_Aztec\_version}]}{Version number of Aztec.}
%
 When {\sf AZ\_solve} returns abnormally, the user may elect to restart using
 the current computed solution as an initial guess.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "az_ug_20"
%%% End:



\section{ Advanced topics}
\subsection {Using \crsmatrix{} Objects as Column Matrices}

\clearpage
\bibliographystyle{plain}
\bibliography{AztecOOUserGuide}
\addcontentsline{toc}{section}{References}

\appendix
\section{Troubleshooting}
\label{Section:Troubleshooting}
\subsection{Conditional Code, Incorrect Results and Stalled Programs}
Many methods in AztecOO distributed classes (those derive from the
\distobject{} class) require all processors to
participate in the method call.  For example, to compute the update of
an \vector{}, all processors that own a portion of the vector must
call the Update() method.  When calling a Norm2() method or something
similar, all processors, regardless of whether they own any portion of
a vector, must participate in the Norm2() call.  
Figure~\ref{Figure:HungCode} illustrates
several versions of a code segment that computes the 2-norm of a residual
and prints it from processor 0.  Only the final version is correct.

\end{document}

