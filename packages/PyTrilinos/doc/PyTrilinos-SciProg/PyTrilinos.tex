\documentclass[11pt]{article}

\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse % we are not running PDFLaTeX
\else
\pdfoutput=1 % we are running PDFLaTeX
\pdftrue
\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

\usepackage{setspace}
\doublespacing

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in


\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}

\title{PyTrilinos: Recent Advances in the \\ Python Interface to Trilinos}
\author{William F. Spotz \\ Sandia National Laboratories, Albuquerque, NM}
\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle

\begin{abstract}
PyTrilinos is a set of Python interfaces to compiled Trilinos packages.  This collection supports serial and parallel dense linear algebra, serial and parallel sparse linear algebra, direct and iterative linear solution techniques, algebraic and multilevel preconditioners, nonlinear solvers and continuation algorithms, eigensolvers and partitioning algorithms.  Also included are a variety of related utility functions and classes, including distributed I/O, coloring algorithms and matrix generation.  PyTrilinos vector objects are compatible with the popular NumPy Python package.  As a Python front end to compiled libraries, PyTrilinos takes advantage of the flexibility and ease of use of Python, and the efficiency of the underlying C++, C and Fortran numerical kernels.  This paper covers recent, previously unpublished advances in the PyTrilinos package.
\end{abstract}

{\bf Keywords:} Trilinos, Python, sparse linear algebra, parallel programming, nonlinear solvers, eigensolvers, partitioning, preconditioners.

\section{Introduction}
\label{sec:introduction}

Python is an increasingly popular language for scientific computing.  NumPy~\cite{NumPyGuide} (Numerical Python) provides an extremely convenient, high-level interface to homogeneous, contiguous (and non-contiguous) arrays of data.  SciPy~\cite{SciPyRefGuide} (Scientific Python) is built on top of NumPy and provides a Python interface to many of the most popular scientific libraries available.  Matplotlib~\cite{Matplotlib} provides high-quality plotting capabilities.  Parallelism is available via a long list of open source modules.  Robust solvers are provided by the Python interfaces to PETSc~\cite{PETScUserRef} and Trilinos~\cite{Trilinos}.  The SciPy Conference~\cite{SciPyConference} continues to grow in popularity, and the presence of several Python sessions at scientific computing conferences such as SuperComputing~\cite{SuperComputing} and the SIAM Conference on Computational Science and Engineering~\cite{SIAM_CSE} attest to the strong interest in using Python for scientific programming.  In fact, Python is now seen as a credible open source competitor to MATLAB~\cite{MATLAB}, perhaps the single most popular platform for small to medium scale scientific computing.  This is in part because Python and MATLAB share certain traits in common: they are both high-level, interpreted, interactive and dynamic.

At the other end of the scientific computing spectrum are compiled codes written in Fortran, C and C++ that run on massively parallel architectures to solve large, multiscale, multiphysics problems.  These codes utilize low-level languages in an attempt to achieve near-optimal processing efficiencies.  While the success at achieving this goal is debatable, there is no question that compiled languages are more efficient than interpreted languages such as Python.

However, as the complexity of simulations increases, more and more code is devoted to setup and to initialization of a series of subproblems that must all interface together to describe the larger scientific problem.  This ``command and control'' software can dominate the numerical kernels in terms of total lines of code, while the kernels themselves still dominate runtime execution.  Low-level languages are notoriously ill-suited to these types of bookkeeping tasks.  It is therefore easy to make the case that low-level languages should handle the numerically intense kernels and high-level languages should be utilized for command and control.

This perhaps explains the rise in popularity of Python for scientific computing.  As a high level, object-oriented language, it is very well suited to the high-level description of scientific problems, to provide the modularity so often sought by scientists asking ``what if'' questions, and to glue together the various components (often developed in different low-level languages) of a successful scientific simulation.  A well designed scientific Python code will hand off the numerically intense computations to optimized compiled code, while maintaining usability, readability and developmental scalability at the highest level.

PyTrilinos provides just such a capability.  It supports massively parallel vector and multivector objects and massively parallel operators such as sparse matrices.  PyTrilinos also supports solver algorithms that utilize these objects, enabling the development of complex codes with convenient Python interfaces and efficient Trilinos algorithms.  This paper details recent advances in the PyTrilinos package, including its new documentation system, recently added Trilinos modules, a focus on improvements to the Teuchos module, and model evaluators.  We finish with a vision for interfaces to second-generation Trilinos packages.

\section{Review}
\label{sec:review}

The first PyTrilinos article~\cite{PyTrilinos}, published in 2008, described the status of the project circa 2007.  In order to put recent advances in context, we begin with a review of the topics covered and conclusions drawn in that paper.

PyTrilinos is a Python interface to selected Trilinos packages.  The ``wrapper code'' necessary to provide such an interface is generated almost entirely by SWIG~\cite{SWIG_CXX_Python}, the Simple Wrapper and Interface Generator.  Other tools could have been chosen to facilitate this wrapping, including SIDL/Babel~\cite{Babel}, Boost.Python~\cite{BoostPython}, and more recently, Cython~\cite{Cython}.  All three of these tools require a manually written interface definition, which can fall out of sync with the wrapper source if the source interface changes.  This is perhaps the primary advantage of using SWIG to wrap Trilinos, which is a very large code base that is under active development.  The default SWIG behavior is to produce Python interfaces with a near one-to-one mapping to its C or C++ source code.  It was decided early in the PyTrilinos project that this was an appropriate approach for a code base as large as Trilinos.

Because of its strong compatibility with NumPy (Numerical Python), PyTrilinos plays a role in a suite of mathematical and scientific Python tools that can be interpreted as an open source competitor to MATLAB.  This suite has the advantage of being free, of leveraging a more powerful scripting language, and of expanded interoperability with other languages.  PyTrilinos adds to this suite of tools implicit solver capabilities designed from the ground up for massively parallel computing.

At the time of publication of~\cite{PyTrilinos}, PyTrilinos provided interfaces to linear algebra services packages Epetra and EpetraExt; tools and testing packages Teuchos, Triutils, Galeri and New\_Package; direct and iterative linear solver packages Amesos and AztecOO; preconditioning packages IFPACK and ML; nonlinear solver package NOX; and continuation algorithms package LOCA.  Since this publication, PyTrilinos has released wrappers to eigensolver package Anasazi and complex linear algebra services package Komplex.  The most recent release of Trilinos -- version 10.8 released in September 2011 --- includes a new PyTrilinos package Isorropia, which provides parallel partitioning algorithms.  Support for New\_Package has been discontinued, as the purpose of this package is to provide a template for adding new packages to Trilinos, and its utility for new PyTrilinos packages was limited.

The Trilinos approach to supporting parallelism is to provide abstract communicator classes (for historical reasons, one in Epetra and one in Teuchos) and then provide concrete implementations of these classes in the form of serial communicators and Message Passing Interface (MPI) communicators (and potentially others in the future).  If Trilinos is configured with MPI support, then the MPI communicators are made available to both the C++ and Python programmer.  Furthermore in PyTrilinos, {\tt MPI\_Init()} will be called automatically when the Epetra or Teuchos modules are imported, and {\tt MPI\_Finalize()} will be called automatically when the top-level Python module exits.  With the latest release of Trilinos, this module behavior is made compatible with other MPI Python interfaces such as pyMPI, PyPar or mpi4py by executing these initialization and finalization calls only if MPI has not already been initialized.  If {\tt MPI\_Init()} has already been called, e.g. by mpi4py, then PyTrilinos assumes that the user is responsible for finalization.

Reference~\cite{PyTrilinos} contains comparisons between PyTrilinos and MATLAB for basic operations that are common to both.  The high-level conclusions are that MATLAB is more efficient at performing dense matrix vector multiplies and that PyTrilinos is more efficient at both sparse matrix vector multiplies and sparse matrix assignment.  These results reflect the different primary design objectives of the two tools.

PyTrilinos was also compared to Trilinos itself.  The primary usage differences are several: Python's dynamic object model versus the static typing of C++; memory management concerns present in C++ but not in Python; no header files in Python; and high-level containers in Python versus low-level C arrays.  The performance differences depend ultimately upon the granularity of the algorithm being tested.  Fine grained algorithms that do a lot of work (especially loops) in Python suffer significant performance penalties.  Coarse grained algorithms that hand off the bulk of the work to compiled routines can exhibit imperceptible performance hits in both serial and parallel.  In situations where no coarse grain algorithm access exists in Python, there are potential alternatives to avoid Python loops.  For example, one can use NumPy array slice syntax to perform array selection operations without an explicit Python loop, or one can use weave, which compiles embedded C/C++ code in Python.  Other alternatives include the previously mentioned wrapper tools SWIG, SIDL/Babel, Boost.Python or Cython.

The advantages of PyTrilinos include rapid prototyping, brevity, modularity, reusability, explorative computing, integration, software quality via testing in Python, stability, and high-level scripting for data input.  The disadvantages include portability issues, shared library support on massively parallel computers, lack of compile-time checks, performance considerations, and an awkward mapping of C++ template code (see Section~\ref{sec:vision} for more details on this last issue).

\section{Documentation}
\label{sec:documentation}

With Trilinos Release 9.0 (PyTrilinos version 4.1) a significant improvement to PyTrilinos documentation was made.  The most important form of documentation for Python modules is the docstring.  Wherever the first line of code within a Python function, method, class or module is a string, that string is interpreted as documentation for that code element.  Many Python documentation tools, including the Python {\tt help()} function, access these docstrings for their content.  SWIG provides some very basic docstring generation capabilities, but this is limited to docstrings that contain the code element name (function, method, class or module), and argument types and names (where appropriate).  Such docstrings are certainly better than nothing, but often fall far short of describing the code sufficiently to help programmers use it appropriately.  In the code-generation environment of SWIG, it is possible to provide static documentation directives, but difficult to provide these accurately for every function, method, class and module for a large and changing project such as Trilinos.

Furthermore, static documentation would be undesirable because Trilinos developers provide significant documentation of code elements via Doxygen~\cite{Doxygen}.  Doxygen is a tool that parses C/C++ code and interprets specially designated comments as documentation.  Doxygen uses this information in conjunction with the code parse tree to generate high-quality documentation in a variety of forms including web pages and PDF files.

Doxygen can write its code parse tree and associated documentation strings to an XML file.  This capability allowed Prabhu Ramachandran of the Indian Institute of Technology to write a Python script that parses this XML data and then writes a SWIG interface file that provides directives that generate automatic docstrings.  The end result is that the PyTrilinos build system will generate Python code that includes docstrings that mirror their corresponding C++ Doxygen documentation.  These docstrings can be overridden on a case-by-case basis where the Python interface differs from the C++ interface.  This results in an extremely useful, interactive and scalable documentation system for PyTrilinos.

\section{Recently Added Packages}
\label{sec:newpackages}

This section describes those packages that have been added to PyTrilinos since the publication of~\cite{PyTrilinos}.

\subsection{Anasazi}
\label{sec:anasazi}

Anasazi~\cite{Anasazi} is the Trilinos eigensolver package and was one of the first Trilinos packages to utilize templates.  Templates in Anasazi allow a single code base for different scalar types ({\tt float}, {\tt double}, {\tt complex}, {\tt complex double}, etc.), different multivector types ({\tt Epetra\_MultiVector}, {\tt Tpetra::MultiVector} and a variety of Thyra multivectors, etc.), and operator types ({\tt Epetra\_Operator}, {\tt Tpetra::Operator}, etc.).  Of the available C++ Anasazi data types, PyTrilinos supports only Epetra, and so the Python interface to Anasazi in PyTrilinos accepts only Epetra objects.

Perhaps the most important customization to the Python interface to Anasazi is the conversion of returned eigenvalues from C++ type
\begin{verbatim}
    std::vector< Anasazi::Value< ScalarType > >
\end{verbatim}
to a NumPy array of complex double precision values.  PyTrilinos completes the coverage of Anasazi data types with support for the {\tt Anasazi::Eigensolution} and {\tt Anasazi::MultiVec} classes.

{\tt PyTrilinos.Anasazi} also provides output and sort managers, as well as operator, eigenproblem and status test classes to give full coverage of the package.  The list of supported eigensolvers includes block Davidson, block Krylov-Schur and locally optimal block preconditioned conjugate gradient (LOBPCG).

The following is a simple example script for solving the first four eigenvalues of a matrix obtained from finite differencing the 2D Laplace operator on a $10\times10$ grid using Block Davidson:
\begin{verbatim}
    from PyTrilinos import Epetra, Galeri, Anasazi
    comm       = Epetra.PyComm()
    
    # Obtain the map and CRS matrix from the Galeri module
    galeriList = { "n": 10*10, "nx":10, "ny":10 }
    map        = Galeri.CreateMap("Linear", comm, galeriList)
    matrix     = Galeri.CreateCrsMatrix("Laplace2D", map, galeriList)
    
    # Build the eigenproblem and Anasazi solver manager
    printer    = Anasazi.BasicOutputManager()
    ivec       = Epetra.MultiVector(map, 5)
    ivec.Random()
    problem    = Anasazi.BasicEigenproblem(matrix, ivec)
    problem.setHermitian(True)
    problem.setNEV(4)
    anasaziList = {"Which"                 : "LM",
                   "Block Size"            : 5,
                   "Num Blocks"            : 8,
                   "Maximum Restarts"      : 100,
                   "Convergence Tolerance" : 1.0e-8 }
   solverMgr    = Anasazi.BlockDavidsonSolMgr(problem, anasaziList)
   
   # Solve the eigenproblem and output the results
   returnCode   = solverMgr.solve()
   sol          = problem.getSolution()
   if comm.MyPID() == 0: print sol.Evals()
\end{verbatim}
Running this script produces the following output:
\begin{verbatim}
   [ 7.83797189+0.j  7.60149301+0.j  7.60149301+0.j  7.36501413+0.j ]
\end{verbatim}
with corresponding errors (calculation not shown):
\begin{verbatim}
   [ 3.6934e-13  4.1688e-12  1.7741e-12  7.7208e-09 ]
\end{verbatim}

\subsection{Komplex}
\label{sec:komplex}

Komplex is a workaround package to provide support for complex linear algebra problems using the double-precision real-valued-only Epetra package.  This involves storing two vectors of the same type and distribution, one representing the real part and one representing the imaginary part.  For dense or sparse matrices, two matrices are stored, again for the real and imaginary parts.  This is enabled with the definition of a single class, {\tt Komplex\_LinearProblem}, which translates to a Python class {\tt Komplex.LinearProblem}.  The following script is a simple example of using the Komplex module:

\begin{verbatim}
    from PyTrilinos import Epetra, AztecOO, Komplex
    comm = Epetra.PyComm()
    n    = 10 * comm.NumProc()
    map  = Epetra.Map(n, 0, comm)
    
    # Build the problem matrix
    Ar   = Epetra.CrsMatrix(Epetra.Copy, map, 1)
    Ai   = Epetra.CrsMatrix(Epetra.Copy, map, 1)
    for gid in map.MyGlobalElements():
        Ar.InsertGlobalValues(gid, [10 * (1 + float(gid)/n),], [gid,])
        Ai.InsertGlobalValues(gid, [10 * (1 - float(gid)/n),], [gid,])
    Ar.FillComplete()
    Ai.FillComplete()

    # Build the solution vector and the RHS
    xr  = Epetra.Vector(map)
    xi  = Epetra.Vector(map)
    br  = Epetra.Vector(map)
    bi  = Epetra.Vector(map)
    for gid in map.MyGlobalElements():
        lid = map.LID(gid)
        br[lid] = Ar[gid,gid] * -1.0
        bi[lid] = Ai[gid,gid] * -1.0

    # Build the complex problem
    problem = Komplex.LinearProblem(1, 0, Ar, 1, 0, Ai,
                                    xr, xi, br, bi)

    # Set up the solver and iterate to a solution
    solver = AztecOO.AztecOO(problem.KomplexProblem())
    aztecOOList  = {"Solver"  : "GMRES",
                    "Precond" : "None",
                    "Output"  : 16      }
    solver.SetParameters(aztecOOList,True)
    solver.Iterate(n, 1e-5)
    if comm.MyPID() == 0: print "Real part"
    print xr
    if comm.MyPID() == 0: print "Imaginary part"
    print xi
\end{verbatim}

\subsection{Isorropia}
\label{sec:isorropia}

Isorropia is a Trilinos package built on top of the Zoltan package for partitioning and dynamic load balancing.  It provides object-oriented interfaces to Zoltan specialized for Epetra, Tpetra and potentially other future linear algebra packages.  Isorropia is used to construct or modify partitions for vector and sparse matrix classes.

In 2010-11, Sandia National Laboratories participated in a Harvey Mudd College Clinic that teamed Sandia researchers with four Harvey Mudd undergraduate students to conduct research on new matrix partitioning methods.  One of the benefits of this project was the development of a Python interface to Isorropia so that the students could rapidly develop a Python-based visualizer for the matrix partitions they were producing.

{\tt PyTrilinos.Isorropia} mirrors the C++ Isorropia package in that is has a top-level module with abstract base classes for operators, colorers, partitioners, redistributors, cost describers, orderers and level schedulers.  It also supports an Epetra submodule that contains concrete implementations of these classes implemented for Epetra data objects.

The students developed their project within their own repository, and the SWIG wrappers they produced depended somewhat on the modifications they made to the Isorropia code.  While this new Isorropia code is being ported to the main Trilinos branch slowly, the Python wrappers to Isorropia have been ported nearly in their entirety, minus the dependencies on the newer code.

The following is a short script that demonstrates usage of some of the Isorropia classes:
\begin{verbatim}
    from PyTrilinos import Teuchos, Epetra, Isorropia
    
    def buildGraph(comm, nRows):
        "Return the graph of a tridiagonal matrix"
        map = Epetra.Map(nRows, 0, comm)
        graph = Epetra.CrsGraph(Epetra.Copy, map, 3)
        for gid in map.MyGlobalElements():
            if gid == 0:
                indices = [0, 1]
            elif gid == nRows-1:
                indices = [nRows-2, nRows-1]
            else:
                indices = [gid-1, gid, gid+1]
            graph.InsertGlobalIndices(gid, indices)
        graph.FillComplete()
        return graph

    # Initialize the sparse matrix graph
    comm  = Epetra.PyComm()
    nRows = 10 * comm.NumProc()
    crsg  = buildGraph(comm, nRows)

    # Assign colors to the graph rows
    colorer = Isorropia.Epetra.Colorer(crsg)
    print colorer.elemsWithColor(0)

    # Build a partitioner
    pList       = {"Partitioning Method" : "Random"}
    partitioner = Isorropia.Epetra.Partitioner(crsg, pList)
    partitioner.partition(True)
    print partitioner

    # Use the partitioner to build a redistributor and redistribute the graph
    redis       = Isorropia.Epetra.Redistributor(partitioner)
    newCrsg     = redis.redistribute(crsg)
    print redis
    print newCrsg
\end{verbatim}

\section{Improvements to the Teuchos Module}
\label{sec:teuchos}

As the primary tools package for Trilinos, Teuchos has many useful capabilities.  Some of these capabilities are already provided by standard Python libraries, e.g. command-line option and argument processing, and so are not wrapped in PyTrilinos.  Thus the list of Python interfaces to Teuchos tools is small relative to the package's overall capabilities.  It includes communicators, reference-counted pointers and parameter lists, including XML support.

\subsection{Teuchos Communicators}
\label{sec:teuchos_communicators}

Teuchos communicators are analogous to Epetra communicators: a virtual base class for the purpose of polymorphism, and serial and MPI concrete implementations to enable these two modes of operation.  Unlike an Epetra communicator, Teuchos communicators are templated on an ordinal type and include some advanced programming techniques not allowed under the self-imposed restrictions for Epetra.  There is also a default Teuchos communicator based on an ordinal of type {\tt int}.  PyTrilinos now supports Teuchos communicators.

\subsection{Teuchos Reference-Counted Pointers}
\label{sec:teuchos_rcp}

The new reference-counted pointer support is perhaps the most important improvement to PyTrilinos involving Teuchos.  The {\tt Teuchos::RCP} class is very similar to the {\tt boost::shared\_ptr} class with a few minor differences.  By developing {\tt Teuchos::RCP}, Trilinos developers can avoid a dependency on Boost and can more directly control memory management issues.

Reference-counted pointers are a memory management technique that allows objects to be allocated dynamically, to be referenced by other objects, to ensure existence in the presence of such references and to delay deallocation until the last object that holds such a reference has been destroyed.  In pure Python, reference counting is performed automatically without any effort from the programmer whatsoever.  In the Python/C API, the programmer must pay careful attention to reference counting issues, and call incrementing and decrementing macros at the proper times to ensure proper memory management.  In C++, classes such as {\tt boost::shared\_ptr} and {\tt Teuchos::RCP} have been written that keep reference counts current automatically via constructors, copy constructors and destructors.

More and more Trilinos packages are adopting the {\tt RCP} as a means of secure memory management.  This has presented a problem for PyTrilinos.  The philosophy of maintaining interfaces with nearly one-to-one mapping between C++ and Python is hard to justify in the face of {\tt RCP}s.  Python programmers would be asked, in what would appear to be a mostly random interface, to sometimes pass an object to a function and other times create a new object, encapsulated in the {\tt RCP} class, in order to pass to a function.  This would be nothing but a source of frustration for Python programmers, who have always been protected from the issue of memory management.

The proper way to implement shared pointers is to hide them completely from the Python interface.  To their credit, SWIG developers have recognized this and have provided an experimental capability to do this.  But it was not until the release of SWIG version 2.0 that all the bugs were addressed in the Python code generator.

The basic idea is this: if a C++ class defines a type that is at some time referenced as a shared pointer, then all instances of that object within the Python extension module should be stored as a shared pointer.  The default storage method used by SWIG is with a raw pointer that relies upon Python reference counts to determine when the object is deallocated.  By changing the storage technique, this implies that the conversion code for accessing an instance within the generated wrapper code must be specialized in all cases.  In fact, the bulk of the shared pointer support in SWIG is a set of new typemaps that define these new conversions.

In order to provide the support for {\tt Teuchos::RCP} that SWIG now provides for {\tt shared\_ptr} classes (in both the {\tt boost} and {\tt std} namespaces), we had to define some macros prior to enabling shared pointer support by applying the {\tt \%include} directive to the SWIG {\tt boost\_shared\_ptr.i} interface file. These macros cause the interface file to refer to {\tt Teuchos::RCP} rather than {\tt shared\_ptr}.  This was far more straightforward than might be expected.  We had to override the output typemaps in order to use the ownership flag that the {\tt RCP} constructor provides, and we had to provide director input and output typemaps, which the SWIG library currently does not implement (see Section~\ref{sec:modelevaluator} for a discussion of SWIG directors).

The end result is that whenever a Trilinos C++ method argument requests an {\tt RCP}-wrapped object, the equivalent Python method argument will accept an unadorned object.  The wrapper code can provide a properly reference-counted object to the C++ routine because the object is stored with an {\tt RCP} internally.  This results in simplified Python programming with increased readability and no loss of capability.

\subsection{Teuchos Parameter Lists}
\label{sec:teuchos_parameterlists}

At the time of~\cite{PyTrilinos}, {\tt Teuchos::ParameterList}s were supported.  Wherever a {\tt ParameterList} was expected as input, the Python programmer could provide a Python dictionary in its place.  Wherever a {\tt ParameterList} was returned as output, a new type of object, a {\tt PyDictParameterList}, was returned in Python.  This has been simplified and improved somewhat.  Python dictionaries are still accepted as input, but now the {\tt ParameterList} class has been wrapped properly, with the addition of several methods and operators so that it also behaves like a Python dictionary.  This allows access to some {\tt ParameterList} capabilities that Python dictionaries do not possess, such as the usage flags, while still allowing Python programmers to specify {\tt ParameterList}s using highly convenient dictionary syntax.

Another addition to the Teuchos Python module are wrappers for XML classes {\tt XMLObject}, {\tt XMLPa\-rameterListReader}, {\tt XMLParameterListWriter}, {\tt XMLInputSource}, {\tt FileInputSource} and {\tt String\-InputSource}, which together provide full I/O capabilities for {\tt ParameterLists} in XML format.

\section{EpetraExt Model Evaluator}
\label{sec:modelevaluator}

A model evaluator is a concept implemented in both EpetraExt and Thyra that allows the generic definition of a model that can then be passed to a variety of solvers, including nonlinear solvers, continuation algorithms and optimization packages.  The {\tt ModelEvaluator} class in EpetraExt is now supported in PyTrilinos.

The {\tt ModelEvaluator} class is a virtual base class with a pure virtual {\tt modelEval()} method that must be implemented by a derived class.  A solver or optimization object that has a ModelEvaluator interface will call this {\tt modelEval()} method whenever a model evaluation is required.

SWIG supports the use case of writing such a derived class in Python, including the {\tt modelEval()} method.  This is known as cross-language polymorphism and works as follows:  SWIG generates a C++ class that inherits from the {\tt ModelEvaluator} class that provides compilable code for all virtual methods.  Such a class is known as a director class and such methods are known as director methods.  This is because the class is wrapped with a Python interface and that interface is checked dynamically for implementations of the director methods (such as {\tt modelEval()}).  If such Python methods are found, the underlying C++ methods direct execution to the Python code.  If not, the default C++ implementation will be called, or for a pure virtual method, an exception raised.

The Python interface for the EpetraExt {\tt ModelEvaluator} class was a challenge to develop because the {\tt ModelEvaluator} makes heavy use of nested classes.  This is the one case of C++ code that is not supported by SWIG.  There are workarounds for this situation suggested by SWIG developers, but the {\tt ModelEvaluator} class is complex enough that it resisted these workarounds.  The ultimate solution was to redefine the nested classes as non-nested pure Python classes and then write typemaps that convert these Python arguments to the appropriate underlying C++ types.

{\tt ModelEvaluator} classes are useful only if there are corresponding solver objects which support the ModelEvaluator interface.  To date only the NOX nonlinear solver package supports the ModelEvaluator interface within PyTrilinos.

\section{Vision for Second-Generation Packages}
\label{sec:vision}

First-generation Trilinos packages are designed around the Epetra package, which provides distributed linear algebra classes such as vectors, multivectors, operators, and sparse matrices.  Development of Epetra began over a decade ago, when variations in C++ compilers from platform to platform were considerable.  For this reason, Epetra was designed without templates or namespaces, to maximize portability.  As a result, Epetra scalar data is always {\tt double} and ordinals are always {\tt int}.  In the intervening decade, needs have inevitably arisen for complex and single precision scalar data (especially for GPUs) and {\tt long} ordinal data (as platforms and global problem sizes have grown).  To address these needs, a second-generation linear algebra services package, Tpetra (Templated Petra) has been developed, with template arguments for scalar data, local ordinals and global ordinals.

PyTrilinos provides wrappers to a significant subset of first-generation packages.  This includes Teuchos, which has evolved to support both first and second-generation packages, and Anasazi, which was designed from its origins to both utilize templates and interface to Epetra.  But Tpetra does not yet have a PyTrilinos interface, and so most of the second-generation packages do not either.

C++ templates present a challenge to designing Python interfaces that wrap such code.  This stems from the fact that C++ implements templates with a heavy dependence on syntax while the same concept is implemented dynamically in Python without syntax.  In other words, because Python function and method arguments do not specify types, any argument type will work as long there is support for all of the operators and functions applied to that argument.  Thus Python ``templates'' are implicit and implemented at run time, while C++ templates are explicit and implemented at compile time.  As a Python interface to compiled code, Python extensions must link to a finite set of concrete instantiations of C++ template code, which makes this use case far less generic than pure Python is.

The SWIG method for generating wrapper code for templates is to parse template code internally but only produce wrappers for concrete instantiations, each one requiring a unique name.  As a simple example of this, consider an attempt to wrap the C++ {\tt Tpetra::Vector} class.  We will focus on a subset of a significant simplification of the class that will expose wrapping issues of concern:
\begin{verbatim}
    namespace Tpetra {
        template< class T >
        class Vector {
            Vector(size_type n = 0);
        };
    }
\end{verbatim}
We can instantiate {\tt Tpetra::Vector} with any type T, and this will produce an array of data of type T.  We would like a Python interface that gives us access to this class with a variety of types supported.  To wrap this class with SWIG, one might include the following in the SWIG interface file:
\begin{verbatim}
    %template(Vector_int   ) Tpetra::Vector<int>;
    %template(Vector_long  ) Tpetra::Vector<long>;
    %template(Vector_float ) Tpetra::Vector<float>;
    %template(Vector_double) Tpetra::Vector<double>;
\end{verbatim}
This would produce a Python extension module with definitions for four independent classes:
\begin{verbatim}
    from PyTrilinos import Tpetra
    n = 10
    vi = Tpetra.Vector_int(n)
    vl = Tpetra.Vector_long(n)
    vf = Tpetra.Vector_float(n)
    vd = Tpetra.Vector_double(n)
\end{verbatim}
This interface is decidedly not ``Pythonic.''  It is also not scalable; C++ code that utilizes multiple template parameters would quickly result in names that are too long or too cryptic to be usable or readable.

A preferable interface would consist of a single Python class named Vector.  This would require the addition of a technique to specify the scalar data type.  The NumPy module has already addressed this issue with the utilization of {\tt dtype} arguments, and so a similar solution would be both familiar to scientific Python programmers and compatible with NumPy:
\begin{verbatim}
    from PyTrilinos import Tpetra
    n = 10
    vi = Tpetra.Vector(n, dtype="i")
    vl = Tpetra.Vector(n, dtype="l")
    vf = Tpetra.Vector(n, dtype="f")
    vd = Tpetra.Vector(n, dtype="d")
\end{verbatim}
To accomplish this in SWIG would require the development of a complete new class in C++ that is not itself templated, but is capable of internally storing several templated Vector classes of different (predefined) types, only one of which would be active with allocated data.  With this paradigm, SWIG loses some of its advantages.  We are no longer targeting a nearly one-to-one interface between C++ and Python and must spend considerable effort designing a new interface.  This interface definition makes other wrapping tools, such as SIDL/Babel, Boost.Python or Cython much more attractive.  Cython in particular might be particularly adept at helping to develop ``Pythonic'' interfaces.

This raises the question of whether interfaces developed with SWIG can be compatible with interfaces developed with another tool, most likely Cython.  If so, Cython may be an attractive approach for wrapping second-generation Trilinos packages.  If not, the sheer inertia of SWIG-wrapped PyTrilinos packages may dictate continuing to use SWIG to generate the Python interfaces.  Clearly, some research must be conducted to determine the best path forward for developing second-generation Trilinos packages for PyTrilinos.

\section{Concluding Remarks}
\label{sec:concluding remarks}

The Trilinos Project is now over a decade old and has seen massive growth in that time.  Beginning with three packages for linear algebra services, iterative solvers and preconditioners, Trilinos has grown to now encompass 50 packages in its current release, with more planned for the future.  It has grown from a suite of solver technologies to a suite of simulation tools, now including meshing, discretizations, partitioning, load balancing, automatic differentiation, optimization and much more.  As C++ compilers have matured, more advanced programming techniques have been employed.  As lessons have been learned regarding object-oriented design for scientific computing, those lessons have been deployed in the code base.

These advances, coupled with the need for stable interfaces, have inevitably led to the development of second-generation packages such as Tpetra, Belos and Ifpack2.  PyTrilinos provides Python interfaces to first-generation packages, with an emphasis on Epetra and those packages that process Epetra objects.  As the second-generation packages mature, we expect pressure to mount to provide Python interfaces to them.  Tpetra vectors, with their support of multiple data types, are more powerful than Epetra vectors, with their restriction to double precision.  This makes Tpetra vectors more like NumPy arrays, with the added capability of distribution over parallel computing architectures.  Thus Tpetra and the packages that use it are obvious candidates for Python wrappers.  So while PyTrilinos currently provides an impressive set of capabilities, it is also at a crossroads, facing a large new set of potential capabilities to provide in the form of second-generation Trilinos packages.

\bibliographystyle{plain}
\bibliography{PyTrilinos}

\end{document}
\end
