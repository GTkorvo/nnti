// @HEADER
// ************************************************************************
//
//                           Intrepid Package
//                 Copyright (2007) Sandia Corporation
//
// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
// license for use of this work by or on behalf of the U.S. Government.
//
// This library is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of the
// License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA
// Questions? Contact Pavel Bochev (pbboche@sandia.gov) or
//                    Denis Ridzal (dridzal@sandia.gov).
//
// ************************************************************************
// @HEADER


/** \file   Intrepid_MultiCell.icpp
\brief  Contains inline function definitions for the Intrepid::MultiCell interface.
\author Created by P. Bochev and D. Ridzal
*/

namespace Intrepid {
  
  //--------------------------------------------------------------------------------------------//
  //                      Accessors operating on a specific MultiCell instance                  //
  //--------------------------------------------------------------------------------------------//
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyAmbientDim() const {
    return ambientDim_;
  }
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getMyCellType() const {
    return myCellType_;
  }
  
  template<class Scalar>
  inline const char* MultiCell<Scalar>::getMyCellName() const {
    return cellNames_[myCellType_];
  }
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyTopologicalDim() const {
    return (myCellType_ > CELL_CANONICAL_MAX ?
            connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][0].topologicalDim_ :
            connMapCanonical_[myCellType_][0].topologicalDim_);
  }
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyNumNodes() const {
    return (CELL_NODE == myCellType_ ? 1 :
            (myCellType_ > CELL_CANONICAL_MAX ?
             connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][0].topologicalDim_-1].numNodesPerSubcell_[0] :
             connMapCanonical_[myCellType_][connMapCanonical_[myCellType_][0].topologicalDim_-1].numNodesPerSubcell_[0])
            );
  }
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyNumSubcells(const int subcellDim) const {
    return (myCellType_ != CELL_NODE && subcellDim > 0 ?
            (myCellType_ > CELL_CANONICAL_MAX ?
             connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].numSubcells_ :
             connMapCanonical_[myCellType_][subcellDim-1].numSubcells_) : (subcellDim ? -1 : getMyNumNodes())
            );
  }
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getMySubcellType(const int subcellDim,const int subcellID) const {
    return (!subcellDim ?
            CELL_NODE :
            (getMyTopologicalDim() == subcellDim ? myCellType_ :
             (myCellType_ > CELL_CANONICAL_MAX ?
              connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].subcellType_[subcellID] :
              connMapCanonical_[myCellType_][subcellDim-1].subcellType_[subcellID])
             )
            );
  }
  
  template<class Scalar>
  inline void MultiCell<Scalar>::getMySubcellNodeIDs(const int subcellDim, const int subcellID,Teuchos::Array<int> & subcellNodeIDs) const {
    int num_nodes = getNumNodes(getMySubcellType(subcellDim, subcellID));	// num nodes of the desired subcell
    subcellNodeIDs.resize(num_nodes);
    for (int i=0; i < num_nodes; i++)
      subcellNodeIDs[i] =
        (CELL_NODE == myCellType_ && 0 == subcellDim && 0 == subcellID ?
         0 :
         (0 == subcellDim ?
          subcellID :
          (myCellType_ > CELL_CANONICAL_MAX ?
           connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].nodeList_[subcellID][i] :
           connMapCanonical_[myCellType_][subcellDim-1].nodeList_[subcellID][i]))
         );
  }
  
  template<class Scalar>
  inline const Teuchos::Array<short> & MultiCell<Scalar>::getMySubcellSigns(const int cellID,const int subcellDim) const{
    assert( (edgeSignsStatus_ == STATUS_DEFINED && subcellDim == 1) || \
            (faceSignsStatus_ == STATUS_DEFINED && subcellDim == 2) );
    return (subcellDim == 1) ? edgeSigns_[cellID] : faceSigns_[cellID];
  }
  
  
  template<class Scalar>
  inline const Point<Scalar> & MultiCell<Scalar>::getVertex(const int cellID, const int vertexID) const {
    return vertices_[cellID][vertexID];
  }
  
  template<class Scalar>
  inline const Teuchos::Array< Point<Scalar> > & MultiCell<Scalar>::getCell(const int cellID) const {
    return vertices_[cellID];
  }
  
  template<class Scalar>
  inline const Teuchos::Array< Point<Scalar> > & MultiCell<Scalar>::operator [] (const int cellID) const {
    return vertices_[cellID];
  }
  

//-------------------------------------------------------------------------------------//
//     Static member functions: can be called without prior MultiCell instantiation    //
//-------------------------------------------------------------------------------------//

  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getCellType(const char* cellName) {
    for (ECell i = CELL_NODE; i < CELL_MAX; i++) {
      if (0 == strcmp(cellName, cellNames_[i]))
        return i;
    }
    return CELL_MAX;
  }
  
  
  template<class Scalar>
  inline const char* MultiCell<Scalar>::getCellName(const ECell cellType) {
    return cellNames_[cellType];
  }
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getTopologicalDim(const ECell cellType) {
    return (cellType > CELL_CANONICAL_MAX ?
            connMapCustom_[cellType-CELL_CANONICAL_MAX-1][0].topologicalDim_ :
            connMapCanonical_[cellType][0].topologicalDim_
            );
  }
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getNumNodes(const ECell cellType) {
    return (CELL_NODE == cellType ? 1 :
            (cellType > CELL_CANONICAL_MAX ?
             connMapCustom_[cellType-CELL_CANONICAL_MAX-1][connMapCustom_[cellType-CELL_CANONICAL_MAX-1][0].topologicalDim_-1].numNodesPerSubcell_[0] :
             connMapCanonical_[cellType][connMapCanonical_[cellType][0].topologicalDim_-1].numNodesPerSubcell_[0]
             )
            );
  }
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getNumSubcells(const ECell parentCellType, 
                                               const int subcellDim) {
    return (parentCellType != CELL_NODE && subcellDim > 0 ?
            (parentCellType > CELL_CANONICAL_MAX ?
             connMapCustom_[parentCellType-CELL_CANONICAL_MAX-1][subcellDim-1].numSubcells_ :
             connMapCanonical_[parentCellType][subcellDim-1].numSubcells_
             ) :
            (subcellDim ?
             -1 :
             getNumNodes(parentCellType)
             )
            );
  }
  
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getSubcellType(const ECell parentCellType, 
                                                 const int subcellDim,
                                                 const int subcellID) {
    return (!subcellDim ?
            CELL_NODE :
            (getTopologicalDim(parentCellType) == subcellDim ?
             parentCellType :
             (parentCellType > CELL_CANONICAL_MAX ?
              connMapCustom_[parentCellType-CELL_CANONICAL_MAX-1][subcellDim-1].subcellType_[subcellID] :
              connMapCanonical_[parentCellType][subcellDim-1].subcellType_[subcellID]
              )
             )
            );
  }
  
  
  template<class Scalar>
  inline void MultiCell<Scalar>::getSubcellNodeIDs(const ECell parentCellType, 
                                                   const int subcellDim,
                                                   const int subcellID, 
                                                   Teuchos::Array<int> &subcellNodeIDs) {
    int num_nodes = getNumNodes(getSubcellType(parentCellType, subcellDim, subcellID));
    subcellNodeIDs.resize(num_nodes);
    for (int i=0; i < num_nodes; i++)
      subcellNodeIDs[i] =
        (CELL_NODE == parentCellType && 0 == subcellDim && 0 == subcellID ?
         0 :
         (0 == subcellDim ?
          subcellID :
          (parentCellType > CELL_CANONICAL_MAX ?
           connMapCustom_[parentCellType-CELL_CANONICAL_MAX-1][subcellDim-1].nodeList_[subcellID][i] :
           connMapCanonical_[parentCellType][subcellDim-1].nodeList_[subcellID][i]
           )
          )
         );  
  }
  
  
  template<class Scalar>
  EStatus MultiCell<Scalar>::getAtlasStatus() const {
    return atlasStatus_;
  }
  
  
  template<class Scalar>
  const char* MultiCell<Scalar>::getAtlasStatusName() const {
    return StatusNames[atlasStatus_];
  }
  
  
} // namespace Intrepid
