#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass extarticle
\begin_preamble
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\fdo}[1]{\mathcal{D}_{#1}}
\newcommand{\sdo}[1]{D_{#1}}
\newcommand{\tdo}[1]{D_{#1}}
\newcommand{\fd}[2]{\fdo{#1} #2}
\newcommand{\sd}[2]{\sdo{#1} #2}
\newcommand{\td}[2]{\tdo{#1} #2}
\newcommand{\pdd}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\newcommand{\pddd}[2]{\frac{\partial^3 #1}{\partial #2^3}}
\newcommand{\pmix}[3]{\frac{\partial^2 #1}{\partial #2 \partial #3}}
\newcommand{\pmixx}[4]{\frac{\partial^3 #1}{\partial #2 \partial #3 \partial #4}}
\newcommand{\funcd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\spaced}[2]{{\cal D}^{#1} #2}
\newcommand{\totald}[2]{{D}^{#1} #2}

\newcommand{\abs}[1]{\left\vert{#1}\right\vert}
\newcommand{\od}[2]{\frac{d #1}{d #2}}
\newcommand{\odd}[2]{\frac{d^2 #1}{d #2^2}}
\newcommand{\R}{\mathbb{R}}

\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\definecolor{lightgray}{RGB}{240,240,240}
\definecolor{bluegray}{RGB}{180,180,200}
\lstset{basicstyle={\sffamily\footnotesize},language={C++},tabsize=2,showstringspaces=false,frame=shadowbox,breaklines=true,mathescape=true,commentstyle={\itshape\textcolor{red}},lineskip=1pt,aboveskip=\bigskipamount,belowskip=\bigskipamount, rulesepcolor=\color{bluegray}}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
theorems-ams-extended
\end_modules
\language english
\inputencoding auto
\font_roman palatino
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\branch answers
\selected 1
\color #5555ff
\end_branch
\leftmargin 0.9in
\topmargin 0.75in
\rightmargin 0.9in
\bottommargin 0.75in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Sundance Example 1: Laplace's Equation in 3D
\end_layout

\begin_layout Author
Kevin Long
\end_layout

\begin_layout Section
Problem definition
\end_layout

\begin_layout Standard
This program will solve a linear boundary value problem in 3D: Laplace's
 equation
\begin_inset Formula \[
\nabla^{2}u=0\]

\end_inset

on a thin square plate with a circular through-hole in the center.
 The geometry of this plate is shown in figures 1 and 2.
 For boundary conditions, we will specify Dirichlet conditions
\begin_inset Formula \[
u=0\;\;\;\mbox{on the west edge of the plate}\]

\end_inset


\begin_inset Formula \[
u=1\;\;\;\mbox{on the east edge of the plate}\]

\end_inset

and homogeneous Neumann conditions 
\begin_inset Formula \[
\pd{u}{n}=0\]

\end_inset

on all other surfaces.
 
\end_layout

\begin_layout Standard
The Galerkin weak form of this problem is
\begin_inset Formula \[
\int_{\Omega}\nabla v\cdot\nabla u\, d\Omega-\int_{\partial\Omega}v\mathbf{n}\cdot\nabla u\, dA=0\;\;\;\forall v\in H_{0}^{1}\]

\end_inset


\begin_inset Formula \[
u=0\;\;\mbox{on west}\]

\end_inset


\begin_inset Formula \[
u=1\;\;\mbox{on east}.\]

\end_inset

In our program we'll represent this weak form in terms of symbolic expression
 objects called 
\family typewriter
Expr
\family default
s.
 As a basis for both the unknown function 
\begin_inset Formula $u$
\end_inset

 and the test function 
\begin_inset Formula $v$
\end_inset

, we will use the first-degree Lagrange functions on tetrahedral elements.
 The integrals will be computed using Gauss-Dunavant quadrature.
 
\end_layout

\begin_layout Standard
The resulting system of equations
\begin_inset Formula \[
K\mathbf{u=}\mathbf{b}\]

\end_inset

is linear and must be solved with some linear solver algorithm.
 Sundance interfaces with linearsolvers through the Playa 
\family typewriter
LinearSolver
\family default
 interface; most Trilinos solver libraries have an adapter letting them
 be used through Playa.
 
\end_layout

\begin_layout Standard
The solution vector is returned wrapped in an 
\family typewriter
Expr
\family default
 object.
 As such, it can be used in other symbolic expressions, for example, expressions
 that define post-processing steps such as flux calculations.
 Finally, it may be given to a 
\family typewriter
FieldWriter
\family default
 object that writes the solution to an output file in a format such as VTK
 or Exodus.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename plateWithHoleMesh.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
3D view of meshed plate with hole
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename plateWithHoleGeom.png
	scale 30
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schematic of labeled surfaces on the plate with hole
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Structure of a simulation program
\end_layout

\begin_layout Subsection
Initialization and finalization code
\end_layout

\begin_layout Standard
A dull but essential first step is to show the boilerplate C++ common to
 nearly every Sundance program:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "Sundance.hpp"
\end_layout

\begin_layout Plain Layout

int main(int argc, void** argv) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	try     
\end_layout

\begin_layout Plain Layout

	{       
\end_layout

\begin_layout Plain Layout

		Sundance::init(argc, argv);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      	/* code body goes here */     
\end_layout

\begin_layout Plain Layout

	}   
\end_layout

\begin_layout Plain Layout

	catch(exception& e)     
\end_layout

\begin_layout Plain Layout

	{        
\end_layout

\begin_layout Plain Layout

		Sundance::handleException(__FILE__, e);     
\end_layout

\begin_layout Plain Layout

	}   
\end_layout

\begin_layout Plain Layout

	Sundance::finalize(); 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These lines control initialization and result gathering for profiling timers,
 initializing and finalizing MPI if MPI is being used, and other administrative
 tasks.
 The body of the code -- everything else we discuss here -- goes in place
 of the comment 
\family typewriter
code body goes here
\family default
.
 
\end_layout

\begin_layout Subsection
Overview of problem setup and solution
\end_layout

\begin_layout Standard
Before diving into code, let's take a coarse-grained look at the steps involved
 in setting up and solving a linear boundary value problem.
\end_layout

\begin_layout Enumerate
Do initialization steps
\end_layout

\begin_layout Enumerate
Create the objects that define the problem's geometry
\end_layout

\begin_layout Enumerate
Create the symbolic objects that will be used in the equation specification
\end_layout

\begin_layout Enumerate
Define the weak form and boundary conditions
\end_layout

\begin_layout Enumerate
Create a 
\begin_inset Quotes eld
\end_inset

problem
\begin_inset Quotes erd
\end_inset

 object that encapsulates the equations, boundary conditions, and geometry
 along with a specification of ordering of unknowns
\end_layout

\begin_layout Enumerate
Create a solver object
\end_layout

\begin_layout Enumerate
Solve the problem
\end_layout

\begin_layout Enumerate
Do postprocessing and/or visualization output
\end_layout

\begin_layout Enumerate
Do finalization steps
\end_layout

\begin_layout Standard
In more complex problems there may be loops over one or more of these steps;
 for example, a time integration will involve a loop over many solution
 steps, with visualization output being done at selected intervals.
 
\end_layout

\begin_layout Subsection
Getting a mesh
\end_layout

\begin_layout Standard
Sundance uses a 
\family typewriter
Mesh
\family default
 object to represent a discretization of the problem's geometric domain.
 There are many ways of getting a mesh; simple meshes might be built on
 the fly at runtime, more complex meshes will need to be build offline and
 read from a file.
 There are then numerous mesh file formats.
 To accomodate the diversity of mesh creation mechanisms, Sundance uses
 an abstract 
\family typewriter
MeshSource
\family default
 interface.
 Different mesh creation modes are represented as subtypes that implement
 this abstract interface.
 
\end_layout

\begin_layout Standard
Sundance is designed to work with different mesh underlying implementations,
 the choice of which is done by specifying a 
\family typewriter
MeshType
\family default
 object.
 
\end_layout

\begin_layout Standard
In this example we read a mesh that's been stored in the Exodus format.
 The file is named 
\family typewriter
plateWithHole.exo
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MeshType meshType = new BasicSimplicialMeshType(); 
\end_layout

\begin_layout Plain Layout

MeshSource meshReader = new ExodusMeshReader("plateWithHole", meshType);
 
\end_layout

\begin_layout Plain Layout

Mesh mesh = mesher.getMesh(); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Defining geometric subdomains
\end_layout

\begin_layout Standard
We'll need to specify subsets of the mesh on which equations or boundary
 conditions are defined.
 In many FEA codes this is done by explicit definition of element blocks,
 node sets, and side sets.
 Rather than working with sets explicitly at the user level, we instead
 work with 
\emph on
filtering rules
\emph default
 that produce sets of cells.
 These rules are represented by 
\family typewriter
CellFilter
\family default
 objects.
 You can think of a cell filter as an operator that acts on a mesh and returns
 a set of cells.
 
\end_layout

\begin_layout Standard
First we define a cell filter that identifies all cells of maximal dimension:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Filter subtype MaximalCellFilter selects all cells having dimension equal
 to the spatial dimension of the mesh */
\end_layout

\begin_layout Plain Layout

CellFilter interior = new MaximalCellFilter();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next we define filters that identify the various boundary surfaces.
 In this example, boundary surfaces are specified by labels assigned to
 the mesh cells during the process of mesh generation.
 The 
\family typewriter
labeledSubset()
\family default
 member function finds those cells having a specified label.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* DimensionalCellFilter selects all cells of a specified dimension.
 Here we select all 2D faces.
 Boundary conditions will be applied on certain subsets of these.
 */
\end_layout

\begin_layout Plain Layout

CellFilter edges = new DimensionalCellFilter(2);
\end_layout

\begin_layout Plain Layout

CellFilter south = edges.labeledSubset(1);     
\end_layout

\begin_layout Plain Layout

CellFilter east = edges.labeledSubset(2);     
\end_layout

\begin_layout Plain Layout

CellFilter north = edges.labeledSubset(3);     
\end_layout

\begin_layout Plain Layout

CellFilter west = edges.labeledSubset(4);     
\end_layout

\begin_layout Plain Layout

CellFilter hole = edges.labeledSubset(5);     
\end_layout

\begin_layout Plain Layout

CellFilter down = edges.labeledSubset(6);     
\end_layout

\begin_layout Plain Layout

CellFilter up = edges.labeledSubset(7);
\end_layout

\end_inset

See figure 2 for a schematic of the various boundary surfaces.
 In subsequent examples we will see other mechanisms for identifying cells.
\end_layout

\begin_layout Subsection
Defining symbolic expressions
\end_layout

\begin_layout Standard
An equation is built out of mathematical expressions.
\end_layout

\begin_layout Subsubsection
Basis families
\end_layout

\begin_layout Standard
Discretization 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Create an object representation of the first-degree Lagrange basis */
\end_layout

\begin_layout Plain Layout

BasisFamily basis = new Lagrange(1);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Test and unknown functions
\end_layout

\begin_layout Standard
With a basis defined, we set up symbolic expressions for the unknown function
 and test function that appear in the weak form.
 They are constructed as in this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr u = new UnknownFunction(basis, "u");     
\end_layout

\begin_layout Plain Layout

Expr v = new TestFunction(basis, "v");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The string arguments 
\family typewriter

\begin_inset Quotes eld
\end_inset

u
\begin_inset Quotes erd
\end_inset


\family default
 and 
\family typewriter

\begin_inset Quotes eld
\end_inset

v"
\family default
 are optional and are used only in labeling these functions in diagnostic
 output.
 Any label can be used; there is no need for the string's value to be identical
 to the name of the C++ variable.
\end_layout

\begin_layout Subsubsection
Differential operators
\end_layout

\begin_layout Standard
Differential operators are also represented as 
\family typewriter
Expr
\family default
 objects.
 The next code fragment shows the construction of partial derivative operators
 and their aggregation into a gradient.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Create differential operators and coordinate functions.
 Directions are 
\end_layout

\begin_layout Plain Layout

 * indexed starting from zero.
 The List() function can collect 
\end_layout

\begin_layout Plain Layout

 * expressions into a vector.
 */     
\end_layout

\begin_layout Plain Layout

Expr dx = new Derivative(0);    /* The operator $
\backslash
pd{}{x}$ */
\end_layout

\begin_layout Plain Layout

Expr dy = new Derivative(1);    /* The operator $
\backslash
pd{}{y}$ */  
\end_layout

\begin_layout Plain Layout

Expr dz = new Derivative(2);    /* The operator $
\backslash
pd{}{z}$ */  
\end_layout

\begin_layout Plain Layout

Expr grad = List(dx, dy, dz);   /* The operator $
\backslash
nabla$   */
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Coordinate expressions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr x = new CoordExpr(0);     
\end_layout

\begin_layout Plain Layout

Expr y = new CoordExpr(1);     
\end_layout

\begin_layout Plain Layout

Expr z = new CoordExpr(2);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Equations and boundary conditions
\end_layout

\begin_layout Subsubsection
Numerical integration rules
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* We need a quadrature rule for doing the integrations */     
\end_layout

\begin_layout Plain Layout

QuadratureFamily quad2 = new GaussianQuadrature(2);     
\end_layout

\begin_layout Plain Layout

QuadratureFamily quad4 = new GaussianQuadrature(4);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Watching expressions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WatchFlag watchMe("watch me");     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("symbolic preprocessing", 1);     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("discrete function evaluation", 3);     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("integration setup", 6);     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("integration", 6);     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("fill", 6);     
\end_layout

\begin_layout Plain Layout

watchMe.setParam("evaluation", 2);     
\end_layout

\begin_layout Plain Layout

watchMe.deactivate(); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Integrals
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Write the weak form */
\end_layout

\begin_layout Plain Layout

Expr eqn = Integral(interior, (grad*u)*(grad*v), quad2, watchMe);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Essential boundary conditions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr h = new CellDiameterExpr();     
\end_layout

\begin_layout Plain Layout

Expr bc = EssentialBC(west, v*u/h, quad2)+EssentialBC(east, v*(u-1.0)/h,
 quad2);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Defining a linear problem
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LinearProblem prob(mesh, eqn, bc, v, u, vecType);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solving a linear problem
\end_layout

\begin_layout Subsubsection
Getting a solver
\end_layout

\begin_layout Subsubsection
Doing the solve
\end_layout

\begin_layout Subsection
Visualization output
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Write the results to a VTK file */
\end_layout

\begin_layout Plain Layout

FieldWriter w = new VTKWriter("PoissonDemo3D");     
\end_layout

\begin_layout Plain Layout

w.addMesh(mesh);     
\end_layout

\begin_layout Plain Layout

w.addField("soln", new ExprFieldWrapper(soln[0]));     
\end_layout

\begin_layout Plain Layout

w.write();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename plateWithHole3D.jpg
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solution of Laplace's equation on the holed plate.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Postprocessing
\end_layout

\begin_layout Standard
We now show several examples of postprocessing computations using the solution
 expression 
\family typewriter
soln
\family default
.
 The first example is the computation of the flux
\begin_inset Formula \[
\int_{\mbox{east+west}}\mathbf{n}\cdot\nabla u\, dA.\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr n = CellNormalExpr(3, "n");     
\end_layout

\begin_layout Plain Layout

Expr fluxExpr = Integral(east + west, (n*grad)*soln, quad2);      
\end_layout

\begin_layout Plain Layout

double flux = evaluateIntegral(mesh, fluxExpr);     
\end_layout

\begin_layout Plain Layout

Out::os() << "numerical flux = " << flux << endl;
\end_layout

\end_inset

In the next example, we compute the center-of-mass position of the body
 
\begin_inset Formula $\Omega$
\end_inset

,
\begin_inset Formula \[
x_{CM}=\frac{1}{V\left(\Omega\right)}\int_{\Omega}x\, d\Omega\]

\end_inset

and similarly for 
\begin_inset Formula $y_{CM}$
\end_inset

 and 
\begin_inset Formula $z_{CM}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr volExpr = Integral(interior, 1.0, quad2);
\end_layout

\begin_layout Plain Layout

Expr xCMExpr = Integral(interior, x, quad2);     
\end_layout

\begin_layout Plain Layout

Expr yCMExpr = Integral(interior, y, quad2);     
\end_layout

\begin_layout Plain Layout

Expr zCMExpr = Integral(interior, z, quad2);    
\end_layout

\begin_layout Plain Layout

double vol = evaluateIntegral(mesh, volExpr);
\end_layout

\begin_layout Plain Layout

double xCM = evaluateIntegral(mesh, xCMExpr);     
\end_layout

\begin_layout Plain Layout

double yCM = evaluateIntegral(mesh, yCMExpr);     
\end_layout

\begin_layout Plain Layout

double zCM = evaluateIntegral(mesh, zCMExpr);     
\end_layout

\begin_layout Plain Layout

Out::os() << "centroid = (" << xCM << ", " << yCM << ", " << zCM << ")"
 << endl;
\end_layout

\end_inset

We next compute the first Fourier sine coefficient of the solution on the
 surface of the hole, 
\begin_inset Formula \[
A_{1}=\frac{\int_{\mbox{hole}}u\sin\phi\, d\Omega}{\int_{\mbox{hole}}\sin^{2}\phi\, d\Omega}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* Compute $
\backslash
sin
\backslash
phi$ from Cartesian coordinates $(x,y)$ */
\end_layout

\begin_layout Plain Layout

Expr r = sqrt(x*x + y*y);     
\end_layout

\begin_layout Plain Layout

Expr sinPhi = y/r;     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Define expressions for the Fourier coefficients */
\end_layout

\begin_layout Plain Layout

Expr fourierSin1Expr = Integral(hole, sinPhi*soln, quad2); 
\end_layout

\begin_layout Plain Layout

Expr fourierDenomExpr = Integral(hole, sinPhi*sinPhi, quad2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Evaluate the integrals */    
\end_layout

\begin_layout Plain Layout

double fourierSin1 = evaluateIntegral(mesh, fourierSin1Expr);
\end_layout

\begin_layout Plain Layout

double fourierDenom = evaluateIntegral(mesh, fourierDenomExpr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Write the results */  
\end_layout

\begin_layout Plain Layout

Out::os() << "fourier sin m=1 = " << fourierSin1/fourierDenom << endl;
\end_layout

\end_inset

As the final postprocessing example, we compute the 
\begin_inset Formula $L^{2}$
\end_inset

 norm of the solution 
\begin_inset Formula $u$
\end_inset

,
\begin_inset Formula \[
\left\Vert u\right\Vert _{2}=\sqrt{\int_{\Omega}u^{2}\, d\Omega}.\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Expr L2NormExpr = Integral(interior, soln*soln, quad2);     
\end_layout

\begin_layout Plain Layout

double l2Norm_method1 = sqrt(evaluateIntegral(mesh, L2NormExpr));     
\end_layout

\begin_layout Plain Layout

Out::os() << "method #1: ||soln|| = " << l2Norm_method1 << endl;
\end_layout

\end_inset

Norm computation is a common enough operation that Sundance provides several
 built-in functions to compute various norms.
 For example, the previous computation can be carried out more compactly
 through the code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double l2Norm_method2 = L2Norm(mesh, interior, soln, quad);     
\end_layout

\begin_layout Plain Layout

Out::os() << "method #2: ||soln|| = " << l2Norm_method2 << endl;
\end_layout

\end_inset

Similar functions exist for the computation of the 
\begin_inset Formula $H^{1}$
\end_inset

 norm and 
\begin_inset Formula $H^{1}$
\end_inset

 seminorm.
\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Enumerate
Change the BC on the hole to 
\begin_inset Formula \[
\pd{u}{n}=1.\]

\end_inset

In a postprocessing step, compute and compare the fluxes
\begin_inset Formula \[
Q_{\mbox{hole}}=\int_{\mbox{hole}}\mathbf{n}\cdot\nabla u\, dA\]

\end_inset


\begin_inset Formula \[
Q_{\Omega\backslash\mbox{hole}}=\int_{\Omega\backslash\mbox{hole}}\mathbf{n}\cdot\nabla u\, dA.\]

\end_inset

Verify that the net flux is zero.
\end_layout

\begin_layout Enumerate
Define an expression that will compute the average element diameter.
\end_layout

\end_body
\end_document
