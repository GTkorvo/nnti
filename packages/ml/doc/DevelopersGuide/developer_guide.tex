\documentclass[10pt,letter,relax]{SANDreport}

\usepackage{psboxit}
\usepackage{times}
\pagenumbering{arabic}
\bibliographystyle{alpha}
\newtheorem{remark}{Remark}
\newcommand{\HRule}{\noindent\rule{\linewidth}{1mm}}
\title{ML 3.0 Developer's Guide}
\SANDnum{SAND2004-XXXX}
\SANDauthor{
Marzio Sala, Jonathan J. Hu, Ray S. Tuminaro}

\SANDprintDate{May 2004}
\SANDreleaseType{Internal Use Only}

\title{ML 3.0 Developer's Guide (DRAFT)}
\author{
Marzio  Sala \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
P.O.~Box 5800 \\
Albuquerque, NM 87185-1110\\[20pt]
Jonathan J. Hu $\quad$ and $\quad$
Ray S. Tuminaro \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
P.O.~Box 0969, MS 9159\\
Livermore, CA 94551-0969\\
}

\date{\today}

\newcommand{\Aztec}  {{\bf Aztec }}
\newcommand{\ML}     {{\bf ML }}
\newcommand{\be}     {\begin{enumerate}}
\newcommand{\ee}     {\end{enumerate}}
\def\optionbox#1#2{\noindent$\hphantom{ii}${\parbox[t]{1.5in}{\it
#1}}{\parbox[t]{4.8in}{#2}} \\[1.1em]}

\def\choicebox#1#2{\noindent$\hphantom{th}$\parbox[t]{3.10in}{\sf
#1}\parbox[t]{3.35in}{#2}\\[0.8em]}

\def\structbox#1#2{\noindent$\hphantom{hix}${\parbox[t]{2.10in}{\it
#1}}{\parbox[t]{3.9in}{#2}} \\[.02cm]}

\def\protobox#1{\vspace{2em}{\flushleft{\bf Prototype}
\hrulefill}\flushleft{\fbox{\parbox[t]{6in}{\vspace{1em}{\sf
#1}\vspace{1em}}}}}

\begin{document}

\maketitle

%\setcounter{page}{3} % Accounts for blank page at beginning
\begin{abstract}
\ML\ is a multigrid preconditioning package intended to solve linear systems
 of equations $A x = b$ where $A$ is a user supplied $n \times n$ sparse
matrix, $b$ is a user supplied vector of length $n$ and $x$ is a vector of
length $n$ to be computed. \ML\ should be used on large sparse linear
systems arising from partial differential equation (PDE) discretizations.
For an overview of ML, we refer to the ML users' guide.

This guide is intended for anyone who will be adding to or modifying the \ML
source code.  This document contains suggested practices, naming conventions,
and autoconf/automake hints.  We don't intend for this document to be a set
of hard-and-fast rules, but rather {\em suggested} and {\em encouraged}
practices. These guidelines are intended to be complimentary to policies
established in the Trilinos Developers Guide~\cite{Trilinos-Dev-Guide}.
\end{abstract}

\clearpage

\section*{Acknowledgments}
The authors would like to acknowledge the support of the ASCI and LDRD 
programs that funded development of ML.

\clearpage

\SANDmain

\tableofcontents

\clearpage
\newpage

%%% ========= %%%
%%% I N T R O %%%
%%% ========= %%%

\vspace*{3cm}
\HRule
\part{ML and Related Tools}
\bigskip

\hfill
\begin{tabular}{p{8cm}}
\begin{boxitpara}{box 0.7 setgray fill}
{\tt
        int
        i;main(){for(;i--<i;++i){--i;}"]; read(i+++,"hello,
          world!",++i++));} read(j,i,p){write(j/p+p,i---j,i/i);}
}
--Obfuscated C Code. Author requested anonymity. 
\end{boxitpara}
\end{tabular}
\HRule

\clearpage
\newpage

%%%
%%%
%%%

\section{Introduction}

%This document was written with the\ML is a large software project (composed by more than 100 thousand
%lines),
\ML development was started in 1997 by Ray Tuminaro and Charles Tong.
Currently, there are 5 full- and part-time developers.
The kernel of \ML is written in ANSI C, and there is a rich C++ interface
for Trilinos users and developers. 

\ML can be customized to run geometric and algebraic multigrid; it can
solve a scalar or a vector equation (with constant number of equations
per grid node), and it can solve a form of Maxwell's equations.
For a general
introduction to \ML and its applications, we refer to the Users
Guide~\cite{ml_users_guide}, and to the \ML web site,
http://software.sandia.gov/ml. 

\subsection{Extensibility}
\label{extensibility}
%
\ML is designed to be {\sl flexible}. Developers can easily add, for example,
\begin{itemize}
%\setlength{\itemsep}{-2pt}
\item new aggregation schemes;
\item new smoothers;
\item new coarse solvers;
\item new multigrid cycles;
\end{itemize}
However, developers should keep the following goals in mind:
\begin{enumerate}
\item Code should be robust and error free.
\item Code should be easy to use and understand.
\item Code should be easy to maintain.
\end{enumerate}
This guide furnished guides, suggestions, and guidelines to help present and
future \ML developers. 

Although all sections of this guide will be useful to most developers,
it is worth mentioning that this guide supports three types of
development activities:
\begin{enumerate}
\item Configuration and building: how to manage the autotools, how to
  add a new file/example/test;
\item Documentation: how to write Doxygen comments. This guide is not an
  introduction to Doxygen, but we give some simple hints to generate
  efficient Doxygen documentation;
\item Coding conventions: how to write code in \ML.
\end{enumerate}

\begin{remark}
  As a note, we recall that guidelines for \ML coding style and other
  suggestions are just that, guidelines and
  suggestions. They are not intended to be obeyed zealously.
  In fact, much of \ML does not strictly adhere to these guidelines because
  most of the \ML code was developed when this developer's
  guide did not yet exist.
  
\end{remark}

%%%
%%%
%%%

\section{How To Use This Guide}
\label{sec:how}

The goal of this document is to guide new \ML developers in:
\begin{itemize}
%\setlength{\itemsep}{-2pt}
\item getting started (in Section~\ref{sec:started});
\item modifying how \ML is configured and built (in Section~\ref{sec:configure});
\item knowing what to do to extend \ML (in Section~\ref{sec:extend});
\item using available development tools: Bonsai, Bugzilla, Mailman, and the
cvs repository 
  (in Section~\ref{sec:tools});
\item writing Doxygen documentation (in Section~\ref{sec:doxygen});
\item adding a new test to the \ML repository (in Section~\ref{sec:add_test});
\item defining some suggested practices to write code for \ML (in Section~\ref{sec:code});
\item better understanding the \ML structures (in Section~\ref{sec:structures});
\item understanding current and future \ML developments (in
  Section~\ref{sec:to-do}).
\end{itemize}

\begin{remark}
  The aim of the following section is to be useful in that part of code
  development that has proved to be painful in the past. Unfortunately,
  only a limited part of \ML's capabilities will be covered in this
  document.
  Developers are encouraged to
  \begin{enumerate}
    \item keep this guide up to date after each relevant change;
    \item add his own experience;
    \item extend the manuscript whenever important topics arise.
  \end{enumerate}
\end{remark}

%%%
%%%
%%%

\section{Notational Conventions}

In this guide, we show typed commands in this font:
\begin{verbatim}
% a_really_long_command
\end{verbatim}
The character \verb!%! indicates any shell prompt\footnote{For
  simplicity, commands are shown as they would be issued in a Linux or
  Unix environment.  Note, however, that \ML\ has and can be built
  successfully in a Windows environment.}.
Function names are shown as {\tt ML\_Gen\_Solver}.  Names of packages or
libraries as reported in small caps, as {\sc Epetra}. Mathematical
entities are shown in italics.

%%%
%%%
%%%

\section{Getting Started}
\label{sec:started}

\ML can be obtained in different ways. Here, we suppose that the
developer has access to the CVS repository on {\tt
  software.sandia.gov}. In addition, the user account must be in the
{\tt trilinos} and {\tt cvs} group on this computer. To request an
account, send a note to {\tt trilinos-help@software.sandia.gov}.  The
following variables must be defined:
\begin{verbatim}
CVSROOT=:ext:your_user_name@software.sandia.gov:/space/CVS
CVS_RHS=ssh
\end{verbatim}
(Replace \verb!your_user_name! with your login name.) To check out a
working copy of \ML in the current directory, type
\begin{verbatim}
cvs checkout ml
\end{verbatim}
For a more detailed description of CVS commands, we refer to the
Trilinos Developers Guide~\cite{Trilinos-Dev-Guide}, and to the GNU CVS home.

Please refer to the ML Users Guide for guidance in configuring \ML,
We suggest creating a simple script that contains all the parameters for {\tt
configure}. Be sure to use continuation characters ('\verb!\!') properly.
The characters should be at the end of every line, except the last line, and
should not be followed by any space.  Recall that autoconf cannot detect
spelling mistakes in configure invocation scripts.

\begin{remark}
  Other tips for making the configure and build more efficient can
  be found in \cite[Section 2.6]{Trilinos-Dev-Guide}.
\end{remark}

%%% ============================= %%%
%%% P A R T  2 : use of configure %%%
%%% ============================= %%%

\clearpage
\newpage

\vspace*{3cm}
\HRule
\part{Configuration and Building}

\medskip

\hfill
\begin{tabular}{p{5cm}}
\begin{boxitpara}{box 0.7 setgray fill}
``C combines the power of assembler with the portability of assembler.''
                                 -- Anonymous
\end{boxitpara}
\end{tabular}

\HRule
\clearpage
\newpage

%%%
%%%
%%%

\section{Modifying how \ML is configured and built}
\label{sec:configure}

\ML is built using the GNU tools autoconf and automake~\cite{Autoconf,Automake}.

As a small example of how to add a new configure option, let us 
assume that the current working director is Trilinos/packages/ml.
The file configure.ac contains all of the configure line option definitions
(e.g., \verb!--enable-ml_flops!).   Suppose that we want to add the configure option
``\verb!--enable-ml_foo!". (Note that \verb!ml_foo! has an underscore
and {\sl not} a dash.)

We first add the following line to \verb!configure.ac!:
\begin{verbatim}
TAC_ARG_ENABLE_OPTION(ml_foo, [This enables the foo option.], ML_FOO, no)
\end{verbatim}
We then run bootstrap:
\begin{verbatim}
% ./bootstrap
... some output here ...
\end{verbatim}
Among other things, bootstrapping  will modify
\verb!src/ml\_config.h.in! and create a new macro, \verb!HAVE_ML_FOO!.
When \ML is configured, the file \verb!ml\_config.h! is created.
If the option \verb!--enable-ml_foo! was supplied on the command line, then
\verb!HAVE_ML_FOO! will be defined in \verb!ml_config.h!.

We could use this macro directly in \ML.
Suppose, however, the macro \verb!ML_FOO! is already used
heavily in \ML, and we don't want to change the ml source.
\ML has an include file, \verb!src/Include/ml\_common.h!, that is included in
every \ML source file.
We add the following to \verb!ml_common.h!:
\begin{verbatim}
#ifdef HAVE_ML_FOO
#define ML_FOO
#endif
\end{verbatim}
and voila!   Adding \verb!--enable-ml_foo! on the configure line will now define the
macro \verb!ML_FOO! inside the ml source.

%%%
%%%
%%%

\section{How and Why to Add a New Test}
\label{sec:add_test}

\ML has a test suite that is automatically
executed every night on a variety of platforms.
This suite verifies
that important part of the code execute correctly, and
that developers' changes do not affect existing code.  For more details
on the test harness, we refer to \cite[Section 3.3]{Trilinos-Dev-Guide}.

There are two ways of adding a new test:
\begin{enumerate}
\item Method 1: Adding a separate executable just for testing.
\begin{enumerate}
\item Create a new subdirectory in \verb!<ml-dir>/test! (for example,
  {\tt new-test}).
\item Put the test source code and the corresponding makefile in {\tt
    new-test}.
\item Add {\tt new-test} to the script file(s), that is located in one or all
of the following:
\begin{verbatim}
<ml-dir>/test/scripts/daily/mpi
<ml-dir>/test/scripts/daily/serial
<ml-dir>/test/scripts/weekly/mpi
<ml-dir>/test/scripts/weekly/serial
\end{verbatim}
(Currently, \ML has daily test only.) {\tt new-test} should be added to
the {\tt foreach} block.
\item Modify {\tt <ml-dir>/configure.ac}, by adding {\tt new-test} to
  the list contained in {\tt AC\_CONFIG\_FILES}.
\item Run {\tt bootstrap}.
\end{enumerate}
\item Method 2: Using an example from ml/examples for testing.
\begin{enumerate}
\item Create a new subdirectory in \verb!<ml-dir>/test! (for example,
  {\tt new-test}).
\item Create an appropriate \verb!Makefile.am! in {\tt new-test}.
We suggest copying and modifying the \verb!Makefile.am! from
\verb!ml/test/2d_Poisson!.
\item Create an appropriate driver script in {\tt new-test} by
copying and modifying the \verb!2d_Poisson.csh! script from
\verb!ml/test/2d_Poisson!.
You should only need to change the value of the executable name at the top
of the script.
\item Append {\tt new-test} to the variable {\tt TEST\_SUBDIRS} in the script
 file \verb!Test_MLExamples! located in one or all of the following:
\begin{verbatim}
<ml-dir>/test/scripts/daily/mpi
<ml-dir>/test/scripts/daily/serial
<ml-dir>/test/scripts/weekly/mpi
<ml-dir>/test/scripts/weekly/serial
\end{verbatim}
(Currently, \ML only has daily tests.)
\item Modify {\tt ml/configure.ac} by adding {\tt new-test} to
  the list contained in {\tt AC\_CONFIG\_FILES}.  (This is near the bottom
  of {\tt configure.ac}.)
\item Run {\tt bootstrap}.
\end{enumerate}
\end{enumerate}

A new test should be added to the test harness suite when a new feature
has been included in \ML. 

%%%
%%%
%%%

\section{How to Write Doxygen Documentation}
\label{sec:doxygen}

This section gives some general guidelines about how to write Doxygen
documentation.  First, a comment on writing comments: you want your comments
to tell {\sl what your} code does, not {\sl how}.  Remember also that comments
are good, but there is also a danger of over-commenting. You can make small
comments to note or warn about something particularly clever (or ugly), but
try to avoid excess.  Instead, put the comments at the head of the function,
telling people what it does, and possibly {\sl why} it does it.  Ideally,
The best way to write comment would be to write the code so that the working
is obvious, and it's a waste of time to explain badly written code.

\ML uses doxygen for the comments~\ref{doxygen} in C++ code. Most
  of the C code is not Doxygen-complaint. (However, the most important
  \ML structures have Doxygen comments.) It is better to write good

For C++ code, always put Doxygen comments every class, and every
  function in the header file.  Other non-doxygen comments can be added
  to the source file.
Also, comment everything in headers. This is where the
  interface is, and where people usually look for help.

It is suggested to start a new file with a small Doxygen comment of type:
\begin{verbatim}
/*!
 *  \file <file name>
 *
 *  \brief <Brief description of file content>
 *
 *  \author <Author Name>
 *
 *  \date <Creation and last modification>
 *
 */
\end{verbatim}

Functions/methods can be commented in Doxygen stle as
\begin{verbatim}
/*! Here a brief description of the function */
/**
 * Search a string in a buffer.
 *
 * @param buffer the buffer in which to search.
 * @param string the string to look for.
 * @return the index of the first occurrence.
 */
int ML_find_string(Buffer& buffer, String& string);
\end{verbatim}
This allows the automatic generation of HTML documentation. 

\begin{remark} 
  Mark every bug and/or potential problem in the code with a comment
  starting with \verb!FIXME:!. This makes it very easy to locate such
  problems with tools like grep. Also, some editors (like \verb!vim!)
  automatically highlight the FIXME keyword.
\end{remark}

%%%
%%%
%%%

\section{Related Tools}
\label{sec:tools}
%
\subsection{Bonsai}
\label{bonsai}
Bonsai is a viewer for the CVS repository that runs via a web browser.
Some of its capabilities include
        \begin{enumerate}
	\item file browsing, with or without "blame" annotation
	\item differencing of file versions
	\item repository searches based on file or directory names
	\item determining CVS changes based on date or time
        \end{enumerate}
Bonsai is located at http://software.sandia.gov/bonsai.
%
\subsection{Bugzilla}
%
Users and developers are encouraged to use Bugzilla~\ref{bugzilla}, to
report configuration problems, bugs, suggest enhancements, or request
new features. Bugzilla can be found on the web at 
\begin{verbatim}
http://software.sandia.gov/bugzilla
\end{verbatim}
If reporting a configuration problem or a bug, please attach the
configure script that has been used, and the compilation and/or run-time
error.

\subsection{How to Use the CVS Repository}

\ML sources are contained in a CVS repository. 
Remember that CVS log files are part of \ML's official
  documentation and therefore may (almost certainly, in fact) be seen by
  persons outside the development team.  With that in mind, write a CVS
  log message as if it will be published for the world to see.

\begin{remark}
  When checking in a fix that addresses a bug reported in bugzilla,
  include the bug number.  Also include a short description of the fix.
\end{remark}

\subsection{Mailing Lists}

Any substantive developer discussion should take place on the \ML
developer's list, 
\begin{verbatim}
ml-developers@software.sandia.gov
\end{verbatim}
If the discussion is off-line, it's entirely appropriate to email a
summary of the discussion to the list.

The list archives the discussion.  This can be helpful to the
developers.  Moreover, this discussion can be used as documention during
external reviews.

%%%
%%%
%%%

\section{Exporting \ML's dependencies to other packages}
\label{exporting dependencies}

\ML's dependencies are exported to other packages via the file
{\tt ml/Makefile.export.in}.
When \ML is configured, autoconf produces the file {\tt Makefile.export},
which defines the variable {\tt ML\_EXPORT\_LIBS}. 
Packages that depend on \ML should use {\tt ML\_EXPORT\_LIBS} in their
configure and build process to ensure their link lines are correct.

If a dependency on package {\tt XX} is introduced during \ML development,
this dependency should be added to {\tt ml/Makefile.export.in} as follows.
\begin{enumerate}
    \item Modify the definition of {\tt ML\_EXPORT\_LIBS} by appending
\begin{verbatim}
 -L$(XX_BUILD_DIRECTORY)/src  $(XX_LIBS)
\end{verbatim}
 

    \item Give the location of {\tt XX}'s build directory:
\begin{verbatim}
XX_BUILD_DIRECTORY = $(ML_BUILD_DIRECTORY)/../XX
\end{verbatim}

    \item Give the name of the XX library:
\begin{verbatim}
HAVE_ML_XX = @HAVE_ML_XX@
ifeq ($(HAVE_ML_XX),true)
XX_LIBS = libXX.a
else
XX_LIBS =
endif
\end{verbatim}
Note that {\tt XX\_LIBS} is defined only if \ML has been configured with
{\tt XX} enabled.
\end{enumerate}


%%%
%%%
%%%

\section{FAQ}
\label{sec:faq}

\begin{enumerate}
\item {\bf Question:} The {\bf ./configure} command
fails with the following error:
\begin{verbatim}
checking for Fortran 77 libraries...
checking for dummy main to link with Fortran 77 libraries... unknown
configure: error: linking to Fortran libraries from C fails
See `config.log' for more details.
\end{verbatim}~\\
{\bf Answer:} The most likely problem is an incorrect configure line option.
Check that all of the library and include locations that you've specified are
correct.
Look in config.log to find the exact error.
%
\item {\bf Question:} I am building with LAM under PH9 Linux, and
  {\tt configure} complains that it cannot find {\tt mpi++.h}.\\
{\bf Answer:} Add \verb!-DLAM_BUILDING! to your CXX parameters; for
instance,
\begin{verbatim}
../configure --with-cxxflags="-DLAM_BUILDING"
\end{verbatim}
%
\item {\bf Question:} I'm getting warnings about non-modifiable left hand sides
when using ML\_free.\\
{\bf Answer:} ML\_free is a macro.  No casting of the argument is necessary or
even correct.
The argument to ML\_free is used within the
macro source on the left hand side of a logical check.
  \begin{enumerate}
    \item[ ] Good: ML\_free(i);
    \item[ ] Bad: ML\_free( (void *) i); (does not compile on SGI, for instance)
  \end{enumerate}
%
%
\item {\bf Question: Are C++ style comments, i.e, \verb!//!, ok to use in
ML?}\\
{\bf Answer:} C++ style comments are fine to use in C++ files.
You must use C style comments, i.e., \verb!/* */!, in \verb!*.c! files.
Otherwise, the code will not compile on either Solaris machines or on Janus.
\end{enumerate}

%%% ================================ %%%
%%% C O D I N G    P R A C T I C E S %%%
%%% ================================ %%%

\clearpage
\newpage

\vspace*{3cm}
\HRule
\part{Coding Practices}

\medskip

\hfill
\begin{tabular}{p{5cm}}
\begin{boxitpara}{box 0.7 setgray fill}
When the code and the comments disagree, both are probably wrong.
\end{boxitpara}
\end{tabular}

\HRule
\clearpage
\newpage

%%%
%%%
%%%

\section{Suggested Practices}
\label{sec:code}

\ML is written in both C and C++.
The C++ programming language differs substantially from the C
programming language. In terms of usage, C is more like Pascal than it
is like C++. This style guide differs from traditional C style guides in
places where the ``C mindset'' is detrimental to the object-oriented
outlook desired for C++ development.

Therefore, it is important to adopt good coding habits, one for C, and
another for C++. A good style guide can enhance the quality of the code
that we write.  This style guide tries to present a standard set of
methods for achieving that end.

It is, however, the end itself that is important. Deviations from this
standard style are acceptable if they enhance readability and code
maintainability. Major deviations require a explanatory comment at each
point of departure so that later readers will know that you didn't make
a mistake, but purposefully are doing a local variation for a good
cause.

Further suggestions on ``how to write good C/C++ code'' can be found,
for instance, in the NOX guide, the Epetra Developers Coding
Guidelines~\cite{Epetra-Dev-Guide}.

\subsection{General}

\begin{itemize}
\item Any code that links to Trilinos, and any Trilinos file must define
  \verb!HAVE_CONFIG_H!.
\item Although there is no maximum length requirement for source files,
  files with more than about 1000 lines are cumbersome to deal
  with. (Unfortunaly many \ML files are longer than 1000 lines.)
\item Lines longer than 80 columns should be avoided. Use C/C++'s string
  concatenation to avoid unwieldy string literals and break long
  statements onto multiple lines. 
\begin{verbatim}
char *s1 = "hello\n"
           "world\n";                    // s1 is exactly the same as s2,
char *s2 = "hello\nworld\n";
\end{verbatim}
The line length limit is related to the fact that many printers and
terminals are limited to an 80 character line length. Source code that
has longer lines will cause either line wrapping or truncation on these
devices. Both of these behaviors result in code that is hard to read.
\item No \verb!#pragma! directive should be used. \verb!#pragma!
  directives are, by definition, non-standard, and can cause unexpected
  behavior when compiled on other systems. On another system, a \verb!#pragma!
  might even have the opposite meaning of the intended one.
\item Macros are almost never necessary in C++.  The construct \verb!#define!
  NAME value should never be used. Use a const or enum instead.
  
  The debugger can deal with them symbolically, while it can't with a
  \verb!#define!, and their scope is controlled and they only occupy a
  particular namespace, while \verb!#define! symbols apply everywhere except
  inside strings.
  
  Macros in C are frequently used to define "maximum" sizes for things.
  This results in data structures that impose arbitrary size
  restrictions on their usage, a particularly insidious source of bugs.
  Try not to carry forward this limitation into C++.
\item When incrementally modifying existing code, follow the style of the code you are modifying, not your favorite style. Nothing is harder to read than code where the personal style changes from line to line.
\item Don't use global data. Consider using file- or class-static data members instead.
\item File static variables are more appropriate than class-static
  variables, since they hide more of the class's implementation from the
  reader of the header file. Of course, if you class implementation does
  not fit within one file, this technique will not be usable.
\item A char may be unsigned or signed. You can't assume either. Thus,
  only use (unmodified) char if you don't care about sign extension and
  can live with values in the range of 0-127.
\item Always provide the return type of a function explicitely, The value
  being returned should be enclosed in parenthesis.
  \begin{verbatim}
  return i;  // No!
  return(i); // Yes
  \end{verbatim}
\item Functions with a return type of void should use an "empty" return
  statment.
  \begin{verbatim}
  void foo() {
     ...
     return;
  }
  \end{verbatim}
\item Functions that don't take any paramer should use an empty parameter
list, and not say void.
\item Always define a pointer when you  declarare it. Either set it equal to
an address in memory, or set it equal to zero. If you don't define a pointer
as you declare it, you will never know if it will be accessed before you
assign to it. This goes both for local variables, and for class members in
constructors.
\item Use zero (0) instead of NULL in C++ code.
\item Always inlcude a default case in a \verb!switch! statment, or in a
sequence of \verb!if-else!'s.
\item Do not use spaces around `.' or `->', or between unay operators and
operands.
\item Always provide a space on both sides of `=' signs and all loginal
operators.
\item Use parenthesis to make the code readable.
\item The block of any \verb!if! statement should always follow on a separate
line.
\begin{verbatim}
if (/*Something*/) i++; // No!

if (/*Something*/)      // Yes!
  i++;
\end{verbatim}
\item Operators should have a space on both sides of them. 
(Exception if the \verb!*! and \verb!&! deferencing operators.). This makes it
easier to distringuish which usage is intended.
\begin{verbatim}
int* a   // defining a pointer to int
a * b    // multiplying two variables
*a       // deferencing a pointer
\end{verbatim}
\end{itemize}

\subsection{File Naming Conversions}

\begin{itemize}
\item C and C++ header files end in \verb!.h!;
\item C source files end in \verb!.c!, and C++ source files end in
\verb!.cpp!;
\item All file (header and source, for library and examples) begin with \verb!ml_!;
\item For C++ files, the name of the files should correspond to the name of
the class they define.
\end{itemize}

\subsection{Include File Structure}

\begin{itemize}
\item Every include file must contain a mechanism that prevents multiple
inclusions of the file. For example, the following should follow the header
information for the file \verb!ml_foo.h!:
\begin{verbatim}
#ifndef ML_FOO_H
#define ML_FOO_H

...body of include file goes here

#endif
\end{verbatim}
\item HOW DO WE DEAL WITH MPI???
\item HOW DO WE DEAL WITH include system files??
\item Definition of classes that are only accesse via pointers (\verb!*!) or
references (\verb!&!) should be declared using forward declarations, and not by
including the header files.
\end{itemize}

\subsection{Naming Conventions}

\begin{itemize}
\item All \ML functions should begin with \verb!ML_!;
\item All \ML-Epetra C++ functions and classes should be in the namespace {\tt
  ML\_Epetra};
\item All \ML functions should begin with an uppercase letter;
\item All \verb!Get! or \verb!Set! functions should be as follows:
\verb!ML_Get_PrintLevel()!;
\item All \ML class names should begin with an uppercase letter;
\item All \ML class data members should end with an underscore (e.g. \verb!int NumLevel_!).
No other variable names should ever end with an underscore;
\item Do not use identifiers that begin with one or two underscores;
\item Accessor method should have the same name as the attribute they access,
  without the underscore:
  \begin{verbatim}
  int someVar_;
  int SomeVar() { return someVar_);
  \end{verbatim}
\item Variables used for loops counters should be names \verb!i,j,k!, etc.
  in that order. 
\end{itemize}

\subsection{C++}

\begin{itemize}
\item For C++ code, C-style casts should never be used. User
  \verb!static_cast!, \verb!reinterprest_cast!, and \verb!const_cast! instead.
\item \verb!const_cast! should be avoided as much as possible. When you need
to modify an object that is logically const but not bitwise const, use the
\verb!mutable! keyword instead.
\item Member definition in constructors: Member definition should be formatted
  as follows, each on their own line, with the colon preceding the first one,
a comma following all but the last one, and the opening curl brace of the
  function beody on a new line.
  \begin{verbatim}
  MLClass::MLClass(int foo)
  : SomeMemberVar(0),
  SomeOtherVar(foo+1)
  {
    ...
  }    
  \end{verbatim}
\item The characters `\verb!*!' and `\verb!&!' should be
written in the following way:
\begin{verbatim}
int* pointer;
double& ref;
\end{verbatim}
Instead of saying the \verb!*i! is of type \verb!int!, say that \verb!i! is of
  type \verb!int*!.
\item Whenever possible, we prefer member initialization to assignment in the
  body of the constructor.
\item Declare only one variable per line.
\begin{verbatim}
int i,j; // No!
int i;
int j;
\end{verbatim}
This is mainly to avoid confusion resulting from mixing \verb!int! and
  \verb!int *! declarations, and also to give room for additional comments
  (when required).
\item The inclusion of every non-C++ header file must be surrounded by
  the extern "C" { } construct.
\item Function calls that are intended to be called from C that take input-only struct arguments may wish to use pointers, since C does not have references. Such pointers must, of course, be declared const.
\item The public, protected and private section of a class are to be declared
  in that order;
\item Friend class declarations should immediately precede the private
  section, to emphasize that they too can access those members;
\item The order functions are listed in the \verb!.c.! or \verb!.cpp! file
  should match the order they are listed in the class declaration in the
  \verb!.h! file.
\end{itemize}

\subsection{Indentation}

\begin{itemize}
\item (Loose) convertion is to put the opening
brace last on the line, and put the closing brace first:
\begin{verbatim}
if (x is true) {
  ... function body ...
}
\end{verbatim}
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus:
\begin{verbatim}
int function(int x)
{
  body of function
}
\end{verbatim}

Note that the closing brace is empty on a line of its own, except in
the cases where it is followed by a continuation of the same statement,
ie a "while" in a do-statement or an "else" in an if-statement, like
this:
\begin{verbatim}
do {
  body of do-loop
} while (condition);
\end{verbatim}
\item An else statement following an if should begin on the line following the
i's closing brace.
\begin{verbatim}
if (x == y) {
  ...
}
else if (x > y) {
  ...
}
else {
  ...
}
\end{verbatim}
\item Do not put spaces between function names and the parenthesis that
  starts the list of arguments. It makes it less obvious that the list
  of parameters belongs to that function call. Also, leave one space
  between parameters, after the comma, but don't leave any space before
  the first parameter, after the last one, or before a comma. If the
  function has no parameters, don't leave a space between parenthesis.
  \begin{verbatim}
  void foo( );       // No!
  void foo (1, 2);   // No!
  void foo( 1, 2 );  // No!
  void foo( 1 , 2 ); // No!

  void foo();     // Yes
  void foo(1, 2); // Yes
  \end{verbatim}

\item When defining functions, the leading parenthesis and the first argument
  (if any) are to be written on the same line as the function name. If space
  permists, other arguments and the closing parenthesis may also be written
  onthe same line as the function name. Otherwise, each additional argument is
  to be written on a separate line (with the closing parenthesis directly
                                    after the last argument).

  \begin{verbatim}
  ML_function(int FirstParameter,     // No!
    int SecondParamete, int ThirdParameter)
  {
    ..
  }

  ML_function(                        // No!
    int FirstParameter,
    int SecondParamete,
    int ThirdParameter
  ) {
    ..
  }    

  ML_function(int FirstParameter, int SecondParameter,  // Yes
              int ThirdParameter)
  {
    ...
  }      
  \end{verbatim}
\item \verb!cin/cout/cerr!-like indentation should look like this:
\begin{verbatim}
cout << "Problem:\t" << problem.name()
     << "Solution:\t" << problem.solution()
     << endl;
\end{verbatim}
\item If you split an expression into multiple lines, split it after an operator, not before it:
\begin{verbatim}
if (condition_number_one &&
    condition_number_two &&
    condition_number_three)
\end{verbatim}
\end{itemize}

\subsection{Portability}

Probably, the only way to write really portable code, is to test
extensively on all the desired (and available) architectures. Using
\verb!g++!, the following flags can be useful to detect non-ANSI
features: \verb!-ansi -pedantic -Wall!. Flag \verb!-ftrapv! can cause
\ML to crash, as some random functions generate an overflow. Flag
\verb!-Weffc++! can be very helpful, but recall that system files can
produce a lot of warnings with this flag.

\subsection{Suggestions}

\begin{itemize}
\item C code does {\sl not} allow C++-style comments (like
  \verb!//!). Even if some compilers do not complain, it is a bad
  habit to mix C++ and C coding pratices, and should be avoided.
\item Most compilers do not support C99 standard. Only C89 code should
  be included in the \ML distribution. The rational is that many
  platforms (like ASCI-Red, for instance) still have very old compilers,
  that are not C99-compliant..
\item For C++ codes, is \verb!malloc()!, \verb!calloc()!, or
  \verb!realloc()! used in lieu of \verb!new!?  C standard library
  allocation functions should never be used in C++ programs, since C++
  provides an allocation operator (\verb!new!)..
\item Are arrays being deleted as if they were scalars?  {\tt delete
    myCharArray} should be {\tt delete [] myCharArray}.
\end{itemize}

%%% ======================================================== %%%
%%% G E N E R A L   I N F O R M A T I O N    A B O U T   M L %%%
%%% ======================================================== %%%

\clearpage
\newpage

\vspace*{3cm}
\HRule
\part{Extending ML}

\HRule
\clearpage
\newpage

%%%
%%%
%%%

\section{Main Structures of ML}
\label{sec:structures}

\subsection{Managing Memory}

\ML has macros that wrap the system calls to allocate and free memory.
``ML\_allocate" should be used instead of ``malloc".
``ML\_free" should be used instead of ``free".
One word of warning -- because ML\_free is a macro, you should avoid casting
within the call to ML\_free:
\begin{itemize}
\item Good: \verb!ML\_free(i);!
\item Bad: \verb!ML\_free( (void *) i);! (does not compile on SGI, for instance)
\end{itemize}


\subsection{Error Handling}

\begin{itemize}
\item Always check return values of functions for errors.
\item Whenever possibly, try to recover from errors, by catching an integer
return value. Currently \ML does not support \verb!try/ catch! blocks.
\item Use \verb!assert()! calls extensively to check the invariants in your
  code. This will dramatically decrease your debugging time by catching
  inconsistencies early.
\end{itemize}

\subsection{Output}

\begin{itemize}
\item \ML uses the concept of {\sl print level}. Each output sentence has a
  value from - to 10 (10 being verbose), and it will be printed out only if
  the current print level is below this value. Each print statement should be
  preceded by a \verb!ML_Get_PrintLevel()!.
\item Standard output should be sent to \verb!stdout! (C) or \verb!cout! (C++).
\item Warnings and errors should be sent to \verb!stderr! (C) and \verb!cerr!
(C++).
\end{itemize}

\subsection{How Getrow() Works}

The following simple code can be used to get all local rows of an
\verb!ML_Operator!, here called \verb!Amat!.
\begin{verbatim}
int allocated = 1;
int    * colInd = new int[allocated];
double * colVal = new double[allocated];
int    NumNonzeros;
int    ierr;

for (int i=0 ; i<Amat->outvec_leng ; ++i)
{
  ierr = ML_Operator_Getrow(Amat,1,&i,allocated,colInd,colVal,&NumNonzeros);

  if( ierr == 0 ) {
    do {
      delete [] colInd;
      delete [] colVal;
      allocated *= 2;
      colInd = new int[allocated];
      colVal = new double[allocated];
      ierr = ML_Operator_Getrow(Amat,1,&i,allocated,colInd,colVal,&NumNonzeros);
    } while( ierr == 0 );
  }
  // .. do something with the row elements
}
delete [] colInd;
delete [] colVal;
\end{verbatim}
The error code \verb!ierr! is zero if the \verb!allocated! space was enough to
copy on vectors \verb!colInd! and \verb!colVal! the nonzero elements and their
(local) column numberfor row \verb!i!. If \verb!ierr==0!, then the user can
reallocate \verb!colInd! and \verb!colVal!, using a larger chunk of memory,
  and recall the getrow() function.

\subsection{Apply the Smoother to a Vector}

The following fragment of code can be used to apply the pre/post smoother
defined for level \verb!ilevel! to a vector \verb!rhs!. The starting solution
is defined in vector \verb!rhs!. We suppose that the ML hierarchy has already
been filled with the appropriate structures.
\begin{verbatim}
ML_Smoother * ptr = ((ml_->SingleLevel[ilevel]).pre_smoother);

int length = ml_->Amat[ilevel].outvec_leng;
double sol[length];
double rhs[lenght];
// ... here define the elements for sol and rhs
// the number of smoother applications is ptr->ntimes;

ML_Smoother_Apply(ptr, length,
		  tmp_sol, length, rhs, ML_NONZERO);
\end{verbatim}

\subsection{Print an ML\_Operator in a File}

The following simple fragment of code can be used to dump an
\verb!ML_Operator! to a file, say \verb!my_operator!.
\begin{verbatim}
// ml is an ML_struct, already filled with the appropriate operators
char name[] = "my_operator";
ML_Operator_Print(&(ml->Amat[LevelID_[i]]), name);
\end{verbatim}
The code works in serial and parallel. Serial runs will create a file called
\verb!my_operatator.serial!; this file can be easily read by MATLAB, where a
sparse matrix can be created using \verb!spconvert()!. Parallel runs will
create a file for each process. For parallel runs, one may find useful the
following function:
\begin{verbatim}
int ML_Operator_Print_UsingGlobalOrdering( ML_Operator *matrix,
                                           const char label[],
                                           int *global_row_ordering,
                                           int *global_col_ordering)
\end{verbatim}
This function prints a \verb!ML_Operator! into MATLAB format. Only one file is generated using global ordering. 
In input, \verb!matrix! is an \verb!ML_Operator!, distributed among the proceses     
If the matrix is rectangular, the user should   pass in both a global row
ordering and a global column numbering. The
matrix will be written in MATLAB (i,j,k) format to file \verb!label.m!. The
last two parameters can be se to NULL.

\subsection{Timing}

The following variables can be used to track timing:
\begin{itemize}
\item \verb!ML_TIMING!;
\item \verb!ML_TIMING_DETAILED!.
\end{itemize}

\subsection{Checking Memory Usage}

Probably, the easiest way to check the memory usage (under Linux) is to use
\verb!valgrind!, like for instance
\begin{verbatim}
% valgrind --leak-check=yes --show-reachable=yes ./ml_example.exe
\end{verbatim}
This also works in parallel:
\begin{verbatim}
% mpirun -np 4 valgrind --leak-check=yes --show-reachable=yes ./ml_example.exe
\end{verbatim}
(but it is slower, and can produce a lot of output.)

Another way is to compile \ML with the flag \verb!ML_MEM_CHECK!. Then,
the user can insert a call to \verb!ML_print_it()!, to print out all the
\ML allocagted memory that is still to be deleted. This check can be
expensive for large runs.

\subsection{Attaching a Debugger to ML}

To debug \ML on a serial computer (that is, using only one processor),
one can simply type somthing like
\begin{verbatim}
% gdb ./mlguide.exe
GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu".
(gdb) r
... output of the code ...
\end{verbatim}
Unfortunatly, most debuggers (like \verb!gdb!) cannot directly run
parallel applications. In this case, one can still attach to the desired
process (or possibly to more than one), in a very simple way:
\begin{enumerate}
\item In the part of the code where one wish to start debugging, call
  the following function:
\begin{verbatim}
ML_PauseForDebugger(Comm);
\end{verbatim}
where \verb!Comm! is an \verb!ML_Comm! structure;
\item Define the environmental variable \verb!ML_BREAK_FOR_DEBUGGER!,
  for instance (using BASH)
\begin{verbatim}
$ export ML_BREAK_FOR_DEBUGGER=1
\end{verbatim}
\item Alternatively, if using class MultiLevelPreconditioner, create a file
called \verb!ML_debug_now! in the working directory.
\item Run the code as required,
\begin{verbatim}
$ mpirun -np 2 ./mlguide.exe
Host and Process Ids for tasks
Host: s850675.sandia.gov   PID: 4153
Host: s850675.sandia.gov   PID: 4154

** Pausing because environment variable ML_BREAK_FOR_DEBUGGER has been set.
**
** You may now attach debugger to the processes listed above.
**
** Enter a character to continue >
\end{verbatim}
The code prints out the process ID of each ML's process. After
attaching, the user proceed by inserting a char value.
\end{enumerate}

%%%
%%%
%%%

\subsection{C++ Return and Exit Macros}
\label{sec:return}

Table~\ref{tab:macros} returns some macros that can be used in C++ codes.

\begin{table}
\centering
\begin{tabular}{| p{4cm} | p{10cm} | }
\hline
\verb!ML_CHK_ERR(ierr)!& If \verb@ierr != 0@, this macro prints out an
error message, and returns \verb!ierr!. \\
\verb!ML_CHK_ERRV(ierr)!& If \verb@ierr != 0@, this macro prints out an
error message, and returns void. \\
\verb!ML_RETURN(ierr)! & If \verb@ierr != 0@, this macro prints out an
error message. This macro always returns \verb!ierr!. \\
\verb!ML_EXIT(ierr)! & If \verb@ierr != 0@, this macro prints out an
error message. This macro always exits. \\
\hline
\end{tabular}
\caption{C++ return and exit macros.}
\label{tab:macros}
\end{table}

%%%
%%%
%%%

\subsection{Redistribute the coarser-level Matrices}

TO DO...

\subsection{Structure ML\_Comm}

The structure \verb!ML_Comm! is defined as follows:
\begin{verbatim}
typedef struct ML_Comm_Struct
{
   int      ML_id;
   int      ML_mypid;
   int      ML_nprocs;
   USR_COMM USR_comm;
   int      (*USR_sendbytes)(void*,unsigned int,int,int,USR_COMM);
   int      (*USR_irecvbytes)(void*,unsigned int,int*,int*,USR_COMM,USR_REQ*);
   int      (*USR_waitbytes)(void*,unsigned int,int*,int*,USR_COMM,USR_REQ*);
   void     (*USR_cheapwaitbytes)(void*,unsigned int,int*,int*,USR_COMM,USR_REQ*);
   USR_ERRHANDLER *USR_errhandler;

} ML_Comm;
\end{verbatim}
To get the process ID, simply use \verb!comm->ML_mypid!. To get the MPI
communicator, one can proceed as follows:
\begin{verbatim}
int orig_comm;
orig_comm = comm->USR_comm;
// now orig_comm can be used as MPI_COMM_WORLD
\end{verbatim}

%%%
%%%
%%%

\subsection{Sparsity Pattern of an {\tt ML\_Operator}}
\label{sec:sparsity}

Function \verb!ML_Operator_PrintSparsity()! can be used to visualize the 
sparsity pattern of an ML\_Operator. The function, that can be used for
both serial and parallel run, has the following syntax:
\begin{verbatim}
int ML_Operator_PrintSparsity(ML_Operator* Op, char* title,
                              char* FileName, int PrintDecomposition,
                              int NumPDEEqns);
\end{verbatim}
\verb!Op! is a pointer to the ML\_Operator, \verb!title! is a character array
that will be inserted in the postscript file, \verb!FileName! a valid file
name. If \verb!PrintDecomposition! is set to \verb!ML_YES!, the postscript
file will contain horizontal an vertical lines, corresponding to the division
of the rows and columns among the processors. Finally, \verb!NumPDEEqns!
defines the number of PDE equations. If greater than 1, only the sparsity
pattern of the block matrix will be plotted.

Two example of output are reported in Figure~\ref{fig:sparsity-pattern}.

\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{sparsity_Amat.ps} \hspace{0.5cm}
\includegraphics[width=6cm]{sparsity_Rmat.ps}
\caption{Sparsity pattern of two ML\_Operators: the fine-level matrix (left)
  and the (non-smoothed) restriction operator from finest to coarsest level.
  The finest-level matrix has size 60, and
  corresponds to a 1D Laplacian on a Cartesian grid. 
  The lines in the matrix show the division of rows and columns among the (two) processors.}
\label{fig:sparsity-pattern}
\end{figure}

%%%
%%%
%%%

\section{Visualization Capabilities}
\label{sec:viz}

\ML\ supports limited capabilities for the visualization of and statistical
information for aggregates, with an interface to OpenDX.
Currently, only {\tt Uncoupled,
METIS} and {\tt ParMETIS} aggregation routines can dump files in OpenDX
format.

The procedure to create the OpenDX input files is as follows:
\begin{enumerate}
\item Add the following line after the creation of the ML\_Aggregate object
\begin{verbatim}
   ML_Aggregate_VizAndStats_Setup( ag, MaxMgLevels );
\end{verbatim}
  where \verb!MaxMgLevels! is the maximum number of levels (this is the
  same value used to create the \ML\ object).
\item Create the multilevel hierarchy;
\item Write OpenDX file using the instruction
%\begin{verbatim}
%   ML_Aggregate_Visualize( ml, ag, MaxMgLevels, x, y, z, option, filename);
%\end{verbatim}
\begin{verbatim}
   ML_Aggregate_VizAndStats_Compute( ml, ag, MaxMgLevels, x, y, z,
                                     option, filename);
\end{verbatim}
   where \verb!ml! is the \ML\ object, \verb!ag! the ML\_Aggregation object, 
   and \verb!x,y,z! are double vectors, whose size
   equals the number of local nodes in the fine grid, containing the coordinates
   of fine grids nodes. \verb!option! is an integer value defined so
   that:
   \begin{itemize}
   \item option = 1 : solution of 1D problem ({\tt y} and {\tt z} can be
     {\tt NULL});
   \item option = 2 : solution of 2D problems ({\tt z} can be {\tt NULL});
   \item option = 3 : solution of 3D problems.
   \end{itemize}
   Processor X will write its own file, \verb!filename_levelY_procX!, where
   \verb!Y! is the level. \verb!filename! can be set to {\tt NULL} (default value of
   \verb!.graph! will be used in this case).
   
   Note that in AMG there is no mesh associated with coarser
   levels. Therefore \newline {\sf ML\_Aggregate\_VizAndStats\_Compute} needs to
   assign a set of coordinates  to each aggregate.
   This is done by computing the center
   of gravity of each aggregate (starting from the fine grid and finishing
   at the coarsest level).

   \verb!ML_Aggregate_VizAndStats_Compute!
   will also write statistical
   information to the screen.

\item Deallocate memory using
\begin{verbatim}
  ML_Aggregate_VizAndStats_Clean( ag, MaxMgLevels ).
\end{verbatim}
\end{enumerate}

At this point, one should copy file \verb!viz_aggre.net! and
\verb!viz_aggre.cfg! (located in \verb!$ML_HOME/util/!) in the directory
where the output files are located, and run OpendDX with the instruction
\begin{verbatim}
% dx -edit viz_aggre.net
\end{verbatim}
Other instructions are reported in file
\verb!$ML_HOME/util/viz_aggre.README!. An example of code can be found in
file \verb!$ML_HOME/examples/ml_aztec_simple_METIS.c!.

%%%
%%%
%%%

\section{Current and Future Developments}
\label{sec:to-do}.

TO BE DONE...

%%% ================= %%%
%%% F U N C T I O N S %%%
%%% ================= %%%

\clearpage
\newpage

\vspace*{3cm}
\HRule
\part{Function Reference}
\HRule
\clearpage
\newpage

\include{functions}

\bibliography{developer_guide.bib}

\end{document}
