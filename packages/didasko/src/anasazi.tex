%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\section{Eigenvalue and Eigenvector Computations with Anasazi}
\label{chap:anasazi}

The Anasazi package was designed as an extensible and interoperable framework
for large-scale eigenvalue algorithms. Anasazi provides a generic interface to
a collection of algorithms for solving large-scale eigenvalue problems. It
utilizes abstract interfaces for operators and multivectors, and therefore it
can be used with any operator or multivector class that implements these
interfaces. The algorithms currently available through Anasazi are a block
Krylov Schur method \cite{Stewart2001}, a block Davidson method and the locally
optimal block preconditioned conjugate gradient (LOBPCG) method
\cite{Knyazev2001}.

In this chapter we present:
\begin{itemize}
\item a description of the Anasazi framework (Section~\ref{sec:anasazi:framework}),
\item the interface to the Epetra linear algebra package
(Section~\ref{sec:anasazi:epetra}), 
\item an overview of the testing routines provided by Anasazi
(Section~\ref{sec:anasazi:MVOPtester}), and
\item an example using Anasazi for the solution of an eigenvalue problem 
(Section~\ref{sec:anasazi:example}).
\end{itemize}


Throughout this chapter, the following abbreviations may be used for the sake of
brevity:
\begin{itemize}
\item ST - scalar type class (e.g., \verb!double!, \verb!complex!)
\item MV - multivector type class (e.g., \verb!Epetra_MultiVector!)
\item OP - operator type class (e.g., \verb!Epetra_Operator!, \verb!Epetra_CrsMatrix!)
\end{itemize}

%%%
%%%
%%%
\subsection{The Anasazi Framework}
\label{sec:anasazi:framework}

Solving an eigenproblem in Anasazi requires the use of four main components: an
eigenvalue solver, an eigenvalue problem, linear operators and multivectors.
The representations of these objects are described by the following four
Anasazi classes:
\begin{itemize}
\item \verb!Eigensolver! (Section~\ref{sec:anasazi:eigensolver}) - this class defines the basic interface that any
eigensolver must support.
\item \verb!Eigenproblem! (Section~\ref{sec:anasazi:eigenproblem}) - this class defines the interface required by an
eigensolver to solve an eigenvalue problem.
\item \verb!MultiVecTraits! (Section~\ref{sec:anasazi:mvt}) - this class defines the interface Anasazi uses to 
perform operations on and with multivectors.
\item \verb!OperatorTraits! (Section~\ref{sec:anasazi:opt}) - this class defines the interface by which Anasazi
applies operators to multivectors.
\end{itemize}

While the four classes listed above are the most important, there are other
classes that are necessary when using Anasazi. These include the
\verb!SortManager! and \verb!OutputManager! classes. These classes, along with
the four classes introduced above, are described in more detail in the following
subsections.

%%%
%%%
\subsubsection{Anasazi::Eigensolver}
\label{sec:anasazi:eigensolver}

The \verb!Anasazi::Eigensolver! class defines the basic interface that must be
met by any eigensolver class in Anasazi. The specific eigensolvers are
implemented as derived classes of \verb!Anasazi::Eigensolver!.
Table~\ref{tab:anasazi:solvers} lists the eigensolver currently implemented in
Anasazi.

\begin{table}[htp]
\begin{center}
\begin{tabular}{| p{4cm} p{8cm} |}
\hline
Solver & Description \\
\hline
{\tt BlockDavidson}    & A block Davidson solver for symmetric
                         eigenvalue problems.\\
{\tt BlockKrylovSchur} & A block Krylov Schur solver for symmetric or
                         nonsymmetric eigenvalue problems.\\
{\tt LOBPCG} & The locally optimal block preconditioned conjugate gradient
method for symmetric eigenproblems.\\
\hline
\end{tabular}
\caption{Eigensolvers currently implemented in Anasazi.}
\label{tab:anasazi:solvers}
\end{center}
\end{table}

The class \verb!Anasazi::Eigensolver!, like \verb!Anasazi::Eigenproblem!, is
templated on the scalar type, multivector type and operator
type. The procedure for using an Anasazi eigensolver is as follows:
\begin{enumerate}
\item Choose scalar, multivector and operator classes.
\item Create the eigenproblem.
\item Create an instance of the desired eigensolver and pass it the necessary
options.
\item Ask the eigensolver to solve the eigenproblem.
\end{enumerate}

The options for the eigensolver are passed through the constructor, defined by
\verb!Anasazi::Eigensolver! to have the following form:
\begin{verbatim}
Eigensolver( 
   const Teuchos::RefCountPtr<Eigenproblem<ScalarType,MV,OP> > &problem, 
   const Teuchos::RefCountPtr<SortManager<ScalarType,MV,OP> > &sm,
   const Teuchos::RefCountPtr<OutputManager<ScalarType> > &om,
   Teuchos::ParameterList &pl );
\end{verbatim}

The first argument is the eigenvalue problem that is to be solved. The second
argument is an instance of \verb!Anasazi::SortManager!. The goal of this class is
to specify the eigenvalues targeted by the solver and to provide sorting
functionality (Section~\ref{sec:anasazi:sm}). The third argument is an instance
of \verb!Anasazi::OutputManager!. This class specifies the verbosity of the
eigensolver and other printing options (Section~\ref{sec:anasazi:om}). The last
argument is an instance of the class \verb!Teuchos::ParameterList!. This is the
mechanism by which solver-specific options are passed to the eigensolver (e.g.,
block size, number of restarts). A list of valid parameters for each
eigensolver is given in Table~\ref{tab:anasazi:solver_params}.

\begin{remark}
Anasazi makes extensive use of the Teuchos utility classes, especially
\verb!RefCountPtr! (Section~\ref{sec:teuchos:RefCountPtr}) and
\verb!ParameterList! (Section~\ref{sec:teuchos:ParameterList}). Users
are encouraged to become familiar with these classes and their correct
usage.
\end{remark}

\begin{table}
\begin{center}
\begin{tabular}{| l | l | p{6cm} |}
\hline
Parameter & Supported Solver & Description \\
\hline
{\tt Block Size}   & BKS, BD, LOBPCG & The number of vectors added to the basis at each iteration \\
{\tt Max Blocks}   & BKS, BD         & The maximum number of blocks in the Krylov basis \\
{\tt Max Restarts} & BKS             & Stopping criterion on the number of restarts \\
{\tt Step Size}    & BKS             & Controls the frequency of convergence checking \\
{\tt Tol}          & BKS, BD, LOBPCG & Stopping criterion on relative residual norm \\
\hline
\end{tabular}
\caption{Options for BlockKrylovSchur (BKS), BlockDavidson (BD), and LOBPCG.}
\label{tab:anasazi:solver_params}
\end{center}
\end{table}

After passing all of the options to the eigensolver, all that remains is to ask
it to solve the eigenproblem. This is done by calling the solve routine 
defined by \verb!Anasazi::Eigensolver!:
\begin{verbatim}
Anasazi::ReturnType solve()
\end{verbatim}
This function returns the status of the solver. Possible return values are
listed in Table~\ref{tab:anasazi:rt}. After calling \verb!solve()!, the
eigensolver class defines some \textbf{get} functions to retrieve information
relevant to many eigensolvers. These are:
\begin{verbatim}
int GetNumIters() const
int GetNumRestarts() const
int GetBlockSize() const 
\end{verbatim}
The class also defines a \verb!GetEigenproblem()! function, which returns a
reference to the eigenproblem the solver was working on.

\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} l |}
\hline
Parameter & Default \\
\hline
\verb!Anasazi::Ok!         & Success. \\
\verb!Anasazi::Unconverged!& Solver did not converge to specified accuracy. \\
\verb!Anasazi::Failed!     & An error with the input or in the solver. \\
\hline
\end{tabular}
\caption{Anasazi::ReturnType values.}
\label{tab:anasazi:rt}
\end{center}
\end{table}

%%%
%%%
\subsubsection{Anasazi::Eigenproblem}
\label{sec:anasazi:eigenproblem}

One of the goals of Anasazi is to provide a framework for eigenvalue
computations that leaves as much flexibility as possible to users. It is
towards this goal that the \verb!Anasazi::Eigenproblem! abstract base class was
defined. By providing a base class for an eigenvalue problem which users can
extend, Anasazi allows them to specify properties that are specific to
their eigenvalue problems. \verb!Anasazi::Eigenproblem! is also a container for
the solutions from the eigensolver. However, by requiring eigenproblems to
derive from \verb!Anasazi::Eigenproblem!, Anasazi defines a minimum interface
that can be expected of all eigenvalue problems by the classes that will work
with the problems (e.g., eigensolvers and status testers).

By storing the operators associated with an eigenproblem, as well as the
solutions computed by an eigensolver, \verb!Anasazi::Eigenproblem! acts as a
repository for information related to an eigenvalue problem. However, this is
not the only function of the \verb!Anasazi::Eigenproblem! class. The class also
provides two functions, \verb!InnerProd()! and \verb!MvNorm()!, which specify
the inner product and the vector norm to be used when computing the solution of
the eigenvalue problem. When creating a concrete derived class of
\verb!Anasazi::Eigenproblem!, the developer must implement these methods.

Both the eigenproblem and the eigensolver in Anasazi are templated 
on the scalar type, the multivector type and the operator type. Before
declaring an eigenproblem, users must choose classes to represent these
entities. Having done so, they can begin to specify the parameters of the
eigenvalue problem. The \verb!Anasazi::Eigenproblem! defines \textbf{set} methods for
the parameters of the eigenproblem. These methods are:
\begin{itemize}
\item \verb!SetOperator! - set the operator for which the eigenvalues will be computed
\item \verb!SetA! - set the $A$ operator for the eigenvalue problem $Ax=\lambda M x$
\item \verb!SetM! - set the $M$ operator for the eigenvalue problem $Ax=\lambda M x$
\item \verb!SetPrec! - set the preconditioner for the eigenvalue problem
\item \verb!SetInitVec! - set the initial guess
\item \verb!SetAuxVec! - set the auxilliary vectors
\item \verb!SetNEV! - set the number of eigenvalues to be computed
\item \verb!SetSymmetric! - specify the symmetry of the problem
\end{itemize}
In addition to these \textbf{set} methods, \verb!Anasazi::Eigenproblem! defines
a method \verb!SetProblem()! which gives the class the opportunity to perform
any initialization that may be necessary before the problem is handed off to an
eigensolver. It is recommended that \verb!SetProblem()! be implemented to
return an error if the problem is not fully specified.

For each of the \textbf{set} methods listed above, there is a corresponding
\textbf{get} function. These are the functions used by the eigensolver to get
the necessary information from the eigenvalue problem. In addition, there are
two methods for returning the results of the eigenvalue computation:
\begin{verbatim}
Teuchos::RefCountPtr< MV > GetEvals()
Teuchos::RefCountPtr< std::vector< ScalarType > > GetEvecs()
\end{verbatim}

Anasazi provides users with a basic implementation of
\verb!Anasazi::Eigenproblem!, called \verb!Anasazi::BasicEigenproblem!
(Section~\ref{sec:anasazi:example}).  The inner product implemented by this
class is the $M$-inner product or the standard Euclidean inner product if $M$
is not specified. The vector norm implemented by this class is the norm induced
by the inner product.  This formulation provides all the functionality
necessary to describe both generalized and standard linear eigenvalue problems.
Users may wish to create their own derivation of \verb!Anasazi::Eigenproblem!
if they desire a different inner product or if they are solving an eigenvalue
problem not supported by \verb!Anasazi::BasicEigenproblem! (e.g., a quadratic
eigenvalue problem).

%%%
%%%
\subsubsection{Anasazi::MultiVecTraits}
\label{sec:anasazi:mvt}

As mentioned above, the eigenproblem and eigensolver classes are templated
classes, allowing users to specify desired classes for scalars, multivectors
and linear operators. The choice of scalar type allows Anasazi to be implemented
with arbitrary numerical precision, while the choice of multivector and operator
classes allows Anasazi to leverage the power of any existing linear algebra
libraries available to users. This flexibility is accomplished through the
usage of the \verb!Anasazi::MultiVecTraits! class. This class defines an opaque
interface, specifying the operations that the chosen multivector class must
support in order to be used in Anasazi. This includes methods for the creation
and initialization of multivectors as well as computational routines. A full
list of methods required by \verb!MultiVecTraits! is given in
Table~\ref{tab:anasazi:mvt}.

\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} || p{8cm} |}
\hline
Method name & Description \\
\hline\hline
Clone           & Creates a new empty multivector containing a specified number
of columns.  \\\hline
CloneCopy       & Creates a new multivector with a copy of the contents of an existing
multivector (deep copy). \\\hline
CloneCopy       & Creates a new multivector with a copy of the selected contents of
an existing multivector (deep copy).  \\\hline
CloneView       & Creates a new multivector that shares the selected contents of
an existing multivector (shallow copy).  \\\hline
GetVecLength    & Obtain the vector length of a multivector.  \\\hline
GetNumberVecs   & Obtain the number of vectors in a multivector.  \\\hline
MvTimesMatAddMv & Apply a SerialDenseMatrix $M$ to the multivector,
                  $mv \leftarrow \alpha A M + \beta mv$.  \\\hline
MvAddMv         & Perform $mv \leftarrow \alpha A + \beta B$.  \\\hline
MvTransMv       & Compute the matrix $C \leftarrow \alpha A^H B$.  \\\hline
MvDot           & Compute the vector $b$ where the components are the individual
dot-products of the $i$-th columns of $A$ and $B$, i.e. $b[i] = A[i]^H B[i]$.
\\\hline
MvNorm          & Compute the 2-norm of each individual vector of $A$.  \\\hline
SetBlock        & Copy the vectors in $A$ to a subset of vectors in $B$. \\\hline
MvRandom        & Replace the vectors in $A$ with random vectors.  \\\hline
MvInit          & Replace each element of the vectors in $A$ with $\alpha$.  \\\hline
MvPrint         & Print the multi-vector to an output stream.  \\\hline
\hline
\end{tabular}
\caption{Methods required by MultiVecTraits interface.}
\label{tab:anasazi:mvt}
\end{center}
\end{table}

In order to use a specific scalar type and multivector type with Anasazi, there
must exist a specialization of \verb!Anasazi::MultiVecTraits! for this pair of
classes. This can be accomplished in a few different ways:
\begin{itemize}
\item subclass the \verb!Anasazi::MultiVector! abstract class (templated on
\verb!ST!), for which a \verb!MultiVectorTraits! specialization already exists,
\item define a specialization satisfying \verb!MultiVecTraits! for multivector
class \verb!MV! and scalar type \verb!ST!,
\item use an \verb!Epetra_MultiVector! with scalar type \verb!double!, 
for which a \verb!MultiVecTraits! specialization is already defined.
\end{itemize}

The first approach is appropriate for users looking to develop a linear algebra
code from scratch.  The second approach is the most appropriate approach for
users who already have a multivector class that they would like to use. They
would use the \verb!Anasazi::MultiVecTraits!  interface as a wrapper around the
functionality of their existing code.  Finally, the third option is for users
who do not have existing linear algebra codes and do not wish to implement
their own multivector class. In addition to providing users with a parallel
linear algebra software, the Epetra adapter allows users to utilize any
Trilinos package that interfaces with Epetra.

If a specialization of \verb!Anasazi::MultiVecTraits! for a class does not
exist or is not complete, then a program using this class will not compile.
However, just because a specification of the \verb!Anasazi::MutliVecTraits!
compiles does not mean that it is correct
(Section~\ref{sec:anasazi:MVOPtester}).

\begin{remark} 
An Anasazi eigenproblem and eigensolver are templated based on a scalar type, a
multivector type, and an operator type. The scalar type must have a
\verb!Teuchos::ScalarTraits! specialization, and the multivector and operator
types must have \verb!Anasazi::MultiVecTraits! and
\verb!Anasazi::OperatorTraits! specializations, respectively. This allows
Anasazi to locally specify the requirements necessary of multivector and
operator classes, without requiring users to derive
from Anasazi abstract base classes.
\end{remark}



%%%
%%%
\subsubsection{Anasazi::OperatorTraits}
\label{sec:anasazi:opt}

Just as \verb!Anasazi::MultiVecTraits! defined the interface required to use a
multivector class with Anasazi, \verb!Anasazi::OperatorTraits! defines the
interface required to use the combination of a specific operator class with a
specific multivector class. This interface defines a single method:
\begin{verbatim}
ReturnType Apply (const OP &Op, const MV &x, MV &y)
\end{verbatim}
This method performs the operation $y = Op*x$, where $Op$ is an operator of type
\verb!OP! and $x$ and $y$ are multivectors of type \verb!MV!. In order to use the
combination of \verb!OP! and \verb!MV!, there must be a specialization of
\verb!Anasazi::OperatorTraits! for \verb!OP! and \verb!MV!. This can be
accomplished in a few different ways, just as described for the multivector in
the previous section:
\begin{itemize}
\item subclass the \verb!Anasazi::Operator! abstract class (using
\verb!MV!), for which an \verb!OperatorTraits! specialization already exists,
\item define a specialization satisfying \verb!OperatorTraits! for multivector
class \verb!MV! and operator class \verb!OP!,
\item use an \verb!Epetra_Operator! and \verb!Epetra_MultiVector! and scalar
type \verb!double!, for which an \verb!OperatorTraits! specialization is already
defined.
\end{itemize}

The first approach makes sense in situations where users are planning to write
an operator class from scratch. The second is most appropriate when users have
an existing operator class. The third is appropriate for users who do not have
an existing linear algebra suite. Section~\ref{sec:anasazi:epetra} gives an
example of using the Anasazi adapter to Epetra.

%%%
%%%
\subsubsection{Anasazi::SortManager}
\label{sec:anasazi:sm}

The purpose of a sort manager is to separate the eigensolver classes from the
sorting functionality required by those classes. This satisfies the flexibility
principle sought by Anasazi, by giving users the opportunity to perform the
sorting in whatever manner is deemed to be most appropriate. Anasazi defines an
abstract class \verb!Anasazi::SortManager! with only two methods, one for real
and one for complex:
\begin{verbatim}
ReturnType  
   sort (..., ST *evals, std::vector<int> *perm) 
ReturnType 
   sort (..., ST *r_evals, ST *i_evals, std::vector<int> *perm)
\end{verbatim}
Each of these sort routines will sort the eigenvalues according to some
implementation and optionally return the permutation vector as well (useful for
sorting associated vectors). Note that when sorting complex eigenvalues, complex
conjugate pairs must be sorted together.

Anasazi provides a derived class \verb!Anasazi::BasicSort!, which implements
\verb!Anasazi::SortManager!. This class provides basic sorting functionality,
described in Table~\ref{tab:anasazi:sm}.

\begin{table}
\begin{center}
\begin{tabular}{| p{2cm} l |}
\hline
Option & Action \\
\hline
{\tt SM} & Sort eigenvalues in increasing order of magnitude \\
{\tt SR} & Sort eigenvalues in increasing order of real part \\
{\tt SI} & Sort eigenvalues in increasing order of imaginary part \\
{\tt LM} & Sort eigenvalues in decreasing order of magnitude \\
{\tt LR} & Sort eigenvalues in decreasing order of real part \\
{\tt LI} & Sort eigenvalues in decreasing order of imaginary part \\
\hline
\end{tabular}
\caption{Options for Anasazi::BasicSort.}
\label{tab:anasazi:sm}
\end{center}
\end{table}


%%%
%%%
\subsubsection{Anasazi::OutputManager}
\label{sec:anasazi:om}

As with the sort manager, the output manager in Anasazi exists to provide
flexibility with regard to the verbosity of the eigensolver. An instance of
\verb!Anasazi::OutputManager! is declared as follows:
\begin{verbatim}
Anasazi::OutputManager<ST> MyOM(myID, verbLevel, printID, ostream);
\end{verbatim}
The parameter \verb!myID! is the ID of the current process and \verb!printID! 
designates which process should print. Parameter \verb!verbLevel! is a bitmask
specifying the desired verbosity level of the eigensolver (see
Table~\ref{tab:anasazi:om}). Lastly, \verb!ostream! is the output stream that
should be used when printing from the eigensolver.

\begin{table}
\begin{center}
\begin{tabular}{| p{7cm} l |}
\hline
Option & Action \\
\hline
{\tt Anasazi::Error} & 
  This option is always set \\
{\tt Anasazi::Warning} & 
  Warnings \\
{\tt Anasazi::IterationDetails} & 
  Details at each iteration \\
{\tt Anasazi::OrthoDetails} & 
  Details about orthogonality \\
{\tt Anasazi::FinalSummary} & 
  A final summary \\
{\tt Anasazi::Debug} & 
  Debugging information \\
\hline
\end{tabular}
\caption{Options for Anasazi::OutputManager.}
\label{tab:anasazi:om}
\end{center}
\end{table}

Inside an eigensolver, the output manager is queried via the following
routines:
\begin{itemize}
\item \verb!GetOstream()! - returns the output which should be used for printing messages.
\item \verb!isVerbosityAndPrint(type)! - specifies whether messages of class
\verb!type! should be printed by this process.
\item \verb!isVerbosity(type)! - specifies whether messages of class \verb!type!
should be printed at all, and therefore, whether joint computation may be
necessary.
\item \verb!doPrint()! - dictates whether messages can be printed through the output
stream by this process.
\end{itemize}


%%%
%%%
%%%
\subsection{Using the Anasazi adapter to Epetra}
\label{sec:anasazi:epetra}

The Epetra package provides the underlying linear algebra foundation for many
Trilinos solvers.  By using the Anasazi adapter to Epetra, users not only
avoid the trouble of designing their own multivector and operator classes, but
they also gain the ability to utilize any other Trilinos package which
recognizes Epetra classes (such as AztecOO, IFPACK, and others).

In order to use the Anasazi adapter to Epetra, users must include the following
file:
\begin{verbatim}
#include "AnasaziEpetraAdapter.hpp"
\end{verbatim}
This file simply defines specializations of the \verb!Anasazi::MultiVecTraits!
and \verb!Anasazi::OperatorTraits! classes, while also including the Epetra
header files defining the multivector and operator classes.

Because Epetra makes exclusive use of double precision arithmetic, choosing
\verb!Epetra_Operator! and \verb!Epetra_MultiVector! makes sense only for the
scalar type \verb!double!. For brevity, it is useful to declare type definitions
for these classes:
\begin{verbatim}
typedef double ST;
typedef Epetra_MultiVector MV;
typedef Epetra_Operator OP;
\end{verbatim}

Multivectors will be of type \verb!MV!:
\begin{verbatim}
Teuchos::RefCountPtr<MV> X = Teuchos::rcp( new MV(...) );
\end{verbatim}

Operators can be any subclass of \verb!OP!, for example, an \verb!Epetra_CrsMatrix!:
\begin{verbatim}
Teuchos::RefCountPtr<OP> A = Teuchos::rcp( new Epetra_CrsMatrix(...) );
\end{verbatim}

The Anasazi interface to Epetra defines a specialization of
\verb!Anasazi::MultiVecTraits! for \verb!Epetra_MultiVector! and a
specialization of \verb!Anasazi::OperatorTraits! for \verb!Epetra_Operator!
applied to \verb!Epetra_MultiVector!. Therefore, we can now specify an
eigenproblem and eigensolver utilizing these computational classes. An example
defining an eigenvalue problem and solving the problem using an Anasazi
eigensolver is given in the next section.

%%%
%%%
%%%
\subsection{Testing MultiVecTraits and OperatorTraits specializations}
\label{sec:anasazi:MVOPtester}

In order to facilitate the usage of different linear algebra packages, Anasazi
provides routines to test the specialization of \verb!MultiVecTraits! and
\verb!OperatorTraits!. Because the \verb!MultiVecTraits! interface requires
creating multivectors by cloning another multivector, this routine requires 
users to pass in a multivector. Likewise, to test a specialization of
\verb!OperatorTraits!, users must pass in an operator instance as well as a
multivector.
\begin{verbatim}
#include "AnasaziMVOPtester.hpp"

typedef Anasazi::MultiVecTraits<MyScalar,MyMV>      MVT;
typedef Anasazi::OperatorTraits<MyScalar,MyMV,MyOP> OPT;

MyMV A(...);
MyOP M(...);
Anasazi::ReturnType ret;

// Test MultiVecTraits specialization
ret = Anasazi::TestMultiVecTraits<MyScalar,MyMV>(A);
if (ret != Anasazi::Ok) {
   ...
}

// Test OperatorTraits specialization
ret = Anasazi::TestOperatorTraits<MyScalar,MyMV,MyOP>(A,M);
if (ret != Anasazi::Ok) {
   ...
}
\end{verbatim}

Because the \verb!MultiVecTraits! interface does not give users access to the
data stored in a multivector, the tests that can be performed by these routines
are somewhat limited, so that a successful test does not guarantee that the
specializations and/or the chosen classes are correct. However, these tests go a
long way to automatically checking for common bugs.

%%%
%%%
%%%
\subsection{Defining and Solving an Eigenvalue Problem}
\label{sec:anasazi:example}

The first step in solving an eigenvalue problem is to define the eigenvalue
problem. Assume we have chosen classes to represent our scalars, multivectors
and operators as \verb!ST!, \verb!MV! and \verb!OP!, respectively. Given an
operator \verb!A! and a multivector \verb!X! containing initial vectors, both
wrapped in \verb!Teuchos::RefCountPtr!s, we might define the eigenproblem as
follows:
\begin{verbatim}
Teuchos::RefCountPtr< BasicEigenproblem<ST,MV,OP> > MyProblem 
  = Teuchos::rcp( new BasicEigenproblem<ST,MV,OP>(A,X) );
MyProblem->SetSymmetric( true );
MyProblem->SetNEV( 5 );
Anasazi::ReturnType ret = MyProblem->SetProblem();
if (ret != Anasazi::Ok) {
   ...
}
\end{verbatim}

The first line creates a \verb!BasicEigenproblem! object and wraps it
in a Teuchos smart-pointer. The second line specifies the symmetry of
the eigenproblem, information which may be utilized by the eigensolver
for extra efficiency. The third line specifies the desired number of
eigenvalues and eigenvectors. Lastly, the fourth signals that we have
finished setting up the eigenproblem. This step must be completed
before attempting to solve the problem.

Let us, for example, attempt to solve this eigenvalue problem with a
block Krylov Schur solver. First, we declare a sort manager to specify the
targeted eigenvalues:
\begin{verbatim}
std::string which("SM");
Teuchos::RefCountPtr<Anasazi::BasicSort<ST,MV,OP> > MySM =
  Teuchos::rcp( new Anasazi::BasicSort<ST,MV,OP>(which) );
\end{verbatim}
The option chosen was \verb!"SM"!, signaling that we want to compute
the eigenvalues with the smallest magnitude. 

Next we create an output manager, specifying the verbosity of the
solver:
\begin{verbatim}
Teuchos::RefCountPtr<Anasazi::OutputManager<ST> > MyOM = 
  Teuchos::rcp( new Anasazi::OutputManager<ST>( MyPID ) );
MyOM->SetVerbosity( Anasazi::Error+Anasazi::Warning );
\end{verbatim}
Here, we have asked for the eigensolver to only output information regarding
errors and warnings.

We also will specify the parameters for the eigensolver:
\begin{verbatim}
Teuchos::ParameterList MyPL;
MyPL.set( "Block Size", 5 );
MyPL.set( "Max Blocks", 5 );
MyPL.set( "Max Restarts", 100 );
MyPL.set( "Tol", 1.0e-8 );
\end{verbatim}

We now have all of the information needed to declare the eigensolver
and solve the problem:
\begin{verbatim}
Anasazi::BlockKrylovSchur<ST,MV,OP> 
  MySolver( MyProblem, MySM, MyOM, MyPL );
\end{verbatim}
The eigenproblem is solved with the instruction
\begin{verbatim}
Anasazi::ReturnType sret = MySolver.solve();
\end{verbatim}
The return value of the solver indicates whether the algorithm
succeeded or not. 

Eigenvectors and eigenvalues can be retrieved using
\begin{verbatim}
Teuchos::RefCountPtr<Epetra_MultiVector >  evecs 
   = MyProblem->GetEvecs();
Teuchos::RefCountPtr<std::vector<double> > evals 
   = MyProblem->GetEvals();
\end{verbatim}
For a nonsymmetric problem with potentially complex eigenvalues and
eigenvectors, \verb!evecs! and \verb!evals! contain both the real and
complex parts of these, as described in the comments of
\TriExe{anasazi/ex1.cpp}.

Example \TriExe{anasazi/ex1.cpp} shows how to compute the eigenvectors
corresponding to the lowest eigenvalues for a 2D Laplace problem using the block
Krylov Schur solver.  Example \TriExe{anasazi/ex2.cpp} solves this example,
using instead the block Davidson eigensolver.  Finally, the block Krylov Schur
solver is used to solve a nonsymmetric convection-diffusion problem in Example
\TriExe{anasazi/ex3.cpp}.

%Table~\ref{tab:anasazi:exLapl} reports the lower
%eigenvalues. 

%\begin{figure}[htbp]
%  \centering
%  \includegraphics[height=6cm]{anasazi_Laplace_1D.ps}
%  \caption{Lowest eigenvalues of a 1D Laplace problem, with $h=1/33$.}
%  \label{fig:anasazi:1D}
%\end{figure}

%\begin{table}[htbp]
%  \centering
%  \begin{tabular}{| l | c |}    
%    \hline
%& {\tt laplace\_2d} \\
%     \hline
%     $h = 1/33$  & 0.00905   & 0.0181    & 0.02716  \\
%     $h = 1/65$  & 0.00235   & 0.00467   & 0.007006 \\
%     $h = 1/129$ & 0.0005936 & 0.0011861 & -        \\
%     $h = 1/257$ & 0.000149  & 0.0002983 & -        \\
%     $h = 1/513$ & 3.75e-5   & -         & -        \\
%     \hline
%  \end{tabular}
%  \caption{$\lambda_{min}$ for 1D, 2D and 3D Laplace problem on a Cartesian mesh.}
%  \label{tab:anasazi:exLapl}
%\end{table}
%%%
%%%
%%%



% FIXME
%\subsection{Concluding Remarks on Anasazi}
%\label{sec:anasazi_concluding}

%More documentation on the Anasazi package can be found in
%\cite{Anasazi-Ref-Guide,Anasazi-User-Guide}.

