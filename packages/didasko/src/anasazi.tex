%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\section{Eigenvalue and Eigenvector Computations with Anasazi}
\label{chap:anasazi}

The Anasazi package has been designed as an extensible and
interoperable framework for large-scale eigenvalue algorithms. Anasazi
provides a generic interface to a collection of algorithms for solving
large-scale eigenvalue problems. Anasazi requires matrices and vectors
to be derived from abstract classes, and therefore it can be used with
any matrix and vector classes that implement these interfaces. The
algorithms currently available through Anasazi are a block Krylov
Schur method and a block Davidson method.

In this Chapter we present:
\begin{itemize}
\item a description of the Anasazi framework (Section~\ref{sec:anasazi:framework}),
\item the interface to the Epetra linear algebra package (Section~\ref{sec:anasazi:interface}), and
\item an example using Anasazi for the solution of an eigenvalue problem 
(Section~\ref{sec:anasazi:example}).
\end{itemize}

%%%
%%%
%%%
\subsection{Anasazi Framework}
\label{sec:anasazi:framework}


The two most important classes in Anasazi are \verb!Eigenproblem! and
\verb!Eigensolver!. The \verb!Anasazi::Eigenproblem! class defines an interface
to provide all of the information necessary to compute the solution to an
eigenproblem. The \verb!Anasazi::Eigensolver! class defines the minimum
interface required of eigensolvers in Anasazi. Eigensolvers are implemented by
subclassing the \verb!Anasazi::Eigensolver! abstract class. The solvers
available in the current version of Anasazi are listed in
Table~\ref{tab:anasazi:solvers}.


\begin{table}[htp]
\begin{center}
\begin{tabular}{| p{4cm} p{8cm} |}
\hline
Solver & Description \\
\hline
{\tt BlockDavidson}    & A block Davidson solver for symmetric
                         eigenvalue problems.\\
{\tt BlockKrylovSchur} & A block Krylov Schur solver for symmetric or
                         nonsymmetric problems.\\
\hline
\end{tabular}
\caption{Current eigensolvers implemented in Anasazi.}
\label{tab:anasazi:solvers}
\end{center}
\end{table}


Both the eigenproblem and the eigensolver in Anasazi are templated according to
the scalar type, the multivector type, and the operator type. The scalar type
must satisfy the interface defined by \verb!Teuchos::ScalarTraits! (see
Section~\ref{sec:teuchos:ScalarTraits}). Both the operators and the
multivectors are considered to be opaque objects. That is, only knowledge of
the matrix and vectors via elementary operations is necessary. The required
operations are specified by the interfaces \verb!MultiVecTraits! and
\verb!OperatorTraits!. An implementation of Anasazi is accomplished via use of
these interfaces. 

This flexibility allows Anasazi to utilize existing linear algebra
codes. For example, with regard to a multivector class, there are
three choices for implementing Anasazi:
\begin{itemize}
\item define a specialization of an existing class which satisfies the
\verb!MultiVecTraits! class,
\item create a subclass of \verb!Anasazi::MultiVec!, for which a
\verb!MultiVecTraits! specialization is already defined by Anasazi, or
\item use the Epetra class \verb!Epetra_MultiVector!, for which a
\verb!MultiVecTraits! specialization is already defined.
\end{itemize}

Similar to the multivector class, there are three approaches for
implementing Anasazi with regard to the linear operators:
\begin{itemize}
\item define a specialization satisfying \verb!OperatorTraits!,
\item subclass the \verb!Anasazi::Operator! abstract class, for which a
\verb!OperatorTraits! specialization already exists, or
\item use a subclass of \verb!Epetra_Operator!, 
for which a \verb!OperatorTraits! specialization is already defined.
\end{itemize}

The first and second approaches are outside the scope of this
tutorial. The third of these is the simplest and allows the usage of
any other Trilinos packages which recognize the Epetra multivector
class. The usage of the Epetra interfaces is discussed in the next
section.

Having chosen classes for the multivector and the operator, it remains
to specify the operators and initial vectors to define the eigenvalue
problem, to specify the options for the eigensolver, and to solve the
problem. Specifying the eigenvalue problem consists mainly of setting
the operators associated with the specific problem and specifying the
symmetry of the problem. 

For the eigensolver, we must first choose which eigensolver to use.  Then any
options for the eigensolver must be put into a \verb!Teuchos::ParameterList!
class (see Section~\ref{sec:teuchos:ParameterList}) and passed to the
eigensolver, along with the eigenproblem. Anasazi also makes use of the
\verb!Teuchos::RefCountPtr! smart-pointers
(Section~\ref{sec:teuchos:RefCountPtr}). Familiarity with these utility classes
will be helpful when using Anasazi. Finally, the eigensolver may also take as
an argument an instance of \verb!Anasazi::SortManager!, to determine which
eigenvalues are targeted by the solver. Usage of these classes are illustrated
in Section~\ref{sec:anasazi:example}.


%%%
%%%
%%%
\subsection{Using the Epetra interface to Anasazi}
\label{sec:anasazi:interface}

In order to use the Epetra interface to Anasazi, the user must include
the following files:
\begin{verbatim}
#include "AnasaziEpetraAdapter.hpp"
#include "AnasaziBasicEigenproblem.hpp"
\end{verbatim}
In addition, the user will need one of the following, depending on
whether MPI is used or not:
\begin{verbatim}
#include "Epetra_MpiComm.h"
#include "Epetra_SerialComm.h"
\end{verbatim}
For more information about the \verb!Epetra_Map! and \verb!Epetra_Comm!
classes, see the tutorial section covering Epetra (Sections~\ref{sec:comm} and
\ref{sec:map}).

Because Epetra makes exclusive use of double precision arithmetic,
choosing \verb!Epetra_Operator!  and \verb!Epetra_MultiVector!  makes
sense when the scalar type for the eigenproblem/solver is
\verb!double!. For brevity, we will declare type definitions for the
multivector type and operator type:
\begin{verbatim}
typedef Epetra_MultiVector MV;
typedef Epetra_Operator OP;
\end{verbatim}

We can now declare an eigenvalue problem and a solver, subclasses of
the following abstract classes:
\begin{verbatim}
Anasazi::Eigenproblem<double,MV,OP>
Anasazi::Eigensolver<double,MV,OP>
\end{verbatim}

An example defining an eigenvalue problem and solving the problem
using an Anasazi eigensolver is given in the next section.

%%%
%%%
%%%
\subsection{Defining and Solving an Eigenvalue Problem}
\label{sec:anasazi:example}

The first step in solving an eigenvalue problem is to define the eigenvalue
problem. Assume we have chosen classes to represent our scalars, multivectors
and operators, as \verb!ST!, \verb!MV! and \verb!OP!, respectively. Given an
operator \verb!A! and a multivector \verb!X! to initialize the problem, both
wrapped in \verb!Teuchos::RefCountPtr!s, we might define the eigenproblem as
follows:
\begin{verbatim}
Teuchos::RefCountPtr< BasicEigenproblem<ST,MV,OP> > MyProblem 
  = Teuchos::rcp( new BasicEigenproblem<ST,MV,OP>(A,X) );
MyProblem->SetSymmetric( true );
MyProblem->SetNEV( 5 );
MyProblem->SetProblem();
\end{verbatim}

The first line creates a \verb!BasicEigenproblem! object and wraps it
in a Teuchos smart-pointer. The second line specifies the symmetry of
the eigenproblem, information which may be utilized by the eigensolver
for extra efficiency. The third line specifies the desired number of
eigenvalues and eigenvectors. Lastly, the fourth signals that we have
finished setting up the eigenproblem. This step must be completed
before attempting to solve the problem.

Let us, for example, attempt to solve this eigenvalue problem with a
block Krylov Schur solver. First, we declare a sort manager to specify the
targeted eigenvalues:
\begin{verbatim}
std::string which("SM");
Teuchos::RefCountPtr<Anasazi::BasicSort<ST,MV,OP> > MySM =
  Teuchos::rcp( new Anasazi::BasicSort<ST,MV,OP>(which) );
\end{verbatim}
The option chosen was \verb!"SM"!, signaling that we want to compute
the eigenvalues with the smallest magnitude. Other options for the
\verb!Anasazi::BasicSort! sort manager are listed in
Table~\ref{tab:anasazi:sm}.

\begin{table}
\begin{center}
\begin{tabular}{| p{2cm} l |}
\hline
Option & Action \\
\hline
{\tt SM} & Sort eigenvalues in increasing order of magnitude \\
{\tt SR} & Sort eigenvalues in increasing order of real part \\
{\tt SI} & Sort eigenvalues in increasing order of imaginary part \\
{\tt LM} & Sort eigenvalues in decreasing order of magnitude \\
{\tt LR} & Sort eigenvalues in decreasing order of real part \\
{\tt LI} & Sort eigenvalues in decreasing order of imaginary part \\
\hline
\end{tabular}
\caption{Options for Anasazi::BasicSort.}
\label{tab:anasazi:sm}
\end{center}
\end{table}

Next we create an output manager, specifying the verbosity of the
solver:
\begin{verbatim}
Teuchos::RefCountPtr<Anasazi::OutputManager<ST> > MyOM = 
  Teuchos::rcp(  new Anasazi::OutputManager<ST>( MyPID ) );
MyOM->SetVerbosity( Anasazi::Error+Anasazi::Warning );
\end{verbatim}
Here, we have asked for information regarding errors and warnings from
the eigensolver. Other available information is listed in
Table~\ref{tab:anasazi:om}.

\begin{table}
\begin{center}
\begin{tabular}{| p{7cm} l |}
\hline
Option & Action \\
\hline
{\tt Anasazi::Error} & 
  This option is always set \\
{\tt Anasazi::Warning} & 
  Warnings \\
{\tt Anasazi::IterationDetails} & 
  Details at each iteration \\
{\tt Anasazi::OrthoDetails} & 
  Details about orthogonality \\
{\tt Anasazi::FinalSummary} & 
  A final summary \\
{\tt Anasazi::Debug} & 
  Debugging information \\
\hline
\end{tabular}
\caption{Options for Anasazi::OutputManager.}
\label{tab:anasazi:om}
\end{center}
\end{table}

We also will specify the parameters for the eigensolver:
\begin{verbatim}
Teuchos::ParameterList MyPL;
MyPL.set( "Block Size", 5 );
MyPL.set( "Max Blocks", 5 );
MyPL.set( "Max Restarts", 100 );
MyPL.set( "Tol", 1.0e-8 );
\end{verbatim}
Different eigensolvers allow different parameters.
Tables~\ref{tab:anasazi:bksparams} and \ref{tab:anasazi:bdparams} list
the settings for the block Krylov Schur and block Davidson solvers.


\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} l |}
\hline
Parameter & Default \\
\hline
{\tt Block Size}   & 1      \\
{\tt Max Blocks}   & 25     \\
{\tt Max Restarts} & 0      \\
{\tt Step Size}    & Block\_Size*Max\_Blocks*(Max\_Restarts+1) \\
{\tt Tol}          & 1.0e-6 \\
\hline
\end{tabular}
\caption{Options for Anasazi::BlockKrylovSchur}
\label{tab:anasazi:bksparams}
\end{center}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} l |}
\hline
Parameter & Default \\
\hline
{\tt Block Size} & 1      \\
{\tt Max Blocks} & 25     \\
{\tt Max Iters}  & 300    \\
{\tt Tol}        & 1.0e-6 \\
\hline
\end{tabular}
\caption{Options for Anasazi::BlockDavidson}
\label{tab:anasazi:bdparams}
\end{center}
\end{table}

We now have all of the information needed to declare the eigensolver
and solve the problem.
\begin{verbatim}
Anasazi::BlockKrylovSchur<ST,MV,OP> 
  MySolver( MyProblem, MySM, MyOM, MyPL );
\end{verbatim}
The eigenproblem is solved with the instruction
\begin{verbatim}
Anasazi::ReturnType sret = MySolver.solve();
\end{verbatim}
The return value of the solver indicates whether the algorithm
succeeded or not. Potential values are listed in
Table~\ref{tab:anasazi:rt}.

\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} l |}
\hline
Parameter & Default \\
\hline
Anasazi::Ok          & Success. \\
Anasazi::Unconverged & Solver did not converge to specified accuracy. \\
Anasazi::Failed      & An error with the input or in the solver. \\
\hline
\end{tabular}
\caption{Anasazi::ReturnType values.}
\label{tab:anasazi:rt}
\end{center}
\end{table}

A summary of results can be printed on the screen:
\begin{verbatim}
MySolver.currentStatus();
\end{verbatim}
Eigenvectors and eigenvalues can be retrieved using
\begin{verbatim}
Teuchos::RefCountPtr<Epetra_MultiVector >  evecs 
   = MyProblem->GetEvecs();
Teuchos::RefCountPtr<std::vector<double> > evals 
   = MyProblem->GetEvals();
\end{verbatim}
For a nonsymmetric problem with potentially complex eigenvalues and
eigenvectors, \verb!evecs! and \verb!evals! contain both the real and
complex parts of these, as described in the comments of
\TriExe{anasazi/ex1.cpp}.

Example \TriExe{anasazi/ex1.cpp} shows how to compute the eigenvectors
corresponding to the lowest eigenvalues for a 2D Laplace problem using
the block Krylov Schur solver.  Example \TriExe{anasazi/ex2.cpp}
solves this example, using instead the block Davidson eigensolver.
Finally, the block Krylov Schur solver is used to solve a nonsymmetric
convection-diffusion problem in Example \TriExe{anasazi/ex3.cpp}.

%Table~\ref{tab:anasazi:exLapl} reports the lower
%eigenvalues. 

%\begin{figure}[htbp]
%  \centering
%  \includegraphics[height=6cm]{anasazi_Laplace_1D.ps}
%  \caption{Lowest eigenvalues of a 1D Laplace problem, with $h=1/33$.}
%  \label{fig:anasazi:1D}
%\end{figure}

%\begin{table}[htbp]
%  \centering
%  \begin{tabular}{| l | c |}    
%    \hline
%& {\tt laplace\_2d} \\
%     \hline
%     $h = 1/33$  & 0.00905   & 0.0181    & 0.02716  \\
%     $h = 1/65$  & 0.00235   & 0.00467   & 0.007006 \\
%     $h = 1/129$ & 0.0005936 & 0.0011861 & -        \\
%     $h = 1/257$ & 0.000149  & 0.0002983 & -        \\
%     $h = 1/513$ & 3.75e-5   & -         & -        \\
%     \hline
%  \end{tabular}
%  \caption{$\lambda_{min}$ for 1D, 2D and 3D Laplace problem on a Cartesian mesh.}
%  \label{tab:anasazi:exLapl}
%\end{table}
%%%
%%%
%%%



% FIXME
%\subsection{Concluding Remarks on Anasazi}
%\label{sec:anasazi_concluding}

%More documentation on the Anasazi package can be found in
%\cite{Anasazi-Ref-Guide,Anasazi-User-Guide}.

