/**
 * Copyright 2006 Sandia Corporation.  Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Coroporation, the U.S. Government
 * retains certain rights in this software.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 */
import TSTTB version 0.7;
package TSTTG version 0.6.99
{

//This file shows the high level organization of the methods into
//interface groupings and classes

//====================================================================
// Enumerator GEntityType
//====================================================================

/**
 * TSTT supports zero-, one-, two-, and three-dimensional entities associated 
 * with a mesh infrastructure, we allow users to access these dimensional 
 * entities using the enumerated type EntityType which contains
 *   @param GVERTEX a zero-dimensional entity (value=0)
 *   @param GEDGE a one-dimensional entity  (value=1)
 *   @param GFACE a two-dimensional entity  (value=2)
 *   @param GREGION a three-dimensional entity  (value=3)
 *   @param GNUMBER_OF_ENTITY_TYPES the number of entities (value=4)
 *   @param GALL_TYPES allows the user to request information about all
 *                    entity types (value=5) 
 */ 

  enum GentityType {
    GVERTEX, 
    GEDGE, 
    GFACE, 
    GREGION,
    GALL_TYPES
  }

//===========================================================================
//  Fundamental interface from which all geometry related interfaces inherit.
//===========================================================================
/**
 * This serves as a base interface for all the TSTT geometry query interfaces.
 * This interface does not have any methods.
 */
  interface Geometry {

  }

//===========================================================================
//  Core entity set query through primitive arrays
//===========================================================================
  interface CoreQuery extends Geometry {

//==========================gLoad=============================
/** 
 * Load a model specified by name. Which formats are supported and the
 * specific meaning of this name string (e.g. file name, model name,
 * etc.) are implementation-dependent.  Options are also implementation-
 * dependent.
 * @param name Name of the model
 * @param options String options 
 */
    void load(in string name, in array<string> options,
               in int options_size) 
      throws TSTTB.Error;

//==========================gSave=============================
/** 
 * Save a model to a file specified by name. Which formats are supported and the
 * specific meaning of this name string (e.g. file name, model name,
 * etc.) are implementation-dependent.  Options are also implementation-
 * dependent.
 * @param name Name of the file to save to
 * @param options String options 
 */
    void save(in string name, in array<string> options,
               in int options_size) 
      throws TSTTB.Error;

  }

//===========================================================================
//  Topology functions
//===========================================================================
/**
 * Functions for evaluating topological characteristics of and relations 
 * between gentities of various dimensions.
 */
  interface Topology extends Geometry {

//==========================gentitysetGetGentitiesOfType=================
/**
 * Return gentities of specified dimension in this set, or in whole model.
 * @param set_handle Entity set being queried (if 0, whole model)
 * @param gentity_dimension Dimension of entities being queried
 * @param gentity_handles Gentity handles
 */
    void getEntities( in opaque set_handle,
                      in GentityType gentity_type,
                      inout array<opaque> gentity_handles,
                      inout int gentity_handles_size) 
      throws TSTTB.Error;

//==========================gentitysetGetNumberGentitiesOfType=================
/**
 * Return number of gentities of specified dimension in this set, or in
 * whole model.
 * @param set_handle Entity set being queried (if 0, whole model)
 * @param gentity_dimension Dimension of entities being queried
 * @return Number of entities
 */
    int getNumOfType(in opaque set_handle, in GentityType gentity_type) 
      throws TSTTB.Error;

    GentityType getEntType( in opaque handle ) throws TSTTB.Error;

//==========================gentityGetType=================
/**
 *    Returns an integer array of topological dimensions for an input
 *    array of entity handles.
 */
    void getArrType(in array<opaque> gentity_handles,
                    in int gentity_handles_size,
                    inout array<GentityType> gtype,
                    inout int gtype_size) 
      throws TSTTB.Error;
  

//==========================gentityGetAdjacencies=================
/**
 * Get the adjacent entities of a given dimension.
 * @param gentity_handle Entity for which adjacencies are requested
 * @param to_dimension Target dimension of adjacent entities
 * @param adj_gentities List returned with adjacent entities
 */
    void getEntAdj(in opaque gentity_handle, 
                   in GentityType to_dimension, 
                   inout array<opaque> adj_gentities,
                   inout int adj_gentities_size) 
      throws TSTTB.Error;
  
    void getArrAdj( in array<opaque> entity_handles,
                    in int entity_handles_size,
                    in GentityType requested_entity_type,
                    inout array<opaque> adj_entity_handles,
                    inout int adj_entity_handles_size,
                    inout array<int> offset, 
                    inout int offset_size
                  ) throws TSTTB.Error;

//==========================gentityGet2OAdjacencies=================
/**
 * Get the "2nd order" adjacent entities, through a specified "bridge"
 * dimension, of a target dimension.  For example, given a region, return
 * the regions (to_dimension=3) sharing an edge (bridge_dimension=1)
 * with that region.  bridge_dimension must be less than dimension of 
 * gentity_handle, and to_dimension must be greater than bridge dimension.
 * 
 * @param gentity_handle Entity for which 2nd order adjacencies are requested
 * @param to_dimension Target dimension of 2nd order adjacent entities
 * @param bridge_dimension Dimension of "bridge" entities
 * @param adj_gentities List returned with 2nd order adjacent entities
 */
    void getEnt2ndAdj(in opaque gentity_handle, 
                      in GentityType bridge_dimension, 
                      in GentityType to_dimension, 
                      inout array<opaque> adjacent_gentities,
                      inout int adjacent_gentities_size) 
      throws TSTTB.Error;

    void getArr2ndAdj( in array<opaque> entity_handles,
                       in int entity_handles_size,
                       in GentityType order_adjacent_key,
                       in GentityType requested_entity_type,
                       inout array<opaque> adj_entity_handles,
                       inout int adj_entity_handles_size,
                       inout array<int> offset, 
                       inout int offset_size
                     ) throws TSTTB.Error;

//==========================gentityIsAdjacent=================
/**
 * Return whether or not entities are adjacent.
 * @param gentity_handle1 1st entity
 * @param gentity_handle2 2nd entity
 * @param are_adjacent If true, entities are adjacent
 */
    int isEntAdj(in opaque gentity_handle1, in opaque gentity_handle2,
                  out bool are_adjacent) 
      throws TSTTB.Error;
  
    void isArrAdj ( in array<opaque> entity_handles_1,
                    in int entity_handles_1_size,
                    in array<opaque> entity_handles_2,
                    in int entity_handles_2_size,
                    inout array <int> is_adjacent_info,
                    inout int is_adjacent_info_size
                  ) throws TSTTB.Error;


    int getTopoLevel( in string model_name ) throws TSTTB.Error;
  }

//===========================================================================
//  Shape functions
//===========================================================================
/**
 * Functions for evaluating shape characteristics of gentities of 
 * various dimensions.
 */
  interface Shape extends Geometry {

//==========================gentityClosestPoint=================

    void getEntClosestPt( in opaque entity_handle,
                          in double near_x, in double near_y, in double near_z,
                          out double on_x, out double on_y, out double on_z
                          ) throws TSTTB.Error;

/**
 * Return a points on specified entities closest to specified points
 * in space.  Input coordinates and output points are interleaved in 
 * the arrays.
 * @param gentity_handles The gentities being queried
 * @param near_coordinates Input coordinates
 * @param on_coordinates Closest point on gentity
 */
    void getArrClosestPt(in array<opaque> gentity_handles, 
                         in int gentity_handles_size,
                         in TSTTB.StorageOrder storage_order,
                         in array <double> near_coordinates, 
                         in int near_coordinates_size,
                         inout array <double> on_coordinates,
                         inout int on_coordinates_size) 
      throws TSTTB.Error;
   
//==========================gentityNormal=================
    void getEntNrmlXYZ( in opaque entity_handle,
                        in double x, in double y, in double z,
                        out double nrml_i, out double nrml_j, out double nrml_k
                        ) throws TSTTB.Error;

/**
 * Return the normals at point on specified entities.  Returns error
 * if any input entity is not a gface.  Input coordinates and normals
 * are interleaved in the arrays.
 * @param gentity_handles The gentities being queried
 * @param coordinates Input coordinates, interleaved
 * @param normals The normals at the specified points, interleaved
 */
    void getArrNrmlXYZ(in array<opaque> gentity_handles, 
                       in int gentity_handles_size,
                       in TSTTB.StorageOrder storage_order,
                       in array <double> coordinates, 
                       in int coordinates_size,
                       inout array <double> normals,
                       inout int normals_size) 
      throws TSTTB.Error;
   
//==========================gentityClosestPointAndNormal=================
    void getEntNrmlPlXYZ( in opaque entity_handle,
                          in double x, in double y, in double z,
                          out double pt_x, out double pt_y, out double pt_z,
                          out double nrml_i, out double nrml_j, out double nrml_k
                        ) throws TSTTB.Error;

/**
 * Return points and normals on specified entities closest to specified points
 * in space.  Input coordinates and output points are interleaved in 
 * the arrays.
 * @param gentity_handles The gentities being queried
 * @param near_coordinates Input coordinates
 * @param on_coordinates Closest point on gentity
 * @param normals Normals on gentity
 */
    void getArrNrmlPlXYZ(in array<opaque> gentity_handles, 
                         in int gentity_handles_size,
                         in TSTTB.StorageOrder storage_order,
                         in array <double> near_coordinates, 
                         in int near_coordinates_size,
                         inout array <double> on_coordinates,
                         inout int on_coordinates_size,
                         inout array <double> normals,
                         inout int normals_size) 
      throws TSTTB.Error;
   
//==========================gentityTangent=================


    void getEntTgntXYZ( in opaque entity_handle,
                        in double x, in double y, in double z,
                        out double tgnt_i, out double tgnt_j, out double tgnt_k
                        ) throws TSTTB.Error;
/**
 * Return the tangent at point on specified entities.  Returns error
 * if any input entity is not a gedge.  Input coordinates and tangents
 * are interleaved in the arrays.
 * @param gentity_handles The gentities being queried
 * @param coordinates Input coordinates, interleaved
 * @param tangents The tangents at the specified points, interleaved
 */
    void getArrTgntXYZ(in array<opaque> gentity_handles, 
                       in int gentity_handles_size,
                       in TSTTB.StorageOrder storage_order,
                       in array <double> coordinates, 
                       in int coordinates_size,
                       inout array <double> tangents,
                       inout int tangents_size) 
      throws TSTTB.Error;
   
// Various Derivatives

    void getFcCvtrXYZ( in opaque face_handle,
                       in double x, in double y, in double z,
                       out double cvtr1_i, out double cvtr1_j, out double cvtr1_k,
                       out double cvtr2_i, out double cvtr2_j, out double cvtr2_k
                       ) throws TSTTB.Error;

    void getEgCvtrXYZ( in opaque edge_handle,
                       in double x, in double y, in double z,
                       out double cvtr_i, out double cvtr_j, out double cvtr_k
                       ) throws TSTTB.Error;

    void getEntArrCvtrXYZ( in array<opaque> entity_handles,
                           in int entity_handles_size,
                           in TSTTB.StorageOrder storage_order,
                           in array<double> coords, in int coords_size,
                           inout array<double> cvtr_1, inout int cvtr_1_size,
                           inout array<double> cvtr_2, inout int cvtr_2_size
                        ) throws TSTTB.Error;

    void getEgEvalXYZ( in opaque edge_handle,
                       in double x, in double y, in double z,
                       out double on_x, out double on_y, out double on_z,
                       out double tgnt_i, out double tgnt_j, out double tgnt_k,
                       out double cvtr_i, out double cvtr_j, out double cvtr_k
                     ) throws TSTTB.Error;

    void getFcEvalXYZ( in opaque face_handle,
                       in double x, in double y, in double z,
                       out double on_x, out double on_y, out double on_z,
                       out double nrml_i, out double nrml_j, out double nrml_k,
                       out double cvtr1_i, out double cvtr1_j, out double cvtr1_k,
                       out double cvtr2_i, out double cvtr2_j, out double cvtr2_k
                     ) throws TSTTB.Error;

    void getArrEgEvalXYZ( in array<opaque> edge_handles,
                          in int edge_handles_size,
                          in TSTTB.StorageOrder storage_order,
                          in array<double> coords, in int coords_size,
                          inout array<double> on_coords, inout int on_coords_size,
                          inout array<double> tangent, inout int tangent_size,
                          inout array<double> cvtr, inout int cvtr_size
                        ) throws TSTTB.Error;

    void getArrFcEvalXYZ( in array<opaque> face_handles,
                          in int face_handles_size,
                          in TSTTB.StorageOrder storage_order,
                          in array<double> coords, in int coords_size,
                          inout array<double> on_coords, inout int on_coords_size,
                          inout array<double> normal, inout int normal_size,
                          inout array<double> cvtr_1, inout int cvtr_1_size,
                          inout array<double> cvtr_2, inout int cvtr_2_size
                        ) throws TSTTB.Error;

//==========================gentityBoundingBox=================

    void getEntBoundBox( in opaque entity_handle,
                         out double min_x, out double min_y, out double min_z,
                         out double max_x, out double max_y, out double max_z
                         ) throws TSTTB.Error;

/**
 * Return the bounding boxex of given entities; coordinates returned
 * interleaved.
 * @param gentity_handles The gentities being queried
 * @param min_corners Minimum corner coordinates of the boxes, interleaved
 * @param max_corners Maximum corner coordinates of the boxes, interleaved
 */
    void getArrBoundBox(in array<opaque> gentity_handles, 
                        in int gentity_handles_size,
                        inout TSTTB.StorageOrder storage_order,
                        inout array <double> min_corner, 
                        inout int min_corner_size,
                        inout array <double> max_corner,
                        inout int max_corner_size) 
      throws TSTTB.Error;

//==========================getGvertexCoordinates=================
   
    void getVtxCoord( in opaque vertex_handle,
                      out double x, out double y, out double z
                    ) throws TSTTB.Error;

/**
 * Return the coordinates of the specified vertices; returns error if any
 * of the entities are not gvertices.  Coordinates returned interleaved.
 * @param gentity_handles The gentities being queried
 * @param coordinates The coordinates of the gvertices, interleaved.
 */
    void getVtxArrCoords(in array<opaque> gentity_handles, 
                         in int gentity_handles_size,
                         inout TSTTB.StorageOrder storage_order,
                         inout array <double> coordinates,
                         inout int coordinates_size)
      throws TSTTB.Error;
   
    void getPntIntsct( in double x, in double y, in double z,
                       in double dir_x, in double dir_y, in double dir_z,
                       inout array<opaque> intersect_entity_handles,
                       inout int intersect_entity_handles_size,
                       inout TSTTB.StorageOrder storage_order,
                       inout array<double> intersect_coords,
                       inout int intersect_coords_size,
                       inout array<double> param_coords,
                       inout int param_coords_size
                     ) throws TSTTB.Error;

    void getPntArrRayIntsct( in TSTTB.StorageOrder storage_order,
                             in array<double> coords, 
                             in int coords_size,
                             in array<double> directions,
                             in int directions_size,
                             inout array<opaque> intersect_entity_handles,
                             inout int intersect_entity_handles_size,
                             inout array<int> offset, 
                             inout int offset_size,
                             inout array<double> intersect_coords,
                             inout int intersect_coords_size,
                             inout array<double> param_coords,
                             inout int param_coords_size
                           ) throws TSTTB.Error;

    void getPntClsf( in double x, in double y, in double z,
                     out opaque entity_handle) throws TSTTB.Error;

    void getPntArrClsf( in TSTTB.StorageOrder storage_order,
                        in array<double> coords, in int coords_size,
                        inout array<opaque> entity_handles,
                        inout int entity_handles_size
                      ) throws TSTTB.Error;

//==========================getGnormalSense=================
/**
 * Return the sense of a gface with respect to a gregion.  Sense is either
 * forward (=1), reverse (=-1), both (=2), or unknown (=0).  Error is returned
 * if first entity is not a gface or second entity is not a gregion.
 * @param gface Gface whose sense is being queried.
 * @param gregion Gregion gface is being queried with respect to
 */
    int getEntNrmlSense(in opaque gface,
                        in opaque gregion) 
      throws TSTTB.Error;

    void getArrNrmlSense( in array<opaque> face_handles,
                          in int face_handles_size,
                          in array<opaque> region_handles,
                          in int region_handles_size,
                          inout array<int> sense, 
                          inout int sense_size
                        ) throws TSTTB.Error;
   
//==========================getGtangentSense=================
/**
 * Return the sense of a gedge with respect to a gface.  Sense is either
 * forward (=1), reverse (=-1), both (=2), or unknown (=0).  Error is returned
 * if first entity is not a gedge or second entity is not a gface.
 * @param gedge Gedge whose sense is being queried.
 * @param gface Gface gedge is being queried with respect to
 */
    int getEgFcSense(in opaque gedge,
                     in opaque gface)
      throws TSTTB.Error;

    void getEgFcArrSense( in array<opaque> edge_handles,
                          in int edge_handles_size,
                          in array<opaque> face_handles,
                          in int face_handles_size,
                          inout array<int> sense, 
                          inout int sense_size
                        ) throws TSTTB.Error;
   
//==========================getGvertexTangentSense=================
/**
 * Return the sense of a gedge with respect to a specified order of
 * vertices bounding the gedge.  Sense is either forward (=1), reverse (=-1), 
 * or unknown (=0).  Error is returned if any gentities are not the expected
 * type or if the gedge is bounded by only one gvertex (in this case, use
 * getGtangentSense).
 * @param gedge Gedge whose sense is being queried.
 * @param gvertex1 First gvertex
 * @param gvertex2 Second gvertex
 */
    int getEgVtxSense(in opaque gedge,
                      in opaque gvertex1,
                      in opaque gvertex2)
      throws TSTTB.Error;

    void getEgVtxArrSense( in array<opaque> edge_handles,
                           in int edge_handles_size,
                           in array<opaque> vertex_handles_1,
                           in int vertex_handles_1_size,
                           in array<opaque> vertex_handles_2,
                           in int vertex_handles_2_size,
                           inout array<int> sense, 
                           inout int sense_size
                         ) throws TSTTB.Error;

//==========================gentityMeasure=================
/**
 * Return the arc length / area / volume of the entities
 * @param gentity_handles Entities for which measure is requested
 * @param gentity_handles_size Number of gentities
 * @param measures Arc length / area / volume of the entities
 * @param measures_length Number of entries in measures
 */
    void measure(in array<opaque> gentity_handles,
                 in int gentity_handles_size,
                 inout array<double> measures,
                 inout int measures_size) throws TSTTB.Error;

//==========================getFaceType=================
/**
 * Return the type of surface as a string; if not a surface, an error is returned
 * @param face_handle Face for which the type is requested
 * @param face_type Type of face, returned as a string
 */
    void getFaceType(in opaque gface_handle,
                     inout string face_type) throws TSTTB.Error;
  }

//===========================================================================
//  Parametric interface
//===========================================================================
/**
 * Functions dealing with parametric space and parameter-based evaluation
 */
  interface Parametric extends Geometry {

  int getParametric() throws TSTTB.Error;

//==========================gentityIsParametric=================
/**
 * Return whether a given gentity is parametric or not.  If a gentity
 * is not parametric, all of the following functions will return an error
 * when called on that entity.
 * @param gentity_handle Gentity being queried.
 */
    int isEntParametric(in opaque gentity_handle) 
      throws TSTTB.Error;
      
    void isArrParametric( in array<opaque> entity_handles,
                          in int entity_handles_size,
                          inout array<int> is_parametric,
                          inout int is_parametric_size
                        ) throws TSTTB.Error;


//==========================gentityUvToXyz=================
    void getEntUVtoXYZ( in opaque entity_handle, in double u, in double v,
                        out double x, out double y, out double z
                      ) throws TSTTB.Error;
/**
 * Given sets of parametric coordinates, return the corresponding real
 * space coordinates on the gentities.  Input and output coordinates are
 * interleaved.
 * @param gentity_handles Gentities being queried.
 * @param uv Input parametric coordinates
 * @param xyz Output real space coordinates
 */
    void getArrUVtoXYZ(in array<opaque> gentity_handles, 
                       in int gentity_handles_size,
                       in TSTTB.StorageOrder storage_order,
                       in array <double> uv, 
                       in int uv_size,
                       inout array <double> coordinates,
                       inout int coordinates_size) 
      throws TSTTB.Error;


    void getEntUtoXYZ( in opaque entity_handle, in double u,
                       out double x, out double y, out double z
                     ) throws TSTTB.Error;

    void getArrUtoXYZ( in array<opaque> entity_handles,
                       in int entity_handles_size,
                       in array<double> u, 
                       in int u_size,
                       inout TSTTB.StorageOrder storage_order,
                       inout array<double> on_coords, 
                       inout int on_coords_size
                     ) throws TSTTB.Error;

//==========================gentityXyzToUv=================
    void getEntXYZtoUV( in opaque entity_handle,
                        in double x, in double y, in double z,
                        out double u, out double v) throws TSTTB.Error;

    void getEntXYZtoU( in opaque entity_handle,
                       in double x, in double y, in double z,
                       out double u) throws TSTTB.Error;

/**
 * Given sets of real space coordinates, return the corresponding 
 * parametric coordinates on the gentities.  Input and output coordinates 
 * are interleaved.
 * @param gentity_handles Gentities being queried.
 * @param xyz Input real space coordinates
 * @param uv Output parametric coordinates
 */
    void getArrXYZtoUV(in array<opaque> gentity_handles, 
                       in int gentity_handles_size,
                       in TSTTB.StorageOrder storage_order,
                       in array <double> coordinates,
                       in int coordinates_size,
                       inout array <double> uv,
                       inout int uv_size) 
      throws TSTTB.Error;

    void getArrXYZtoU(in array<opaque> gentity_handles, 
                       in int gentity_handles_size,
                       in TSTTB.StorageOrder storage_order,
                       in array <double> coordinates,
                       in int coordinates_size,
                       inout array <double> u,
                       inout int u_size) 
      throws TSTTB.Error;

    void getEntXYZtoUVHint( in opaque entity_handle,
                            in double x, in double y, in double z,
                            inout double u, inout double v
                          ) throws TSTTB.Error;

    void getArrXYZtoUVHint( in array<opaque> entity_handles,
                            in int entity_handles_size,
                            in TSTTB.StorageOrder storage_order,
                            in array<double> coords, in int coords_size,
                            inout array<double> uv, inout int uv_size
                          ) throws TSTTB.Error;

//==========================gentityUvRange=================
    void getEntUVRange( in opaque entity_handle,
                        out double u_min, out double v_min,
                        out double u_max, out double v_max
                      ) throws TSTTB.Error;

    void getEntURange( in opaque entity_handle,
                       out double u_min, out double u_max) throws TSTTB.Error;

/**
 * Return the uv range of the specified gentities.  Parameters are interleaved.
 * @param gentity_handles Gentities being queried.
 * @param uv_min Minimum parameters of gentities, interleaved
 * @param uv_max Maximum parameters of gentities, interleaved
 */
    void getArrUVRange(in array<opaque> gentity_handles, 
                        in int gentity_handles_size,
                        inout TSTTB.StorageOrder storage_order,
                        inout array <double> uv_min, 
                        inout int uv_min_size,
                        inout array <double> uv_max,
                        inout int uv_max_size) 
      throws TSTTB.Error;

    void getArrURange( in array<opaque> entity_handles,
                       in int entity_handles_size,
                       inout array<double> u_min, inout int u_min_size,
                       inout array<double> u_max, inout int u_max_size
                     ) throws TSTTB.Error;

//==========================getAdjacentUv=================
    void getEntUtoUV( in opaque edge_handle, in opaque face_handle,
                      in double in_u, out double u, out double v
                    ) throws TSTTB.Error;
                    
    void getVtxToUV (in opaque vertex_handle, in opaque face_handle,
                     out double u, out double v) throws TSTTB.Error;
                     
    void getVtxToU( in opaque vertex_handle, in opaque edge_handle,
                    out double u) throws TSTTB.Error;
                    
    void getArrUtoUV( in array<opaque> edge_handles,
                      in int edge_handles_size,
                      in array<opaque> face_handles,
                      in int face_handles_size,
                      in array<double> u_in, in int u_in_size,
                      inout TSTTB.StorageOrder storage_order,
                      inout array<double> uv, inout int uv_size
                    ) throws TSTTB.Error;
                    
    void getVtxArrToUV( in array<opaque> vertex_handles,
                        in int vertex_handles_size,
                        in array<opaque> face_handles,
                        in int face_handles_size,
                        inout TSTTB.StorageOrder storage_order,
                        inout array<double> uv, inout int uv_size
                      ) throws TSTTB.Error;
                      
    void getVtxArrToU( in array<opaque> vertex_handles,
                       in int vertex_handles_size,
                       in array<opaque> edge_handles,
                       in int edge_handles_size,
                       inout array<double> u, inout int u_size
                     ) throws TSTTB.Error;


//==========================gentityNormalUv=================
    void getEntNrmlUV( in opaque entity_handle, in double u, in double v,
                       out double nrml_i, out double nrml_j, out double nrml_k
                     ) throws TSTTB.Error;
/**
 * Return the normals at specified uv positions on gfaces.  If any
 * gentity input is not a face, returns error.  Input parameters and 
 * output normals are interleaved.
 * @param gface_handles The entities being queried
 * @param parameters The uv parameters of points being queried, interleaved
 * @param normals Normals at specified points, interleaved
 */
    void getArrNrmlUV(in array<opaque> gface_handles, 
                      in int gface_handles_size, 
                      in TSTTB.StorageOrder storage_order,
                      in array <double> parameters, 
                      in int parameters_size, 
                      inout array <double> normals,
                      in int normals_size) 
      throws TSTTB.Error;
   
//==========================gentityTangentU=================
    void getEntTgntU( in opaque entity_handle, in double param_coord,
                      out double tngt_i, out double tngt_j, out double tngt_k
                    ) throws TSTTB.Error;
/**
 * Return the tangents at specified u positions on gedges.  If any
 * gentity input is not a face, returns error.  Output normals are 
 * interleaved.
 * @param gentity_handles The gedges being queried
 * @param parameters The u parameters of points being queried
 * @param tangents Tangents at specified points, interleaved
 */
    void getArrTgntU( in array<opaque> gedge_handles, 
                      in int gedge_handles_size,
                      in TSTTB.StorageOrder storage_order,
                      in array <double> parameters, 
                      in int parameters_size, 
                      inout array <double> tangents,
                      inout int tangents_size) 
      throws TSTTB.Error;

    void getEnt1stDrvt( in opaque entity_handle, in double u, in double v,
                        inout array<double> drvt_u, inout int drvt_u_size,
                        inout array<double> drvt_v, inout int drvt_v_size
                      ) throws TSTTB.Error;

    void getArr1stDrvt( in array<opaque> entity_handles,
                        in int entity_handles_size,
                        in TSTTB.StorageOrder storage_order,
                        in array<double> uv, in int uv_size,
                        inout array<double> drvt_u, inout int drvt_u_size,
                        inout array<int> u_offset, inout int u_offset_size,
                        inout array<double> drvt_v, inout int drvt_v_size,
                        inout array<int> v_offset, inout int v_offset_size
                      ) throws TSTTB.Error;

    void getEnt2ndDrvt ( in opaque entity_handle, in double u, in double v,
                         inout array<double> drvt_uu, inout int drvt_uu_size,
                         inout array<double> drvt_vv, inout int drvt_vv_size,
                         inout array<double> drvt_uv, inout int drvt_uv_size
                       ) throws TSTTB.Error;

    void getArr2ndDrvt( in array<opaque> entity_handles,
                        in int entity_handles_size,
                        in TSTTB.StorageOrder storage_order,
                        in array<double> uv, in int uv_size,
                        inout array<double> drvt_uu, inout int drvt_uu_size,
                        inout array<int> uu_offset, inout int uu_offset_size,
                        inout array<double> drvt_vv, inout int drvt_vv_size,
                        inout array<int> vv_offset, inout int vv_offset_size,
                        inout array<double> drvt_uv, inout int drvt_uv_size,
                        inout array<int> uv_offset, inout int uv_offset_size
                      ) throws TSTTB.Error;

    void getFcCvtrUV( in opaque entity_handle, in double u, in double v,
                out double cvtr1_i, out double cvtr1_j, out double cvtr1_k,
                out double cvtr2_i, out double cvtr2_j, out double cvtr2_k
                ) throws TSTTB.Error;

    void getFcArrCvtrUV( in array<opaque> face_handles,
                         in int face_handles_size,
                         in TSTTB.StorageOrder storage_order,
                         in array<double> uv, 
                         in int uv_size,
                         inout array<double> cvtr_1, 
                         inout int cvtr_1_size,
                         inout array<double> cvtr_2, 
                         inout int cvtr_2_size
                       ) throws TSTTB.Error;

    void isEntPeriodic( in opaque entity_handle, out int in_u, out int in_v
                      ) throws TSTTB.Error;

    void isArrPeriodic( in array<opaque> entity_handles,
                        in int entity_handles_size,
                        inout array<int> in_uv,
                        inout int in_uv_size
                      ) throws TSTTB.Error;

    int isFcDegenerate( in opaque face_handle) throws TSTTB.Error;

    void isFcArrDegenerate( in array<opaque> face_handles,
                            in int face_handles_size,
                            inout array<int> degenerate,
                            inout int degenerate_size
                          ) throws TSTTB.Error;

  }

 
//===========================================================================
//  Tolerance interface
//===========================================================================
/**
 * Tolerances (relative and absolute) for models and gentities in a model
 */
  interface Tolerance extends Geometry {

//==========================getGtolerance=================
/**
 * Return the relative and absolute tolerances at the modeler level.  If
 * model does not have a modeler-wide tolerance, zero is returned for both
 * values.
 * @param relative_tolerance Relative tolerance for model as a whole
 * @param absolute_tolerance Absolute tolerance for model as a whole
 */
    void getTolerance(out int type,
                      out double tolerance)
      throws TSTTB.Error;
   
//==========================getGentityTolerance=================
    double getEntTolerance( in opaque entity_handle) throws TSTTB.Error;
/**
 * Return the relative and absolute tolerances for specified gentities.  If
 * a gentity does not have a specific tolerance, zero is returned for both
 * values.
 * @param gentity_handles Gentities being queried
 * @param relative_tolerances Relative tolerances
 * @param absolute_tolerances Absolute tolerances
 */
    void getArrTolerance(in array<opaque> entity_handles,
                         in int entity_handles_size,
                         inout array<double> tolerances,
                         inout int tolerances_size)
      throws TSTTB.Error;

  }

//===========================================================================
//  Iterators interface
//===========================================================================
/**
 * This interface provides a means for iterating over all gentities of
 * a given topological dimension
 */
  interface Iterators extends Geometry {

//==========================gentityIteratorInit=================
/**
 * Initialize an iterator over gentities of a specified dimension.
 * @param gentity_dimension Dimension of gentities to be iterated over
 * @param gentity_iterator Iterator initialized by this function
 */
    void initEntIter(in int gentity_dimension, 
                     out opaque gentity_iterator) 
      throws TSTTB.Error;
    bool initEntArrIter( in opaque entity_set_handle,
                         in GentityType requested_entity_type,
                         in int requested_array_size,
                         out opaque entArr_iterator
                       ) throws TSTTB.Error;

//==========================gentityIteratorNext=================
/**
 * Get the next entity for this iterator.
 * @param gentity_iterator Iterator being iterated over
 * @param gentity_handle Next gentity
 * @return If true, there are more gentities, if false, this is the last one
 */
    bool getNextEntIter(inout opaque gentity_iterator, 
                        out opaque gentity_handle) 
      throws TSTTB.Error;
      
    bool getNextEntArrIter( in opaque entArr_iterator,
                            inout array<opaque> entity_handles,
                            inout int entity_handles_size) throws TSTTB.Error;

//==========================gentityIteratorReset=================
/**
 * Reset an iterator back to the first gentity
 * @param gentity_iterator Iterator reset by this function
 */
    void resetEntIter (in opaque gentity_iterator) 
      throws TSTTB.Error;
      
    void resetEntArrIter( in opaque entArr_iterator) throws TSTTB.Error;
    
//==========================gentityIteratorDelete=================
/**
 * Delete an iterator
 * @param gentity_iterator Iterator deleted by this function
 */
    void endEntIter (in opaque Gentity_dim_iterator) 
      throws TSTTB.Error;

    void endEntArrIter( in opaque entArr_iterator) throws TSTTB.Error;
  }


  interface Modify extends Geometry 
    {
    }
  
  interface Construct extends Modify
    {
        /* Duplicate the input entity
         */
      void Copy(in opaque geom_entity,
                out opaque geom_entity2) 
        throws TSTTB.Error;
      
        /* Sweep the entity around axis specified by normal, by angle specified in degrees.
         * Generates a new entity, leaving input entity unchanged.
         * Result undefined if region (dim = 3) is specified
         */
      void SweepAboutAxis(in opaque geom_entity,
                          in double angle,
                          in double axis_normal_x, 
                          in double axis_normal_y, 
                          in double axis_normal_z, 
                          out opaque geom_entity2) 
        throws TSTTB.Error;
      
        /* Delete the specified entity.  Deletes any lower-dimensional entities.
         * Result undefined if any higher-dimensional entities still use input
         * entity.
         */
      void Delete(in opaque geom_entity) 
        throws TSTTB.Error;
    }

  interface Primitives extends Modify
    {
        /* Construct a brick with specified dimensions.  If both y and z are
         * zero, a cube of dimension x is constructed.  
         * Result is undefined if only one dimension is zero.
         */
      void Brick(in double x, in double y, in double z,
                 out opaque geom_entity) 
        throws TSTTB.Error;
          
        /* Construct a cylinder with specified height and major/minor radii.
         * Major radius is along x axis, minor along y axis, and height along z.
         * If minor radius is zero, a circular cylinder is produced.
         */
      void Cylinder(in double height, in double major_rad, in double minor_rad,
                    out opaque geom_entity) 
        throws TSTTB.Error;
          
        /* Construct a torus with circular cross-section, with major and minor
         * radii specified.  Torus is aligned with z axis, i.e. the locus of points
         * defined by the cross-section centers lies in the xy plane.
         */
      void Torus(in double major_rad, in double minor_rad,
                 out opaque geom_entity) 
        throws TSTTB.Error;
    }
  
  interface Transforms extends Modify
    {
        /* Move the specified entity by the specified vector 
         */
      void Move(inout opaque geom_entity,
                in double x, in double y, in double z) 
        throws TSTTB.Error;
      
        /* Rotate the specified entity the specified angle (in degrees) about the
         * specified axis; axis_normal is assumed to pass through the origin.
         */
      void Rotate(inout opaque geom_entity,
                  in double angle, 
                  in double axis_normal_x,
                  in double axis_normal_y,
                  in double axis_normal_z) 
        throws TSTTB.Error;
      
        /* Reflect the specified entity through a plane defined by the specified normal
         */
      void Reflect(inout opaque geom_entity,
                   in double plane_normal_x,
                   in double plane_normal_y,
                   in double plane_normal_z) 
        throws TSTTB.Error;

        /* scale the specified entity 
         */
      void Scale(inout opaque geom_entity,
                 in double scale_x,
                 in double scale_y,
                 in double scale_z) 
        throws TSTTB.Error;
    }
  
  interface Booleans extends Modify
    {
        /* Unite the specified entities, resulting in a new entity; original entities
         * are unmodified
         */
      void Unite(in array<opaque> geom_entities,
                 in int geom_entities_size,
                 out opaque geom_entity) 
        throws TSTTB.Error;
      
        /* Subtract the tool from the blank, resulting in a new entity; original
         * entities are unmodified
         */
      void Subtract(in opaque blank, in opaque tool,
                    out opaque geom_entity) 
        throws TSTTB.Error;

        /* Cut the specified entity with a plane containing the origin defined by 
         * the specified normal, discarding anything on the negative side of the
         * plane (as defined by the normal direction).  If offset is specified, 
         * plane is offset along the normal direction by the specified distance.  
         * If reverse is true, positive side of the plane is discarded instead.
         */
      void Section(inout opaque geom_entity, 
                   in double plane_normal_x,
                   in double plane_normal_y,
                   in double plane_normal_z,
                   in double offset, in bool reverse,
                   out opaque geom_entity2) 
        throws TSTTB.Error;

        /* Imprint the entities in the input list together.
         */
      void Imprint(in array<opaque> geom_entities,
                   in int geom_entities_size) 
        throws TSTTB.Error;

        /* Merge coincident topology in the entities in the input list.
         */
      void Merge(in array<opaque> geom_entities,
                 in int geom_entities_size,
                 in double tolerance) 
        throws TSTTB.Error;
    };

  class Factory {
     static Geometry newGeom(in string option) throws TSTTB.Error;
   };
}

