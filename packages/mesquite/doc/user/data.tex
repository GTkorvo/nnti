% alternative names
%\chapter{Telling Mesquite About Your Mesh}
\chapter{Accessing Mesh and Geometry}
\label{sec:meshes}

Mesquite is responsible for gathering information from the
application's mesh and geometry.  Because this must be as efficient as
possible, considerable attention has been given to the interface
between Mesquite and the application code.  Because Mesquite is
designed as a library to work on a broad assortment of mesh and
element types on complex geometrical domains, a general,
data-structure neutral API is needed.  In general, Mesquite requires
access to basic information about the mesh such as the number of
vertices and elements in the mesh, the vertex locations, and the
element connectivities.  To move the vertex locations, Mesquite needs
to set the vertex coordinate positions, and eventually, to perform
swapping operations Mesquite will need to add and delete various mesh
entities.  In addition, for smoothing meshes on complex surfaces,
evaluations of the associated geometric or CAD model such as normal
information and closest point information are required to ensure
vertices are constrained to the geometric domain.

Mesquite defines object interfaces for accessing mesh data and quering 
geometric domains.  These are defined in the {\tt Mesquite::Mesh} and 
{\tt Mesquite::MeshDomain} classes.  An application will typically provide custom implementations of the {\tt Mesquite::Mesh} and {\tt Mesquite::MeshDomain} interfaces.  However, Mesquite also provides 
implementations of the {\tt Mesquite::Mesh} interface for accessing 
mesh via files (Section \ref{sec:meshFiles}) and for accessing mesh
through the TSTT mesh interface (section \ref{sec:TSTT}.  Additionally, Mesquite provides a few trivial implementations of {\tt Mesquite::MeshDomain} for working with two-dimensional meshes and for testing.

\section{Mesh Interface Concepts}

To expose this information, Mesquite defines a set of interfaces 
(C++ abstract base classes) that are specifically designed for mesh
quality improvement needs.  There are four such interfaces: \texttt{Mesh},
\texttt{VertexIterator}, \texttt{ElementIterator}, and \texttt{MeshDomain}.
\begin{itemize}
\item \texttt{Mesh}: The Mesh interface represents the set of mesh
entities that are to be operated on.  It is through this interface
that Mesquite retrieves information about the mesh and its entities.
Examples of functionality provided by this interface include:
retrieving the number of elements in the mesh, determining which
elements contain a particular vertex, and modifying vertex
coordinates.
\item \texttt{VertexIterator}: The VertexIterator provides access to each
vertex in a mesh.  A VertexIterator is obtained from a Mesh object,
and is used to iterate through the list of all vertices in the Mesh
from which it was obtained.
\item \texttt{ElementIterator}: The ElementIterator provides access to
each element in a mesh.  Other than the type of entity it exposes, it
is identical to the VertexIterator.
\item \texttt{MeshDomain}: The MeshDomain represents the set of geometric
domains to which the mesh may be constrained. Its implementation is \emph{not} systematically 
required. See section \ref{sec:geometry} for more details. 
%The MeshDomain
%interface enables an application to restrict the locations to which a
%vertex can be moved, such as constraining a vertex to a surface.
%Through the MeshDomain interface, Mesquite's algorithms can also
%obtain a domain's normal vector, which aides validity checking and 
%decision making during the quality improvement process.
\end{itemize}
These interfaces are data-structure neutral and use only primitive
data types; an application may implement the Mesquite interfaces
without changing its existing mesh data structures.  Mesquite uses
handles to reference individual mesh entities.  Mesquite will treat
the handles as an opaque value.  It is guaranteed that the {\tt Mesh::EntityHandle} type is at least the size of a pointer. 

\section{Reading in a Mesh File} \label{sec:meshFiles}

The simplest way to start using Mesquite is to import a mesh from a file
using the {\tt MeshImpl} class in Mesquite.  The {\tt MeshImpl} class supports reading
mesh from VTK version 2.0 \cite{VTKbook, VTKuml} and optionally ExodusII
files. See Sections \ref{sec:depends} and \ref{sec:compiling} for more 
information regarding the optional support for ExodusII files.
The functions \texttt{MeshImpl::read\_vtk()}
and \texttt{MeshImpl::read\_exodus()} are used to read mesh from files.

\section{Implementing the Mesquite Mesh Interface} \label{sec:msq_mesh}

%Most users will want to skip this section and avoid the associated work. There are several manners
%to give the mesh data to Mesquite, and implementing the Mesquite mesh interface is the one that
%requires the most coding work. 
%
%Let's review the alternative in the first place. For very simple meshes, Mesquite has an integrated
%mesh database that can read in mesh files in specific format, such as VTK (see section \ref{sec:meshFiles}). 
%On the other hand, Mesquite is compatible with the TSTT mesh interface: this means that if you are
%running a code that has implemented the TSTT mesh interface, you can link Mesquite with your code
%and perform all mesh improvements through the TSTT mesh interface (see section \ref{sec:TSTT}).
%Implementing the TSTT mesh interface also has the advantage that your code will be compatible with
%the TSTT mesh interface standard: this is a very good investment. 
%
%If you want to implement the specific Mesquite mesh interface, you probably have very specific
%reasons in mind ... and you know what you are doing. In this section, we will give you the
%documentation for the abstract classes. This will allow you to implement the interface. 

%\subsection{Implementation Details}
%
%The implementation details must be looked up in the doxygen documentation %located in the {\tt doc/user/doxygen} subdirectory.

%  While Mesquite should provide some testing of Mesh interfaces, using
%  the unit testing framework as described below will NOT work and 
%  probably isn't a good idea.  It is preferable that the users
%  not customize Mesquite to the extend that the discussion below assumes.
%  (App-specific Mesh interface added as part of mesquite rather than
%  the app, changes to source files in mesquite's unit tests, modifications
%  to the build system, etc.)
%\subsection{Testing Your Implementation}

%The implementation of the Mesquite mesh interface is considerably eased by using %the unit testing
%framework. From the mesquite/testSuite/unit directory, change the %MeshInterfaceTest.cpp file to
%instantiate your mesh interface implentation (i.e. replace occurences of %\texttt{MeshImpl} with your
%class). Run {\tt make} and run the test:
%\begin{verbatim} 
%./msq_test MeshInterfaceTest
%\end{verbatim} 
%This should help you pinpoint the vast majority of implementation errors. 


\section{The TSTT Mesh Interface} 
\label{sec:TSTT}

Mesquite can instead use the mesh interfaces currently
being developed through the TSTT center.  This interface definition
effort focuses on providing access to information pertaining to low
level mesh objects such as vertices, edges, faces, and regions through
both array-based and iterator-based mechanisms.  It is designed to
support existing packages such as MAOB, NWGrid, PAOMD, and Overture. 
The TSTT interface achieves language interoperability
through use of the SIDL/Babel tools from LLNL \cite{babel}.
%Achieving consensus within a large group of participants is
%paramount (see \cite{Cubit-website}, \cite{overture}, \cite{aomd-imr},
%and \cite{NWGrid-website}).  
%This interface definition effort is
%evolving, and the Mesquite team is actively participating to ensure
%that our needs for mesh quality improvement are adequately and
%efficiently addressed.  
A TSTT-based implementation of the Mesquite
interfaces is available.  As such, any tool that exposes its
mesh through the TSTT interfaces can be used with Mesquite without
additional development.

Note that the Mesquite-specific interface described in section \ref{sec:msq_mesh} is fully compatible
with the current TSTT mesh and geometry interfaces, and in fact,
Mesquite's approach to data structure neutrality is directly derived
from the TSTT interfaces.  Although similar in spirit to the TSTT
interface, the Mesquite-specific interface is not as general, and 
therefore consist of fewer
functions and does not require additional tools such as Babel.

\section{The Geometric Domain}
\label{sec:geometry}

Certain smoothing procedures in Mesquite require some geometry information. The mean ratio quality
metric for example requires the normal of a 2D element in a surface mesh. Also, boundary
vertices can be snapped back to the surface they belong to during a smoothing procedure, instead of
simply fixing the boundary vertices (and therefore lowering the quality of the final mesh). A simple abstract
class, \texttt{MeshDomain}, must be inherited and implemented by the user in order to provide the
geometry information to Mesquite.  

There are cases where the application need not provide an instance of an
object implementing the {\tt MeshDomain} interface.  For both 2D and 3D meshes,
one of the most important functions of the domain is to constrain the boundary
of the mesh.  Without such a constraint, the optimzation may not be well-defined.  However, as an alternative to providing a domain for the boundary
mesh vertices, the application may simply mark all the boundary vertices as 
fixed.  

As Mesquite works with $\mathbb{R}^{3}$ coordinates, a domain must be provided
when meshing purely $\mathbb{R}^{2}$ meshes to constrain the mesh to a single plane in $\mathbb{R}^{3}$.  The {\tt PlanarDomain} class provided by Mesquite may be 
used for this purpose.
