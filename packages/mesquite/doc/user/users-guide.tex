\documentstyle[psfig]{article}

\pagestyle{empty}

\title{ {\LARGE\bf Mesquite User's Guide}}

\author{Patrick Knupp, Lori Freitag, Darryl Melander, Mike Brewer \\
The Sandia National Laboratories \\
Albuquerque NM USA \\
and \\
Thomas Leurent \\
Argonne National Laboratory \\
Argonne, IL 60490 USA}

\date{}


\begin{document}

\maketitle
\begin{abstract} 
MESQUITE is a software library for improving mesh quality. 
\end{abstract}

\tableofcontents

\listoffigures

\listoftables

\section{Introduction to Mesh Quality Improvement} 

\subsection{General Overview}
What do we mean by mesh quality. Why is it important? A priori vs. a posteriori
quality control.

Goals:
\begin{itemize}
\item To provide a vision for Mesquite (what it is and what it will become),
\item To cover both noice and expert users. The novice should know what to
do after reading a small percentage of the guide (perhaps a third); more 
advanced concepts are also included but are done later in the text.
\item To provide practical instructions on using Mesquite API, compiling,
linking, TSTT interface,
\item To provide insight into the optimization algorithms
\end{itemize}

\subsection{Mesquite Philosophy}
The hippocratic oath: we will do no harm (can we do an undo or should the 
user keep track of the original mesh?).  What are the boundaries of Mesquite?
What it is not going to do. What do we mean by a mesh quality improvement 
algorithm. Including the best known algorithms for a particular goal (not 
just a collection of hacked tools). Provides both a useful tool that is easy
to use for application scientists and is extensible to provide a platform for
mesh quality improvment research. Give an example API file (script for 
Laplace smoothing - novice). Show the expert view of the world. Readers can
use script to build from. Use example to help explain our philosophy.

\subsection{The Mesquite Vision}
Comprehensive, robust, flexible, efficient. In core to applications, not 
just a preprocessign step.

\section{Mesh Improvement Goals}
Why have different mesh improvement goals? What are they (shape, untangle, 
alignment, morph, etc.). Improvement goals currently supported (shape, untangle).

\section{Methods - Theory and Algorithms}

\subsection{Vertex Movement Schemes}
Why use an optimization-based approach. Posing mesh quality as an optimization
problem (metrics, objective function templates and goals, L1, L2, Linf).
Optimization Algorithms (brief description, enough to have the API discussion 
make sense): variational, discrete, solvers (CG, active set), local vs. global,
fitting Laplacian and other common smoothers into this framework.

\subsection{Topology Modifiers}
Swapping algorithms.

\section{Basic Mesquite Usage}

\subsection{Telling Mesquite About Your Mesh}
TSTT and Mesquite interface overview. Particular interfaces needed. 
Testing your TSTT interface implementation.

\subsection{Wrapper Classes}
Provides sophisticated functionality via simple interface. List the ones
provided (goal, stopping criterion, customization options).

\subsection{Compilling and Linking Mesquite}
TODO:  Software dependencies, compiling AOMD, TSTT interfaces
(need the .h file),
other (gmake, makedepend)?  Makefiles (examples that link Mesquite to an 
application code). Compiler flags and options (debugging, profiling). 
Platforms supported. Optional functionalities (debugging, profiling, 
error handling).
\subsubsection{System Requirements}
TODO:  List the supported platforms (Lin, SGI, Sun, etc.?), the required
softwar (makedepend, gmake, Babel, etc.?), and any related information.
\subsubsection{Acquiring the Necessary Code/Libraries}
TODO:  How and where Mesquite, AOMD, CPPUnit, (MDB), etc. can be
acquired... with appropriate acknowledgments.
\subsubsection{Compiling Mesquite}
Having acquired the Mesquite source code, the user can perform the
following steps which outline the process for compiling the code and
creating the library, `libmesquite.a'.
\begin{enumerate}

\item While in the main directory (typically, .../mesquite/), type
`config'.  This will set up the makefiles with a default configuration
for your platform.

\item Examine the file Makefile.customize.  This file defines
the tools and settings to be used while compiling Mesquite.  Make
any modifications deemed necessary to Makefile.customize.  Section
\ref{mes_vars_and_defs} lists some of the specific variables which
may need to be modified before Mesquite will compile correctly.

\item While in the main directory (typically, .../mesquite/),
type 'gmake -f GNUmakefile'.  This will compile all source files
and create libmesquite.a.  If the build is not successful, you may need
to make additional modifications to Makefile.customize.

\item If Makefile.customize is modified such that Mesquite will
link to a compatible implementation of TSTT, type `gmake -f GNUmakefile
all\_tests' to compile sample executables that use the Mesquite
library.

\end{enumerate}
In general, most customizations to the makefile system should be
made by modifying Makefile.customize, not by directly modifying
GNUmakefile.
\subsubsection{Makefile Definitions}
The following is a list of variables used in Mesquite's Makefile
structure to allow for custimization of the compilation process.
Most of the provided examples come directly from Mesquite's default
linux setup which is defined in Makefile.lin, a file located in
the main directory.
\label{mes_vars_and_defs}
\begin{enumerate}

\item Tools used by Mesquite:
  \begin{description}
  \item[ARCHIVER] defines the command to call the archiver\\
    	({\it e.g.,} ARCHIVER = ar ru).
  \item[CXX] defines the command to call the compiler\\
	({\it e.g.,} CXX = g++).
  \item [LINKER] defines the command to call the linker\\
	({\it e.g.,} LINKER = \$\{CXX\}).
  \item[MAKEDEPEND] defines the command to call makedepend\\
	({\it e.g.,} MAKEDEPEND = makedepend).
  \end{description}

\item Compilation flags and variables:
  \begin{description}
  \item[AOMD\_FLAG]
  \item[CXX\_FLAGS]
  \item[DEBUG\_FLAG] defines the flags to be used to compile the Mesquite
	with the desired levels of debug information, optimization, and
	warning statements\\
	({\it e.g.,} DEBUG\_FLAG = -g -Wno-deprecated).
  \item[DEPEND\_FLAGS]
  \item[LD\_FLAGS]
  \item[STD\_INCLUDE\_FLAG] defines certain global definitions that
	tell the compiler which types of header files to include.
 	Essentially, the two options are USE\_STD\_INCLUDES and
	USE\_C\_PREFIX\_INCLUDES.  With USE\_STD\_INCLUDES defined
	Mesquite will include the standard header files.  For example,
	`list' will be included instead of `list.h'.  With
	USE\_C\_PREFIX\_INCLUDES defined, Mesquite will include the
	`c-prefixed' header files.  For example, `cmath' will be
	inlcuded instead of `math.h'.  \\
	({\it E.g.,} STD\_INCLUDE\_FLAG = -DUSE\_STD\_INCLUDES\\
	-DUSE\_C\_PREFIX\_INCLUDES).
  \end{description}
\item Directories:
  \begin{description}
  \item[AOMD\_LIB\_DIR] is an optional variable which can be set
	to hold the location of the AOMD library if Mesquite will
	be linked to AOMD\\
	({\it e.g.,} AOMD\_LIB\_DIR = \$\{MSQ\_BASE\_DIR/external/AOMD/lib\}).
  \item[EXODUS\_LIB\_DIR] is an optional variable used to hold the
	location of the ExodusII library, an external library needed
	by MDB.  This library is not needed if Mesquite is not being
	linked to MDB.
	({\it E.g.,} EXODUS\_LIB\_DIR = \$\{MSQ\_BASE\_DIR\}/external/exodus/lib).
  \item[MDB\_LIB\_DIR] is another optional variable which can be set
	to hold the location of the MDB library if Mesquite will
	be linked to MDB\\
	({\it e.g.,} MDB\_LIB\_DIR = \$\{MSQ\_BASE\_DIR\}/external/MDB/lib).
  \item[MSQ\_BASE\_DIR] holds the name of the main Mesquite directory.
	Generally, the default value for this variable will be correct.\\
	(The default value is `MSQ\_BASE\_DIR = .').
  \end{description}
\item TSTT linking information:
\begin{description}
  \item[AOMD\_TSTT\_LINK] is an optional variable that holds the
	information needed by the linker to link the AOMD to Mesquite\\
	({\it e.g.,} AOMD\_TSTT\_LINK = -L\$\{AOMD\_LIB\_DIR\} -lAOMD -lm).
  \item[MDB\_TSTT\_LINK] is an optional variable that holds the
	information needed by the linker to link the MDB to Mesquite\\
	({\it e.g.,} MDB\_TSTT\_LINK = -L\$\{MDB\_LIB\_DIR\} -lMDB -lm).
  \item[TSTT\_LINK] holds the information used by the LINKER to link
	the TSTT implementation to Mesquite \\
	({\it e.g.,} TSTT\_LINK = \$\{AOMD\_TSTT\_LINK\}).
\end{description}
\end{enumerate}


\subsection{Hints for Performance Profiling}
Compiler options, aggregation.

\section{Software Design}

\subsection{Overview}
Why did we choose C++ (extensibility)? Achieving performance in the 
numerical kernals.

\subsection{Mesquite Classes}
QualityMetric, Objective Function Templates, Vertex Movers, Instruction Queue,
Stopping Criterion, MeshSet and PatchData

\subsection{Directory Structure}
The base directory of the Mesquite project contains several
sub-directories which are intended to help keep the project's
files organized.  Some of the sub-directories themselves are
also sub-divided.  Below are descriptions of the first level
of sub-directories ({\it i.e.,} the directories contained in the
base directory).
\begin{enumerate}
\item doc:  Contains a version of this document and a version of
the developer's documention generated with doxygen (TODO: acknowledge
doxygen).
\item external:  Contains directories which can be used to store external
libraries.  These libraries are not necessarily provided with Mesquite.
\item include:  Contains the Mesquite header file, ``Mesquite.hpp.''
\item includeLinks:  Contains soft links to the other header files
used within Mesquite.  
\item lib:  The location where the Mesquite library, ``libmesquite.a,'' is
stored.
\item meshFiles:  Conatains example meshes that are used in some of
the test cases.
\item mswindow:  Contains the project file for compiling with Visual C++
(TODO: VC++ trademark statement???).
\item obj:  The directory where the object files are placed.
\item src:  Contains the Mesquite source code and header files (except for
Mesquite.hpp).
\item testSuite:  Contains example driver codes which use Mesquite.  These
test cases can only be ran when linked with the correct libraries (generally,
AOMD or MDB).
\item TSTT-interface:  Contains the copy of the TSTT header file,
``TSTT\_Base.h,'' which is compatible with Mesquite.
\end{enumerate}
\subsection{Example Programs}
The Mesquite code is designed to improve and assess the quality of
a mesh.  To accomplish this task, however, Mesquite needs the mesh
to be stored in some type of mesh data-base which has an implementation
of the TSTT interace  (TODO: reference the interface).  That is, the
mesh must be stored in another program which is capable of communicating
with Mesquite through the TSTT interface.  Through this interface
the mesh can be identified using its Mesh\_Handle.  Below is an example
of a function which takes a Mesh\_Handle as an arguement and performs
a Laplacian smooth (using a Mesquite wrapper function for simplificity)
on the associated mesh.  It is assumed that ``Mesquite.hpp'' has been
included in the file.  The example code just adds ``my\_mesh'' to a
Mesquite MeshSet object and then runs a Laplacian smoother on that
MeshSet.

TODO: Verify the following compiles.

\begin{verbatim}
void laplace_smooth_my_mesh(TSTT::Mesh_Handle my_mesh)
{     
    // Mesquite error object
  Mesquite::MsqError err;
    // initialises a MeshSet object
  Mesquite::MeshSet mesh_set1;
    //  adds my_mesh to the Mesquite MeshSet
  mesh_set1.add_mesh(my_mesh, err);
    //  checks to see whether the previous call caused an error
  MSQ_CHKERR(err);
    // creates an intruction queue
  Mesquite::LaplacianIQ laplacian_smoother;
    // launches optimization on mesh_set1
  laplacian_smoother.run_instructions(mesh_set1, err);
    //checks to see if the previous call caused an error
  MSQ_CHKERR(err);
}
\end{verbatim}

It is often the case that users have a mesh in file format and wish
to improve the quality of that mesh.  However, Mesquite does not have
the capability to read a mesh directly from a file.  Therefore, the mesh
must first be read into a mesh data-base which provides a compatible TSTT
interface.  Examples of such data-bases are MDB and AOMD.  TODO:
where these programs can be found.  Mesquite does provide some utility
functions to simplify this process.  As an example, the following
code reads a mesh which has been stored in ExodusII (TODO reference
Exodus/Genesis/etc) format into MDB, uses Mesquite to smooth the mesh,
and then writes the mesh to another file.  The following code requires
that ``MDBMesquite.hpp'' be included as well as ``Mesquite.hpp''.  This
code sample calls the above function, laplace\_smooth\_my\_mesh($\cdots$),
to smooth the mesh.

TODO:: verify that the following compiles.

\begin{verbatim}
void load_and_improve_my_mesh(char* input_file, char* output_file)
{
    //creates a Mesh_Handle and an error object
  TSTT::Mesh_Handle my_mesh;
  TSTT::MeshError error=0;
    //loades the mesh into MDB and flags the boundary vertices as fixed.
  load_and_flag_mesh(&my_mesh, input_file, &error);  
    //Smooth the mesh
  laplace_smooth_my_mesh(my_mesh);
    //write out the results to a new file (given by output_file)
  write_results(my_mesh, output_file, &error);
    // clean up
  deinit_mesh(my_mesh);
}
\end{verbatim}
\subsection{Testing Philosophy}

\section{Advanced Use of Mesquite}

\subsection{The Simplified Geometry Engine}

\subsection{Creating a Quality Metric}
What is a quality metric? Define full range, acceptable range, what is means 
if the metric uses a map, nodal-invariance, well-posed metrics, averaging 
methods, sample points. Give a list of the individual metrics we support. 
Provide a key to the tables.

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Metric Name & Type & Dimension & Full Range & Ideal & Degenerate \\ \hline
Inverse Mean Ratio & Shape & 2D, 3D & $[0,1]$ & 1 & 0 \\ 
Mean Ratio &  &  &  &  &  \\ 
Condition Number &  &  &  &  &  \\ 
Untangle &  &  &  &  &  \\ 
Aspect Ratio Gamma &  &  &  &  &  \\ 
\hline
\end{tabular}
\caption{\label{QualityMetrics1} Mesquite Quality Metrics Summary, Part I}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
Metric Name & Map? & Averaging & Sample Pts & Elements & Gradient & Source \\ \hline
Inverse Mean Ratio & No & Harmonic & Vertices & TQTH & Analytic & \\ 
Mean Ratio &  &  &  &  &  \\ 
Condition Number &  &  &  &  &  \\ 
Untangle &  &  &  &  &  \\ 
Aspect Ratio Gamma &  &  &  &  &  \\ 
\hline
\end{tabular}
\caption{\label{QualityMetrics2} Mesquite Quality Metrics Summary, Part II}
\end{center}
\end{table}

\noindent {\bf Mean Ratio Metric} \newline
Give description, formulas. 

\subsection{Creating an Objective Function}
List of all the templates. What is the difference between a template and
an obective function? For each element of the mesh (or for each 
free-node of the mesh), let there be an associated quality metic, 
$\mu_m$.  Define the vector 
\begin{equation}
{\bf U} = [ \mu_1, \mu_2, \ldots, \mu_M ]
\end{equation}
where $M$ is the number of elements or free-nodes in the mesh. \newline

\noindent Available templates in Mesquite: \newline

\noindent {\bf The $\ell_p$ Template} \newline
Given $1 \leq p < \infty$, let
\begin{equation}
\| {\bf U} \|_p = ( \sum_{m=1}^M \mid \mu_m \mid^p )^{1/p}
\end{equation}
be the $\ell_p$ template. \newline

\noindent {\bf The $\ell_p^p$ Template} \newline
Given $1 \leq p < \infty$, let $\| {\bf U} \|_p^p$ be the 
$\ell_p^p$ template. \newline

\noindent {\bf The $\ell_{\infty}$ Template} \newline
The $\ell_{\infty}$ template is
\begin{equation}
\| {\bf U} \|_{\infty} = \max_{m=1,\ldots,M} \mid \mu_m \mid
\end{equation}

These are currently the only tempates available in Mesquite.
We soon hope to add the 'max' template:
\begin{equation}
MAX = \max_{m=1,\ldots,M} ( \mu_m )
\end{equation}

Which of these templates has numerical/analytic gradient/Hessian?

\subsection{Creating a Vertex Mover}
List solvers and appropriate templates. Is a solver the same things as a 
vertex mover? List options.

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Solver Name & Description & Templates & L/G & Num/Anal & Fixed Vertices? \\ \hline
Steepest Descent & Clasical & $\ell_p$ & Both & Both & Yes \\
Conjugate Gradient & & & & & \\
Feasible Newton & & & & & \\
Active Set & & Own & & & \\
Laplace & & None & & & \\
Randomize & & None & & & \\
\hline
\end{tabular}
\caption{\label{Solvers} Mesquite Solver Summary}
\end{center}
\end{table}


\subsection{Creating a Topology Modifier}

\subsection{Termination Criteria}
List, along with uses.

\subsection{Culling Algorithms}

\subsection{Quality Assessment}

\subsection{The Instruction Queue}
Setting the master quality improver, setting up and using preconditioners,
using quality assessors, running the instruction queue.

\subsection{Composite Metrics}

\subsection{Composite Objective Functions}
The only ones currently available are CompositeMult, CompositeAdd,
CompositeScalarMult, and CompositeScalarAdd.

\subsection{Running in Parallel}

\section{Extending Mesquite}
Adding a new quality metric, adding a new template, adding a new vertex 
mover.

\section{Troubleshooting}

\section{Caveats, Limitations, and Disclaimers}

\section{User Support}
Mailing lists, web site, examples, tutorials (pointer to slides?), 
instructions on downloading the software (open source, preparing 
derivative works), referencing Mesquite.

\section{The Mesquite Team}
Development team, external contributors.

\section{The Mesquite Development Plan}
Timeline for proposed additions to the software.

\section{Acknowledgements}
Funding sources (DOE SciDAC Program, Chuck Romine), Related activities 
(TSTT, Cubit, Opt-MS), helpful folks (RPI for AOMD, TSTT for MDB, 
LLNL for Overture tests, etc.

\begin{thebibliography}{999}
\bibitem{Hawaii}
L. Freitag, P. Knupp, T. Leurent, and D. Melander, {\it MESQUITE Design: Issues in the Development of a Mesh Quality Improvement Toolkit}, p159-168, Proceedings of the 8th Intl. Conference on Numerical Grid Generation in Computational Field Simulations, Honolulu 2002.

\bibitem{unt}
P. Knupp, {\it Hexahedral and Tetrahedral Mesh Untangling}, Engineering with Computers, Vol. 17, No. 3, pp261-268, 2001.

\bibitem{Nocedal}
J. Nocedal and S. Wright, {\it Numerical Optimization}, Springer, New York, 1999.

\end{thebibliography}

\newpage
\appendix{\large {\bf Appendix A: The Conjugate Gradient Algorithm }} \newline
\label{append_A}
\newpage
\appendix{\large {\bf Appendix B: The Feasible Newton Algorithm }} \newline
\label{append_B}
\newpage
\appendix{\large {\bf Appendix C: The Active Set Method }} \newline
\label{append_C}

\end{document}

