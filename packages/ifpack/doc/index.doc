/*! \mainpage Trilinos/IFPACK: Object-oriented Algebraic Preconditioner Package

\image html ../IFPACKLogo.gif

\section ifp_table Table of Contents

- \ref ifp_intro
- \ref ifp_download
- \ref ifp_configure
- \ref ifp_example 
- \ref ifp_params
- \ref ifp_note 
- \ref ifp_tools 
- \ref ifp_error 
- \ref ifp_copyright

\section ifp_intro Introduction

IFPACK, developed by Micheal Heroux and Marzio Sala (SNL 9214), 
provides a suite of object-oriented algebraic preconditioners
for the solution of preconditioned iterative solvers.  IFPACK
constructors expect an Epetra_RowMatrix object for construction.
IFPACK is part of the Trilinos Solver Project and IFPACK object
interacts well with other Trilinos classes.  In particular, IFPACK can
be used as a preconditioner for AztecOO.

<P>Most IFPACK preconditioners can be rewritten as additive Schwarz methods,
of overlapping domain decomposition type. The user can adopt
a minimal-overlap (that is, zero-row overlap), 
or ask IFPACK to extend the overlap.
The resulting preconditioner reads:
\f[
P_{IFPACK}^{-1} = \sum_{i = 0}^{NumProcs-1} P_i A_i^{-1} R_i
\f]
where \f$R_i\f$ is the restriction operator from the global vector, to the
overlapping subdomain \f$i\f$,
and \f$P_i\f$ is the prolongator operator. 
\f$P_i\f$ is generally be the transpose of \f$R_i\f$ (in which case
the resulting preconditioner is symmetic).
If is supposed that each subdomain
is assigned to a different processors.

<P>A key component of the previous formula is a strategy to apply
\f$A_i^{-1}\f$. Using IFPACK, this can be defined by one of the
following:
- one or more steps of a point/block method (like Jacobi and Gauss-Seidel);
- an incomplete factorization (ICT or RILUK);
- an exact LU solve (using Amesos' factorizations).

More precisely, the choices for \f$A_i^{-1}\f$ are:
- point relaxation preconditioners (through class Ifpack_PointRelaxation).
  Point relaxation preconditioners are probably the simplest iterative methods,
  and are generally used as smoothers in multilevel
  methods (for instance, within ML). Available choices are:
  - Jacobi
  - Gauss-Seidel
  - symmetric Guass-Seidel
  - SOR
  - SSOR
- block relaxation preconditioners (through class Ifpack_BlockRelaxation).
Block relaxation preconditioners represent an extension of point preconditioners.  The
local matrix \f$A_i\f$ is divided into blocks, than the Jacobi or the
Gauss-Seidel methods are applied on the block structure rather than
point-wise. The code extracts the diagonal blocks (the application of whose
inverse is required), and stored them either as dense or as sparse matrices.
The first approach is suggested for small blocks. In this case, LAPACK
functions will be used to factorize the block and to perform the backsolve.
For large blocks, instead, it is suggested to store the blocks are sparse
matrices (Epetra_CrsMatrix's). Any IFPACK preconditioner derived from
Ifpack_Preconditioner can be used to apply the inverse of the diagonal blocks.
  Available choices are:
  - block Jacobi
  - block Gauss-Seidel
  - block symmetric Gauss-Seidel
- point incomplete factorizations (through classes Ifpack_gIct, Ifpack_vIct,
  Ifpack_gRiluk, Ifpack_vRiluk). Incomplete factorizations represent a
  very successful class of algebriac preconditioners. IFPACK offers the
  following:
  - ICT(K) for symmetric problems
  - RILU(K) for general problems
- exact factorizations (through class Ifpack_Amesos):
  - all Amesos classes can be used to compute the LU factorization
    of a given matrix.

Note that all the above preconditioners should be used through
class Ifpack_AdditiveSchwarz only.


\section ifp_download Download IFPACK

IFPACK can be downloaded from the web page http://software.sandia.gov/trilinos/downloads.html

\section ifp_configure Configuring IFPACK

IFPACK is configured with autotools. IFPACK is enabled by default
if configured at the Trilinos level (please refer to the Trilinos
documentation for more details). This section briefly recalls some
of the configure parameters that affect the IFPACK compilation. For
a complete list of parameters, please type
\code
$ $TRILINOS_HOME/packages/ifpack/configure --help
\endcode

- \c "enable-amesos" enables the support for Amesos (off by default).
- \c "enable-aztecoo" enables the support for AztecOO (on by default).
- \c "enable-teuchos" enables the support for Teuchos (off by default).
- \c "enable-triutils" enables the support for Triutils (on by default).
- \c "enable-ifpack-metis" enables the support for the METIS package. The
  location of the header files should be specified using 
  \c "--with-incdirs=-=I/include/location", the path of the METIS library with
  \c "--with-ldflags=-L/lib/location", and the library name using
  \c "--with-libs=-lmetis".

\note IFPACK depends on the Epetra library.
  
\section ifp_example Examples of Usage

This section details how to use the IFPACK Factory class.

<P>Probably, the easiest way to use IFPACK is through the function class
Ifpack. This is a \e factory class, that contains only one method,
Create(). A call to Create() returns a pointer to a newly-created
IFPACK object. (The user is responsible of deleting this object.)

An example of usage is reported by the following code:
\code
#include "Ifpack.h"
...
Ifpack Factory;
Epetra_RowMatrix* A; 
string PrecType = "Amesos"; // exact solve on each subdomain 
int OverlapLevel = 1; // one row of overlap among the processes
Ifpack_Preconditioner* Prec = Factory.Create(PrecType, A, OverlapLevel);
assert (Prec != 0);

IFPACK_CHK_ERR(Prec->SetParameters(List));
IFPACK_CHK_ERR(Prec->Initialize());
IFPACK_CHK_ERR(Prec->Compute());
\endcode

<P>Although the Ifpack factory is appropriate for most users, 
it is possible to create IFPACK preconditioners by handling
directly an Ifpack_AdditiveSchwarz object.
The preconditioner of the previous example is equivalent to
the one created in the following fragment of code:
\code
#include "Ifpack_AdditiveSchwarz.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_Amesos> (A, OverlapLevel);
\endcode

Another example is the following, where the local solve is
a block Jacobi method, which uses dense containers (LAPACK).
\code
#include "Ifpack_AdditiveSchwarz.h"
#include "Ifpack_DenseContainer.h"
#include "Ifpack_BlockJacobi.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_BlockJacobi<Ifpack_DenseContainer> > (A, OverlapLevel);
\endcode

Using sparse containers and Amesos the code may look as follows.
\code
#include "Ifpack_AdditiveSchwarz.h"
#include "Ifpack_SparseContainer.h"
#include "Ifpack_BlockJacobi.h"
#include "Ifpack_Amesos.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_BlockJacobi<Ifpack_SparseContainer<Ifpack_Amesos> > > (A, OverlapLevel);
\endcode

<P>Other examples are reported in the \c example subdirectory with several
comments:
- \ref ifp_ex_factory shows how to use Ifpack factory to create
                            a variety of IFPACK preconditioners.  This is the simplest way to use IFPACK.  The example details all the phases of IFPACK. Difficulty = beginners.
- \ref ifp_ex_mm reads an MatrixMarket matrix (a simple
                             format that contains i,j and a(i,j) of
                             all nonzero elements), redistribute
                             the matrix to all avaialble processes
                             (using a linear distribution), and
                             solve the problem with AztecOO and IFPACK.
                             Matrices downloaded from
                             math.nist.gov/MatrixMarket/ in .mtx
                             format can be used with this example. A
                             small example is reported.
                             Difficulty = beginners.
- \ref ifp_ex_amesos      shows how to use exact LU solvers on
                            each subdomain, using Amesos. This example
                            is very similar to the previous one.
                            Difficulty = beginners.
- \ref ifp_ex_vict     shows how to define incomplete Cholesky
                            factorizations (with dropping based on values),
			    and tune parameters. Although
                            an vICT factorization can be constructed using
                            the Factory (as done in file
                            Ifpack_ex_Factory.cpp), this example tells
                            the real story: how to define an
                            Ifpack_AdditiveSchwar which uses vICT on
                            each subdomain.
                            Difficulty: intermediate.
- \ref ifp_ex_block  shows how to define block preconditioner
                            in the more general case, using
                            Ipfack_AdditiveSchwarz.
                            Difficulty: advanced.

\section ifp_params List of Supported Parameters

The complete list of supported parameters is reported below.

- \c "relaxation: type": specifies the type of point and block relaxation scheme. Valid
  values: 
  - \c "Jacobi";
  - \c "Gauss-Seidel";
  - \c "symmetric Gauss-Seidel";

- \c "relaxation: sweeps": specifies the number of sweeps in the application
  of point relaxation schemes. 

- \c "relaxation: damping factor": specifies the damping factor in the
  application of point relaxation schemes. 

- \c "block: type": specifies the type of block relaxation scheme. Valid
  values: \c "Jacobi", \c "Gauss-Seidel", \c "symmetric Gauss-Seidel".

- \c "relaxation: min diagonal value": replace
  diagonal values below this value with this value (only for point relaxation).

- \c "partitioner: type": specifies the scheme to adopt to partition
  the graph. Valid values: 
  - \c "linear" (uses a linear decomposition);
  - \c "greedy" (uses a simple greedy algorithm);
  - \c "metis" (calls METIS, this required \c --enable-ifpack-metis).

- \c "partitioner: overlap": specifies the overlap among the blocks
  which can differ from the overlap among the processors. Note that
  only the Jacobi block relaxation scheme can take advantage
  of non-zero overlaps.

- \c "partitioner: local parts": specifies the number of local blocks.

- \c "partitioner: root node": specifies the root node for greedy algorithm.

- \c "partitioner: use symmetric graph": if \c true, METIS will partition
  the graph of A + A<sup>T</sup>. If \c false, METIS will partition the graph
  of A. Note that METIS can core dump if the input graph is non-symmetric.
  Users should set this option to \c false only when the graph is
  symmetric. If the non-symmetry is determined by Dirichlet nodes, then
  the singleton filter should create a symmetric graph. Note also that
  dropping techniques applied to non-symmetric matrices can result in
  non-symmetric graph.

- \c "amesos: solver type": defines the Amesos solver to be
  used by class Ifpack_Amesos. Valid values:
  - \c "Amesos_Lapack" (use Amesos interface to LAPACK);
  - \c "Amesos_Klu" (use Amesos' internal solver KLU);
  - \c "Amesos_Umfpack" (use UMFPACK interface);
  - \c "Amesos_Superlu" (use serial SuperLU interface);
  - \c "Amesos_Mumps" (use MUMPS interface);
  - \c "Amesos_Dscpack" (use DSCPACK interface).
 
- \c "schwarz: combine mode": defines how values corresponding to
  overlapping nodes are handled (after the solution of the local problem).
  Any Epetra_CombineMode is valid. Users should set this value to
  \c Add if interested in a symmetric preconditioner. Otherwise,
  the default value of \c "Zero" usually results in better convergence.

<P>The table below reports the C++ type and the default value of each
parameter.
<center>
<table>
<tr>
<td><b>Parameter name</b></td><td><b>C++ type</b></td><td><b>Defaut value</b></td>
</tr> <tr>
<td>\c "relaxation: type"              </td><td>\c string </td><td>\c "Jacobi" </td>
</tr> <tr>
<td>\c "relaxation: sweeps"            </td><td>\c int    </td><td>\c "1" </td>
</tr> <tr>
<td>\c "relaxation: damping factor"    </td><td>\c double </td><td>\c "1.0" </td>
</tr> <tr>
<td>\c "relaxation: min diagonal value" </td><td>\c double </td><td>\c "0.0" </td>
</tr> <tr>
<td>\c "partitioner: type"        </td><td>\c string </td><td>\c "greedy" </td>
</tr> <tr>
<td>\c "partitioner: overlap"     </td><td>\c int    </td><td>\c "0" </td>
</tr> <tr>
<td>\c "partitioner: local parts" </td><td>\c int    </td><td>\c "1" </td>
</tr> <tr>
<td>\c "partitioner: root node"   </td><td>\c int    </td><td>\c "0" </td>
</tr> <tr>
<td>\c "partitioner: use symmetric graph" </td><td>\c bool </td><td>\c "true" </td>
</tr> <tr>
<td>\c "amesos: solver type"      </td><td>\c string </td><td>\c "Amesos_Klu" </td>
</tr> <tr>
<td>\c "schwarz: combine mode"    </td><td>\c Epetra_CombineMode </td><td>\c "Zero" </td>
</tr>
</table>
</center>

\note Whenever possible, the Teuchos::ParameterList given in input
to SetParameters() is only parsed. There are cases, however, where the
solver needs to store a copy of this list, because it will be used
in a later stage. This happens, for example, in block relaxation schemes that
use Amesos as local solver. As the the list given in input to SetParameters()
is parsed or copied, this list can go out of scope after this function
returns. 

\section ifp_tools Developers' Tools 

IFPACK contains several classes, meant for developers rather than
for users:
- Graphs are derived from the pure virtual class Ifpack_Graph
  (whose documentation details the concept of graphs for IFPACK).
  Concrete implementations are Ifpack_Graph_Epetra_CrsGraph 
  and Ifpack_Graph_Epetra_RowMatrix;
- Containers are derived from the pure virtual class Ifpack_Container
  (whose documentation describes what a container is). Concrete
  implementations are Ifpack_DenseContainer and Ifpack_SparseContainer;
- Reorderings are derived from the pure virtual class Ifpack_Reordering
  (whose documentation outlines the features of reorderings)
  Concrete implementations are
  Ifpack_RCMReordering and Ifpack_METISReordering;
- Partitioners are derived from the pure virtual class Ifpack_Partitioner 
  (whose
  documentation describes the features of partitioners). Concrete
  implementations are Ifpack_LinearPartitioner, Ifpack_METISPartitioner
  and Ifpack_EquationPartitioner;
- Available filters are Ifpack_LocalFilter (whose documentation
  explains the creation and use of filters), Ifpack_ReorderFilter,
  Ifpack_DropFilter, Ifpack_SparsityFilter;

\section ifp_error Error Table

The following table defines the class of IFPACK errors.
Return code should be checked using the IFPACK_CHK_ERR() macro.
In general terms, we follow this convention:
- a return value of 0 means that the called 
function or method successfully completed;
- a negative return function means that an error occurred;
- a positive value is a warning for the user.

<table>
<tr>
<td><b>Error Code</b></td><td><b>Meaning</b></td>
</tr>
<tr>
<td>-1</td><td>Generic Error (Called function returns error)</td>
</tr>
<tr>
<td>-2</td><td>Range not valid (Out-of-bounds)</td>
</tr>
<tr>
<td>-3</td><td>Data has not been correctly pre-processed</td>
</tr>
<tr>
<td>-4</td><td>Division by zero</td>
</tr>
<tr>
<td>-5</td><td>Memory allocation error</td>
</tr>
<tr>
<td>-6</td><td>Failure of the algorithm</td>
</tr>
<tr>
<td>-98</td><td>Feature is not supported</td>
</tr>
<tr>
<td>-99</td><td>Feature is not implemented (submit a bug?)</td>
</tr>
</table>

</tr>
\section ifp_copyright Copyright

\verbatim
Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
license for use of this work by or on behalf of the U.S. Government.

This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
\endverbatim

*/

/*! \page ifp_ex_factory Ex_Factory

\include Ifpack_ex_Factory.cpp

*/

/*! \page ifp_ex_amesos Ex_AmesosPrec

\include Ifpack_ex_Amesos.cpp

*/

/*! \page ifp_ex_vict Ex_vIctPrec

\include Ifpack_ex_vIct.cpp

*/

/*! \page ifp_ex_block Ex_BlockRelaxationPrec

\include Ifpack_ex_BlockPrec.cpp

*/

/*! \page ifp_ex_mm Ex_MatrixMarket

\include Ifpack_ex_MatrixMarket.cpp

*/
