/*! \mainpage Trilinos/IFPACK: Object-oriented Algebraic Preconditioner Package

\image html ../IFPACKLogo.gif

\section table Table of Contents

- \ref intro
- \ref download
- \ref example 
- \ref note 
- \ref tools 
- \ref error 
- \ref copyright

\section intro Introduction

IFPACK, developed by Micheal Heroux and Marzio Sala (SNL 9214), 
provides a suite of object-oriented algebraic preconditioners
for the solution of preconditioned iterative solvers.  IFPACK
constructors expect an Epetra_RowMatrix object for construction.
IFPACK is part of the Trilinos Solver Project and IFPACK object
interacts well with other Trilinos classes.  In particular, IFPACK can
be used as a preconditioner for AztecOO.

<P>All IFPACK preconditioners can be rewritten as additive Schwarz methods,
of overlapping domain decomposition type. The user can adopt
a minimal-overlap (that is, zero-row overlap), 
or ask IFPACK to extend the overlap.
The resulting preconditioner reads:
\f[
P_{IFPACK}^{-1} = \sum_{i = 0}^{NumProcs-1} P_i A_i^{-1} R_i
\f]
where \f$R_i\f$ is the restriction operator from the global vector, to the
overlapping subdomain \f$i\f$,
and \f$P_i\f$ is the prolongator operator. 
\f$P_i\f$ is generally be the transpose of \f$R_i\f$ (in which case
the resulting preconditioner is symmetic).
If is supposed that each subdomain
is assigned to a different processors.

<P>A key component of the previous formula is a strategy to apply
\f$A_i^{-1}\f$. Using IFPACK, this can be defined by one of the
following:
- one or more steps of a point/block method (like Jacobi and Gauss-Seidel);
- an incomplete factorization (ICT or RILUK);
- an exact LU solve (using Amesos' factorizations).

More precisely, the choices for \f$A_i^{-1}\f$ are:
- point preconditioners:
  - Jacobi
  - Gauss-Seidel
  - symmetric Guass-Seidel
  - SOR
  - SSOR
- block preconditioners:
  - block Jacobi
  - block Gauss-Seidel
  - block symmetric Gauss-Seidel
- point incomplete factorizations:
  - ICT(K) for symmetric problems
  - RILU(K) for general problems
- exact factorizations:
  - all Amesos classes can be used to compute the LU factorization
    of a given matrix.

Point preconditioners are probably the simplest iterative methods,
and are generally used as smoothers in multilevel
methods (for instance, within ML). The user can select the damping factor,
and the number of sweeps.

Block preconditioners represent an extension of point preconditioners.  The
local matrix \f$A_i\f$ is divided into blocks, than the Jacobi or the
Gauss-Seidel methods are applied on the block structure rather than
point-wise. The code extracts the diagonal blocks (the application of whose
inverse is required), and stored them either as dense or as sparse matrices.
The first approach is suggested for small blocks. In this case, LAPACK
functions will be used to factorize the block and to perform the backsolve.
For large blocks, instead, it is suggested to store the blocks are sparse
matrices (Epetra_CrsMatrix's). Any IFPACK preconditioner derived from
Ifpack_Preconditioner can be used to apply the inverse of the diagonal blocks.
As IFPACK contains an interface to Amesos (this requires IFPACK to be
configured with \c --enable-amesos), all Amesos-supported (and enables)
factorizations can be used to apply the inverse of each block.

\note For block Jacobi preconditioner, the user can specify the amount
of overlap among blocks (which is a-priori different from the amount
of overlap among the processes.

\section download Download IFPACK

IFPACK can be downloaded from the web page http://software.sandia.gov/trilinos/downloads.html

\section example Examples of Usage

This section details how to use the IFPACK Factory class.

<P>Probably, the easiest way to use IFPACK is through the function class
Ifpack. This is a \e factory class, that contains only one method,
Create(). A call to Create() returns a pointer to a newly-created
IFPACK object. 

An example of usage is reported by the following code:
\code
#include "Ifpack.h"
...
Ifpack Factory;
Epetra_RowMatrix* A; 
string PrecType = "Amesos"; // exact solve on each subdomain 
int OverlapLevel = 1; // one row of overlap among the processes
Ifpack_Preconditioner* Prec = Factory.Create(PrecType, A, OverlapLevel);
assert (Prec != 0);

IFPACK_CHK_ERR(Prec->SetParameters(List));
IFPACK_CHK_ERR(Prec->Initialize());
IFPACK_CHK_ERR(Prec->Compute());
\endcode

<P>Although the Ifpack factory is appropriate for most users, 
it is possible to create IFPACK preconditioners by handling
directly an Ifpack_AdditiveSchwarz object.
The preconditioner of the previous example is equivalent to
the one created in the following fragment of code:
\code
#include "Ifpack_AdditiveSchwarz.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_Amesos> (A, OverlapLevel);
\endcode

Another example is the following, where the local solve is
a block Jacobi method, which uses dense containers (LAPACK).
\code
#include "Ifpack_AdditiveSchwarz.h"
#include "Ifpack_DenseContainer.h"
#include "Ifpack_BlockJacobi.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_BlockJacobi<Ifpack_DenseContainer> > (A, OverlapLevel);
\endcode

Using sparse containers and Amesos the code may look as follows.
\code
#include "Ifpack_AdditiveSchwarz.h"
#include "Ifpack_SparseContainer.h"
#include "Ifpack_BlockJacobi.h"
#include "Ifpack_Amesos.h"
...
Epetra_RowMatrix* A; 
int OverlapLevel = 1;
Ifpack_AdditiveSchwarz Prec<Ifpack_BlockJacobi<Ifpack_SparseContainer<Ifpack_Amesos> > > (A, OverlapLevel);
\endcode

<P>Other examples are reported in the \c example subdirectory with several
comments:
- \ref ex_factory shows how to use Ifpack factory to create
                            a variety of IFPACK preconditioners.  This is the simplest way to use IFPACK.  The example details all the phases of IFPACK. Difficulty = beginners.
- \ref ex_mm reads an MatrixMarket matrix (a simple
                             format that contains i,j and a(i,j) of
                             all nonzero elements), redistribute
                             the matrix to all avaialble processes
                             (using a linear distribution), and
                             solve the problem with AztecOO and IFPACK.
                             Matrices downloaded from
                             math.nist.gov/MatrixMarket/ in .mtx
                             format can be used with this example. A
                             small example is reported.
                             Difficulty = beginners.
- \ref ex_amesos      shows how to use exact LU solvers on
                            each subdomain, using Amesos. This example
                            is very similar to the previous one.
                            Difficulty = beginners.
- \ref ex_vict     shows how to define incomplete Cholesky
                            factorizations (with dropping based on values),
			    and tune parameters. Although
                            an vICT factorization can be constructed using
                            the Factory (as done in file
                            Ifpack_ex_Factory.cpp), this example tells
                            the real story: how to define an
                            Ifpack_AdditiveSchwar which uses vICT on
                            each subdomain.
                            Difficulty: intermediate.
- \ref ex_block  shows how to define block preconditioner
                            in the more general case, using
                            Ipfack_AdditiveSchwarz.
                            Difficulty: advanced.

\section note Note On IFPACK Classes

The only class the IFPACK users should consider  is
Ifpack_AdditiveSchwarz.
The distribution contains several other classes, that are supposed to 
be used as \e tools for Ifpack_AdditiveSchwarz (see above examples). These
classes are Ifpack_Jacobi, Ifpack_GaussSeidel, Ifpack_SymGaussSeidel,
Ifpack_SOR, Ifpack_SSOR, Ifpack_BlockJacobi, Ifpack_BlockGaussSeidel,
Ifpack_BlockSymGaussSeidel, Ifpack_Amesos, Ifpack_vIct, Ifpack_vRiluk,
Ifpack_gIct, Ifpack_gRiluk.
These classes operate on local components only (with the assumption that
OperatorDomainMap(), OperatorRangeMap() and RowMatrixRowMap()
coincide). A robust code should use them directly only
to specify templates for Ifpack_AdditiveSchwarz objects.


\section tools Developers' Tools 

IFPACK contains several classes, meant for developers rather than
for users:
- Graphs are derived from the pure virtual class Ifpack_Graph
  (whose documentation details the concept of graphs for IFPACK).
  Concreate implementations are Ifpack_Graph_Epetra_CrsGraph 
  and Ifpack_Graph_Epetra_RowMatrix;
- Containers are derived from the pure virtual class Ifpack_Container
  (whose documentation describes what a container is). Concreate
  implementations are Ifpack_DenseContainer and Ifpack_SparseContainer;
- Reorderings are derived from the pure virtual class Ifpack_Reordering
  (whose documentation outlines the features of reorderings)
  Concreate implementations are
  Ifpack_RCMReordering and Ifpack_METISReordering;
- Partitioners are derived from the pure virtual class Ifpack_Partitioner 
  (whose
  documentation describes the features of partitioners). Concrete
  implementations are Ifpack_LinearPartitioner, Ifpack_METISPartitioner
  and Ifpack_EquationPartitioner;
- Available filters are Ifpack_LocalFilter (whose documentation
  explains the creation and use of filters), Ifpack_ReorderFilter,
  Ifpack_DropFilter, Ifpack_SparsityFilter;
- Semi-virtual classes are Ifpack_PointPreconditioner and
  Ifpack_BlockPreconditioner, which contain the main functionalities
  of Jacobi, Gauss-Seidel and other point- and block-preconditioners.

\section error Error Table

The following table defines the class of IFPACK errors.
Return code should be checked using the IFPACK_CHK_ERR() macro.
In general terms, we follow this convention:
- a return value of 0 means that the called 
function or method successfully completed;
- a negative return function means that an error occurred;
- a positive value is a warning for the user.

<table>
<tr>
<td><b>Error Code</b></td><td><b>Meaning</b></td>
</tr>
<tr>
<td>-1</td><td>Generic Error (Called function returns error)</td>
</tr>
<tr>
<td>-2</td><td>Range not valid (Out-of-bounds)</td>
</tr>
<tr>
<td>-3</td><td>Data has not been correctly pre-processed</td>
</tr>
<tr>
<td>-4</td><td>Division by zero</td>
</tr>
<tr>
<td>-5</td><td>Memory allocation error</td>
</tr>
<tr>
<td>-6</td><td>Failure of the algorithm</td>
</tr>
<tr>
<td>-98</td><td>Feature is not supported</td>
</tr>
<tr>
<td>-99</td><td>Feature is not implemented (submit a bug?)</td>
</tr>
</table>

</tr>
\section copyright Copyright

\verbatim
Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
license for use of this work by or on behalf of the U.S. Government.

This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
\endverbatim

*/

/*! \page ex_factory

\include Ifpack_ex_Factory.cpp

*/

/*! \page ex_amesos

\include Ifpack_ex_Amesos.cpp

*/

/*! \page ex_vict

\include Ifpack_ex_vIct.cpp

*/

/*! \page ex_block

\include Ifpack_ex_BlockPrec.cpp

*/

/*! \page ex_mm

\include Ifpack_ex_MatrixMarket.cpp

*/


