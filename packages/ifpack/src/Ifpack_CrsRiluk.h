#ifndef _IFPACK_CrsRiluk_H_
#define _IFPACK_CrsRiluk_H_

#include "Ifpack_ScalingType.h"
#include "Ifpack_IlukGraph.h"
#include "Epetra_CompObject.h"
class Epetra_Comm;
class Epetra_Map;
class Epetra_CrsGraph;
class Epetra_CrsMatrix;
class Epetra_Vector;
class Epetra_MultiVector;

//! Ifpack_CrsRiluk: A class for constructing and using real-valued double-precision sparse compressed row matrices.

/*! The Ifpack_CrsRiluk enable the piecewise construction and use of real-valued double-precision sparse matrices
    where matrix entries are intended for row access.

    At this time, the primary function provided by Ifpack_CrsRiluk is matrix time vector and matrix 
    times multi-vector multiplication.  It is also possible to extract matrix rows from a constructed matrix.

<b>Constructing Ifpack_CrsRiluk objects</b>

Constructing Ifpack_CrsRiluk objects is a multi-step process.  The basic steps are as follows:
<ol>
  <li> Create Ifpack_CrsRiluk instance, including storage,  via constructor.
  <li> Enter values via one or more Put or SumInto functions.
  <li> Complete construction via FillComplete call.
</ol>

Note that, even after a matrix is constructed, it is possible to update existing matrix entries.  It is \e not possible to
create new entries.

<b> Counting Floating Point Operations </b>

Each Ifpack_CrsRiluk object keep track of the number
of \e serial floating point operations performed using the specified object as the \e this argument
to the function.  The Flops() function returns this number as a double precision number.  Using this 
information, in conjunction with the Epetra_Time class, one can get accurate parallel performance
numbers.  The ResetFlops() function resets the floating point counter.

\warning A Epetra_Map is required for the Ifpack_CrsRiluk constructor.

*/    


class Ifpack_CrsRiluk: public Epetra_CompObject {
      
  // Give ostream << function some access to private and protected data/functions.

  friend ostream& operator << (ostream& os, const Ifpack_CrsRiluk& A);

 public:
  //! Ifpack_CrsRiluk constuctor with variable number of indices per row.
  /*! Creates a Ifpack_CrsRiluk object and allocates storage.  
    
    \param In 
           A - User matrix to be factored.
    \param In
           Graph - Graph generated by Ifpack_IlukGraph.
  */
  Ifpack_CrsRiluk(const Epetra_CrsMatrix &A, const Ifpack_IlukGraph & Graph);
  
  //! Copy constructor.
  Ifpack_CrsRiluk(const Ifpack_CrsRiluk & Matrix);

  //! Ifpack_CrsRiluk Destructor
  virtual ~Ifpack_CrsRiluk();

  //! Initialize L and U with values from user matrix A.
  /*! Copies values from the user's matrix into the nonzero pattern of L and U.
   */
  int InitValues();

  //! If values have been initialized, this query returns true, otherwise it returns false.
  bool ValuesInitialized() const {return(ValuesInitialized_);};

  //! Set RILU(k) relaxation parameter
  void SetRelaxValue( double RelaxValue) {RelaxValue_ = RelaxValue; return;}

  //! Set diagonal shift parameter
  void SetShiftValue( double ShiftValue) {ShiftValue_ = ShiftValue; return;}

  //! Set overlap mode type
  void SetOverlapMode( Epetra_CombineMode OverlapMode) {OverlapMode_ = OverlapMode; return;}

  //! Compute ILU factors L and U using the specified graph, diagonal shift and relaxation parameters.
  /*! This function computes the RILU(k) factors L and U using the current:
    <ol>
    <li> Ifpack_IlukGraph specifying the structure of L and U.
    <li> Value for the RILU(k) relaxation parameter (default is 0,
         value can be set via SetRelaxValue()).
    <li> Value for the \e a \e priori diagonal shift value (default is 0, 
         value can be set via SetShiftValue()).
    </ol>
    InitValues() must be called before the factorization can proceed.
   */
  int Factor();

  //! If factor is completed, this query returns true, otherwise it returns false.
  bool Factored() const {return(Factored_);};
  

  // Mathematical functions.
  
  
  //! Returns the result of a Ifpack_CrsRiluk forward/back solve on a Epetra_Vector x in y.
  /*! 
    \param In
    Trans -If true, solve transpose problem.
    \param In
    x -A Epetra_Vector to solve for.
    \param Out
    y -A Epetra_Vector containing result.
    
    \return Integer error code, set to 0 if successful.
  */
  int Solve(bool Trans, const Epetra_Vector& x, Epetra_Vector& y);
  
  //! Returns the result of a Ifpack_CrsRiluk forward/back solve on a Epetra_MultiVector X in Y.
  /*! 
    \param In
    Trans -If true, solve transpose problem.
    \param In
    NumVectors -Number of vectors in X and Y.
    \param In
    X - A Epetra_MultiVector of dimension NumVectors to solve for.
    \param Out
    Y -A Epetra_MultiVector of dimension NumVectorscontaining result.
    
    \return Integer error code, set to 0 if successful.
  */
  int Solve(bool Trans, const Epetra_MultiVector& X, Epetra_MultiVector& Y);
  
  // Atribute access functions
  
    
  //! Returns the number of global matrix rows.
  int NumGlobalRows() const {return(NumGlobalRows_);};
  
  //! Returns the number of global matrix columns.
  int NumGlobalCols() const {return(NumGlobalCols_);};
  
  //! Returns the number of nonzero entries in the global graph.
  int NumGlobalNonzeros() const {return(NumGlobalNonzeros_);};
  
  //! Returns the number of diagonal entries found in the global input graph.
  virtual int NumGlobalDiagonals() const {return(NumGlobalDiagonals_);};
  
  //! Returns the number of local matrix rows.
  int NumMyRows() const {return(NumMyRows_);};
  
  //! Returns the number of local matrix columns.
  int NumMyCols() const {return(NumMyCols_);};
  
  //! Returns the number of nonzero entries in the local graph.
  int NumMyNonzeros() const {return(NumMyNonzeros_);};
  
  //! Returns the number of diagonal entries found in the local input graph.
  virtual int NumMyDiagonals() const {return(NumMyDiagonals_);};
  
  //! Returns the index base for row and column indices for this graph.
  int IndexBase() const {return(IndexBase_);};
  
  //! Returns the address of the Ifpack_IlukGraph associated with this factored matrix.
  const Ifpack_IlukGraph & Graph() const {return(Graph_);};
  
  //! Returns the address of the L factor associated with this factored matrix.
  const Epetra_CrsMatrix & L() const {return(*L_);};
    
  //! Returns the address of the D factor associated with this factored matrix.
  const Epetra_Vector & D() const {return(*D_);};
    
  //! Returns the address of the L factor associated with this factored matrix.
  const Epetra_CrsMatrix & U() const {return(*U_);};

 protected:
  void SetFactored(bool Flag) {Factored_ = Flag;};
  void SetValuesInitialized(bool Flag) {ValuesInitialized_ = Flag;};
  bool Allocated() const {return(Allocated_);};
  int SetAllocated(bool Flag) {Allocated_ = Flag; return(0);};
  
 private:
  
  
  int Allocate();
    
  const Epetra_CrsMatrix &A_;
  const Ifpack_IlukGraph & Graph_;
  Epetra_CrsMatrix * L_;
  Epetra_CrsMatrix * U_;
  Epetra_Vector * D_;

  
  bool Allocated_;
  bool ValuesInitialized_;
  bool Factored_;
  double RelaxValue_;
  double ShiftValue_;
  
  int IndexBase_;

  int NumGlobalRows_;
  int NumGlobalCols_;
  int NumGlobalDiagonals_;
  int NumGlobalNonzeros_;
  int NumMyRows_;
  int NumMyCols_;
  int NumMyDiagonals_;
  int NumMyNonzeros_;
  Epetra_MultiVector * OverlapX_;
  Epetra_MultiVector * OverlapY_;
  Epetra_CombineMode OverlapMode_;

#ifdef PETRA_LEVELSCHEDULING  
  
 public:
  //! Returns the result of a Ifpack_CrsRiluk forward/back solve on a Epetra_Vector x in y.
  /*! 
    \param In
    Trans -If true, solve transpose problem.
    \param In
    x -A Epetra_Vector to solve for.
    \param Out
    y -A Epetra_Vector containing result.
    
    \return Integer error code, set to 0 if successful.
  */
  int LevelSolve(bool Trans, const Epetra_Vector& x, Epetra_Vector& y);
  
  //! Returns the result of a Ifpack_CrsRiluk forward/back solve on a Epetra_MultiVector X in Y.
  /*! 
    \param In
    Trans -If true, solve transpose problem.
    \param In
    NumVectors -Number of vectors in X and Y.
    \param In
    X - A Epetra_MultiVector of dimension NumVectors to solve for.
    \param Out
    Y -A Epetra_MultiVector of dimension NumVectorscontaining result.
    
    \return Integer error code, set to 0 if successful.
  */
  int LevelSolve(bool Trans, const Epetra_MultiVector& X, Epetra_MultiVector& Y);

#endif

};

//! << operator will work for Ifpack_CrsRiluk.
ostream& operator << (ostream& os, const Ifpack_CrsRiluk& A);

#endif /* _IFPACK_CrsRiluk_H_ */
