/*! \mainpage TSFCore : Interfaces for the development of Abstract Numerical Algorithms

The namespace C++ <tt>TSFCore</tt> contains abstract interfaces to
linear objects such as vectors and linear operators.  This interfaces
are designed to provide only the very basic functionality needed to
implement advanced abstract numerical algorithms (ANAs).  For example,
a numerical optimization or equation solver algorithm can be written
in such a way that it can be used with serial, parallel and other
specialized conditioins with different linear algebra libraries and
computing environments.  All of the interfaces are templated on the
scalar type <tt>Scalar</tt>.  The code in <tt>TSFCore</tt> is
logically broken up into seperate pieces (by namespace) and compiled
into a single library called <tt>libTSFCore</tt>.

<ol>

<li> Basic interfaces

<ol>

<li> \ref TSFCore_Core_Interfaces_grp "Fundamental vector and linear operator interfaces" (in namespace <tt>TSFCore</tt>)

Included are vector and linear operator interfaces and bare minimum
support software needed for default method implementations.  The
vector interface is <tt>TSFCore::Vector</tt>.  The basic
interface for linear operators is <tt>TSFCore::LinearOp</tt>.

<li> \ref TSFCore_Solvers_Interfaces_grp "Interfaces to (iterative) linear solvers" (in namespace <tt>TSFCore::Solvers</tt>)

This library contains interfaces and classes assoicated with iterative
linear solvers.

<li> \ref TSFCore_Nonlin_Interfaces_grp "Interfaces to nonlinear problems" (in namespace <tt>TSFCore::Nonlin</tt>)

The abstact class <tt>TSFCore::Nonlin::LinearOpWithSolve</tt>
provides an interface to nonsingular linear operators.  The abstract
classes <tt>TSFCore::Nonlin::NonlinearProblem</tt> and
<tt>TSFCore::Nonlin::NonlinearProblemFirstOrder</tt> define
interfaces to nonlinear problems.

</ol>

<li> Adapters

There are adapter subclasses that implement the basic and extended
TSFCore interfaces.

<ol>

<li> \ref TSFCore_Adapters_MPI_Base_grp "Base classes for MPI-based vectors, multi-vectors and vector spaces" (in namespace <tt>TSFCore</tt>)

</ol>


<li> Utilities




<li> Examples


</ol>



*/
//@{

/** \defgroup TSFCore_Core_Interfaces_grp Fundamental Vector and Linear Operator Interfaces.

<ul>

<li> Types:

  <ul>
  <li> \ref TSFCoreBasicTypes_grp "Basic types"
  <li> \ref TSFCoreExceptions_grp "Basic exception classes"
  </ul>

.

<li> Classes:

  <ul>
  <li> Core abstract interface classes
    <ul>
    <li><tt>TSFCore::VectorSpaceFactory</tt>
    <li><tt>TSFCore::VectorSpace</tt>
    <li><tt>TSFCore::Vector</tt>
    <li><tt>TSFCore::OpBase</tt>
    <li><tt>TSFCore::LinearOp</tt>
    <li><tt>TSFCore::MultiVector</tt>
    </ul>
  <li> Basic node support subclasses
    <ul>
    <li><tt>TSFCore::SerialVectorSpaceBase</tt>
    <li><tt>TSFCore::SerialVectorBase</tt>
    </ul>
  <li> Basic concrete support subclasses
    <ul>
    <li><tt>TSFCore::SerialVectorSpaceFactory</tt>
    <li><tt>TSFCore::SerialVectorSpace</tt>
    <li><tt>TSFCore::SerialVector</tt>
    <li><tt>TSFCore::MultiVectorCols</tt>
    </ul>
  </ul>
.

<li> Vector interfaces:

Finite-dimensional vectors are abstracted by the interface
<tt>TSFCore::Vector</tt>.  Every vector is a member of a vector
space.  %Vector spaces are represented in software as objects with
their own abstract interface.  A vector space is represented through
the base interface <tt>TSFCore::VectorSpace</tt>.  In software
terms, a vector space object primarily acts as an "Abstract Factory"
[Design Patterns, Gamma, et. al., 1995] where the products are vector
objects from the vector space.  In addition to acting as abstact
factories, vector space objects are responsible for determining the
compatibility of vector objects which is useful in debugging an
application.  %Vector spaces also provide the definition of the scalar
product for a vector space.

These finite dimensional vector and vector space objects admit a
finite dimension (i.e. <tt>TSFCore::VectorSpace::dim()</tt>).
While any arbibrary vector operation can be implemented if direct
access to the individual elements of vectors are granted, to do so
through virtual function calls on an element-wise basis is
unacceptable slow and would not even be correct in may environments
(i.e. parallel programs).  What is needed is a different way to
represent and implement vector reduction and transformation operations
that puts the client (i.e. abstract numerical algorithm developer) in
charge while still allowing efficient implementation in a variety of
environments.

The solution to this problem which has been embraced by the vector
interface is to adopt a <A HREF="../../RTOpPack/html/index.html">
specification for user defined vector reduction/transformation
operators</A>.  This design is based on the "Visitor" design pattern.
A detailed discussion of the underlying design concepts for this idea
can be found at http://cs.sandia.gov/MOOCHO/RTOp .  These vector
interfaces accept operator objects through to the templated C++
<tt>RTOpPack::RTOpT</tt> interface.  The vector interface
<tt>TSFCore::Vector</tt> declares a method
<tt>TSFCore::Vector::applyOp()</tt> that accepts <tt>RTOpT</tt>
objects and uses them to perform the desired reduction/transformation
operations.  These methods allow great flexibility in how vectors are
used in an application.  The method <tt>applyOp(...)</tt> can
be used to allow vector objects to participate as sub-vectors in a
larger composite vector or allow only sub-sets of the elements to
participate in vector operatations.  Therefore, to define a very
powerful, fully functional vector subclass, only two methods must be
overridden: <tt>TSFCore::Vector::space()</tt> (which requires
defining a concreate <tt>TSFCore::VectorSpace</tt> class with
three pure virtual methods <tt>TSFCore::VectorSpace::dim()</tt>,
<tt>TSFCore::VectorSpace::isCompatible()</tt> and
<tt>TSFCore::VectorSpace::createMember()</tt>) and
<tt>TSFCore::Vector::applyOp()</tt>.  By far the hardest method
to implement is <tt>applyOp(...)</tt>.  Compare this to most
other abstract vector interfaces that require between 20-50 pure
virtual methods that most be overridden (e.g. 56 methods in <A
HREF="http://www.trip.caam.rice.edu/txt/hcldoc/html/HCL_Vector_d.html">HCL</A>).

<b>Heads Up !!!!!!</b>
There already exists reduction/transformation operator-based
implementatations of several standard vector operations and
some convenience functions that wrap these operators and call
<tt>applyOp()</tt> can be found \ref TSFCore_VectorStdOps_grp "here".

<li> Miscellaneous vector operations.

A set of functions for miscellaneous vector operations based on the
RTOp operator classes in <A
HREF="../../RTOpStdOpsLib/html/index.html">libRTOpStdOpsLib</A> is
declared in <tt>VectorStdOps.hpp</tt> and documented
\ref TSFCore_VectorStdOps_grp "here".

<li> Linear operator interfaces:

Blah blah blah ...

</ul>

*/

/** \defgroup TSFCore_Solvers_Interfaces_grp Extended Interfaces for Iterative Linear Solvers.

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Solvers::Norm</tt>
    <li><tt>TSFCore::Solvers::SolverState</tt>
    <li><tt>TSFCore::Solvers::ConvergenceTester</tt>
    <li><tt>TSFCore::Solvers::IterativeLinearSolver</tt>
    </ul>
  </ul>
.

</ul>

*/

/** \defgroup TSFCore_Nonlin_Interfaces_grp Extended Interfaces to Nonlinear Problems

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Nonlin::LinearSolveOp</tt>
    <li><tt>TSFCore::Nonlin::LinearOpWithSolve</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblem</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblemFirstOrder</tt>
    </ul>
  </ul>
.

</ul>

*/

/** \defgroup TSFCore_Adapters_MPI_Base_grp Generic Node Subclasses for MPI-based Vectors and MultiVectors.

<ul>

<li> Node Base Classes:

  <ul>
  <li><tt>TSFCore::MPIVectorSpaceBase</tt>
  <li><tt>TSFCore::MPIVectorBase</tt>
  <li><tt>TSFCore::MPIMultiVectorBase</tt>
  <li><tt>TSFCore::MultiVectorSerialization</tt>
  </ul>
.

</ul>

These subclasses are designed to be base classes for all MPI-based
TSFCore adapters for <tt>TSFCore::Vector</tt>,
<tt>TSFCore::VectorSpace</tt> and <tt>TSFCore::MultiVector</tt>.
These classes are all fully templated on the <tt>Scalar</tt> type and
should work with arbitrary scalar types (such as <tt>std::complex</tt>
and extended precision types) if a fully MPP environment.  These
subclasses are also carfully designed to allow interoperability
between various 


*/


