/*! \mainpage TSFCore : Interfaces for the development of Abstract Numerical Algorithms

<b>Warning!</b> Clicking on the above links (i.e. "Class List", "File
List" etc.)  can be a bit overwhelming and not recommended as a way to
"browse" what is in the Trilinos "package" %TSFCore.  Instead, it is
recommended that one uses the below outline to browse the classes and
various functions in %TSFCore.  The below presentation is designed to
expose developers to %TSFCore in manageable chunks as to not
overwhelm.

The base namespace C++ <tt>TSFCore</tt> contains abstract interfaces
to linear objects such as vectors and linear operators.  This
namespace as well as subnamespaces also contain a host of other
related software.  This interfaces are designed to provide only the
very basic functionality needed to implement advanced abstract
numerical algorithms (ANAs).  For example, a numerical optimization or
equation solver algorithm can be written in such a way that it can be
used with serial, parallel and other specialized conditioins with
different linear algebra libraries and computing environments.  All of
the interfaces are templated on the scalar type <tt>Scalar</tt>.  The
code in <tt>TSFCore</tt> is logically broken up into seperate pieces
(by namespace) and compiled into a single library called
<tt>libTSFCore</tt>.

<ol>

<li> Basic interfaces

These are interfaces that are designed to be standardized upon to
provide "glue" for different types of ANA software.

<ol>

<li> \ref TSFCore_Interfaces_Core_grp "Fundamental vector and linear operator interfaces" (in namespace <tt>TSFCore</tt>)

These are the bread and butter interfaces for <tt>%TSFCore</tt>.
Included are vector and linear operator interfaces and bare minimum
support software needed for default method implementations.  The
vector interface is <tt>TSFCore::Vector</tt>.  The basic interface for
linear operators is <tt>TSFCore::LinearOp</tt>.  These interfaces are
described in detail in <a
href="http://software.sandia.gov/trilinos/packages/tsfcore/TSFCoreSAND.pdf">this</a>
SAND report.

<li> \ref TSFCore_Interfaces_Solvers_grp "Interfaces to (iterative) linear solvers" (in namespace <tt>TSFCore::Solvers</tt>)

These are interfaces and classes assoicated with iterative linear
solvers.

<li> \ref TSFCore_Interfaces_Nonlin_grp "Interfaces to nonlinear problems" (in namespace <tt>TSFCore::Nonlin</tt>)

The abstact class <tt>TSFCore::Nonlin::LinearOpWithSolve</tt>
provides an interface to nonsingular linear operators.  The abstract
classes <tt>TSFCore::Nonlin::NonlinearProblem</tt> and
<tt>TSFCore::Nonlin::NonlinearProblemFirstOrder</tt> define
interfaces to nonlinear problems.

</ol>

<li> Adapters

There are adapter subclasses that implement the basic and extended
TSFCore interfaces.  These provide hooks to actual implementations of
the interfaces described above.

<ol>

<li> \ref TSFCore_Adapters_MPI_Base_grp "Base classes for MPI-based vectors, multi-vectors and vector spaces" (in namespace <tt>TSFCore</tt>)

<li> \ref TSFCore_Adapters_Epetra_grp "Concrete subclasses that adapt Epetra objects" (in namespace <tt>TSFCore</tt>)

</ol>


<li> Utilities

The software described here is a mixed collection of different types
of software.  Included are some abstract intefaces, concrete classes
and helper functions that are ment to make the use of TSFCore somehow
easier.  For the most part what interfaces are included here are not
central to interoperability.

<ol>

<li> \ref TSFCore_Utilities_Core_grp "Utilities based on TSFCore interfaces" (in namespace <tt>TSFCore</tt>)

<li> \ref TSFCore_Utilities_Solvers_grp "Utilities based on TSFCore::Solvers interfaces" (in namespace <tt>TSFCore::Solvers</tt>)

<li> \ref TSFCore_Utilities_Nonlin_grp "Utilities based on TSFCore::Nonlin interfaces" (in namespace <tt>TSFCore::Nonlin</tt>)

</ol>

<li> Examples

These are examples and test programs for some or all of the software
categories described above.

</ol>

*/
//@{

/** \defgroup TSFCore_Interfaces_Core_grp Fundamental Vector and Linear Operator Interfaces.

These interfaces are described in detail in <a
href="http://software.sandia.gov/trilinos/packages/tsfcore/TSFCoreSAND.pdf">this</a>
SAND report.

<ul>

<li> Types:

  <ul>
  <li> \ref TSFCoreBasicTypes_grp "Basic types"
  <li> \ref TSFCoreExceptions_grp "Basic exception classes"
  </ul>

.

<li> Classes:

  <ul>
  <li> Core abstract interface classes
    <ul>
    <li><tt>TSFCore::VectorSpaceFactory</tt>
    <li><tt>TSFCore::VectorSpace</tt>
    <li><tt>TSFCore::Vector</tt>
    <li><tt>TSFCore::OpBase</tt>
    <li><tt>TSFCore::LinearOp</tt>
    <li><tt>TSFCore::MultiVector</tt>
    </ul>
  <li> Basic node support subclasses
    <ul>
    <li><tt>TSFCore::SerialVectorSpaceBase</tt>
    <li><tt>TSFCore::SerialVectorBase</tt>
    </ul>
  <li> Concrete serial subclasses
    <ul>
    <li><tt>TSFCore::SerialVectorSpaceFactory</tt>
    <li><tt>TSFCore::SerialVectorSpace</tt>
    <li><tt>TSFCore::SerialVector</tt>
    </ul>
  <li> Other basic concrete support subclasses
    <ul>
    <li><tt>TSFCore::VectorMultiVector</tt>
    <li><tt>TSFCore::MultiVectorCols</tt>
    </ul>
  </ul>
.

<li> Vector interfaces:

Finite-dimensional vectors are abstracted by the interface
<tt>TSFCore::Vector</tt>.  Every vector is a member of a vector
space.  %Vector spaces are represented in software as objects with
their own abstract interface.  A vector space is represented through
the base interface <tt>TSFCore::VectorSpace</tt>.  In software
terms, a vector space object primarily acts as an "Abstract Factory"
[Design Patterns, Gamma, et. al., 1995] where the products are vector
objects from the vector space.  In addition to acting as abstact
factories, vector space objects are responsible for determining the
compatibility of vector objects which is useful in debugging an
application.  %Vector spaces also provide the definition of the scalar
product for a vector space.

These finite dimensional vector and vector space objects admit a
finite dimension (i.e. <tt>TSFCore::VectorSpace::dim()</tt>).
While any arbibrary vector operation can be implemented if direct
access to the individual elements of vectors are granted, to do so
through virtual function calls on an element-wise basis is
unacceptable slow and would not even be correct in may environments
(i.e. parallel programs).  What is needed is a different way to
represent and implement vector reduction and transformation operations
that puts the client (i.e. abstract numerical algorithm developer) in
charge while still allowing efficient implementation in a variety of
environments.

The solution to this problem which has been embraced by the vector
interface is to adopt a <A HREF="../../RTOpPack/html/index.html">
specification for user defined vector reduction/transformation
operators</A>.  This design is based on the "Visitor" design pattern.
A detailed discussion of the underlying design concepts for this idea
can be found at http://cs.sandia.gov/MOOCHO/RTOp .  These vector
interfaces accept operator objects through to the templated C++
<tt>RTOpPack::RTOpT</tt> interface.  The vector interface
<tt>TSFCore::Vector</tt> declares a method
<tt>TSFCore::Vector::applyOp()</tt> that accepts <tt>RTOpT</tt>
objects and uses them to perform the desired reduction/transformation
operations.  These methods allow great flexibility in how vectors are
used in an application.  The method <tt>applyOp(...)</tt> can
be used to allow vector objects to participate as sub-vectors in a
larger composite vector or allow only sub-sets of the elements to
participate in vector operatations.  Therefore, to define a very
powerful, fully functional vector subclass, only two methods must be
overridden: <tt>TSFCore::Vector::space()</tt> (which requires
defining a concreate <tt>TSFCore::VectorSpace</tt> class with
three pure virtual methods <tt>TSFCore::VectorSpace::dim()</tt>,
<tt>TSFCore::VectorSpace::isCompatible()</tt> and
<tt>TSFCore::VectorSpace::createMember()</tt>) and
<tt>TSFCore::Vector::applyOp()</tt>.  By far the hardest method
to implement is <tt>applyOp(...)</tt>.  Compare this to most
other abstract vector interfaces that require between 20-50 pure
virtual methods that most be overridden (e.g. 56 methods in <A
HREF="http://www.trip.caam.rice.edu/txt/hcldoc/html/HCL_Vector_d.html">HCL</A>).

<b>Heads Up !!!!!!</b>
There already exists reduction/transformation operator-based
implementatations of several standard vector operations and
some convenience functions that wrap these operators and call
<tt>applyOp()</tt> can be found \ref TSFCore_VectorStdOps_grp "here".

<li> Miscellaneous vector operations.

A set of functions for miscellaneous vector operations based on the
RTOp operator classes in <A
HREF="../../RTOpStdOpsLib/html/index.html">libRTOpStdOpsLib</A> is
declared in <tt>VectorStdOps.hpp</tt> and documented
\ref TSFCore_VectorStdOps_grp "here".

<li> Linear operator interfaces:

Blah blah blah ...

</ul>

*/

/** \defgroup TSFCore_Interfaces_Solvers_grp Extended Interfaces for Iterative Linear Solvers.

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Solvers::Norm</tt>
    <li><tt>TSFCore::Solvers::SolverState</tt>
    <li><tt>TSFCore::Solvers::ConvergenceTester</tt>
    <li><tt>TSFCore::Solvers::IterativeLinearSolver</tt>
    </ul>
  </ul>
.

</ul>

*/

/** \defgroup TSFCore_Interfaces_Nonlin_grp Extended Interfaces to Nonlinear Problems

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Nonlin::LinearSolveOp</tt>
    <li><tt>TSFCore::Nonlin::LinearOpWithSolve</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblem</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblemFirstOrder</tt>
    </ul>
  </ul>
.

</ul>

These abstract classes provide interfaces for more general nonlinear
problems (see the definition in
<tt>TSFCore::Nonlin::NonlinearProblem</tt>) and an interface for a
linear operator with a solve operation (see
<tt>TSFCore::Nonlin::LinearOpWithSolve</tt>) .

*/

/** \defgroup TSFCore_Adapters_MPI_Base_grp Generic Node Subclasses for MPI-based Vectors and MultiVectors.

<ul>

<li> Node Base Classes:

  <ul>
  <li><tt>TSFCore::MPIVectorSpaceBase</tt>
  <li><tt>TSFCore::MPIVectorBase</tt>
  <li><tt>TSFCore::MPIMultiVectorBase</tt>
  <li><tt>TSFCore::MultiVectorSerialization</tt>
  </ul>
.

<li> Standard implementations:

  <ul>
  <li><tt>TSFCore::MPIVectorSpaceFactoryStd</tt>
  <li><tt>TSFCore::MPIVectorSpaceStd</tt>
  <li><tt>TSFCore::MPIMultiVectorStd</tt>
  </ul>
.

</ul>

The first set of subclasses are designedto be standard base classes
for adapters for <tt>TSFCore::Vector</tt>,
<tt>TSFCore::VectorSpace</tt> and <tt>TSFCore::MultiVector</tt>.
These classes are all fully templated on the <tt>Scalar</tt> type and
should work with arbitrary scalar types (such as <tt>std::complex</tt>
and extended precision types) if a fully MPP environment.  These
subclasses are also carfully designed to allow interoperability
between various concrete implementations of MPI-based
<tt>TSFCore::Vector</tt> and <tt>TSFCore::MultiVector</tt> objects.

The second set of classes provide general and highly optimized
implementations for <tt>TSFCore::MultiVector</tt>,
<tt>TSFCore::VectorSpace</tt> and <tt>TSFCore::VectorSpaceFactory</tt>.

*/


/** \defgroup TSFCore_Adapters_Epetra_grp Generic concrete adapter subclasses for Epetra objects

<ul>

<li> Node Base Classes:

  <table>
  <tr>
    <td><tt>TSFCore::EpetraVectorSpace</tt></td>
    <td>Adapts an <tt>Epetra_Map</tt> object to form a <tt>TSFCore::VectorSpace</tt> object.</td>
  </tr>
  <tr>
    <td><tt>TSFCore::EpetraVectorSpaceFactory</tt></td>
    <td>Adapts an <tt>Epetra_Comm</tt> object to form a <tt>TSFCore::VectorSpaceFactory</tt> object.</td>
  </tr>
  <tr>
    <td><tt>TSFCore::EpetraVector</tt></td>
    <td>Adapts an <tt>Epetra_Vector</tt> object to form a <tt>TSFCore::Vector</tt> object.</td>
  </tr>
  <tr>
    <td><tt>TSFCore::EpetraMultiVector</tt></td>
    <td>Adapts an <tt>Epetra_MultiVector</tt> object to form a <tt>TSFCore::MultiVector</tt> object.</td>
  </tr>
  <tr>
    <td><tt>TSFCore::EpetraLinearOp</tt></td>
    <td>Adapts an <tt>Epetra_Object</tt> object to form a <tt>TSFCore::LinearOp</tt> object.</td>
  </tr>
  </table>

.

<li> Basic support software

  <table>
  <tr>
    <td><tt>TSFCore::get_Epetra_MultiVector()</tt></td>
    <td>Gets <tt>Epetra_MultiVector</tt> views of <tt>TSFCore::MultiVector</tt> objects if possible</td>
  </tr>
  </table>

</ul>

These are completely general-purpose subclasses that adapt Epetra
objects to form <tt>%TSFCore</tt> objects.

*/

/** \defgroup TSFCore_Utilities_Core_grp Utility software based on TSFCore interfaces.

<ul>

<li> Explicit views of vector and multi-vector elements:

  <ul>
  <li><tt>TSFCore::ExplicitVectorView</tt>
  <li><tt>TSFCore::ExplicitMutableVectorView</tt>
  <li><tt>TSFCore::ExplicitMultiVectorView</tt>
  <li><tt>TSFCore::ExplicitMutableMultiVectorView</tt>
  </ul>

.

<li> Product vector spaces, vectors and multi-vectors:

  <ul>
  <li> Node interface classes:
    <ul>
    <li><tt>TSFCore::ProductVectorSpaceBase</tt>
    <li><tt>TSFCore::ProductVectorBase</tt>
    <li><tt>TSFCore::ProductMultiVectorBase</tt>
    </ul>
  <li> Standard concrete implementations:
    <ul>
    <li><tt>TSFCore::ProductVectorSpace</tt>
    <li><tt>TSFCore::ProductVector</tt>
    <li><tt>TSFCore::ProductMultiVector</tt> (ToDo: This needs to be implemented!)
    </ul>
  </ul>

.

<li> Miscellaneous omposite linear operators:

  <ul>
	<li><tt>TSFCore::DiagonalLinearOp</tt>
	<li><tt>TSFCore::MultiplicativeLinearOp</tt>
  </ul>

.

<li> Testing:

  <ul>
  <li><tt>TSFCore::LinearOpTester</tt>
  </ul>

.

<li> Miscellaneous:

  <ul>
  <li><tt>TSFCore::MultiVectorAllocator</tt>
  </ul>
.

</ul>

All of this software only has dependencies on the basic
<tt>%TSFCore</tt> interfaces described \ref TSFCore_Interfaces_Core_grp "here".

This is a mixed bag of software and is divided into the categories
shown above.

The first category of software is concrete classes to help create
explicit views of constant and non-constant vectors and multi-vectors.
The concrete classes <tt>TSFCore::ExplicitVectorView</tt>,
<li><tt>TSFCore::ExplicitMutableVectorView</tt>,
<li><tt>TSFCore::ExplicitMultiVectorView</tt> and
<li><tt>TSFCore::ExplicitMutableMultiVectorView</tt> have constructors
and destructors that greatly simplify getting at the explicit elements
of any vector or multi-vector object.  Note, it is generally not a
good idea to ask for explicit access to vector or multi-vector
elements but there are some special cases where this type of access is
absoluting critical (see the TSFCore design document).

Another important category of software is for supporting interfaces
and implementations to product vectors and product multi-vectors that
are created by product vector spaces.  There are abstract interface
classes to these types of objects provided in
<tt>TSFCore::ProductVectorBase</tt>,
<tt>TSFCore::ProductMultiVectorBase</tt> and
<tt>TSFCore::ProductVectorSpaceBase</tt> which are appropriate for
some client software but need not be tied to a particular
implementation.  There are also very general default implementations
in <tt>TSFCore::ProductVector</tt>,
<tt>TSFCore::ProductMultiVector</tt> and
<tt>TSFCore::ProductVectorSpace</tt> that should have all of the
functionality needed for most use cases.  These subclasses represent
true "Composite" (in the lingo of design patterns) objects where
multiple objects can be composed to represent a single object.

ToDo: Finish discussion.

*/
