/*! \mainpage TSFCore : Interfaces for the development of Abstract Numerical Algorithms

<b>Warning!</b> Clicking on the above links (i.e. "Class List", "File
List" etc.)  can be a bit overwhelming and not recommended as a way to
"browse" what is in the Trilinos "package" %TSFCore.  Instead, it is
recommended that one uses the below outline to browse the classes and
various functions in %TSFCore.  The below presentation is designed to
expose developers to %TSFCore in manageable chunks as to not
overwhelm.

The base namespace C++ <tt>TSFCore</tt> contains abstract interfaces
to linear objects such as vectors and linear operators.  This
namespace as well as subnamespaces also contain a host of other
related software.  This interfaces are designed to provide only the
very basic functionality needed to implement advanced abstract
numerical algorithms (ANAs).  For example, a numerical optimization or
equation solver algorithm can be written in such a way that it can be
used with serial, parallel and other specialized conditioins with
different linear algebra libraries and computing environments.  All of
the interfaces are templated on the scalar type <tt>Scalar</tt>.  The
code in <tt>TSFCore</tt> is logically broken up into seperate pieces
(by namespace) and compiled into a single library called
<tt>libTSFCore</tt>.

\image html TSFCoreSimple.gif "Fundamental vector and linear operator interfaces (Note: above graphic not hyperlinked!)"

<ol>

<li> Basic interfaces

These are interfaces that are designed to be standardized upon to
provide "glue" for different types of ANA software.

<ol>

<li> \ref TSFCore_Interfaces_Core_grp "Fundamental vector and linear operator interfaces" (in namespace <tt>TSFCore</tt>)

These are the bread and butter interfaces for <tt>%TSFCore</tt>.
Included are vector and linear operator interfaces and bare minimum
support software needed for default method implementations.  The
vector interface is <tt>TSFCore::Vector</tt>.  The basic interface for
linear operators is <tt>TSFCore::LinearOp</tt>.  These interfaces are
described in detail in <a
href="http://software.sandia.gov/trilinos/packages/tsfcore/TSFCoreSAND.pdf">this</a>
SAND report.

</ol>

<li> Adapters

There are adapter subclasses that implement the basic and extended
TSFCore interfaces.  These provide hooks to actual implementations of
the interfaces described above.

<ol>

<li> \ref TSFCore_Adapters_MPI_Base_grp "Sublasses for MPI-based vectors, multi-vectors and vector spaces" (in namespace <tt>TSFCore</tt>)

<li> \ref TSFCore_Adapters_Epetra_grp "Concrete subclasses that adapt Epetra objects" (in namespace <tt>TSFCore</tt>)

</ol>


<li> Utilities

The software described here is a mixed collection of different types
of software.  Included are some abstract intefaces, concrete classes
and helper functions that are ment to make the use of TSFCore somehow
easier.  For the most part what interfaces are included here are not
central to interoperability.

<ol>

<li> \ref TSFCore_Utilities_Core_grp "Utilities based on TSFCore interfaces" (in namespace <tt>TSFCore</tt>)

</ol>

<li> Examples

These are examples and test programs for some or all of the software
categories described above.

</ol>

*/
//@{

/** \defgroup TSFCore_Interfaces_Core_grp Fundamental Vector and Linear Operator Interfaces.

\image html TSFCore.gif "Fundamental vector and linear operator interfaces (Note: above graphic not hyperlinked!)"

The details behind the design of these interfaces are described in
detail in <a
href="http://software.sandia.gov/trilinos/packages/tsfcore/TSFCoreSAND.pdf">this SAND report</a>
.

<ul>

<li> Types:

  <ul>
  <li> \ref TSFCoreBasicTypes_grp "Basic types"
  <li> \ref TSFCoreExceptions_grp "Basic exception classes"
  </ul>

.

<li> Classes:

  <ul>
  <li> Core abstract interface classes

    <ul>
    <li><tt>TSFCore::VectorSpaceFactory</tt> is basic factory interface for creating
        <tt>TSFCore::VectorSpace</tt> objects given a dimension.
    <li><tt>TSFCore::VectorSpace</tt> is the fundamental abstract interface for a vector space that defines
        the spaces scalar product and factory functions for creating <tt>TSFCore::Vector</tt> and <tt>TSFCore::MultiVector</tt> objects.
    <li><tt>TSFCore::Vector</tt> is the fundamental abstract interface for finite-dimensional vectors.
    <li><tt>TSFCore::OpBase</tt> is a base intreface that defines functions for domain and range spaces for operators.
    <li><tt>TSFCore::LinearOp</tt> is the fundamental abstract interface for applying linear operators.
    <li><tt>TSFCore::MultiVector</tt> is the fundamental abstract interface for collections of column vectors.
    </ul>

  <li> Other interface classes

    <ul>
    <li><tt>TSFCore::ScalarProd</tt> is a simple interface for the definition of a scalar product independent from
        a <tt>TSFCore::VectorSpace</tt> object (see <tt>TSFCore::VectorSpaceStdBase</tt>).
    </ul>

  <li> Basic node support subclasses

    <ul>
    <li><tt>TSFCore::VectorSpaceStdBase</tt> is a almost universal base class for concrete <tt>TSFCore::VectorSpace</tt> subclasses
        that allows the defintion of the scalar product to be swapped in and out.
    <li><tt>TSFCore::SerialVectorSpaceBase</tt> is a uesful node base calss for defining serial vector space subclasses.
    <li><tt>TSFCore::SerialVectorBase</tt> is a useful node base class for defining serial vector space subclasses.
    </ul>

  <li> Concrete subclasses

    <ul>
    <li><tt>TSFCore::SerialVectorSpaceFactory</tt> is a general concrete implementation of a factory for serial vector spacees.
    <li><tt>TSFCore::SerialVectorSpace</tt> is a general concrete implementation for serial vector spaces.
    <li><tt>TSFCore::SerialVector</tt> is a general concrete implementaion for serial vectors.
    <li><tt>TSFCore::DotProd</tt> is a simple <tt>TSFCore::ScalarProd</tt> subclass for a scaled dot product.
    </ul>

  <li> Concrete adapter subclasses for <tt>TSFCore::Vector</tt> and <tt>TSFCore::MultiVector</tt> 

    <ul>
    <li><tt>TSFCore::VectorMultiVector</tt> is a concrete subclass that takes any <tt>TSFCore::MultiVector</tt> with
        one column and turns it into a <tt>TSFCore::Vector</tt>.
    <li><tt>TSFCore::MultiVectorCols</tt> is a concrete subclass that takes an array of <tt>TSFCore::Vector</tt>
        objects with the same space and simulates a multi-vector.
    </ul>

  <li> Miscellaneous utilities

    <ul>
    <li><tt>TSFCore::LinOpPersisting</tt> is a simple concrete handle class that aggregates
         a <tt>LinearOp</tt> and its natural transpose and scalar multiplier arguments (for
         persisting relationships)
    <li><tt>TSFCore::LinOpNonPersisting</tt> is a simple concrete handle class that aggregates
         a <tt>LinearOp</tt> and its natural transpose and scalar multiplier arguments (for
         persisting relationships)
    </ul>

  </ul>

.

<li> Vector interfaces:

Finite-dimensional vectors are abstracted by the interface
<tt>TSFCore::Vector</tt>.  Every vector is a member of a vector
space.  %Vector spaces are represented in software as objects with
their own abstract interface.  A vector space is represented through
the base interface <tt>TSFCore::VectorSpace</tt>.  In software
terms, a vector space object primarily acts as an "Abstract Factory"
[Design Patterns, Gamma, et. al., 1995] where the products are vector
objects from the vector space.  In addition to acting as abstact
factories, vector space objects are responsible for determining the
compatibility of vector objects which is useful in debugging an
application.  %Vector spaces also provide the definition of the scalar
product for a vector space (and therefore is natural norm).

These finite dimensional vector and vector space objects admit a
finite dimension (i.e. <tt>TSFCore::VectorSpace::dim()</tt>).
While any arbibrary vector operation can be implemented if direct
access to the individual elements of vectors are granted, to do so
through virtual function calls on an element-wise basis is
unacceptable slow and would not even be correct in may environments
(i.e. parallel programs).  What is needed is a different way to
represent and implement vector reduction and transformation operations
that puts the client (i.e. abstract numerical algorithm developer) in
charge while still allowing efficient implementation in a variety of
environments.

The solution to this problem which has been embraced by %TSFCore is to
adopt a <tt>RTOpPack</tt>.  This design is based on the "Visitor"
design pattern.  A detailed discussion of the underlying design
concepts for this idea can be found <A
HREF="http://software.sandia.gov/RTOp/RTOpTOMS.pdf">here</A>.  These
vector interfaces accept operator objects through to the templated C++
<tt>RTOpPack::RTOpT</tt> interface.  The vector interface
<tt>TSFCore::Vector</tt> declares a method
<tt>TSFCore::Vector::applyOp()</tt> that accepts <tt>RTOpT</tt>
objects and uses them to perform the desired reduction/transformation
operations.  These methods allow great flexibility in how vectors are
used in an application.

<b>Heads Up !!!!!!</b>
There already exists reduction/transformation operator-based
implementatations of several standard vector operations and
some convenience functions that wrap these operators and call
<tt>applyOp()</tt> can be found \ref TSFCore_VectorStdOps_grp "here".

<li> Linear operator interfaces:

Linear operators are abstracted behind the <tt>TSFCore::LinearOp</tt>
interface which really only defines one non-trivial method,
<tt>TSFCore::LinearOp::apply()</tt>, for applying the operator.

<li> Multi-vector interfaces:

A multi-vector can be thought of as a tall thin matrix where each
column is a vector.  In TSFCore, the <tt>TSFCore::MultiVector</tt>
interface class inherits from the <tt>TSFCore::LinearOp</tt>.  This
means that every multi-vector can act as a linear operator.  Another
interesting feature of the TSFCore design is that
<tt>TSFCore::Vector</tt> inherits from <tt>TSFCore::MultiVector</tt>.
What this means is that every <tt>TSFCore::Vector</tt> is a
<tt>TSFCore::MultiVector</tt> which has one column.  The motivation
for this so that any piece of code that accepts
<tt>TSFCore::MultiVector</tt> objects should also automatically accept
<tt>TSFCore::Vector</tt> objects.

Just as for <tt>TSFCore::Vector</tt>, <tt>TSFCore::MultiVector</tt>
also accepts user-defined vector reduction/transformation operators
through <tt>RTOpPack::RTOpT</tt>.

<b>Heads Up !!!!!!</b> There already exists reduction/transformation
operator-based implementatations of several standard vector
(multi-vector) operations and some convenience functions that wrap
these operators and call <tt>applyOp()</tt> can be found
\ref TSFCore_MultiVectorStdOps_grp "here".


</ul>

*/

/** \defgroup TSFCore_Interfaces_Solvers_grp Extended Interfaces for Iterative Linear Solvers.

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Solvers::Norm</tt>
    <li><tt>TSFCore::Solvers::SolverState</tt>
    <li><tt>TSFCore::Solvers::ConvergenceTester</tt>
    <li><tt>TSFCore::Solvers::IterativeLinearSolver</tt>
    </ul>
  </ul>
.

</ul>

*/

/** \defgroup TSFCore_Interfaces_Nonlin_grp Extended Interfaces to Nonlinear Problems

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes

    <ul>
    <li><tt>TSFCore::Nonlin::LinearSolveOp</tt>
    <li><tt>TSFCore::Nonlin::LinearOpWithSolve</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblem</tt>
    <li><tt>TSFCore::Nonlin::NonlinearProblemFirstOrder</tt>
    </ul>

  </ul>
.

</ul>

These abstract classes provide interfaces for more general nonlinear
problems (see the definition in
<tt>TSFCore::Nonlin::NonlinearProblem</tt>) and an interface for a
linear operator with a solve operation (see
<tt>TSFCore::Nonlin::LinearOpWithSolve</tt>) .

*/

/** \defgroup TSFCore_Adapters_MPI_Base_grp Generic Subclasses for MPI-based Vectors and MultiVectors.

<ul>

<li> Node Base Classes:

  <ul>
  <li><tt>TSFCore::MPIVectorSpaceBase</tt> is an general abstract node base subclass for all SPMD MPI-based vector spaces.
  <li><tt>TSFCore::MPIVectorBase</tt> is a general abstract node base subcalss for all SPMD MPI-based vectors.
  <li><tt>TSFCore::MPIMultiVectorBase</tt> is a general abstract node base subclass for all SPMD MPI-based multi-vectors.
  </ul>

.

<li> Standard Implementations:

  <ul>
  <li><tt>TSFCore::MPIVectorSpaceFactoryStd</tt> is a concrete <tt>TSFCore::VectorSpaceFactory</tt> subclas that creates locally replicated
      <tt>TSFCore::MPIVectorSpaceStd</tt> objects given their dimension.
  <li><tt>TSFCore::MPIVectorSpaceStd</tt> is a general concrete <tt>TSFCore::VectorSpace</tt> subclass for SPMD MPI-based vector spaces which
      creates <tt>MPIMultiVector</tt> objects.
  <li><tt>TSFCore::MPIMultiVectorStd</tt> is a very general, highly optimized <tt>TSFCore::MultiVector</tt> subclass for SPMD MPI-based
      multi-vectors. 
  </ul>

.

<li> Miscellaneous utilities:

  <ul>
  <li><tt>TSFCore::MultiVectorSerialization</tt> is a concrete utility class that performs ASCII and binary
      <tt>std::stream</tt> based input and output of any <tt>TSFCore::MultiVector</tt> object who's range space
      supports the <tt>TSFCore::MPIVectorSpaceBase</tt> interface.
  </ul>

.

</ul>

The first set of subclasses (Node Base Classes) are designed to be
standard base classes for adapters for <tt>TSFCore::Vector</tt>,
<tt>TSFCore::VectorSpace</tt> and <tt>TSFCore::MultiVector</tt> for
all SPMD-based implementations.  These classes are all fully templated
on the <tt>Scalar</tt> type and should work with arbitrary scalar
types (such as <tt>std::complex</tt> and extended precision types) if
a fully SPMD (single program multiple data) MPP (massively parallel
platform) environment.  These subclasses are also carfully designed to
allow interoperability between various concrete implementations of
MPI-based <tt>TSFCore::Vector</tt> and <tt>TSFCore::MultiVector</tt>
objects.

The second set of subclasses (Standard Implementations) provide
general and highly optimized implementations for
<tt>TSFCore::MultiVector</tt>, <tt>TSFCore::VectorSpace</tt> and
<tt>TSFCore::VectorSpaceFactory</tt> for SPMD MPP implementations.  As
far as abstract numerical algorithms (ANAs) go, these concrete
subclasses are all that are really needed irregardless of how the
<tt>TSFCore::LinearOp</tt> objects are implemented.

*/

/** \defgroup TSFCore_Adapters_Epetra_grp Generic concrete adapter subclasses for Epetra objects

<ul>

<li> Concrete Classes:

  <ul>
  <li><tt>TSFCore::EpetraVectorSpaceFactory</tt> adapts an <tt>Epetra_Comm</tt>
      object to form a <tt>TSFCore::VectorSpaceFactory</tt> object and creates <tt>TSFCore::EpetraVectorSpace</tt> objects.
  <li><tt>TSFCore::EpetraVectorSpace</tt> adapts an <tt>Epetra_Map</tt>
      object to form a <tt>TSFCore::VectorSpace</tt> object and creates <tt>TSFCore::EpetraVector</tt> and
      <tt>TSFCore::EpetraMultiVector</tt> objects.
  <li><tt>TSFCore::EpetraVector</tt> adapts an <tt>Epetra_Vector</tt> object
      to form a <tt>TSFCore::Vector</tt> object.
  <li><tt>TSFCore::EpetraMultiVector</tt> adapts an <tt>Epetra_MultiVector</tt> object
      to form a <tt>TSFCore::MultiVector</tt> object.
  <li><tt>TSFCore::EpetraLinearOp</tt> adapts an <tt>Epetra_Operator</tt> object to form a <tt>TSFCore::LinearOp</tt> object.
  </ul>

.

<li> Basic support software

  <ul>
  <li><tt>TSFCore::get_Epetra_MultiVector()</tt> gets an <tt>Epetra_MultiVector</tt> view of
      any compatible <tt>TSFCore::MultiVector</tt> object even if it is not derived from
      <tt>TSFCore::EpetraMultiVector</tt>.
  </ul>

</ul>

These are completely general-purpose subclasses that adapt Epetra
objects to form <tt>%TSFCore</tt> objects.

*/

/** \defgroup TSFCore_Utilities_Core_grp Utility software based on TSFCore interfaces.

<ul>

<li> Concrete classes for explicit views of vector and multi-vector elements:

  <ul>
  <li><tt>TSFCore::ExplicitVectorView</tt> creates a non-mutable (<tt>const</tt>) explicit view of a <tt>const TSFCore::Vector</tt> object,
      allows direct access to vector elements and then frees the view in the destructor.
  <li><tt>TSFCore::ExplicitMutableVectorView</tt> creates a mutable (non-<tt>const</tt>) explicit view of a <tt>TSFCore::Vector</tt> object,
      allows direct access to vector elements and then frees the view in the destructor.
  <li><tt>TSFCore::ExplicitMultiVectorView</tt> creates a non-mutable (<tt>const</tt>) explicit view of a <tt>const TSFCore::MultiVector</tt> object,
      allows direct access to multi-vector elements and then frees the view in the destructor.
  <li><tt>TSFCore::ExplicitMutableMultiVectorView</tt> creates a mutable (non-<tt>const</tt>) explicit view of a <tt>TSFCore::MultiVector</tt> object,
      allows direct access to multi-vector elements and then frees the view in the destructor.
  </ul>

.

<li> Product vector spaces, vectors and multi-vectors:

  <ul>
  <li> Node interface classes:

    <ul>
    <li><tt>TSFCore::ProductVectorSpaceBase</tt> defines an interface for a composite product vector space composed out of one
        or more constituent <tt>TSFCore::VectorSpace</tt> objects.
    <li><tt>TSFCore::ProductVectorBase</tt> defines an interface for a composite product vector composed out of one
        or more constituent <tt>TSFCore::Vector</tt> objects.
    <li><tt>TSFCore::ProductMultiVectorBase</tt>  defines an interface for a composite product multi-vector composed out of one
        or more constituent <tt>TSFCore::MultiVector</tt> objects.
    </ul>

  <li> Standard concrete implementations:

    <ul>
    <li><tt>TSFCore::ProductVectorSpace</tt> is a general concrete implementation of <tt>TSFCore::ProductVectorSpaceBase</tt>
        that should be sufficient for most use cases.
    <li><tt>TSFCore::ProductVector</tt> is a general concrete implementation of <tt>TSFCore::ProductVectorBase</tt>
        that should be sufficient for most use cases.
    <li><tt>TSFCore::ProductMultiVector</tt> is a general concrete implementation of <tt>TSFCore::ProductMultiVectorBase</tt>
        that should be sufficient for most use cases. (ToDo: This needs to be implemented!)
    </ul>

  </ul>

.

<li> Miscellaneous composite linear operators:

  <ul>
	<li><tt>TSFCore::DiagonalLinearOp</tt> is a simple concrete subclass that defines a diagonal <tt>TSFCore::LinearOp</tt>
       \f$M = \gamma \; \mbox{diag}(d) \in \Re^{n \times n}\f$
      out of any <tt>TSFCore::Vector</tt> object for the diagonal \f$d \in \Re^n\f$.
	<li><tt>TSFCore::MultiplicativeLinearOp</tt> is a simple concrete subclass that defines a composite  multipliciative
      <tt>TSFCore::LinearOp</tt> of the form \f$M = \gamma \; A^1 A^2 \ldots A^m}\f$ composed out of one or more
      constituent <tt>TSFCore::LinearOp</tt> objects \f$A^1, A^2 \ldots A^m\f$.
  </ul>

.

<li> Testing:

  <ul>
  <li><tt>TSFCore::LinearOpTester</tt> is a concrete class that tests any generic <tt>TSFCore::LinearOp</tt> object
      to see if its <tt>TSFCore::LinearOp::apply()</tt> function works correctly.
  </ul>

.

<li> Miscellaneous:

  <ul>
  <li><tt>TSFCore::MultiVectorAllocator</tt> is an allocator class to be used with
      <t>MemMngPack::AbstractFactoryStd</tt> to create <tt>TSFCore::MultiVector</tt> objects of a given size.
  </ul>
.

</ul>

All of this software only has dependencies on the basic
<tt>%TSFCore</tt> interfaces described \ref TSFCore_Interfaces_Core_grp "here".

This is a mixed bag of software and is divided into the categories
shown above.

The first category of software is concrete classes to help create
explicit views of constant and non-constant vectors and multi-vectors.
The concrete classes <tt>TSFCore::ExplicitVectorView</tt>,
<li><tt>TSFCore::ExplicitMutableVectorView</tt>,
<li><tt>TSFCore::ExplicitMultiVectorView</tt> and
<li><tt>TSFCore::ExplicitMutableMultiVectorView</tt> have constructors
and destructors that greatly simplify getting at the explicit elements
of any vector or multi-vector object.  Note, it is generally not a
good idea to ask for explicit access to vector or multi-vector
elements but there are some special cases where this type of access is
absoluting critical (see the TSFCore design document).

Another important category of software is for supporting interfaces
and implementations to product vectors and product multi-vectors that
are created by product vector spaces.  There are abstract interface
classes to these types of objects provided in
<tt>TSFCore::ProductVectorBase</tt>,
<tt>TSFCore::ProductMultiVectorBase</tt> and
<tt>TSFCore::ProductVectorSpaceBase</tt> which are appropriate for
some client software but need not be tied to a particular
implementation.  There are also very general default implementations
in <tt>TSFCore::ProductVector</tt>,
<tt>TSFCore::ProductMultiVector</tt> and
<tt>TSFCore::ProductVectorSpace</tt> that should have all of the
functionality needed for most use cases.  These subclasses represent
true "Composite" (in the lingo of design patterns) objects where
multiple objects can be composed to represent a single object.

ToDo: Finish discussion.

*/
