/** \mainpage TSFCore: Minimal interfaces for the Trilinos Solver Framework.

The namespace C++ <tt>TSFCore</tt> contains abstract interfaces to linear
objects such as vectors and linear operators.  This interfaces are
designed to provide only the very basic functionality needed to
implement advanced abstract numerical algorithms (ANAs).  For example,
a numerical optimization or equation solver algorithm can be written
in such a way that it can be used with serial, parallel and other
specialized types of linear algebra libraries and computing
environments.  All of the interfaces are templated on the scalar type
<tt>Scalar</tt>.  The code in <tt>TSFCore</tt> is logically broken up
into seperate pieces (by namespace) and compiled into a single
library called <tt>libTSFCore</tt>.

<ol>

<li> Fundamental vector and linear operator interfaces: namespace <tt>TSFCore</tt>

Included are vector and linear operator interfaces and bare minimum
support software needed for default method implementations.  The
vector interface is <tt><em>TSFCore::Vector</em></tt>.  The basic
interface for linear operators is <tt><em>TSFCore::LinearOp</em></tt>.

<li> Interfaces to (iterative) linear solvers: namespace <tt>TSFCore::Solvers</tt>

This library contains interfaces and classes assoicated with iterative
linear solvers.

<li> Interfaces to nonlinear problems: namespace <tt>TSFCore::Nonlin</tt>

The abstact class <tt><em>TSFCore::Nonlin::LinearOpWithSolve</em></tt>
provides an interface to nonsingular linear operators.  The abstract
classes <tt><em>TSFCore::Nonlin::NonlinearProblem</em></tt> and
<tt><em>TSFCore::Nonlin::NonlinearProblemFirstOrder</em></tt> define
interfaces to nonlinear problems.

</ol>

*/
//@{

/** \namespace TSFCore
\brief Fundamental %Vector and Linear Operator Interfaces.

<ul>

<li> Types:

  <ul>
  <li> \ref TSFCoreBasicTypes_grp "Basic types"
  <li> \ref TSFCoreExceptions_grp "Basic exception classes"
  </ul>

.

<li> Classes:

  <ul>
  <li> Core abstract interface classes
    <ul>
    <li><tt>TSFCore::<em>VectorSpaceFactory</em></tt>
    <li><tt>TSFCore::<em>VectorSpace</em></tt>
    <li><tt>TSFCore::<em>Vector</em></tt>
    <li><tt>TSFCore::<em>OpBase</em></tt>
    <li><tt>TSFCore::<em>LinearOp</em></tt>
    <li><tt>TSFCore::<em>MultiVector</em></tt>
    </ul>
  <li> Basic node support subclasses
    <ul>
    <li><tt>TSFCore::<em>SerialVectorSpaceBase</em></tt>
    <li><tt>TSFCore::<em>SerialVectorBase</em></tt>
    </ul>
  <li> Basic concrete support subclasses
    <ul>
    <li><tt>TSFCore::SerialVectorSpaceFactory</tt>
    <li><tt>TSFCore::SerialVectorSpace</tt>
    <li><tt>TSFCore::SerialVector</tt>
    <li><tt>TSFCore::MultiVectorCols</tt>
    </ul>
  </ul>
.

<li> Vector interfaces:

Finite-dimensional vectors are abstracted by the interface
<tt>TSFCore::<em>Vector</em></tt>.  Every vector is a member of a vector
space.  %Vector spaces are represented in software as objects with
their own abstract interface.  A vector space is represented through
the base interface <tt>TSFCore::<em>VectorSpace</em></tt>.  In software
terms, a vector space object primarily acts as an "Abstract Factory"
[Design Patterns, Gamma, et. al., 1995] where the products are vector
objects from the vector space.  In addition to acting as abstact
factories, vector space objects are responsible for determining the
compatibility of vector objects which is useful in debugging an
application.  %Vector spaces also provide the definition of the scalar
product for a vector space.

These finite dimensional vector and vector space objects admit a
finite dimension (i.e. <tt>TSFCore::<em>VectorSpace::dim()</em></tt>).
While any arbibrary vector operation can be implemented if direct
access to the individual elements of vectors are granted, to do so
through virtual function calls on an element-wise basis is
unacceptable slow and would not even be correct in may environments
(i.e. parallel programs).  What is needed is a different way to
represent and implement vector reduction and transformation operations
that puts the client (i.e. abstract numerical algorithm developer) in
charge while still allowing efficient implementation in a variety of
environments.

The solution to this problem which has been embraced by the vector
interface is to adopt a <A HREF="../../RTOpPack/html/index.html">
specification for user defined vector reduction/transformation
operators</A>.  This design is based on the "Visitor" design pattern.
A detailed discussion of the underlying design concepts for this idea
can be found at http://cs.sandia.gov/MOOCHO/RTOp .  These vector
interfaces accept operator objects through to the templated C++
<tt>RTOpPack::<em>RTOpT</em></tt> interface.  The vector interface
<tt>TSFCore::<em>Vector</em></tt> declares a method
<tt>TSFCore::<em>Vector::applyOp()</em></tt> that accepts <tt>RTOpT</tt>
objects and uses them to perform the desired reduction/transformation
operations.  These methods allow great flexibility in how vectors are
used in an application.  The method <tt><em>applyOp(...)</em></tt> can
be used to allow vector objects to participate as sub-vectors in a
larger composite vector or allow only sub-sets of the elements to
participate in vector operatations.  Therefore, to define a very
powerful, fully functional vector subclass, only two methods must be
overridden: <tt>TSFCore::<em>Vector::space()</em></tt> (which requires
defining a concreate <tt>TSFCore::<em>VectorSpace</em></tt> class with
three pure virtual methods <tt>TSFCore::<em>VectorSpace::dim()</em></tt>,
<tt>TSFCore::<em>VectorSpace::isCompatible()</em></tt> and
<tt>TSFCore::<em>VectorSpace::createMember()</em></tt>) and
<tt>TSFCore::<em>Vector::applyOp()</em></tt>.  By far the hardest method
to implement is <tt>applyOp(...)</em></tt>.  Compare this to most
other abstract vector interfaces that require between 20-50 pure
virtual methods that most be overridden (e.g. 56 methods in <A
HREF="http://www.trip.caam.rice.edu/txt/hcldoc/html/HCL_Vector_d.html">HCL</A>).

<b>Heads Up !!!!!!</b>
There already exists reduction/transformation operator-based
implementatations of several standard vector operations and
some convenience functions that wrap these operators and call
<tt>applyOp()</tt> can be found \ref TSFCore_VectorStdOps_grp "here".

<li> Miscellaneous vector operations.

A set of functions for miscellaneous vector operations based on the
RTOp operator classes in <A
HREF="../../RTOpStdOpsLib/html/index.html">libRTOpStdOpsLib</A> is
declared in <tt>VectorStdOps.hpp</tt> and documented
\ref TSFCore_VectorStdOps_grp "here".

<li> Linear operator interfaces:

Blah blah blah ...

</ul>

*/

/** \namespace TSFCore::Solvers
\brief Interfaces for Iterative Linear %Solvers.

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Solvers::<em>Norm</em></tt>
    <li><tt>TSFCore::Solvers::<em>SolverState</em></tt>
    <li><tt>TSFCore::Solvers::<em>ConvergenceTester</em></tt>
    <li><tt>TSFCore::Solvers::<em>IterativeLinearSolver</em></tt>
    </ul>
  </ul>
.

</ul>

*/

/** \namespace TSFCore::Nonlin
\brief Interfaces to Nonlinear Problems

<ul>

<li> Classes:

  <ul>
  <li> Abstract interface classes
    <ul>
    <li><tt>TSFCore::Nonlin::<em>LinearSolveOp</em></tt>
    <li><tt>TSFCore::Nonlin::<em>LinearOpWithSolve</em></tt>
    <li><tt>TSFCore::Nonlin::<em>NonlinearProblem</em></tt>
    <li><tt>TSFCore::Nonlin::<em>NonlinearProblemFirstOrder</em></tt>
    </ul>
  </ul>
.

</ul>

*/

//@}
