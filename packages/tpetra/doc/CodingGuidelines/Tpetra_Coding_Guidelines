1. Everything should be in namespace Tpetra. (This does not apply to tests or examples.)

2. When more than one template argument is used, they should be ordered from most general to most specific: PacketType, OrdinalType, ScalarType.
	Right: <OrdinalType, ScalarType>
	Wrong: <ScalarType, PacketType>

3. All header files should be bracketed with a preprocessor directive to prevent multiple inclusion. This should be the name of the file, in all uppercase, with an underscore between words. Example:
	#ifndef TPETRA_SOMEHEADER_HPP
	#define TPETRA_SOMEHEADER_HPP

	...

	#endif // TPETRA_SOMEHEADER_HPP

4. When multiple closing braces occur in sequence, add comments if it is not immediately obvious which scoping blocks those braces are closing.

4.5. Placement of * and &:

5. Placement of const: For consistency, and so that certain macro-expansions work, const is to follow whatever is being made const.

	const variable:					int const someVar
	reference to const variable:	int const& someRef
	non-const pointer to const obj:	int const* somePtr
	const pointer to non-const obj:	int* const somePtr
	const pointer to const obj:		int const* const somePtr

This also makes const usage consistent with functions and function return types.

6. The name of a class's data member(s) should end with an underscore. 

7. All variable and instance names should start with a lowercase letter, and use an uppercase letter for the beginning of each subsequent rule. There are two exceptions to this rule: 1) A member that is a pointer or reference to an object (as opposed to a primitive or STL container) may start with an uppercase letter to show that it represents a seperate object. 2) Acronyms occuring in names should be capitalized the way they would be in English, even if the acronym occurs at the beginning of a variable name.

8. Member initializations in a constructor should be in the same order as the members are listed in the class declaration.

9. Code should be written Java-style, with the function definitions inline with the function declarations in the class's *.hpp file.

10. Prefer member initialization to member assignment in constructor body.

11. If a class has non-trivial data members, always declare a default constructor, a copy constructor, a destructor, and an assignment operator. You don't need to define them, but always declare them. This will prevent the compiler from adding in those functions, which it will usually write poorly. This way, if someone tries to use one of those functions, it will be a compile-time error instead of working but potentially producing the Wrong behavior. Always document these declarations as such.

12. The opening curly bracket of a function should be on the same line as the arguments, except if the arguments take up more than one line. Then the opening curly bracket should be on its own line. 

13. If the arguments for a function take up more than one line, then they should be formatted so that the first argument is on the same line as the name of the function, and each subsequent argument should be on its own line.

14. Member initializations in a constructor should be formatted one per line, with the semicolon or comma preceding the initialization. This allows us to add, remove, and comment out individual lines without having to change the surrounding code. Example:
	SomeClass()
		: classMember1_()
		, classMember2_()
		, classMember3_()
	{
		// constructor body

15. Indents should be 4 characters wide. Indents should be done using spaces (ASCII 32), not tabs (ASCII 09). The tab character is interpreted differently by different applications. On the other hand, a space is a space is a space. Most editors can be set so that hitting the tab key will generate a series of spaces instead of a tab.

16. Variable names should never start with an underscore.

17. Avoid using dynamic allocation. When necessary, use a Teuchos::RefCountPtr to manage it. A Tpetra class should never be calling new or delete directly.
17.1. Never use malloc/realloc/free. Use new and delete instead.
17.2. Avoid creating dynamic arrays using new[]. Consider using a STL container instead.

18. If a Tpetra class will be copied or shared, place the data members in an inner data class, and use a RefCountPtr to manage the inner data class. This will vastly decrease the cost of copying the object, and the user can pass it around at will without having to worry about it going out of scope. (For example, an ElementSpace or BlockElementSpace object.)

19. Prefer passing OrdinalType and ScalarType arguments by reference-to-const over passing by value. We don't know what ScalarType is being used, and a copy construction may be very expensive.

20. All arguments that are not being modified should be const. (aka const whenever possible).

21. Use mutable very sparingly and reluctantly. A different way of accomplishing the same task is usually (but not always) possible.

22. Don't reinvent the wheel. Utilize the Standard Template Library whenever possible. Approximately two thirds of the routines that are done by hand in Epetra can be done using the algorithms in the STL.

23. Including other header files: Tpetra files should be pound-included using quotes. Headers from other Trilinos packages and system headers should be pound-included using angle brackets.

#include "Tpetra_CisMatrix.hpp"
#include <Teuchos_RefCountPtr.hpp>
#include <mpi.h>

24. Don't include system header files directly. Instead, include Tpetra_ConfigDefs.hpp. This allows us to use autoconf to manage differences across platforms. (For example, some machines still use the old-style standard library headers. (i.e. <iostream.h> instead of <iostream>)
