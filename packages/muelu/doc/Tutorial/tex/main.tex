 
\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{pifont}
\usepackage{listings}
\usepackage{calc,xcolor}

%
\definecolor{hellgelb}{rgb}{1,1,0.8}
\definecolor{hellgrau}{rgb}{0.9,0.9,0.9}
\definecolor{hellblau}{HTML}{B0FAFF}
\definecolor{hellgruen}{HTML}{C2FFA4}
\definecolor{hellrot}{HTML}{FFA4C2}
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{1,0,0}
\definecolor{colString}{rgb}{0,0.5,0}

\lstset{%
    float=hbp,%
    basicstyle=\ttfamily\small, %
    identifierstyle=\color{colIdentifier}, %
    keywordstyle=\color{colKeys}, %
    stringstyle=\color{colString}, %
    commentstyle=\color{colComments}, %
    columns=flexible, %
    tabsize=2, %
    frame=single, %
    extendedchars=true, %
    showspaces=false, %
    showstringspaces=false, %
    numbers=left, %
    numberstyle=\tiny, %
    breaklines=true, %
    backgroundcolor=\color{hellgelb}, %
    breakautoindent=true, %
    captionpos=b%
}


\newtheorem*{mycomment}{\ding{42}}
\newtheoremstyle{plain}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\normalfont}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC

  
\definecolor{MyGray}{rgb}{0.96,0.97,0.98}
\makeatletter\newenvironment{graybox}{%
   \noindent\begin{lrbox}{\@tempboxa}\begin{minipage}{\textwidth}}{\end{minipage}\end{lrbox}%
   \colorbox{MyGray}{\usebox{\@tempboxa}}
}\makeatother  
  
\newcommand\printScreenOutput[1]{
\lstinputlisting[firstline=2]{#1}
{\vspace{-0.3cm}\hfill\tiny{created with \muelu version \input{version.txt}}}
}
  
\title{A MueLu hands-on tutorial}
\author{Tobias Wiesner  \\
	Institute for Computational Mechanics \\
	Technische Universit\"at M\"unchen  \\
	Boltzmannstr. 15 \\
	85747 Garching
	\and 
Andrey Prokopenko \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
Mailstop 1318 \\
P.O.~Box 5800 \\
Albuquerque, NM 87185-1318\\
\and
Jonathan J. Hu \\
Computational Math \& Algorithms \\
Sandia National Laboratories\\
Mailstop 9159 \\
P.O.~Box 0969 \\
Livermore, CA 94551-0969
	}

\date{\today}



\begin{document}

\include{definitions}

\lstset{
  breaklines=true,                % sets automatic line breaking
}

\maketitle


\begin{abstract}
This is a \muelu tutorial.
\end{abstract}

\section{Quick start}

The first example is meant to quickly get into touch with \muelu. 

We generate a test matrix corresponding to the stencil of a 2D Laplacian operator on a structured Cartesian grid. The matrix stencil is
\begin{displaymath}
\frac{1}{h^2}\begin{pmatrix} & -1 & \\ -1 & 4 & -1 \\ & -1 & \end{pmatrix}.
\end{displaymath}
The resulting matrix is symmetric positive definite. We choose the right hand side to be the constant vector one and use a random initial guess 
for the iterative solution process. The problem domain is the unit cube with a Cartesian (uniform) mesh.

The reader can skip the first subsection which discusses the basic C++ code snippets that are necessary to use \muelu.
The second subsection demonstrates how to use \muelu through xml parameters for a simple 2D Laplace problem. It is meant as the starting point for the following more complex examples.
The third section contains some basic exercises which may encourage the reader for some more experiments.

\subsection{Source code}

The C++ source code for this example can be found in the \texttt{laplace2d.cpp} file in the \texttt{doc/Tutorial/src/} folder. Here we only discuss briefly the most important pieces of code 
to define the multigrid preconditioner and solver.

The \muelu package is based on \xpetra, which is designed as a thin wrapper for \epetra and \tpetra. First, we have to create a communicator object, e.g. by using 
\lstinputlisting[firstline=2]{laplace2d.cpp_2.fragment}

%\xpetra provides different functions to transform \epetra and \tpetra objects.

To keep things simple we create a Laplace operator using the \textsc{Galeri} package. Of course, this step is optional. For a real world application the user will generate the linear operator within its application.
\lstinputlisting[firstline=2]{laplace2d.cpp_4.fragment}

Assuming that we have an \epetra object storing the matrix we have to transform it to the corresponding \xpetra objects. This is done by
\lstinputlisting[firstline=2]{laplace2d.cpp_6.fragment}
Note that this is done in several steps: first you encapsulate the \texttt{Epetra\_CrsMatrix} object in a \texttt{Xpetra::CrsMatrix} object which can be a \texttt{Xpetra::EpetraCrsMatrix} or a \texttt{Xpetra::TpetraCrsMatrix} object 
depending on the underlying linear algebra package. Then, in the next step, the \texttt{Xpetra::CrsMatrix} ojbect is wrapped into a \texttt{Xpetra::Matrix} object which represents the abstract interface of a linear operator within \muelu.
\begin{mycomment}
In a similar way one can wrap a \tpetra matrix. Instead of a \texttt{Xpetra::EpetraCrsMatrix} one then would use a \texttt{Xpetra::TpetraCrsMatrix} object.
\end{mycomment}
The \texttt{SetFixedBlockSize} function just states that there is only one degree of freedom per node. For block operators one would choose the appropriate number of degrees of freedom per node.
\begin{mycomment}
Please note that \muelu only supports block operators with a fixed number of degrees of freedom per node.
\end{mycomment}

Once the linear operator is set up and wrapped into a \xpetra obect it is time to define the right hand side vector and the solution vector.
\lstinputlisting[firstline=2]{laplace2d.cpp_7.fragment}
In this example we just create \epetra vectors and wrap them into \xpetra objects. The right hand side vector is initialized with one and the solution vector is filled with random values.

The setup routine for the aggregation-based algebraic multigrid method needs a set of near null space vectors for input. In case of a Laplace problem we just use a constant vector
\lstinputlisting[firstline=2]{laplace2d.cpp_8.fragment}

A \muelu factory is created which interprets multigrid parameters from a given xml file. A detailed description of the parameters can be found in the \muelu user guide and in the next sections of this tutorial.
\lstinputlisting[firstline=2]{laplace2d.cpp_10.fragment}

Next we create a new \muelu hierarchy object which manages the different multigrid levels and is responsible for the multigrid setup.
\lstinputlisting[firstline=2]{laplace2d.cpp_12.fragment}
We feed in the linear operator as variable \texttt{A} and the null space vector as variable \texttt{Nullspace} on the finest level, which is accessible through \texttt{GetLevel(0)}.
Once the necessary input for the finest level is declared we can call the \texttt{SetupHierarchy} routine which generates the coarse levels using the information from the multigrid parameter list.

As soon as the multigrid hierarchy has been created one has the option to use the multigrid hierarchy either as solver for the linear system or use it as preconditioner within an outer iterative linear Krylov solver such as GMRES or CG from the \aztecoo or \belos package in \trilinos.

\subsubsection{\muelu as multigrid solver}
To use \muelu as standalone solver one can use the following code
\lstinputlisting[firstline=2]{laplace2d.cpp_18.fragment}
In this code snippet a solution vector is created using the \texttt{Xpetra::VectorFactory}. Then, the \texttt{MueLu::Hierarchy} object is set to the non-preconditioner mode and the \texttt{Iterate} routine is called
to perform \texttt{mgridSweeps} sweeps with the chosen multigrid cycle. If successfull, the \texttt{mgridLsgVec} vector contains the solution.

\subsubsection{\muelu as preconditioner}
Commonly, multigrid methods are used as preconditioners for iterative linear solvers. Here, we show how to use the \texttt{MueLu::Hierarchy} as preconditioner within an \aztecoo solver.
After a solution vector has been created by 
\lstinputlisting[firstline=2]{laplace2d.cpp_14.fragment}
the following code can be used to apply the \muelu hierarchy as preconditioner within the \aztecoo CG solver
\lstinputlisting[firstline=2]{laplace2d.cpp_16.fragment}
Basically, the \muelu hierarchy is put into an \texttt{MueLu::EpetraOperator} object, which implements the \epetra interface for preconditioners.
With the \texttt{SetPrecOperator} routine from the \aztecoo solver the \texttt{MueLu::EpetraOperator} object then is defined as preconditioner.

TODO: what about Tpetra?

\subsection{Usage}

\lstset{
backgroundcolor=\color{hellrot}, %
}

Generate an input file containing the following solver parameters: 
\small
\lstinputlisting{../src/xml/s1_easy.xml}
\normalsize

The parameters are self-explaining and for an overview of all options the reader may refer to the \muelu user guide (\cite{Mue}) where an extensive list of all options and parameter choices is given.
Beside the multigrid parameter the user can choose different types of multigrid algorithms. For a symmetric problem a smoothed aggregation multigrid method is the proper choice (\texttt{multigrid algorithm = sa}). Furthermore, one can define the level smoother. In above case a damped Jacobi smoother is used. Last but not least, some basic aggregation parameters can be chosen by the user. 

Assuming that above xml parameters are stored in the xml file \texttt{s1\_easy.xml} one can run the test program using
\begin{center}
\texttt{MueLu\_tutorial\_laplace2d.exe ----xml=s1\_easy.xml}.
\end{center}
This should produce the following output on screen.

\lstset{
backgroundcolor=\color{hellgrau}, %
}

\printScreenOutput{s1_easy.txt_3.fragment_1.fragment}

It helps to learn about the setup process and gives basic information about aggregation and level smoothers. In the end an overview of the multigrid setup is printed

\printScreenOutput{s1_easy.txt_3.fragment_3.fragment}

The multigrid overview just gives some basic information about the different multigrid levels. One can see that a three level multigrid method is used with a direct solver on the coarsest level and Jacobi level smoothers on the fine and intermedium level. Furthermore some basic information is printed such as the operator complexity.

In the end the CG convergence is printed when applying the generated multigrid method as preconditioner within a CG solver from the Aztec package in Trilinos.
The numbers give the relative residual after the corresponding number of iterations as well as the solution time in seconds.
\printScreenOutput{s1_easy.txt_5.fragment}

\subsection{Exercises}

Before proceeding with the next examples in this tutorial the reader is invited to perform some more experiments.

\begin{graybox}
 \textbf{Exercise}
 \begin{itemize}
  \item Run the example in parallel using two processors
        \begin{verbatim}
        mpirun -np 2 ./MueLu_tutorial_laplace2d.exe --xml=s1_easy.xml
        \end{verbatim}
        What changes in the screen output? Are there differences between the aggregates when using one or two processors? If yes, what could cause the difference?
  \item Create a copy of above xml solver parameters \verb|s1_easy.xml| that you can adapt for your experiments
        \begin{verbatim}
        cp s1_easy.xml mysolver.xml
        \end{verbatim}
  \item Increase the number of multigrid levels (e.g. to 10 multigrid levels) and store the xml file. Rerun the example using
        \begin{verbatim}
        mpirun -np 2 ./MueLu_tutorial_laplace2d.exe --xml=mysolver.xml
        \end{verbatim}
        How many multigrid levels are built? What is the size of the matrix on the coarsest level? Can you adapt the \texttt{coarse: max size} parameter to obtain a 3 level multigrid hierarchy again when leaving the \texttt{max levels} parameter as 10 multigrid levels?
  \item Swith the \texttt{multigrid algorithm} parameter to \texttt{unsmoothed}. What differences in the multigrid behavior do you observe?
  \item Play around with the level smoother parameters. When using unsmoothed aggregation, can you find level smoothers which lead to a convergent method within less than 50 iterations? What happens if you change from a \texttt{Jacobi} smoother to a \texttt{Symmetric Gauss-Seidel} method for level smoothing?
  \end{itemize}
\end{graybox}

\begin{thebibliography}{9}
\bibitem[Mue]{Mue} A. Prokopenko, T.A. Wiesner and J.J. Hu, \emph{MueLu User's Guide.}, SAND????-????, 2014
\end{thebibliography}

\end{document}