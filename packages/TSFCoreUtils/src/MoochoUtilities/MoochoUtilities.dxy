/** \mainpage MoochoUtilities: Low level utilities used in MOOCHO.

These are low level utility classes and functions that are very
foundational and useful.

<ul>

<li> <b>Memory management</b>:

Here are many classes and tools for performing memory management in
C++.

By far, the most important class is
<tt>Teuchos::RefCountPtr</tt><tt><T></tt> which is described in
detail \ref ref_count_ptr_stuff "here".  This class implements smart
reference counted pointers that perform automatic garbage collection
when used properly.  This class can be used with build-in,
non-polymophic and polymorphic types but can only be used with the
single object creation form of <tt>new T</tt>, not the array form
<tt>new T[n]</tt>.

To intialize a <tt>RefCountPtr</tt><tt><T></tt> object, one must
know the concrete type of the object so that its constructor can be
called.  To decouple a client from the implementation of the objects
it creates, a univeral templated "Abstract Factory" [Design Patters,
1994] interface <tt>MemMngPack::AbstractFactory</tt><tt><T></tt> is
included.  This allows a client to create objects that are handled by
<tt>RefCountPtr</tt><tt><T></tt> without having the know the
implementation subclasses of these objects.  In order to make it
easier for a developer to define a concreate
<tt>AbstractFactory</tt></tt><T></tt> object, the templated subclass
<tt>MemMngPack::AbstractFactoryStd</tt><tt><T_itfc,T_impl></tt> is
included.  The default behavior of this subclass is to simply call
default constructor for the concrete imlementation type
(<tt>T_impl</tt>) and then casts to the interface type
(<tt>T_itfc</tt>) which is returned to the client.  It is simple to
create policy classes that can perform allocation and deletion in
arbitrary ways that can be used with
<tt>MemMngPack::AbstractFactoryStd</tt><tt><></tt> (see the other
template arguments).

A common situation that occurs in the implementation of many C++
functions is when an array must be created for temporary workspace
that is discarded when the function is exited.  This type of memory
usage does not need the kind of sophisticated and potentially
inefficient memory management model as provided by <tt>new</tt> and
<tt>delete</tt> and is supported by default in many languages like GNU
Fortran (g77) and Fortran 90.  The class <tt>WorkspacePack::Workspace</tt><tt><T></tt>
and its \ref WorkspacePack_grp "supporting software" are included to
allow the efficient creation of
automatic arrays that are needed for temporary workspace in C++
functions.  The memory management model for <tt>Workspace</tt> is a
stack model and is therefore potentially much faster than the generic
<tt>new</tt> and <tt>delete</tt> implementations.

<li> <b>Debugging</b>:

These are tools for aiding in the task of debugging.

When exception handling was added to C++ it greatly relieved the
amount of code that developers had to write to obtain robust
applications in the face of exception conditions.  The C
<tt>assert()</tt> macro has an advantage that is makes it very easy in
most debugging environments to examine the state of the program when
an assertion fails.  However, the program is usally stopped which is
unacceptable in some types of applications.  Exceptions however allow
a subsystem of a program to report an error and then let an upper
level entity decide how to handle the error.  The problem is that it
can be difficult in many debugging environments to examine the state
of the program that caused the exception to occur.  The macro
<tt>TEST_FOR_EXCEPTION()</tt> is included that trys to help in the debugging
process involving C++ excepttions.  The macro helps in building an
error message that is associated with the exception object
(i.e. <tt>std::logic_error</tt>) that includes the file and
line-number where the exception was thrown from, the condition that
caused the exception to be thrown and an extra optional user-defined
error message.  With a careful use of this macro, it is very easy to
set up a debugger (e.g. gdb) to break when the condition to throw the
exception is met.

<li> <b>Macros for simple containment relationships in classes</b>:

Several macros have been defined to aid in adding members to a class
for different types of relationships for different kinds of objects.

The simplest type of association is where a class exposes an option
that is an concreate object with value semantics (i.e. built-in types
<tt>bool</tt>, <tt>int</tt>, <tt>double</tt> and simple classes like
<tt>std::complex<double></tt> etc.).  For these types of simple
relationships the macro <tt>STANDARD_MEMBER_COMPOSITION_MEMBERS()</tt>
has been defined.  Using this macro take care of much of the dudery of
adding data members and external access function (we never allow a
client do directly access a data member).

Another type of relationship is where an object is shared by one or
more other objects but only one entity has ownership to delete the
object.  The macros <tt>STANDARD_AGGREGATION_MEMBERS()</tt> and
<tt>STANDARD_CONST_AGGREGATION_MEMBERS()</tt> insert the class members
for an aggregation relationship based on a raw C++ pointer.

A more sophisticated type of relationship where an object is shared
between one or more objects is when each of the objects has ownership
to delete the object being pointed to.  This is a much more difficult
situation and this is where the macro
<tt>STANDARD_COMPOSITION_MEMBERS()</tt> comes in handy.  The
underlying data member here is an
<tt>Teuchos::RefCountPtr</tt><tt><T></tt> object.  This allows
garbage collection (i.e. <tt>delete</tt> called) when all of the
object references to the shared compsite object are removed.

<li> <b>Linear algebra utilities</b>:

These are utilities that are helpful in building interfaces for linear algebra:

The class <tt>RangePack::Range1D</tt> is a simple class that abstract
a range of indexes.  Using an object to represent a range of indexes
has several advantages.  This class was designed to aid in creating
sub-views of vectors and matrices and to be used in any other use case
where a range of indexes is needed.

</ul>

*/
